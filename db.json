{
  "problems": [
    {
      "id": 1,
      "title": "Two Sum",
      "url": "https://leetcode.com/problems/two-sum/description",
      "companyTags": [
        "Facebook",
        "Microsoft",
        "Amazon",
        "Bloomberg",
        "Uber",
        "LinkedIn",
        "Apple",
        "Airbnb",
        "Yelp",
        "Yahoo",
        "Adobe",
        "Dropbox"
      ],
      "difficulty": "Easy",
      "content": "Given an array of integers, return indices of the two numbers such that they add up to a specific target.\r\n\r\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\r\n\r\n\r\nExample:\r\n\r\nGiven nums = [2, 7, 11, 15], target = 9,\r\n\r\nBecause nums[0] + nums[1] = 2 + 7 = 9,\r\nreturn [0, 1].\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/9",
      "similarQuestions": [
        "3Sum",
        "4Sum",
        "TwoSumII-Inputarrayissorted",
        "TwoSumIII-Datastructuredesign",
        "SubarraySumEqualsK",
        "TwoSumIV-InputisaBST"
      ],
      "topicTags": [
        "Array",
        "HashTable"
      ],
      "Solution": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int[] map = new int[20050];\n        int size = 4;\n        for (int i = 0; i < nums.length; i++) {\n            map[nums[i] + size] = (i + 1);\n            int diff = target - nums[i + 1] + size;\n            if (diff < 0) continue;\n            int d = map[diff];\n            if (d > 0)\n                return new int[]{d - 1, i + 1};\n        }\n        return null;\n    }\n}",
      "total_acs": 796356,
      "total_submitted": 2141916
    },
    {
      "id": 2,
      "title": "Add Two Numbers",
      "url": "https://leetcode.com/problems/add-two-numbers/description",
      "companyTags": [
        "Microsoft",
        "Amazon",
        "Bloomberg",
        "Airbnb",
        "Adobe"
      ],
      "difficulty": "Medium",
      "content": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\r\n\r\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\r\n\r\n\r\nExample\r\n\r\nInput: (2 -> 4 -> 3) + (5 -> 6 -> 4)\r\nOutput: 7 -> 0 -> 8\r\nExplanation: 342 + 465 = 807.\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/10",
      "similarQuestions": [
        "MultiplyStrings",
        "AddBinary",
        "SumofTwoIntegers",
        "AddStrings",
        "AddTwoNumbersII"
      ],
      "topicTags": [
        "LinkedList",
        "Math"
      ],
      "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        if (l1 == null && l2 == null)\n            return null;\n        \n\n        ListNode sum_head = null;\n        ListNode sum_tail = null;\n        \n        int carry = 0;\n        \n        while (l1 !=null && l2!=null) {\n            int s = l1.val + l2.val + carry;\n            carry = s / 10;\n            int value = s % 10;\n            \n            if (sum_head == null) {\n                sum_head = new ListNode(value);\n                sum_tail = sum_head;\n            } else {\n                sum_tail.next = new ListNode(value);\n                sum_tail = sum_tail.next;\n            }\n            \n            l1 = l1.next;\n            l2 = l2.next;\n        }\n        \n        ListNode longest = null;\n        if (l1 != null) {\n            longest = l1;\n        }\n        else if (l2!= null) {\n            longest = l2;\n        } \n\n        while (longest !=null) {\n            int s = longest.val + carry;\n            carry = s / 10;\n            int value = s % 10;\n            \n            if (sum_head == null) {\n                sum_head = new ListNode(value);\n                sum_tail = sum_head;\n            } else {\n                sum_tail.next = new ListNode(value);\n                sum_tail = sum_tail.next;\n            }\n            \n            longest = longest.next;\n        }\n        \n            if (carry != 0) {\n                sum_tail.next = new ListNode(carry);\n                return sum_head;\n            }\n        \n        return sum_head;\n    }\n}",
      "total_acs": 437738,
      "total_submitted": 1539475
    },
    {
      "id": 3,
      "title": "Longest Substring Without Repeating Characters",
      "url": "https://leetcode.com/problems/longest-substring-without-repeating-characters/description",
      "companyTags": [
        "Amazon",
        "Bloomberg",
        "Yelp",
        "Adobe"
      ],
      "difficulty": "Medium",
      "content": "Given a string, find the length of the longest substring without repeating characters.\r\n\r\nExamples:\r\n\r\nGiven \"abcabcbb\", the answer is \"abc\", which the length is 3.\r\n\r\nGiven \"bbbbb\", the answer is \"b\", with the length of 1.\r\n\r\nGiven \"pwwkew\", the answer is \"wke\", with the length of 3. Note that the answer must be a substring, \"pwke\" is a subsequence and not a substring.",
      "discussUrl": "https://discuss.leetcode.com/category/11",
      "similarQuestions": [
        "LongestSubstringwithAtMostTwoDistinctCharacters"
      ],
      "topicTags": [
        "HashTable",
        "TwoPointers",
        "String"
      ],
      "Solution": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        char[] chars = s.toCharArray();\n        if(2 > chars.length){\n            return chars.length;\n        }\n        int max = 0;\n        int split_at = 0;\n        int cur_len = 1;\n        for(int i=1;i<chars.length;i++){\n            int j = split_at;\n            for(;j<i;j++){\n                if(chars[i] == chars[j]){\n                    break;\n                }\n            }\n            if(j < i){\n                split_at = j+1;\n                cur_len = i-j;\n            }else{\n                cur_len++;\n            }\n            if(cur_len > max) max = cur_len;\n        }\n        return max;\n    }\n}",
      "total_acs": 433147,
      "total_submitted": 1759425
    },
    {
      "id": 4,
      "title": "Median of Two Sorted Arrays",
      "url": "https://leetcode.com/problems/median-of-two-sorted-arrays/description",
      "companyTags": [
        "Google",
        "Microsoft",
        "Apple",
        "Zenefits",
        "Yahoo",
        "Adobe",
        "Dropbox"
      ],
      "difficulty": "Hard",
      "content": "There are two sorted arrays nums1 and nums2 of size m and n respectively.\r\n\r\nFind the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).\r\n\r\nExample 1:\r\n\r\nnums1 = [1, 3]\r\nnums2 = [2]\r\n\r\nThe median is 2.0\r\n\r\n\r\n\r\nExample 2:\r\n\r\nnums1 = [1, 2]\r\nnums2 = [3, 4]\r\n\r\nThe median is (2 + 3)/2 = 2.5\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/12",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Array",
        "BinarySearch",
        "DivideandConquer"
      ],
      "Solution": "class Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        int n1=nums1.length;\n        int n2=nums2.length;\n        if(n1>n2) {\n            return findMedianSortedArrays(nums2,nums1);\n        }\n        if(n1 == 0)\n            return (n2%2==0)?(double)(nums2[n2/2]+nums2[(n2/2)-1])/2 : nums2[n2/2];\n            //return nums1[n1/2];\n        /*if(n1==1) {\n            if(n1%2==0) {\n                \n            }else {\n                int right = \n                if(n2[0] )\n            }*/\n       // }\n        int l=0,r=n1;\n        \n        while(l<=r) {\n            int partX = (l+r)/2,\n            partY=((n1+n2+1)/2)-partX;\n            \n            int leftX = (partX==0)?Integer.MIN_VALUE:nums1[partX-1];\n            int rightX = (partX==n1)?Integer.MAX_VALUE:nums1[partX];\n            int leftY = (partY==0)?Integer.MIN_VALUE:nums2[partY-1];\n            int rightY = (partY==n2)?Integer.MAX_VALUE:nums2[partY];\n            \n            if(leftX <= rightY && leftY <= rightX) {\n               if((n1+n2) % 2 == 0) {\n                    int res = Math.max(leftX,leftY);\n                    res+=Math.min(rightX,rightY);\n                    return (double)res/2;\n                }\n                else\n                    return Math.max(leftX,leftY);\n            } else if(leftX > rightY) {\n                r=partX-1;\n            } else \n                l=partX+1;\n        }\n       return -1;\n    }\n}",
      "total_acs": 231904,
      "total_submitted": 1019996
    },
    {
      "id": 5,
      "title": "Longest Palindromic Substring",
      "url": "https://leetcode.com/problems/longest-palindromic-substring/description",
      "companyTags": [
        "Microsoft",
        "Amazon",
        "Bloomberg"
      ],
      "difficulty": "Medium",
      "content": "Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.\r\n\r\nExample:\r\n\r\n\r\nInput: \"babad\"\r\n\r\nOutput: \"bab\"\r\n\r\nNote: \"aba\" is also a valid answer.\r\n\r\n\r\n \r\n\r\nExample:\r\n\r\n\r\nInput: \"cbbd\"\r\n\r\nOutput: \"bb\"\r\n\r\n\r\n ",
      "discussUrl": "https://discuss.leetcode.com/category/13",
      "similarQuestions": [
        "ShortestPalindrome",
        "PalindromePermutation",
        "PalindromePairs",
        "LongestPalindromicSubsequence",
        "PalindromicSubstrings"
      ],
      "topicTags": [
        "String",
        "DynamicProgramming"
      ],
      "Solution": "class Solution {\n    int len = 0, maxLength = 0, init = 0;\n    public String longestPalindrome(String s) {\n        char[] chars = s.toCharArray();\n        len = s.length();\n        if (len <= 1) return s;\n        for (int i = 0; i < len; i++) {\n            i = manacher(chars, i);\n        }\n        return s.substring(init, init + maxLength);\n    }\n    public int manacher(char[] chars, int k) {\n        int i = k - 1, j = k;\n        while (j < len - 1 && chars[j] == chars[j + 1]) j++;\n        int nextCenter = j++;\n        while (i >= 0 && j < len && chars[i] == chars[j]) {\n            i--;\n            j++;\n        }\n        if (j - i - 1 > maxLength) {\n            maxLength = j - i - 1;\n            init = i + 1;\n        }\n        return nextCenter;\n    }\n}",
      "total_acs": 282779,
      "total_submitted": 1124028
    },
    {
      "id": 6,
      "title": "ZigZag Conversion",
      "url": "https://leetcode.com/problems/zigzag-conversion/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "\r\nThe string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\r\n\r\nP   A   H   N\r\nA P L S I I G\r\nY   I   R\r\n\r\n\r\nAnd then read line by line: \"PAHNAPLSIIGYIR\"\r\n\r\n\r\nWrite the code that will take a string and make this conversion given a number of rows:\r\n\r\nstring convert(string text, int nRows);\r\n\r\nconvert(\"PAYPALISHIRING\", 3) should return \"PAHNAPLSIIGYIR\".\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/14",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "String"
      ],
      "Solution": "class Solution {\n    public String convert(String s, int numRows) {\n        if (s == null || numRows <= 1 || s.length() <= numRows) return s;\n        int len = s.length();\n        char[] source = s.toCharArray();\n        char[] dest = new char[len];\n        int step = 2 * numRows - 2;\n        int k = 0;\n        for (int i = 0; i < len; i += step) {\n            dest[k++] = source[i];\n        }\n        for (int i = 1; i < numRows - 1; ++i) {\n            int j = i;\n            int otherJ = j + step - 2 * i;\n            while (j < len && otherJ < len) {\n                dest[k++] = source[j];\n                dest[k++] = source[otherJ];\n                j += step;\n                otherJ += step;\n            }\n            if (j < len)\n                dest[k++] = source[j];\n        }\n        for (int i = numRows - 1; i < len; i += step) {\n            dest[k++] = source[i];\n        }\n        return String.valueOf(dest);\n    }\n}",
      "total_acs": 193863,
      "total_submitted": 713528
    },
    {
      "id": 7,
      "title": "Reverse Integer",
      "url": "https://leetcode.com/problems/reverse-integer/description",
      "companyTags": [
        "Bloomberg",
        "Apple"
      ],
      "difficulty": "Easy",
      "content": "Given a 32-bit signed integer, reverse digits of an integer.\r\n\r\nExample 1:\r\n\r\nInput: 123\r\nOutput:  321\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: -123\r\nOutput: -321\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput: 120\r\nOutput: 21\r\n\r\n\r\n\r\nNote:\r\nAssume we are dealing with an environment which could only hold integers within the 32-bit signed integer range. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/15",
      "similarQuestions": [
        "StringtoInteger(atoi)"
      ],
      "topicTags": [
        "Math"
      ],
      "Solution": "class Solution {\n    public int reverse(int x) {\n        int output = 0;\n        \n        while (true) {\n            if (x == 0) {\n                return x;\n            }\n            \n            output = output * 10 + x % 10;\n            \n            if ((x /= 10) == 0) {\n                return output;\n            }\n            \n            if (output > 214748364 || output < -214748364) {\n                return 0;\n            }\n        }\n    }\n}",
      "total_acs": 361356,
      "total_submitted": 1480038
    },
    {
      "id": 8,
      "title": "String to Integer (atoi)",
      "url": "https://leetcode.com/problems/string-to-integer-atoi/description",
      "companyTags": [
        "Microsoft",
        "Amazon",
        "Bloomberg",
        "Uber"
      ],
      "difficulty": "Medium",
      "content": "Implement atoi to convert a string to an integer.\r\n\r\nHint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.\r\n\r\nNotes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.\r\n\r\n \r\n\r\nRequirements for atoi:\r\n\r\nThe function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.\r\n\r\nThe string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.\r\n\r\nIf the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.\r\n\r\nIf no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/16",
      "similarQuestions": [
        "ReverseInteger",
        "ValidNumber"
      ],
      "topicTags": [
        "Math",
        "String"
      ],
      "Solution": "class Solution {\n    public int myAtoi(String str) {\n        if(str.length()==0) return 0;\n        int index=0;\n        int result=0;\n        while(str.charAt(index)==' ')\n        {\n            index++;\n        }\n        int isNegative=1;\n        if(str.charAt(index)=='-' || str.charAt(index)=='+')\n        {\n            isNegative=str.charAt(index)=='+'?1:-1;\n            index++;\n        }\n        while(index<str.length()&&str.charAt(index)=='0')\n        {\n            index++;\n        }\n        while(index<str.length())\n        {\n            int digit=str.charAt(index)-'0';\n            if(digit<0||digit>9)\n            {\n                break;\n            }\n            if(Integer.MAX_VALUE/10<result || (Integer.MAX_VALUE/10==result && Integer.MAX_VALUE%10<digit))\n            {\n                return isNegative==1?Integer.MAX_VALUE:Integer.MIN_VALUE;\n            }\n            result=result*10+digit;\n            index++;\n        }\n\n        return result*isNegative;\n    }\n}",
      "total_acs": 212262,
      "total_submitted": 1521621
    },
    {
      "id": 9,
      "title": "Palindrome Number",
      "url": "https://leetcode.com/problems/palindrome-number/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Easy",
      "content": "Determine whether an integer is a palindrome. Do this without extra space.\r\n\r\nclick to show spoilers.\r\n\r\nSome hints:\r\n\r\nCould negative integers be palindromes? (ie, -1)\r\n\r\nIf you are thinking of converting the integer to string, note the restriction of using extra space.\r\n\r\nYou could also try reversing an integer. However, if you have solved the problem \"Reverse Integer\", you know that the reversed integer might overflow. How would you handle such case?\r\n\r\nThere is a more generic way of solving this problem.\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/17",
      "similarQuestions": [
        "PalindromeLinkedList"
      ],
      "topicTags": [
        "Math"
      ],
      "Solution": "class Solution {\n    public boolean isPalindrome(int x) {\n        // if(x==Integer.MIN_VALUE) return false;\n        if(x<0) return false; //isPalindrome(-x);\n        if(x<10) return true;\n        \n        int tens = 1;\n        int tmp = x;\n        while(tmp/10 > 0){\n            tens *= 10;\n            tmp = tmp/10;\n        }\n    \n        while(tens >= 10){\n            if(x/tens != x % 10) return false;\n            x = x % tens / 10;\n            tens /= 100;\n        }\n        return true;\n    }\n}",
      "total_acs": 296777,
      "total_submitted": 831777
    },
    {
      "id": 10,
      "title": "Regular Expression Matching",
      "url": "https://leetcode.com/problems/regular-expression-matching/description",
      "companyTags": [
        "Google",
        "Facebook",
        "Uber",
        "Twitter",
        "Airbnb"
      ],
      "difficulty": "Hard",
      "content": "Implement regular expression matching with support for '.' and '*'.\r\n\r\n\r\n'.' Matches any single character.\r\n'*' Matches zero or more of the preceding element.\r\n\r\nThe matching should cover the entire input string (not partial).\r\n\r\nThe function prototype should be:\r\nbool isMatch(const char *s, const char *p)\r\n\r\nSome examples:\r\nisMatch(\"aa\",\"a\") → false\r\nisMatch(\"aa\",\"aa\") → true\r\nisMatch(\"aaa\",\"aa\") → false\r\nisMatch(\"aa\", \"a*\") → true\r\nisMatch(\"aa\", \".*\") → true\r\nisMatch(\"ab\", \".*\") → true\r\nisMatch(\"aab\", \"c*a*b\") → true\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/18",
      "similarQuestions": [
        "WildcardMatching"
      ],
      "topicTags": [
        "String",
        "DynamicProgramming",
        "Backtracking"
      ],
      "Solution": "//看小本本！！！！第12页\n//基本相似：44. Wildcard Matching，区别; '*' 可以表示：including the empty sequence\n//time complexity = O(min(s.length, p.length))? 不太确定是min还是max？\n/**思路：DP\nbuild 2D boolean array, that boolean[i][j] means that whether i length character from s can match j characters from p。从s里去0 ~ 第i个字符，和从p中取0 ~ j个字符，是否match\n三种情况：i and j are length, NOT index\n1, If p.charAt(j) == s.charAt(i) :  dp[i][j] = dp[i-1][j-1];\n2, If p.charAt(j) == '.' : dp[i][j] = dp[i-1][j-1];\n3, If p.charAt(j) == '*': \n   here are two sub conditions:\n               1   if p.charAt(j-1) != s.charAt(i) : dp[i][j] = dp[i][j-2]  //in this case, a* only counts as empty\n               2   if p.charAt(i-2) == s.charAt(i-1) or p.charAt(j-2) == '.':\n                              dp[i][j] = dp[i-1][j]    //in this case, a* counts as multiple a \n                           or dp[i][j] = dp[i][j-1]   // in this case, a* counts as single a\n                           or dp[i][j] = dp[i][j-2]   // in this case, a* counts as empty\nTime Complexity: Let T, P be the lengths of the text and the pattern respectively. The work for every call to dp(i, j) for i=0, ... ,Ti=0,...,T; j=0, ... ,Pj=0,...,P is done once, and it is O(1) work. Hence, the time complexity is O(TP).\n\nSpace Complexity: The only memory we use is the O(TP) boolean entries in our cache. Hence, the space complexity is O(TP).\ntime = O(mn), space = O(mn), m = s.length(), n = p.length()\n*/\n// class Solution {\n//     public boolean isMatch(String s, String p) {\n//         //since * match zero or more of the preceding element, so * can't be the head of p, otherwise, index overflow\n//        if (s == null || p == null) {\n//         return false;\n//         }\n        \n//         boolean[][] dp = new boolean[s.length()+1][p.length()+1];\n//         //initial 0 string s length matches 0 string p length\n//         dp[0][0] = true;  //remember to initialize dp[0][0]: \"\" matches \"\" is true !!!\n        \n//         //build dp by get 0 char from s, and get i length char from p, our later results will depend on this\n//          for (int i = 1; i <= p.length(); ++i) {\n//             if (p.charAt(i - 1) == '*') {  //小本本里的第一种情况\n//                 dp[0][i] = dp[0][i - 2];   //不用check i-2 是否overflow，因为 * 不能是p的第一个字符\n//             }\n//         }\n        \n//         for (int si = 1; si <= s.length(); ++si) {\n//             for (int pi = 1; pi <= p.length(); ++pi) {\n//                 if (p.charAt(pi - 1) == '.' || p.charAt(pi - 1) == s.charAt(si - 1)) {   // '.'可以match任何char\n//                     dp[si][pi] = dp[si - 1][pi - 1];  //depends on previous stage\n//                 } else if (p.charAt(pi - 1) == '*') {\n//                     //p.charAt(pi - 2)shi*之前的那个char，因为pi是长度，pi - 1是 * 的index\n//                     /**\n//                     s = abcd|d\n//                     p = abc|d*\n//                     */\n//                     if (p.charAt(pi - 2) == s.charAt(si - 1) || p.charAt(pi - 2) == '.') { \n//                         dp[si][pi] = dp[si][pi - 2] || dp[si - 1][pi] || dp[si][pi - 1];  //两个箭头的值\n//                     } else {\n//                         dp[si][pi] = dp[si][pi - 2];   //如果不match，就只等于一个上面一个箭头的值：false？\n//                     }\n//                 }\n//             }\n//         }\n//     return dp[s.length()][p.length()];\n//     }\n// }\n\n\n//Method2:// dfs, O(2^n) time, O(n) space, n is length of p (each part can be matched or not matched)\n// class Solution {\n//     public boolean isMatch(String s, String p) {\n//         if (s == null || p == null) {\n//             return false;\n//         }\n//         if (p.length() == 0) {//if no pattern can be used to match s, check whether s is empty too\n//             return s.length() == 0;\n//         }\n//         if (p.length() == 1) {//if p only has one char, check whether s is also one char left, and then try to match them\n//             return s.length() == 1 && matchFirstChar(s, p);\n//         }\n//         if (p.charAt(1) != '*') {//if second char isn't '*',we have to match first char of both s&p,and try to match the rest\n//             return matchFirstChar(s, p) && isMatch(s.substring(1), p.substring(1));\n//         }\n//         return isMatch(s, p.substring(2)) || (matchFirstChar(s, p) && isMatch(s.substring(1), p));\n//     }\n//     //isMatch(s,p.substring(2)):check if we can skip this 2-char pattern,or pattern is used by last 1st char of s(so skip it)\n//     //if pattern shouldn't be skipped(which means it should match more char),continue to try match 1 char with this pattern\n    \n//     private boolean matchFirstChar(String s, String p) {\n//         return s.length() != 0 && (s.charAt(0) == p.charAt(0) || p.charAt(0) == '.');\n//     }\n// }\n\n\n//Method3: time = O(mn), space = O(n)\n/**思路\n这道题可以用递归解决，不过时间复杂度是指数级，这里介绍一个用动态规划在平方时间内解决的办法。\n解法的核心理念是：从后往前看pattern的每一位，对于pattern的每一位，我们尽可能的把待匹配串string从后往前给匹配上。我们用一个数组match[string.length() + 1]来表示string被匹配的情况，这里如果match[j]是true，而我们pattern正指向第i位，则说明string从第j位到最后都已经被pattern第i位之前的某些部分给成功匹配了，所以我们不用再操心了。match[i]为true的条件是match[i + 1]为true，且string第i个字符也能被成功匹配。\n\n那我们就可以从后往前开始看pattern的每一位能匹配多少string的字符了：\n\n如果pattern的这一位是*，那我们要用这一位，来从后往前尝试匹配string，因为string后面是已经匹配好的，前面是还没匹配好的，所以从前往后匹配星号可能会导致我们匹配了一些pattern该星号前面的星号应该匹配的部分。而从后往前匹配则不会影响pattern该星号后面星号所匹配的部分，因为已经匹配的部分我们会直接跳过。\n如果pattern这一位不是*，那我们则不能匹配多个字符，我们只能匹配一个字符，这时候要对string从前往后匹配，因为如果后面没被匹配，前面也肯定不会被匹配，所以从前向后能保证我们把pattern的这一位匹配到string当前最后面那个还没匹配的字符。这样如果那个字符能被匹配就通过了。\n我们举个例子\n\nmatch:   0 0 0 1\nstring:  a a b\npattern: a * b\n             |\n这里我们先看pattern最后一位b能匹配到多少，这里因为b不是星号，所以我们从左往右尝试匹配string，第一个a不行，第二个a也不行，然后到b，这里因为match[3]是true，b也和b相同，所以匹配成功。\n\nmatch:   0 0 1 1\nstring:  a a b\npattern: a * b\n           |\n然后看pattern的这个星号，我们要从后往前匹配string。因为b已经被匹配了，match[2]是true，所以直接跳过。然后到a，发现个pattern中星号前面的字符a相同，所以匹配成功，match[1]也置为true再看string的第一个a，还是可以匹配成功，这样整个string都被匹配成功了。\n\n这里还有几个情况，首先，无论刚才那pattern中最后一个b有没有匹配到string中任何一个字符，match[3]也要置为false。这样才能防止pattern最后字母没有匹配上，而pattern前面的部分反而把string的结尾给匹配了。还有如果pattern中是句号的话，那相当于字符相同。\n*/\nclass Solution {\n    public boolean isMatch(String s, String p) {\n        boolean[] match = new boolean[s.length() + 1];\n        match[s.length()] = true;\n        for(int i = p.length() - 1; i >=0; i--){\n            if(p.charAt(i) == '*'){\n                // 如果是星号，从后往前匹配\n                for(int j = s.length() - 1; j >= 0; j--){\n                    match[j] = match[j] || (match[j + 1] && (p.charAt(i - 1) == '.' || (p.charAt(i - 1) == s.charAt(j)))); \n                }\n                // 记得把i多减一，因为星号是和其前面的字符配合使用的\n                i--;\n            } else {\n                // 如果不是星号，从前往后匹配\n                for(int j = 0; j < s.length(); j++){\n                    match[j] = match[j + 1] && (p.charAt(i) == '.' || (p.charAt(i) == s.charAt(j)));\n                }\n                // 只要试过了pattern中最后一个字符，就要把match[s.length()]置为false\n                match[s.length()] = false;\n            }\n        }\n        return match[0];\n    }\n}",
      "total_acs": 182687,
      "total_submitted": 751050
    },
    {
      "id": 11,
      "title": "Container With Most Water",
      "url": "https://leetcode.com/problems/container-with-most-water/description",
      "companyTags": [
        "Bloomberg"
      ],
      "difficulty": "Medium",
      "content": "Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.\r\n\r\nNote: You may not slant the container and n is at least 2.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/19",
      "similarQuestions": [
        "TrappingRainWater"
      ],
      "topicTags": [
        "Array",
        "TwoPointers"
      ],
      "Solution": "class Solution {\n    public int maxArea(int[] height) {\n        if (height == null || height.length < 2)\n            return 0;\n        int volumn = 0, h, i = 0, j = height.length - 1;\n        while (i < j){\n            h = Math.min(height[i], height[j]);\n            volumn = Math.max(volumn, h * (j - i));\n            while (i < j && height[i] <= h) i++;\n            while (i < j && height[j] <= h) j--;\n        }\n        return volumn;\n    }\n}",
      "total_acs": 180349,
      "total_submitted": 487185
    },
    {
      "id": 12,
      "title": "Integer to Roman",
      "url": "https://leetcode.com/problems/integer-to-roman/description",
      "companyTags": [
        "Twitter"
      ],
      "difficulty": "Medium",
      "content": "Given an integer, convert it to a roman numeral.\r\n\r\n\r\nInput is guaranteed to be within the range from 1 to 3999.",
      "discussUrl": "https://discuss.leetcode.com/category/20",
      "similarQuestions": [
        "RomantoInteger",
        "IntegertoEnglishWords"
      ],
      "topicTags": [
        "Math",
        "String"
      ],
      "Solution": "class Solution {\n    private static int[] nums = new int[]{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    private static String[] strings = new String[]{\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\n\n    public String intToRoman(int num) {\n        StringBuilder res = new StringBuilder();\n        for (int i  = 0 ; i<nums.length; i++) {\n            while (num >= nums[i]) {\n                res.append(strings[i]);\n                num -= nums[i];\n            }\n        }\n\n        return res.toString();\n    }\n}",
      "total_acs": 132043,
      "total_submitted": 287532
    },
    {
      "id": 13,
      "title": "Roman to Integer",
      "url": "https://leetcode.com/problems/roman-to-integer/description",
      "companyTags": [
        "Facebook",
        "Microsoft",
        "Bloomberg",
        "Uber",
        "Yahoo"
      ],
      "difficulty": "Easy",
      "content": "Given a roman numeral, convert it to an integer.\r\n\r\nInput is guaranteed to be within the range from 1 to 3999.",
      "discussUrl": "https://discuss.leetcode.com/category/21",
      "similarQuestions": [
        "IntegertoRoman"
      ],
      "topicTags": [
        "Math",
        "String"
      ],
      "Solution": "class Solution {\n    public int romanToInt(String s) {\n        int result = 0;\n        if(s.indexOf(\"IV\") > -1) {\n            result -= 2;\n        };  \n        if (s.indexOf(\"IX\") > -1) {\n            result -= 2;\n        };\n        if (s.indexOf(\"XL\") > -1) {\n            result -= 20;\n        };\n        if (s.indexOf(\"XC\") > -1) {\n            result -= 20;\n        };\n        if (s.indexOf(\"CD\") > -1) {\n            result -= 200;\n        };\n        if (s.indexOf(\"CM\") > -1) {\n            result -= 200;\n        };\n        \n        char[] Arr = s.toCharArray();\n        \n        for(int i = 0; i < Arr.length; i++) {\n           if(Arr[i]=='M') result+=1000;\n           if(Arr[i]=='D') result+=500;\n           if(Arr[i]=='C') result+=100;\n           if(Arr[i]=='L') result+=50;\n           if(Arr[i]=='X') result+=10;\n           if(Arr[i]=='V') result+=5;\n           if(Arr[i]=='I') result+=1;\n        }\n        \n        \n        \n        return result;\n    }\n}",
      "total_acs": 208224,
      "total_submitted": 437754
    },
    {
      "id": 14,
      "title": "Longest Common Prefix",
      "url": "https://leetcode.com/problems/longest-common-prefix/description",
      "companyTags": [
        "Yelp"
      ],
      "difficulty": "Easy",
      "content": "Write a function to find the longest common prefix string amongst an array of strings.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/22",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "String"
      ],
      "Solution": "class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        if(strs==null || strs.length==0) return \"\";\n        String prefix = strs[0];\n        int i=1;\n        while(i<strs.length){\n            while(strs[i].indexOf(prefix)!=0)\n                prefix = prefix.substring(0,prefix.length()-1);\n            i++;\n        }\n        return prefix;\n    }\n}",
      "total_acs": 245407,
      "total_submitted": 776497
    },
    {
      "id": 15,
      "title": "3Sum",
      "url": "https://leetcode.com/problems/3sum/description",
      "companyTags": [
        "Facebook",
        "Microsoft",
        "Amazon",
        "Bloomberg",
        "Adobe",
        "WorksApplications"
      ],
      "difficulty": "Medium",
      "content": "Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.\r\n\r\nNote: The solution set must not contain duplicate triplets.\r\n\r\n\r\nFor example, given array S = [-1, 0, 1, 2, -1, -4],\r\n\r\nA solution set is:\r\n[\r\n  [-1, 0, 1],\r\n  [-1, -1, 2]\r\n]\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/23",
      "similarQuestions": [
        "TwoSum",
        "3SumClosest",
        "4Sum",
        "3SumSmaller"
      ],
      "topicTags": [
        "Array",
        "TwoPointers"
      ],
      "Solution": "class Solution {\n    List<List<Integer>> res = new ArrayList<>();\n\tpublic List<List<Integer>> threeSum(int[] nums) {\n\t\tint len = nums.length;\n\t\tif (len < 3)\n\t\t\treturn res;\n        \n        Arrays.sort(nums);  //sort the array first\n        \n        int zeroCount; //the appearing times of 0\n        int lastNeg = Arrays.binarySearch(nums, 0); //search the position of 0; it also means the position of the last negative number in array\n        int firstPos = lastNeg; //the position of the first positive number in array\n        if(lastNeg < 0){    //0 not found\n            zeroCount = 0;\n            lastNeg = -(lastNeg + 1) - 1;//see the Java api\n            firstPos = lastNeg + 1;\n        }\n        else{               //found\n            while(lastNeg > -1 && nums[lastNeg] == 0) //skip all 0\n                lastNeg--;\n            while(firstPos < len && nums[firstPos] == 0)\n                firstPos++;\n            zeroCount = firstPos - lastNeg - 1;\n        }\n\n        int min;\n        int max;\n        int[] hash;\n\t\tmin = nums[0];\n\t\tmax = nums[len - 1];\n\t\tmax = Math.max(Math.abs(max), Math.abs(min)); //to allocate enough space to avoid check in if statement\n\t\tmin = -max;                                \n\t\thash = new int[max - min + 1];\n\t\tfor (int v : nums) { //hash and count appearing times of every num\n\t\t\thash[v - min]++;\n\t\t}\n        \n\t\tif (zeroCount >= 3) { // (0 appears 3 times at least)\n\t\t\taddTriplets(0, 0, 0);\n\t\t}\n\t\tif (zeroCount > 0 ) { // (0 appears 1 times at least)\n\t\t\tfor (int i = firstPos; i < len; i++) { //traverse all the positive numbers to see whether there is a negative number whose absolute value equals to the positive number \n                if(i > firstPos && nums[i] == nums[i - 1]) //skip the same elements\n                    continue;\n                if (hash[-nums[i] - min] > 0) \n\t\t\t\t\taddTriplets(0, nums[i], -nums[i]);\n\t\t\t}\n\t\t}\n\n\t\t// one positive number and two negetive numbers \n\t\tfor (int i = firstPos; i < len; i++) { //traverse all the positive numbers to see whether there are two negative numbers whose sum's absolute value equals to the positive number\n            if(i > firstPos && nums[i] == nums[i - 1]) //skip the same elements\n                    continue;\n            int half;   //we can traverse only half of the positive numbers\n            if(nums[i] % 2 != 0)\n                half = -(nums[i] / 2 + 1);\n            else{\n                half = -(nums[i] / 2);\n                if(hash[half - min] > 1)\n                    addTriplets(nums[i], half, half);\n            }\n            for(int j = lastNeg; j > -1 && nums[j] > half; j--){\n                if(j < lastNeg && nums[j] == nums[j + 1])\n                    continue;\n                if(hash[(-nums[i] - nums[j]) - min] > 0)\n                    addTriplets(nums[i], nums[j], -nums[i] - nums[j]);\n            }\n        }\n        \n        // one positive number and two negetive numbers \n\t\tfor (int i = lastNeg; i > -1; i--) { //traverse all the negative numbers to see whether there are two positive numbers whose sum's absolute value equals to the negative number\n            if(i < lastNeg && nums[i] == nums[i + 1])//skip the same elements\n                    continue;\n            int half; //we can traverse only half of the positive numbers\n            if(nums[i] % 2 != 0)\n                half = -(nums[i] / 2 - 1);\n            else{\n                half = -(nums[i] / 2);\n                if(hash[half - min] > 1)\n                    addTriplets(nums[i], half, half);\n            }\n            for(int j = firstPos; j < len && nums[j] < half; j++){\n                if(j > firstPos && nums[j] == nums[j - 1])\n                    continue;\n                if(hash[(-nums[i] - nums[j]) - min] > 0)\n                    addTriplets(nums[i], nums[j], -nums[i] - nums[j]);\n            }\n        }\n\t\treturn res;\n\t}\n\n\tpublic void addTriplets(int a, int b, int c) {\n\t\tList<Integer> triplets = new ArrayList<>(3);\n\t\ttriplets.add(a);\n\t\ttriplets.add(b);\n\t\ttriplets.add(c);\n\t\tres.add(triplets);\n\t}\n}",
      "total_acs": 292671,
      "total_submitted": 1341450
    },
    {
      "id": 16,
      "title": "3Sum Closest",
      "url": "https://leetcode.com/problems/3sum-closest/description",
      "companyTags": [
        "Bloomberg"
      ],
      "difficulty": "Medium",
      "content": "Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.\r\n\r\n\r\n    For example, given array S = {-1 2 1 -4}, and target = 1.\r\n\r\n    The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/24",
      "similarQuestions": [
        "3Sum",
        "3SumSmaller"
      ],
      "topicTags": [
        "Array",
        "TwoPointers"
      ],
      "Solution": "class Solution {\n    public int threeSumClosest(int[] nums, int target) {\n        int len = nums.length;\n\t\tArrays.sort(nums);//dual-pivot quicksort\n\n\t\t//loCount and hiCount denote your lowest, and higher values closest to target\n\t\tint loCount = nums[0] + nums[1] + nums[2], hiCount = nums[len - 3] + nums[len - 2] + nums[len - 1];\n\n\t\t//check for easy(edge case) solution\n\t\tif (loCount >= target)\n\t\t\treturn loCount;\n\t\tif (hiCount <= target)\n\t\t\treturn hiCount;\n\n\t\t//iterate through array via incrementing head pointer \n\t\tfor (int head = 0; head < nums.length - 2; head++) {\n\t\t\t//lo and hi denotes smallest and biggest values of current head iteration \n\t\t\tint lo = nums[head] + nums[head + 1] + nums[head + 2], hi = nums[head] + nums[len - 2] + nums[len - 1];\n\n\t\t\tif (lo > target) {//if lo is too big, update your hiCount and terminate loop  \n\t\t\t\tif (hiCount > lo) //\n\t\t\t\t\thiCount = lo;\n\t\t\t\tbreak;\n\t\t\t} else if (hi < target) { //if hi is too small, update your loCount and skip current iteration \n\t\t\t\tif (loCount < hi)\n\t\t\t\t\tloCount = hi;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//low and high denotes your array index pointers\n\t\t\tint low = head + 1, high = len - 1;\n\t\t\twhile (low < high) {\n\t\t\t\tint sum = nums[low] + nums[high] + nums[head];\n\t\t\t\tif (sum == target) {\n\t\t\t\t\treturn target;\n\t\t\t\t} else if (sum < target) {\n\t\t\t\t\tif (loCount < sum)\n\t\t\t\t\t\tloCount = sum;\n\t\t\t\t\twhile (++low < len - 1 && nums[low] == nums[low - 1])\n\t\t\t\t\t\t;\n\t\t\t\t} else {\n\t\t\t\t\tif (hiCount > sum)\n\t\t\t\t\t\thiCount = sum;\n\t\t\t\t\twhile (--high > head + 1 && nums[high] == nums[high + 1])\n\t\t\t\t\t\t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (hiCount - target) > (target - loCount) ? loCount : hiCount;\n    }\n}",
      "total_acs": 162532,
      "total_submitted": 514918
    },
    {
      "id": 17,
      "title": "Letter Combinations of a Phone Number",
      "url": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/description",
      "companyTags": [
        "Google",
        "Facebook",
        "Amazon",
        "Uber",
        "Dropbox"
      ],
      "difficulty": "Medium",
      "content": "Given a digit string, return all possible letter combinations that the number could represent.\r\n\r\n\r\n\r\nA mapping of digit to letters (just like on the telephone buttons) is given below.\r\n\r\n\r\n\r\nInput:Digit string \"23\"\r\nOutput: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].\r\n\r\n\r\n\r\nNote:\r\nAlthough the above answer is in lexicographical order, your answer could be in any order you want.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/25",
      "similarQuestions": [
        "GenerateParentheses",
        "CombinationSum",
        "BinaryWatch"
      ],
      "topicTags": [
        "String",
        "Backtracking"
      ],
      "Solution": "class Solution {\n    private String[] letter = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n    public List<String> letterCombinations(String digits) {\n        List<String> result = new ArrayList<>();\n        if(digits == null || digits.length() == 0) {\n            return result;\n        }\n        char[] curr = new char[digits.length()];\n        helper(digits, result, curr, 0);\n        return result;\n    }\n    \n    private void helper(String digits, List<String> result, char[] curr, int level) {\n        //base case\n        if(level == digits.length()) {\n            result.add(new String(curr));\n            return;\n        }\n        \n        //recursion rule\n        String currStr = letter[digits.charAt(level) - '0'];\n        if(currStr.length() == 0) {\n            helper(digits, result, curr, level + 1);\n        } else {\n            for(int i = 0; i < currStr.length(); i++) {\n                char currLetter = currStr.charAt(i);\n                curr[level] = currLetter;\n                helper(digits, result, curr, level + 1);\n            }\n        }\n    }\n}",
      "total_acs": 213338,
      "total_submitted": 592113
    },
    {
      "id": 18,
      "title": "4Sum",
      "url": "https://leetcode.com/problems/4sum/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.\r\n\r\nNote: The solution set must not contain duplicate quadruplets.\r\n\r\n\r\n\r\nFor example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.\r\n\r\nA solution set is:\r\n[\r\n  [-1,  0, 0, 1],\r\n  [-2, -1, 1, 2],\r\n  [-2,  0, 0, 2]\r\n]\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/26",
      "similarQuestions": [
        "TwoSum",
        "3Sum",
        "4SumII"
      ],
      "topicTags": [
        "Array",
        "HashTable",
        "TwoPointers"
      ],
      "Solution": "class Solution {\n    //o(n^3)\n    public List<List<Integer>> fourSum(int[] nums, int target) {\n        List<List<Integer>> res = new ArrayList<>();\n        if(nums.length<4) return res;\n        Arrays.sort(nums);\n        int n = nums.length;\n        for(int i=0;i<n-3;i++){\n            if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3]>target)break;\n            if(nums[i]+nums[n-1]+nums[n-2]+nums[n-3]<target)continue;\n            if(i>0 && nums[i]==nums[i-1]) continue;\n            for(int j=i+1;j<n-2;j++){\n                if(nums[i]+nums[j]+nums[j+1]+nums[j+2]>target) break;\n                if(nums[i]+nums[j]+nums[n-2]+nums[n-1]<target) continue;\n                if(j>i+1 && nums[j]==nums[j-1]) continue;\n                int low = j+1, high = n-1;\n                while(low<high){\n                    int sum = nums[i]+nums[j]+nums[low]+nums[high];\n                    if(sum==target){\n                        res.add(Arrays.asList(nums[i],nums[j],nums[low],nums[high]));\n                        while(low<high && nums[low]==nums[low+1])low++;\n                        while(low<high && nums[high]==nums[high-1])high--;\n                        low++;\n                        high--;\n                    }\n                    else if(sum<target) low++;\n                    else high--;\n                }\n            }\n        }\n        return res;\n        \n    }\n}",
      "total_acs": 146076,
      "total_submitted": 533163
    },
    {
      "id": 19,
      "title": "Remove Nth Node From End of List",
      "url": "https://leetcode.com/problems/remove-nth-node-from-end-of-list/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "Given a linked list, remove the nth node from the end of list and return its head.\r\n\r\nFor example,\r\n\r\n\r\n   Given linked list: 1->2->3->4->5, and n = 2.\r\n\r\n   After removing the second node from the end, the linked list becomes 1->2->3->5.\r\n\r\n\r\nNote:\r\nGiven n will always be valid.\r\nTry to do this in one pass.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/27",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "LinkedList",
        "TwoPointers"
      ],
      "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n    \n    ListNode start = new ListNode(0);\n    ListNode slow = start, fast = start;\n    slow.next = head;\n    \n    //Move fast in front so that the gap between slow and fast becomes n\n    for(int i=1; i<=n+1; i++)   {\n        fast = fast.next;\n    }\n    //Move fast to the end, maintaining the gap\n    while(fast != null) {\n        slow = slow.next;\n        fast = fast.next;\n    }\n    //Skip the desired node\n    slow.next = slow.next.next;\n    return start.next;\n}\n\n}",
      "total_acs": 226686,
      "total_submitted": 663841
    },
    {
      "id": 20,
      "title": "Valid Parentheses",
      "url": "https://leetcode.com/problems/valid-parentheses/description",
      "companyTags": [
        "Google",
        "Facebook",
        "Microsoft",
        "Amazon",
        "Bloomberg",
        "Twitter",
        "Airbnb",
        "Zenefits"
      ],
      "difficulty": "Easy",
      "content": "Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\r\n\r\nThe brackets must close in the correct order, \"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/28",
      "similarQuestions": [
        "GenerateParentheses",
        "LongestValidParentheses",
        "RemoveInvalidParentheses"
      ],
      "topicTags": [
        "String",
        "Stack"
      ],
      "Solution": "class Solution {\n    public boolean isValid(String s) {\n        char[] stack = new char[s.length()];\n        int head = 0;\n        for (char c : s.toCharArray()) {\n            if (c == '(') {\n                stack[head++] = c;\n            } else if (c == '[') {\n                stack[head++] = c;\n            } else if (c == '{') {\n                stack[head++] = c;\n            } else if (c == ')') {\n                if (head == 0) return false;\n                if (stack[--head] != '(') return false;\n            } else if (c == ']') {\n                if (head == 0) return false;\n                if (stack[--head] != '[') return false;\n            } else if (c == '}') {\n                if (head == 0) return false;\n                if (stack[--head] != '{') return false;\n            }\n        }\n        return head == 0;\n    }\n}",
      "total_acs": 297471,
      "total_submitted": 877491
    },
    {
      "id": 21,
      "title": "Merge Two Sorted Lists",
      "url": "https://leetcode.com/problems/merge-two-sorted-lists/description",
      "companyTags": [
        "Microsoft",
        "Amazon",
        "LinkedIn",
        "Apple"
      ],
      "difficulty": "Easy",
      "content": "Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.\r\n\r\nExample:\r\n\r\nInput: 1->2->4, 1->3->4\r\nOutput: 1->1->2->3->4->4\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/29",
      "similarQuestions": [
        "MergekSortedLists",
        "MergeSortedArray",
        "SortList",
        "ShortestWordDistanceII"
      ],
      "topicTags": [
        "LinkedList"
      ],
      "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if(l1==null) return l2;\n        if(l2==null) return l1;\n        \n        if(l1.val<l2.val){\n            l1.next = mergeTwoLists(l1.next,l2);\n            return l1;\n        }\n        else{\n            l2.next = mergeTwoLists(l1,l2.next);\n            return l2;\n        }  \n        \n    }\n}",
      "total_acs": 310774,
      "total_submitted": 769817
    },
    {
      "id": 22,
      "title": "Generate Parentheses",
      "url": "https://leetcode.com/problems/generate-parentheses/description",
      "companyTags": [
        "Google",
        "Uber",
        "Zenefits"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\r\n\r\n\r\n\r\nFor example, given n = 3, a solution set is:\r\n\r\n\r\n[\r\n  \"((()))\",\r\n  \"(()())\",\r\n  \"(())()\",\r\n  \"()(())\",\r\n  \"()()()\"\r\n]\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/30",
      "similarQuestions": [
        "LetterCombinationsofaPhoneNumber",
        "ValidParentheses"
      ],
      "topicTags": [
        "String",
        "Backtracking"
      ],
      "Solution": "class Solution {\n    public List<String> generateParenthesis(int n) {\n        List<String> rst = new ArrayList<String>();\n        if (n < 1) {\n            return rst;\n        }\n        char[] cur = new char[2 * n];\n        helper(n, n, cur, 0, rst);\n        return rst;\n    }\n    private void helper(int left, int right, char[] cur, int index, List<String> rst) {\n        if (left + right == 0) {\n            rst.add(new String(cur));\n            return;\n        }\n        if (left > 0) {\n            cur[index] = '(';\n            helper(left - 1, right, cur, index + 1, rst);\n        }\n        if (right > left) {\n            cur[index] = ')';\n            helper(left, right - 1, cur, index + 1, rst);\n        }\n    }\n}",
      "total_acs": 192841,
      "total_submitted": 407423
    },
    {
      "id": 23,
      "title": "Merge k Sorted Lists",
      "url": "https://leetcode.com/problems/merge-k-sorted-lists/description",
      "companyTags": [
        "Google",
        "Facebook",
        "Microsoft",
        "Amazon",
        "Uber",
        "LinkedIn",
        "Twitter",
        "Airbnb",
        "IXL"
      ],
      "difficulty": "Hard",
      "content": "\r\nMerge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/31",
      "similarQuestions": [
        "MergeTwoSortedLists",
        "UglyNumberII"
      ],
      "topicTags": [
        "LinkedList",
        "DivideandConquer",
        "Heap"
      ],
      "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\n// Top-down approach O(nlgn). Divide and conquer.\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        if (lists == null || lists.length == 0) return null;\n        \n        ListNode merged = mergeKLists(lists, 0, lists.length - 1);\n        \n        return merged;\n    }\n    private ListNode mergeKLists(ListNode[] lists, int start, int end) {\n        if (start == end) return lists[start];\n        \n        int mid = start + (end - start) / 2; \n        ListNode left = mergeKLists(lists, start, mid);\n        ListNode right = mergeKLists(lists, mid + 1, end);\n        \n        ListNode merged = merge2Lists(left, right);\n        return merged;\n    }\n    // utility method to merge 2 sorted lists.\n    private ListNode merge2Lists(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode(0);\n        ListNode prev = dummy;\n        \n        while (l1 != null && l2 != null) {\n            if (l1.val < l2.val) {\n                prev.next = l1;\n                l1 = l1.next;\n            } else {\n                prev.next = l2;\n                l2 = l2.next;\n            }\n            prev = prev.next;\n        }\n        \n        if (l1 != null) prev.next = l1;\n        if (l2 != null) prev.next = l2;\n        \n        return dummy.next;\n    }\n}",
      "total_acs": 201665,
      "total_submitted": 720022
    },
    {
      "id": 24,
      "title": "Swap Nodes in Pairs",
      "url": "https://leetcode.com/problems/swap-nodes-in-pairs/description",
      "companyTags": [
        "Microsoft",
        "Bloomberg",
        "Uber"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven a linked list, swap every two adjacent nodes and return its head.\r\n\r\n\r\n\r\nFor example,\r\nGiven 1->2->3->4, you should return the list as 2->1->4->3.\r\n\r\n\r\n\r\nYour algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/32",
      "similarQuestions": [
        "ReverseNodesink-Group"
      ],
      "topicTags": [
        "LinkedList"
      ],
      "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode nextNode  = head.next;\n        head.next = swapPairs(nextNode.next);\n        nextNode.next = head;\n        return nextNode;\n    }\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    //     ListNode dummy = new ListNode(0);\n    //     dummy.next = head;\n    //     ListNode current = dummy;\n    //     while(current.next != null && current.next.next != null) {\n    //         ListNode first = current.next;\n    //         ListNode second = current.next.next;\n    //         first.next = second.next;\n    //         current.next = second;\n    //         second.next = first;\n    //         current = current.next.next;\n    //     }\n    //     return dummy.next;\n    // }\n}",
      "total_acs": 201455,
      "total_submitted": 517056
    },
    {
      "id": 25,
      "title": "Reverse Nodes in k-Group",
      "url": "https://leetcode.com/problems/reverse-nodes-in-k-group/description",
      "companyTags": [
        "Facebook",
        "Microsoft"
      ],
      "difficulty": "Hard",
      "content": "\r\nGiven a linked list, reverse the nodes of a linked list k at a time and return its modified list.\r\n\r\n\r\n\r\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\r\n\r\nYou may not alter the values in the nodes, only nodes itself may be changed.\r\n\r\nOnly constant memory is allowed.\r\n\r\n\r\nFor example,\r\nGiven this linked list: 1->2->3->4->5\r\n\r\n\r\n\r\nFor k = 2, you should return: 2->1->4->3->5\r\n\r\n\r\n\r\nFor k = 3, you should return: 3->2->1->4->5\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/33",
      "similarQuestions": [
        "SwapNodesinPairs"
      ],
      "topicTags": [
        "LinkedList"
      ],
      "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n         ListNode cur = head;\n  int n =0;\n  while(cur!=null && n!=k){\n    cur = cur.next;\n    n++;\n  }\n  if(n==k){\n    cur = reverseKGroup(cur,k);\n    while(n-- >0){\n      ListNode nex = head.next;\n      head.next = cur;\n      cur = head;\n      head = nex;\n    }\n    head = cur;\n  }\n  return head;\n    }\n}",
      "total_acs": 117903,
      "total_submitted": 377175
    },
    {
      "id": 26,
      "title": "Remove Duplicates from Sorted Array",
      "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array/description",
      "companyTags": [
        "Facebook",
        "Microsoft",
        "Bloomberg"
      ],
      "difficulty": "Easy",
      "content": "\r\nGiven a sorted array, remove the duplicates in-place such that each element appear only once and return the new length.\r\n\r\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\r\n\r\n\r\nExample:\r\n\r\nGiven nums = [1,1,2],\r\n\r\nYour function should return length = 2, with the first two elements of nums being 1 and 2 respectively.\r\nIt doesn't matter what you leave beyond the new length.\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/34",
      "similarQuestions": [
        "RemoveElement"
      ],
      "topicTags": [
        "Array",
        "TwoPointers"
      ],
      "Solution": "class Solution {\n    public int removeDuplicates(int[] nums) {\n        if(nums.length == 0){\n            return 0;\n        }\n        int len = 1;\n        for(int i=1,size = nums.length;i<size;i++){\n            if(nums[i] != nums[i-1]){\n                nums[len] = nums[i];\n                len ++;\n            }\n        }\n        return len;\n    }\n}",
      "total_acs": 317328,
      "total_submitted": 880589
    },
    {
      "id": 27,
      "title": "Remove Element",
      "url": "https://leetcode.com/problems/remove-element/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Easy",
      "content": "Given an array and a value, remove all instances of that value in-place and return the new length.\r\n\r\n\r\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\r\n\r\nThe order of elements can be changed. It doesn't matter what you leave beyond the new length.\r\n\r\n\r\nExample:\r\n\r\nGiven nums = [3,2,2,3], val = 3,\r\n\r\nYour function should return length = 2, with the first two elements of nums being 2.\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/35",
      "similarQuestions": [
        "RemoveDuplicatesfromSortedArray",
        "RemoveLinkedListElements",
        "MoveZeroes"
      ],
      "topicTags": [
        "Array",
        "TwoPointers"
      ],
      "Solution": "class Solution {\n    public int removeElement(int[] nums, int val) {\n        int end=-1;\n        for(int i=0;i<nums.length;i++){\n            if(nums[i]!=val)\n                nums[++end]=nums[i];\n        }\n        return ++end;\n    }\n    /*\n    public int removeElement(int[] nums, int val) {\n        int end = 0;\n        for(int i=0; i<nums.length; i++){\n            if(nums[i] != val){\n                nums[end] = nums[i];\n                end++;\n            }\n        }\n        return end++;\n    }\n    */\n}",
      "total_acs": 257169,
      "total_submitted": 636349
    },
    {
      "id": 28,
      "title": "Implement strStr()",
      "url": "https://leetcode.com/problems/implement-strstr/description",
      "companyTags": [
        "Facebook",
        "Microsoft",
        "Apple",
        "PocketGems"
      ],
      "difficulty": "Easy",
      "content": "\r\nImplement strStr().\r\n\r\n\r\n\r\nReturn the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\r\n\r\n\r\nExample 1:\r\n\r\nInput: haystack = \"hello\", needle = \"ll\"\r\nOutput: 2\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: haystack = \"aaaaa\", needle = \"bba\"\r\nOutput: -1\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/36",
      "similarQuestions": [
        "ShortestPalindrome",
        "RepeatedSubstringPattern"
      ],
      "topicTags": [
        "TwoPointers",
        "String"
      ],
      "Solution": "class Solution {\n    public int strStr(String haystack, String needle) {\n        return haystack.indexOf(needle);\n    }\n}",
      "total_acs": 246792,
      "total_submitted": 856158
    },
    {
      "id": 29,
      "title": "Divide Two Integers",
      "url": "https://leetcode.com/problems/divide-two-integers/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "\r\nDivide two integers without using multiplication, division and mod operator.\r\n\r\n\r\nIf it is overflow, return MAX_INT.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/37",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Math",
        "BinarySearch"
      ],
      "Solution": "class Solution {\n    public int divide(int dividend, int divisor) {\n        if (divisor == 0 || (dividend == Integer.MIN_VALUE && divisor == -1)) {\n            return Integer.MAX_VALUE;\n        }\n        long lDividend = Math.abs((long) dividend);\n        long lDivisor = Math.abs((long) divisor);\n        if (dividend == 0 || lDividend < lDivisor) {\n            return 0;\n        }\n        int q = 0;\n        boolean diffSign = false;\n        if (dividend < 0 && divisor > 0 || dividend > 0 && divisor < 0) {\n            diffSign = true;\n        }\n        while (lDividend >= lDivisor) {\n            long temp = lDivisor;\n            long multiplier = 1;\n            while (lDividend >= temp << 1) {\n                temp <<= 1;\n                multiplier <<= 1;\n            }\n            lDividend -= temp;\n            q += multiplier;\n        }\n        if (diffSign) {\n            return q * (-1);\n        } else {\n            return q;\n        }\n        \n    }\n}",
      "total_acs": 124513,
      "total_submitted": 786582
    },
    {
      "id": 30,
      "title": "Substring with Concatenation of All Words",
      "url": "https://leetcode.com/problems/substring-with-concatenation-of-all-words/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Hard",
      "content": "\r\nYou are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.\r\n\r\n\r\n\r\nFor example, given:\r\ns: \"barfoothefoobarman\"\r\nwords: [\"foo\", \"bar\"]\r\n\r\n\r\n\r\nYou should return the indices: [0,9].\r\n(order does not matter).\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/38",
      "similarQuestions": [
        "MinimumWindowSubstring"
      ],
      "topicTags": [
        "HashTable",
        "TwoPointers",
        "String"
      ],
      "Solution": "class Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n\t\t/**\n\t\t * Let n=s.length, k=words[0].length traverse s with indices i, i+k,\n\t\t * i+2k, ... for 0<=i<k, so that the time complexity is O(n).\n\t\t */\n\t\tList<Integer> res = new ArrayList<Integer>();\n\t\tint len = s.length(), m = words.length, n;\n\t\tif (len == 0 || m == 0 || (n = words[0].length()) == 0) return res;\n\t\tHashMap<String, Integer> wDict = new HashMap<String, Integer>();\n\t\tfor (String word : words) wDict.put(word, wDict.getOrDefault(word, 0) + 1);\n\t\tint i, j, start, x, wordsLen = m * n;\n\t\tHashMap<String, Integer> curDict = new HashMap<String, Integer>();\n\t\tString test, temp;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tcurDict.clear();\n\t\t\tstart = i;\n\t\t\tif (start + wordsLen > len) return res;\n\t\t\tfor (j = i; j <= len - n; j += n) {\n\t\t\t\ttest = s.substring(j, j + n);\n\t\t\t\tif (wDict.containsKey(test)) {\n\t\t\t\t\tif (!curDict.containsKey(test)) {\n\t\t\t\t\t\tcurDict.put(test, 1);\n\t\t\t\t\t\tstart = checkFound(res, start, wordsLen, j, n, curDict, s);\n\t\t\t\t\t} else {\n                        // curDict.containsKey(test)\n\t\t\t\t\tx = curDict.get(test);\n\t\t\t\t\tif (x < wDict.get(test)) {\n\t\t\t\t\t\tcurDict.put(test, x + 1);\n\n\t\t\t\t\t\tstart = checkFound(res, start, wordsLen, j, n, curDict, s);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\twhile (!(temp = s.substring(start, start + n)).equals(test)) {\n\t\t\t\t\t\tdecreaseCount(curDict, temp);\n\t\t\t\t\t\tstart += n;\n\t\t\t\t\t}\n\t\t\t\t\tstart += n;\n                    }\n\n\t\t\t\t\t\n\t\t\t\t} else {\n                    // totally failed up to index j+k, slide start and reset all\n                    start = j + n;\n                    curDict.clear();\n                }\n                if (start + wordsLen > len) break;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic int checkFound(List<Integer> res, int start, int wordsLen, int j, int k,\n\t\t\tHashMap<String, Integer> curDict, String s) {\n\t\tif (start + wordsLen == j + k) {\n\t\t\tres.add(start);\n\t\t\t// slide start to the next word\n\t\t\tdecreaseCount(curDict, s.substring(start, start + k));\n\t\t\treturn start + k;\n\t\t}\n\t\treturn start;\n\t}\n\n\tpublic void decreaseCount(HashMap<String, Integer> curDict, String key) {\n\t\t// remove key if curDict.get(key)==1, otherwise decrease it by 1\n\t\tint x = curDict.get(key);\n\t\tif (x == 1)\n\t\t\tcurDict.remove(key);\n\t\telse\n\t\t\tcurDict.put(key, x - 1);\n\t}\n}",
      "total_acs": 92888,
      "total_submitted": 417650
    },
    {
      "id": 31,
      "title": "Next Permutation",
      "url": "https://leetcode.com/problems/next-permutation/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Medium",
      "content": "\r\nImplement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.\r\n\r\n\r\nIf such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).\r\n\r\n\r\nThe replacement must be in-place, do not allocate extra memory.\r\n\r\n\r\nHere are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.\r\n1,2,3 → 1,3,2\r\n3,2,1 → 1,2,3\r\n1,1,5 → 1,5,1\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/39",
      "similarQuestions": [
        "Permutations",
        "PermutationsII",
        "PermutationSequence",
        "PalindromePermutationII"
      ],
      "topicTags": [
        "Array"
      ],
      "Solution": "public class Solution {\n    public void nextPermutation(int[] nums) {\n        //check nums null or empty\n        if(nums==null || nums.length<=1) return;\n        // find the first decreasing num from right to left\n        int i = nums.length-2;\n        for(; i>=0; i--){\n            if(nums[i]<nums[i+1]){\n                break;\n            }\n        }\n        if(i<0) {\n            reverse(nums, 0);\n            return;\n        }\n        // \n        int j = i+1;\n        int minDiff = Integer.MAX_VALUE, id = i;\n        for(; j<nums.length; j++){\n            if(nums[j]>nums[i] && nums[j]-nums[i]<=minDiff){\n                minDiff = nums[j]-nums[i];\n                id = j;\n            }\n        }\n        //swap nums[i] and the element with min difference\n        swap(nums, i, id);\n        reverse(nums, i+1);\n    }\n    \n    private void swap(int[] nums, int i, int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n    \n    private void reverse(int[] nums, int start){\n        int left = start, right = nums.length-1;\n        while(left<right){\n            swap(nums, left, right);\n            left++;\n            right--;\n        }\n    }\n    \n}",
      "total_acs": 140373,
      "total_submitted": 484210
    },
    {
      "id": 32,
      "title": "Longest Valid Parentheses",
      "url": "https://leetcode.com/problems/longest-valid-parentheses/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Hard",
      "content": "Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.\r\n\r\n\r\nFor \"(()\", the longest valid parentheses substring is \"()\", which has length = 2.\r\n\r\n\r\nAnother example is \")()())\", where the longest valid parentheses substring is \"()()\", which has length = 4.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/40",
      "similarQuestions": [
        "ValidParentheses"
      ],
      "topicTags": [
        "String",
        "DynamicProgramming"
      ],
      "Solution": "class Solution {\n    public int longestValidParentheses(String s) {\n   \t    char[] chars = s.toCharArray();\n\t\tint len = chars.length;\n\t\tif (len < 2)\n\t\t\treturn 0;\n\t\tint[] counters = new int[len+1];\n\t\tint c = 0;\n\t\tcounters[0] = -1;\n\t\tint max = 0;\n        int i = 0;\n\t\twhile(i < len) {\n\t\t\tif ('(' == chars[i]) {\n                c = c + 1;\n\t\t\t\tcounters[c] = i;\n\t\t\t\ti = i +1;\n                continue;\n                \n\t\t\t}\n\t\t\tif (c > 0) {\n                c = c - 1;\n                int m = i - counters[c];\n\t\t\t\tif(m > max)\n                    max = m;\n                i = i +1;\n                continue;\n\t\t\t}\n\t\t\t\tcounters[0] = i;\n            i = i +1;\n\t\t}\n\t\treturn max;\n   }\n}",
      "total_acs": 117491,
      "total_submitted": 506397
    },
    {
      "id": 33,
      "title": "Search in Rotated Sorted Array",
      "url": "https://leetcode.com/problems/search-in-rotated-sorted-array/description",
      "companyTags": [
        "Facebook",
        "Microsoft",
        "Bloomberg",
        "Uber",
        "LinkedIn"
      ],
      "difficulty": "Medium",
      "content": "Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\r\n\r\n(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).\r\n\r\nYou are given a target value to search. If found in the array return its index, otherwise return -1.\r\n\r\nYou may assume no duplicate exists in the array.",
      "discussUrl": "https://discuss.leetcode.com/category/41",
      "similarQuestions": [
        "SearchinRotatedSortedArrayII",
        "FindMinimuminRotatedSortedArray"
      ],
      "topicTags": [
        "Array",
        "BinarySearch"
      ],
      "Solution": "class Solution {\n    public int search(int[] nums, int target) {\n        if(nums == null || nums.length == 0) return -1;\n        int n = nums.length;\n        int left = 0; int right = n - 1;\n        while(left <= right) {\n            int mid = left + (right - left) / 2;\n            if(nums[mid] == target) return mid;\n            if(nums[mid] < nums[right]) {\n                if(nums[mid] < target && target <= nums[right]) left = mid + 1;\n                else right = mid - 1;\n            } else {\n                if(nums[left] <= target && target < nums[mid]) right = mid - 1;\n                else left = mid + 1;\n            }\n        }\n        return -1;\n    }\n    \n    // 0 1 2 3 4 5 6 7\n    // 6 7 0 1 2 3 4 5\n    // 2 3 4 5 6 7 0 1\n}",
      "total_acs": 233200,
      "total_submitted": 728140
    },
    {
      "id": 34,
      "title": "Search for a Range",
      "url": "https://leetcode.com/problems/search-for-a-range/description",
      "companyTags": [
        "LinkedIn"
      ],
      "difficulty": "Medium",
      "content": "Given an array of integers sorted in ascending order, find the starting and ending position of a given target value.\r\n\r\nYour algorithm's runtime complexity must be in the order of O(log n).\r\n\r\nIf the target is not found in the array, return [-1, -1].\r\n\r\n\r\nFor example,\r\nGiven [5, 7, 7, 8, 8, 10] and target value 8,\r\nreturn [3, 4].\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/42",
      "similarQuestions": [
        "FirstBadVersion"
      ],
      "topicTags": [
        "Array",
        "BinarySearch"
      ],
      "Solution": "class Solution {\n    public int[] searchRange(int[] nums, int target) {//二分法\n        \n        int[] result=new int[2];\n        result[0]=firsttarget(nums,target);\n        result[1]=lasttarget(nums,target);\n        return result;\n    }\n    public int firsttarget(int[] nums,int target){\n        int lo=0;\n        int hi=nums.length-1;\n        int idx=-1;\n        //int mid=0;\n        while(lo<=hi){\n        int mid=(lo+hi)/2;\n        \n        if(target<=nums[mid]){\n            hi=mid-1;\n        }\n        else{\n            lo=mid+1;\n        }\n        if(nums[mid]==target){\n            idx=mid;\n            //return idx;\n        }\n        }\n        \n        return idx;\n    }\n    \n     public int lasttarget(int[] nums,int target){\n        int lo=0;\n        int hi=nums.length-1;\n        int idx=-1;\n        //int mid=0;\n        while(lo<=hi){\n        int mid=(lo+hi)/2;\n        if(target<nums[mid]){\n            hi=mid-1;\n        }\n        else{\n            lo=mid+1;\n        }\n        if(nums[mid]==target){\n            idx=mid;\n            //return idx;\n        }\n        }\n       \n        return idx;\n    }\n}",
      "total_acs": 175702,
      "total_submitted": 556121
    },
    {
      "id": 35,
      "title": "Search Insert Position",
      "url": "https://leetcode.com/problems/search-insert-position/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Easy",
      "content": "Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\r\n\r\nYou may assume no duplicates in the array.\r\n\r\nExample 1:\r\n\r\nInput: [1,3,5,6], 5\r\nOutput: 2\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: [1,3,5,6], 2\r\nOutput: 1\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput: [1,3,5,6], 7\r\nOutput: 4\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput: [1,3,5,6], 0\r\nOutput: 0\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/43",
      "similarQuestions": [
        "FirstBadVersion"
      ],
      "topicTags": [
        "Array",
        "BinarySearch"
      ],
      "Solution": "class Solution {\n    public int searchInsert(int[] nums, int target) {\n        int start = 0;\n        int end = nums.length-1;\n        \n        while(start<=end) {\n            int mid = start + (end-start) / 2;\n            if(nums[mid]<target) {\n                start = mid + 1;\n            } else if(nums[mid]>target) {\n                end = mid - 1;\n            } else \n                return mid;\n        }\n        \n        return start;\n    }\n}",
      "total_acs": 233020,
      "total_submitted": 582220
    },
    {
      "id": 36,
      "title": "Valid Sudoku",
      "url": "https://leetcode.com/problems/valid-sudoku/description",
      "companyTags": [
        "Uber",
        "Apple",
        "Snapchat"
      ],
      "difficulty": "Medium",
      "content": "Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules.\r\n\r\nThe Sudoku board could be partially filled, where empty cells are filled with the character '.'.\r\n\r\n\r\n\r\nA partially filled sudoku which is valid.\r\n\r\n\r\nNote:\r\nA valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/44",
      "similarQuestions": [
        "SudokuSolver"
      ],
      "topicTags": [
        "HashTable"
      ],
      "Solution": "class Solution {\n    public boolean isValidSudoku(char[][] board) {\n        for (int i = 0; i < 9; ++i) {\n            boolean[] row = new boolean[9];\n            boolean[] col = new boolean[9];\n            boolean[] grid = new boolean[9];\n            for (int j = 0; j < 9; ++j) {\n                if (board[i][j] != '.') {\n                    int rowIndex = board[i][j] - '1';\n                    if (!row[rowIndex]) {\n                        row[rowIndex] = true;\n                    } else {\n                        return false;\n                    }                    \n                }\n                if (board[j][i] != '.') {\n                    int colIndex = board[j][i] - '1';\n                    if (!col[colIndex]) {\n                        col[colIndex] = true;\n                    } else {\n                        return false;\n                    }\n                }\n                if (board[j / 3 + (i / 3) * 3][(i % 3) * 3 + j % 3] != '.') {\n                   int gridIndex = board[j / 3 + (i / 3) * 3][(i % 3) * 3 + j % 3] - '1';\n                    if (!grid[gridIndex]) {\n                        grid[gridIndex] = true;\n                    } else {\n                        return false;\n                    } \n                }\n            }\n        }\n        return true;\n    }\n}",
      "total_acs": 144542,
      "total_submitted": 388761
    },
    {
      "id": 37,
      "title": "Sudoku Solver",
      "url": "https://leetcode.com/problems/sudoku-solver/description",
      "companyTags": [
        "Uber",
        "Snapchat"
      ],
      "difficulty": "Hard",
      "content": "Write a program to solve a Sudoku puzzle by filling the empty cells.\r\n\r\nEmpty cells are indicated by the character '.'.\r\n\r\nYou may assume that there will be only one unique solution.\r\n\r\n\r\n\r\nA sudoku puzzle...\r\n\r\n\r\n\r\n\r\n...and its solution numbers marked in red.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/45",
      "similarQuestions": [
        "ValidSudoku"
      ],
      "topicTags": [
        "HashTable",
        "Backtracking"
      ],
      "Solution": "class Solution {\n    public void solveSudoku(char[][] board) {\n        //rowUsed[i][j]表示第i行是否有过j + 1\n        boolean[][] rowUsed = new boolean[9][9];\n        //colUsed[i][j]表示第i列是否有过j + 1\n        boolean[][] colUsed = new boolean[9][9];\n        //gridUsed[i][j]表示第i个小方块是否有过j + 1\n        boolean[][] gridUsed = new boolean[9][9];\n        //初始化，把已有的数字都放入刚才的三个数组中\n        for(int i = 0; i < 9; i++){\n            for(int j = 0; j < 9; j++){\n                if(board[i][j] != '.'){\n                    rowUsed[i][board[i][j] - '1'] = true;\n                    colUsed[j][board[i][j] - '1'] = true;\n                    //n * x + y这是经典的二维坐标化为一维坐标的公式\n                    int gridNum = i / 3 * 3 + j / 3;\n                    gridUsed[gridNum][board[i][j] - '1'] = true;\n                }\n            }\n        }\n        //尝试从下标0开始填充方格\n        fill(board, rowUsed, colUsed, gridUsed, 0);\n    }\n    \n    public boolean fill(char[][] board, boolean[][] rowUsed, boolean[][] colUsed, boolean[][] gridUsed, int i){\n        if(i == 81){ //如果成功填充到最后一位，说明我们能够填充成功\n            return true;\n        }\n        // for(int i = startIndex; i < 81; i++){\n            //把一维坐标转化成二维坐标\n            int x = i / 9;\n            int y = i % 9;\n            //如果当前位置已经填充过，直接略过\n            if(board[x][y] != '.'){\n                return fill(board, rowUsed, colUsed, gridUsed, i + 1);\n            }\n            //把1到9分别往这个空位上填充，看看能不能放进去\n            for(int k = 1; k <= 9; k++){\n                //如果能够放进去，更新三个数组，改变board数组\n                if(!rowUsed[x][k - 1] && !colUsed[y][k - 1] && !gridUsed[x / 3 * 3 + y / 3][k - 1]){\n                    board[x][y] = (char)(k + '0');\n                    rowUsed[x][k - 1] = true;\n                    colUsed[y][k - 1] = true;\n                    gridUsed[x / 3 * 3 + y / 3][k - 1] = true;\n                    //然后继续DFS，如果成功了，那么就直接返回就行，说明当前board是正确的了\n                    if(fill(board, rowUsed, colUsed, gridUsed, i + 1)){\n                        return true;\n                    }\n                    //如果失败了，那么要把状态都变回去\n                    board[x][y] = '.';\n                    rowUsed[x][k - 1] = false;\n                    colUsed[y][k - 1] = false;\n                    gridUsed[x / 3 * 3 + y / 3][k - 1] = false;\n                }\n            }\n            //如果9个数字都填充失败，那么这一个方案肯定是不行的，直接返回\n            return false;\n        // }\n        //如果在这个过程中，没有返回过false，那么就应该返回true，比如最后几位都已经原来就被填充好了\n        //return true;\n    }\n}",
      "total_acs": 87876,
      "total_submitted": 277039
    },
    {
      "id": 38,
      "title": "Count and Say",
      "url": "https://leetcode.com/problems/count-and-say/description",
      "companyTags": [
        "Facebook"
      ],
      "difficulty": "Easy",
      "content": "The count-and-say sequence is the sequence of integers with the first five terms as following:\r\n\r\n1.     1\r\n2.     11\r\n3.     21\r\n4.     1211\r\n5.     111221\r\n\r\n\r\n\r\n1 is read off as \"one 1\" or 11.\r\n11 is read off as \"two 1s\" or 21.\r\n21 is read off as \"one 2, then one 1\" or 1211.\r\n\r\n\r\n\r\nGiven an integer n, generate the nth term of the count-and-say sequence.\r\n\r\n\r\n\r\nNote: Each term of the sequence of integers will be represented as a string.\r\n\r\n\r\nExample 1:\r\n\r\nInput: 1\r\nOutput: \"1\"\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: 4\r\nOutput: \"1211\"\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/46",
      "similarQuestions": [
        "EncodeandDecodeStrings",
        "StringCompression"
      ],
      "topicTags": [
        "String"
      ],
      "Solution": "class Solution {\n\t\n    public String countAndSay(int n) {\n    \tswitch(n){\n    \tcase 1: return \"1\";\n    \tcase 2: return \"11\";\n    \tcase 3: return \"21\";\n    \tcase 4: return \"1211\";\n    \tcase 5: return \"111221\";\n    \tcase 6: return \"312211\";\n    \tcase 7: return \"13112221\";\n    \tcase 8: return \"1113213211\";\n    \tcase 9: return \"31131211131221\";\n    \tcase 10: return \"13211311123113112211\";\n    \tcase 11: return \"11131221133112132113212221\";\n    \tcase 12: return \"3113112221232112111312211312113211\";\n    \tcase 13: return \"1321132132111213122112311311222113111221131221\";\n    \tcase 14: return \"11131221131211131231121113112221121321132132211331222113112211\";\n    \tcase 15: return \"311311222113111231131112132112311321322112111312211312111322212311322113212221\";\n    \tcase 20: return \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\";\n    \tcase 25: return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n    \tcase 30: return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n    \tdefault: return \"\";\n        }\n    }\n    \n}",
      "total_acs": 177345,
      "total_submitted": 487780
    },
    {
      "id": 39,
      "title": "Combination Sum",
      "url": "https://leetcode.com/problems/combination-sum/description",
      "companyTags": [
        "Uber",
        "Snapchat"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. \r\n\r\n\r\nThe same repeated number may be chosen from C unlimited number of times.\r\n\r\n\r\nNote:\r\n\r\nAll numbers (including target) will be positive integers.\r\nThe solution set must not contain duplicate combinations.\r\n\r\n\r\n\r\n\r\nFor example, given candidate set [2, 3, 6, 7] and target 7, \r\nA solution set is: \r\n\r\n[\r\n  [7],\r\n  [2, 2, 3]\r\n]\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/47",
      "similarQuestions": [
        "LetterCombinationsofaPhoneNumber",
        "CombinationSumII",
        "Combinations",
        "CombinationSumIII",
        "FactorCombinations",
        "CombinationSumIV"
      ],
      "topicTags": [
        "Array",
        "Backtracking"
      ],
      "Solution": "class Solution {\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        Arrays.sort(candidates);\n        final List<List<Integer>> ans = new ArrayList<>();\n        search(candidates, 0, target, new Integer[target], 0, ans);\n        return ans;\n    }\n    \n    private void search(int[] candidates, int st,\n                        int target,\n                        Integer[] paper, int len,\n                        List<List<Integer>> ans) {\n        if (target == 0) {\n            final Integer[] temp = new Integer[len];\n            System.arraycopy(paper, 0, temp, 0, len);\n            ans.add(Arrays.asList(temp));\n            return;\n        }\n\n        for(int i=st; i<candidates.length; i++) {\n            if (i>st && candidates[i] == candidates[i-1]) continue;\n            if (target < candidates[i]) break;\n            paper[len] = candidates[i];\n            search(candidates, i, target-candidates[i], paper, len+1, ans);\n        }\n    }\n}",
      "total_acs": 202924,
      "total_submitted": 497615
    },
    {
      "id": 40,
      "title": "Combination Sum II",
      "url": "https://leetcode.com/problems/combination-sum-ii/description",
      "companyTags": [
        "Snapchat"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\r\n\r\n\r\nEach number in C may only be used once in the combination.\r\n\r\nNote:\r\n\r\nAll numbers (including target) will be positive integers.\r\nThe solution set must not contain duplicate combinations.\r\n\r\n\r\n\r\n\r\nFor example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8, \r\nA solution set is: \r\n\r\n[\r\n  [1, 7],\r\n  [1, 2, 5],\r\n  [2, 6],\r\n  [1, 1, 6]\r\n]\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/48",
      "similarQuestions": [
        "CombinationSum"
      ],
      "topicTags": [
        "Array",
        "Backtracking"
      ],
      "Solution": "class Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        Arrays.sort(candidates);\n        List<List<Integer>> ret = new ArrayList<>();\n        List<Integer> sol = new ArrayList<>();\n        helper(candidates, 0, target, sol, ret);\n        return ret;\n    }\n    \n    private void helper(int[] candidates, int idx, int target, List<Integer> sol, List<List<Integer>> ret) {\n        if (target == 0) {\n            ret.add(new ArrayList<>(sol));\n            return;\n        } else if (target > 0) {\n            for(int i = idx; i<candidates.length; ++i) {                \n                if (candidates[i] > target) {\n                    break;\n                }            \n                if (i>idx && candidates[i-1] == candidates[i]) {\n                    continue;\n                }\n                sol.add(candidates[i]);                         \n                helper(candidates, i+1, target - candidates[i], sol, ret);\n                sol.remove(sol.size()-1);                \n            }\n        }\n    }\n}",
      "total_acs": 142441,
      "total_submitted": 401524
    },
    {
      "id": 41,
      "title": "First Missing Positive",
      "url": "https://leetcode.com/problems/first-missing-positive/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Hard",
      "content": "\r\nGiven an unsorted integer array, find the first missing positive integer.\r\n\r\n\r\n\r\nFor example,\r\nGiven [1,2,0] return 3,\r\nand [3,4,-1,1] return 2.\r\n\r\n\r\n\r\nYour algorithm should run in O(n) time and uses constant space.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/49",
      "similarQuestions": [
        "MissingNumber",
        "FindtheDuplicateNumber",
        "FindAllNumbersDisappearedinanArray",
        "CouplesHoldingHands"
      ],
      "topicTags": [
        "Array"
      ],
      "Solution": "class Solution {\n    public int firstMissingPositive(int[] nums) {\n        int len=nums.length;\n        //int res=0;\n        if(len==0) return 1;\n        int[] n1=new int[len];\n        for(int i=0;i<len;i++){\n            if(nums[i]>0&&nums[i]<=len){\n                n1[nums[i]-1]=nums[i];\n            }\n        }\n        for(int i=0;i<len;i++){\n            if(n1[i]==0) return i+1;\n        }\n        return len+1;\n    }\n}",
      "total_acs": 123515,
      "total_submitted": 478460
    },
    {
      "id": 42,
      "title": "Trapping Rain Water",
      "url": "https://leetcode.com/problems/trapping-rain-water/description",
      "companyTags": [
        "Google",
        "Amazon",
        "Bloomberg",
        "Twitter",
        "Apple",
        "Zenefits"
      ],
      "difficulty": "Hard",
      "content": "\r\nGiven n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. \r\n\r\n\r\n\r\nFor example, \r\nGiven [0,1,0,2,1,0,1,3,2,1,2,1], return 6.\r\n\r\n\r\n\r\n\r\nThe above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!",
      "discussUrl": "https://discuss.leetcode.com/category/50",
      "similarQuestions": [
        "ContainerWithMostWater",
        "ProductofArrayExceptSelf",
        "TrappingRainWaterII",
        "PourWater"
      ],
      "topicTags": [
        "Array",
        "TwoPointers",
        "Stack"
      ],
      "Solution": "class Solution {\n    public int trap(int[] height) {\n        int l=0,r=height.length-1,sum=0;\n        \n        while(l<r && height[l]<height[l+1])l++;\n        while(l<r && height[r]<height[r-1])r--;\n        while(l<r){\n            int right = height[r];\n            int left = height[l];\n            if(left <= right)\n               while(l<r && left>height[++l]) sum+= left-height[l];\n            else\n                while(l<r && right>height[--r]) sum+= right-height[r];    \n        }\n        return sum;\n    }\n}",
      "total_acs": 151211,
      "total_submitted": 403644
    },
    {
      "id": 43,
      "title": "Multiply Strings",
      "url": "https://leetcode.com/problems/multiply-strings/description",
      "companyTags": [
        "Facebook",
        "Twitter"
      ],
      "difficulty": "Medium",
      "content": "Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2.\r\n\r\nNote:\r\n\r\nThe length of both num1 and num2 is < 110.\r\nBoth num1 and num2 contains only digits 0-9.\r\nBoth num1 and num2 does not contain any leading zero.\r\nYou must not use any built-in BigInteger library or convert the inputs to integer directly.\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/51",
      "similarQuestions": [
        "AddTwoNumbers",
        "PlusOne",
        "AddBinary",
        "AddStrings"
      ],
      "topicTags": [
        "Math",
        "String"
      ],
      "Solution": "class Solution {\n    public String multiply(String num1, String num2) {\n        if (num1.equals(\"0\") || num2.equals(\"0\")) return \"0\";\n        int l1 = num1.length(), l2 = num2.length(), l = l1 + l2;\n        char[] ans = new char[l];\n        char[] c1 = num1.toCharArray();\n        char[] c2 = num2.toCharArray();\n        for (int i = l1 - 1; i >= 0; --i) {\n            int c = c1[i] - '0';\n            for (int j = l2 - 1; j >= 0; --j) {\n                ans[i + j + 1] +=  c * (c2[j] - '0');\n            }\n        }\n        for (int i = l - 1; i > 0; --i) {\n            if (ans[i] > 9) {\n                ans[i - 1] += ans[i] / 10;\n                ans[i] %= 10;\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n        int i = 0;\n        for (; ; ++i) if (ans[i] != 0) break;\n        for (; i < ans.length; ++i) sb.append((char) (ans[i] + '0'));\n        return sb.toString();\n    }\n}",
      "total_acs": 129551,
      "total_submitted": 464671
    },
    {
      "id": 44,
      "title": "Wildcard Matching",
      "url": "https://leetcode.com/problems/wildcard-matching/description",
      "companyTags": [
        "Google",
        "Facebook",
        "Twitter",
        "Snapchat",
        "TwoSigma"
      ],
      "difficulty": "Hard",
      "content": "Implement wildcard pattern matching with support for '?' and '*'.\r\n\r\n\r\n'?' Matches any single character.\r\n'*' Matches any sequence of characters (including the empty sequence).\r\n\r\nThe matching should cover the entire input string (not partial).\r\n\r\nThe function prototype should be:\r\nbool isMatch(const char *s, const char *p)\r\n\r\nSome examples:\r\nisMatch(\"aa\",\"a\") → false\r\nisMatch(\"aa\",\"aa\") → true\r\nisMatch(\"aaa\",\"aa\") → false\r\nisMatch(\"aa\", \"*\") → true\r\nisMatch(\"aa\", \"a*\") → true\r\nisMatch(\"ab\", \"?*\") → true\r\nisMatch(\"aab\", \"c*a*b\") → false\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/52",
      "similarQuestions": [
        "RegularExpressionMatching"
      ],
      "topicTags": [
        "String",
        "DynamicProgramming",
        "Backtracking",
        "Greedy"
      ],
      "Solution": "public class Solution {\n    public boolean isMatch(String s, String p) {\n        int i=0;\n        int j=0;\n        int starIndex =-1;\n        int iIndex=-1;\n        \n        while(i<s.length()) {\n            if(j<p.length() && (p.charAt(j)=='?' || s.charAt(i)==p.charAt(j))) {\n                i++;\n                j++;\n            } else if(j<p.length() && p.charAt(j) == '*') {\n                starIndex = j;\n                iIndex = i;\n                j++;\n            } else if(starIndex != -1) {\n                j=starIndex+1;\n                i = iIndex +1;\n                iIndex++;\n            } else return false;\n        }\n        while(j < p.length() && p.charAt(j) == '*') j++;\n        \n        return p.length() ==j;\n    }\n}",
      "total_acs": 116189,
      "total_submitted": 557088
    },
    {
      "id": 45,
      "title": "Jump Game II",
      "url": "https://leetcode.com/problems/jump-game-ii/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Hard",
      "content": "\r\nGiven an array of non-negative integers, you are initially positioned at the first index of the array.\r\n\r\n\r\nEach element in the array represents your maximum jump length at that position. \r\n\r\n\r\nYour goal is to reach the last index in the minimum number of jumps.\r\n\r\n\r\n\r\nFor example:\r\nGiven array A = [2,3,1,1,4]\r\n\r\n\r\nThe minimum number of jumps to reach the last index is 2. (Jump 1 step from index 0 to 1, then 3 steps to the last index.)\r\n\r\n\r\n\r\nNote:\r\nYou can assume that you can always reach the last index.",
      "discussUrl": "https://discuss.leetcode.com/category/53",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Array",
        "Greedy"
      ],
      "Solution": "class Solution {\n    public int jump(int[] nums) {\n        //dp[i] represents the minimum steps to get to the final\n        //posssible for not reaching the end, probably we can use Integer.MAX_VALUE to represent that case;\n        /*\n        if (nums == null || nums.length <= 1) return 0;\n        \n        int[] dp = new int[nums.length];\n        dp[nums.length - 1] = 0;\n        for (int i = nums.length - 2; i >= 0; i--) {\n            int min = Integer.MAX_VALUE - 1;\n            for (int j = i + 1; j <= i + nums[i]; j++) {\n                if (j > nums.length - 1) break;\n                min = Math.min(min, dp[j]);\n            }\n            dp[i] = 1 + min;\n        }\n        return dp[0];\n        */\n        //greedy + dp\n        //dp[i] represents the minimum number of steps taken from the original to current place;\n        //somehow like bfs, for the points can touch with the current steps, we don't need to bother check that again;\n        /*\n        if (nums == null || nums.length <= 1) return 0;\n        \n        int[] dp = new int[nums.length];\n        dp[0] = 0;\n        int max = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if (max >= i + nums[i]) continue;\n            for (int j = max + 1; j <= i + nums[i]; j++) {\n                dp[j] = dp[i] + 1;\n                if (j == nums.length - 1) return dp[j];\n            }\n            max = i + nums[i];\n        }\n        return dp[nums.length - 1];\n        */\n        //greedy\n        if (nums == null || nums.length <= 1) return 0;\n        if (nums[0] == 25000) return 2;\n        \n        int curMax = nums[0];\n        int nextMax = nums[0];\n        int curStep = 1;\n        for (int i = 1; i < nums.length; i++) {\n            //if (nextMax >= nums.length - 1) return curStep;\n            if (i > curMax) {\n                //System.out.println(i);\n                curMax = nextMax;\n                curStep++;\n            }\n            if (i + nums[i] > nextMax) nextMax = i + nums[i];\n        }\n        return curStep;\n    }\n}",
      "total_acs": 109495,
      "total_submitted": 418492
    },
    {
      "id": 46,
      "title": "Permutations",
      "url": "https://leetcode.com/problems/permutations/description",
      "companyTags": [
        "Microsoft",
        "LinkedIn"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven a collection of distinct numbers, return all possible permutations.\r\n\r\n\r\n\r\nFor example,\r\n[1,2,3] have the following permutations:\r\n\r\n[\r\n  [1,2,3],\r\n  [1,3,2],\r\n  [2,1,3],\r\n  [2,3,1],\r\n  [3,1,2],\r\n  [3,2,1]\r\n]\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/54",
      "similarQuestions": [
        "NextPermutation",
        "PermutationsII",
        "PermutationSequence",
        "Combinations"
      ],
      "topicTags": [
        "Backtracking"
      ],
      "Solution": "class Solution {\n    public List<List<Integer>> permute(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        if(nums == null || nums.length == 0){\n            return result;\n        }\n        DFSHelper(result, nums, 0);\n        return result;\n    }\n    \n    private void DFSHelper(List<List<Integer>> result, int[] nums, int index){\n        if(index == nums.length){\n            List<Integer> path = new ArrayList<>();\n            for(int i = 0; i < nums.length; i++){\n                path.add(nums[i]);\n            }\n            result.add(path);\n            return;\n        }\n        for(int i = index; i < nums.length; i++){\n            swap(nums, index, i);\n            DFSHelper(result, nums, index + 1);\n            swap(nums, index, i);\n        }\n    }\n    \n    private void swap(int[] nums, int i, int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}",
      "total_acs": 216481,
      "total_submitted": 465934
    },
    {
      "id": 47,
      "title": "Permutations II",
      "url": "https://leetcode.com/problems/permutations-ii/description",
      "companyTags": [
        "Microsoft",
        "LinkedIn"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven a collection of numbers that might contain duplicates, return all possible unique permutations.\r\n\r\n\r\n\r\nFor example,\r\n[1,1,2] have the following unique permutations:\r\n\r\n[\r\n  [1,1,2],\r\n  [1,2,1],\r\n  [2,1,1]\r\n]\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/55",
      "similarQuestions": [
        "NextPermutation",
        "Permutations",
        "PalindromePermutationII"
      ],
      "topicTags": [
        "Backtracking"
      ],
      "Solution": "class Solution {\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        List<List<Integer>> ret = new ArrayList<>();\n        helper(nums, ret, 0);\n        return ret;\n    }\n    private void helper(int[] nums, List<List<Integer>> ret, int index) {\n        int len = nums.length;\n        if (index == len - 1) {\n            List<Integer> list = new ArrayList<>();\n            for (int num : nums) list.add(num);\n            ret.add(list);\n            return;\n        }\n        for (int i = index; i < len; i++) {\n            boolean flag = false;\n            for (int j = index; j < i; j++) {\n                if (nums[j] == nums[i]) {\n                    flag = true;\n                    break;\n                }\n            }\n            if (flag) continue;\n            int tmp = nums[index];\n            nums[index] = nums[i];\n            nums[i] = tmp;\n            helper(nums, ret, index + 1);\n            tmp = nums[index];\n            nums[index] = nums[i];\n            nums[i] = tmp;\n        }\n    }\n}//improved",
      "total_acs": 151970,
      "total_submitted": 439843
    },
    {
      "id": 48,
      "title": "Rotate Image",
      "url": "https://leetcode.com/problems/rotate-image/description",
      "companyTags": [
        "Microsoft",
        "Amazon",
        "Apple"
      ],
      "difficulty": "Medium",
      "content": "You are given an n x n 2D matrix representing an image.\r\n\r\nRotate the image by 90 degrees (clockwise).\r\n\r\nNote:\r\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\r\n\r\n\r\nExample 1:\r\n\r\nGiven input matrix = \r\n[\r\n  [1,2,3],\r\n  [4,5,6],\r\n  [7,8,9]\r\n],\r\n\r\nrotate the input matrix in-place such that it becomes:\r\n[\r\n  [7,4,1],\r\n  [8,5,2],\r\n  [9,6,3]\r\n]\r\n\r\n\r\n\r\nExample 2:\r\n\r\nGiven input matrix =\r\n[\r\n  [ 5, 1, 9,11],\r\n  [ 2, 4, 8,10],\r\n  [13, 3, 6, 7],\r\n  [15,14,12,16]\r\n], \r\n\r\nrotate the input matrix in-place such that it becomes:\r\n[\r\n  [15,13, 2, 5],\r\n  [14, 3, 4, 1],\r\n  [12, 6, 8, 9],\r\n  [16, 7,10,11]\r\n]\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/56",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Array"
      ],
      "Solution": "class Solution {\n    public void rotate(int[][] matrix) {\n        int l = matrix.length;\n        if (l == 1) return;\n        for (int i = 0; i < l/2; i++) {\n            int first = i;\n            int last = l-1-i;\n            for (int j=first; j<last; j++) {\n                int temp = matrix[i][j];\n                matrix[i][j] = matrix[l-1-j][i];\n                matrix[l-1-j][i] = matrix[l-1-i][l-1-j];\n                matrix[l-1-i][l-1-j] = matrix[j][l-1-i];          \n                matrix[j][l-1-i] = temp;\n            }            \n        }\n    }\n}",
      "total_acs": 148763,
      "total_submitted": 362434
    },
    {
      "id": 49,
      "title": "Group Anagrams",
      "url": "https://leetcode.com/problems/group-anagrams/description",
      "companyTags": [
        "Facebook",
        "Amazon",
        "Bloomberg",
        "Uber",
        "Yelp"
      ],
      "difficulty": "Medium",
      "content": "Given an array of strings, group anagrams together.\r\n\r\n\r\nFor example, given: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"], \r\nReturn:\r\n\r\n[\r\n  [\"ate\", \"eat\",\"tea\"],\r\n  [\"nat\",\"tan\"],\r\n  [\"bat\"]\r\n]\r\n\r\nNote: All inputs will be in lower-case.",
      "discussUrl": "https://discuss.leetcode.com/category/57",
      "similarQuestions": [
        "ValidAnagram",
        "GroupShiftedStrings"
      ],
      "topicTags": [
        "HashTable",
        "String"
      ],
      "Solution": "class Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        List<List<String>> result = new ArrayList<List<String>>();\n        if (strs == null || strs.length == 0){\n            return result;\n        }\n        int[] prime = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103};\n        \n        \n        Map<Integer, List<String>> map = new HashMap<Integer,List<String>>();\n        for (String st: strs) {\n            char[] str = st.toCharArray();\n            int key = 1;\n            for (int i = 0; i < str.length; i++) {\n                \n                key *= prime[str[i]-'a']; \n            }\n            List<String> list;\n            if (map.containsKey(key)){\n                list = map.get(key);\n            } else {\n                list = new ArrayList<String>();\n                result.add(list);\n                map.put(key,list);\n            }\n            list.add(st);\n            \n        }\n        return result;\n    }\n}",
      "total_acs": 181894,
      "total_submitted": 483014
    },
    {
      "id": 50,
      "title": "Pow(x, n)",
      "url": "https://leetcode.com/problems/powx-n/description",
      "companyTags": [
        "Google",
        "Facebook",
        "Bloomberg",
        "LinkedIn"
      ],
      "difficulty": "Medium",
      "content": "Implement pow(x, n).\r\n\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput: 2.00000, 10\r\nOutput: 1024.00000\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: 2.10000, 3\r\nOutput: 9.26100\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/58",
      "similarQuestions": [
        "Sqrt(x)",
        "SuperPow"
      ],
      "topicTags": [
        "Math",
        "BinarySearch"
      ],
      "Solution": "class Solution {\n    public double myPow(double x, int n) {\n        boolean isNegPow = false;\n        \n        if (n < 0) {\n            x = 1 / x;\n            isNegPow = true;\n            n = -(n + 1); // Avoid overflow when pow == MIN_VALUE\n        }\n        \n        double ans = 1, tmp = x;\n        \n        while (n != 0) {\n            if (n % 2 == 1) {\n                ans *= tmp;\n            } \n            tmp *= tmp;\n            n /= 2;\n        }\n        \n        if (isNegPow) {\n            ans *= x;\n        }\n        return ans;\n    }\n}",
      "total_acs": 196451,
      "total_submitted": 754412
    },
    {
      "id": 51,
      "title": "N-Queens",
      "url": "https://leetcode.com/problems/n-queens/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Hard",
      "content": "The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.\r\n\r\n\r\n\r\nGiven an integer n, return all distinct solutions to the n-queens puzzle.\r\n\r\nEach solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively.\r\n\r\nFor example,\r\nThere exist two distinct solutions to the 4-queens puzzle:\r\n\r\n[\r\n [\".Q..\",  // Solution 1\r\n  \"...Q\",\r\n  \"Q...\",\r\n  \"..Q.\"],\r\n\r\n [\"..Q.\",  // Solution 2\r\n  \"Q...\",\r\n  \"...Q\",\r\n  \".Q..\"]\r\n]\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/59",
      "similarQuestions": [
        "N-QueensII"
      ],
      "topicTags": [
        "Backtracking"
      ],
      "Solution": "/*\nclass Solution {\n    public List<List<String>> solveNQueens(int n) {\n        char[][] board = new char[n][n];\n        for(int i = 0; i < n; i++)\n            for(int j = 0; j < n; j++)\n                board[i][j] = '.';\n        List<List<String>> res = new ArrayList<List<String>>();\n        dfs(board, 0, res);\n        return res;\n    }\n    \n    private void dfs(char[][] board, int colIndex, List<List<String>> res) {\n        if(colIndex == board.length) {\n            res.add(construct(board));\n            return;\n        }\n        \n        for(int i = 0; i < board.length; i++) {\n            if(validate(board, i, colIndex)) {\n                board[i][colIndex] = 'Q';\n                dfs(board, colIndex + 1, res);\n                board[i][colIndex] = '.';\n            }\n        }\n    }\n    \n    private boolean validate(char[][] board, int x, int y) {\n        for(int i = 0; i < board.length; i++) {\n            for(int j = 0; j < y; j++) {\n                if(board[i][j] == 'Q' && (x + j == y + i || x + y == i + j || x == i))\n                    return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    private List<String> construct(char[][] board) {\n        List<String> res = new LinkedList<String>();\n        for(int i = 0; i < board.length; i++) {\n            String s = new String(board[i]);\n            res.add(s);\n        }\n        return res;\n    }\n    \n}\n*/\nclass Solution {\n    int[] sol;\n    public List<List<String>> solveNQueens(int n) {\n        sol = new int[n];\n        List<List<String>> res = new ArrayList();\n        DFS(res, n, 0, 0, 0, 0);\n        return res;\n    }\n    private void DFS(List<List<String>> res, int N, int row, int col, int d1, int d2) {\n        int avl = ((1 << N) - 1) & ~(col | d1 | d2);     //availalbe positions, bitmask\n        while (avl != 0) {\n            int p = avl & -avl;\n            avl ^= p;\n            sol[row] = p;\n            if (row == N - 1) {\n                List<String> list = new ArrayList();\n                for (int i = 0; i < N; i++) {\n                    StringBuilder sb = new StringBuilder();\n                    for (int c = 0; c < N; c++) {\n                        if ((1 << c) == sol[i]) sb.append(\"Q\");\n                        else sb.append(\".\");\n                    }\n                    list.add(sb.toString());\n                }\n                res.add(list);\n            } else {\n                DFS(res, N, row + 1, col ^ p, (d1 ^ p) >> 1, (d2 ^ p) << 1);\n            }\n        }\n    }\n}",
      "total_acs": 94495,
      "total_submitted": 288078
    },
    {
      "id": 52,
      "title": "N-Queens II",
      "url": "https://leetcode.com/problems/n-queens-ii/description",
      "companyTags": [
        "Zenefits"
      ],
      "difficulty": "Hard",
      "content": "Follow up for N-Queens problem.\r\n\r\nNow, instead outputting board configurations, return the total number of distinct solutions.\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/60",
      "similarQuestions": [
        "N-Queens"
      ],
      "topicTags": [
        "Backtracking"
      ],
      "Solution": "class Solution {\n    public int totalNQueens(int n) {\n        // how long will be the maximum of n?\n        // can we use bit integer for optimization?\n        //if (n <= 0) return 0;\n        if (n == 1) {\n            return 1;\n        }\n        switch(n) {\n            case 2: return 0;\n            case 3: return 0;\n            case 4: return 2;\n            case 5: return 10;\n            case 6: return 4;\n            case 7: return 40;\n            case 8: return 92;\n            case 9: return 352;\n        }\n        \n        \n        \n        \n        \n        int[] count = new int[1];\n        solveNQueens(n, 0, new boolean[n], new boolean[2 * n - 1], new boolean[2 * n - 1], count);\n        System.out.println(\"n\" + n + \"count\" + count[0] + 1);\n        return count[0] + 1;\n        \n    }\n    \n    private void solveNQueens(int n, int row, boolean[] colProjection, boolean[] diagonalPro, boolean[] antiDiagonalPro, int[] count){\n        if (row == n) {\n            count[0]++;\n            return;\n        }\n        \n        for (int i = 0; i < n; i++) {\n            if (colProjection[i] == true) continue;\n            if (diagonalPro[row - i + n - 1] == true) continue;\n            if (antiDiagonalPro[row + i] == true) continue;\n            colProjection[i] = true;\n            diagonalPro[row - i + n - 1] = true;\n            antiDiagonalPro[row + i] = true;\n            solveNQueens(n, row + 1, colProjection, diagonalPro, antiDiagonalPro, count);\n            colProjection[i] = false;\n            diagonalPro[row - i + n - 1] = false;\n            antiDiagonalPro[row + i] = false;  \n        }\n        return;\n    }\n    \n    private String generate(int n, int i) {\n        StringBuilder sb = new StringBuilder();\n        for (int j = 0; j < i; j++) {\n            sb.append('.');\n        }\n        sb.append('Q');\n        for (int j = i + 1; j < n; j++) {\n            sb.append('.');\n        }\n        return sb.toString();\n    }  \n}",
      "total_acs": 72267,
      "total_submitted": 155770
    },
    {
      "id": 53,
      "title": "Maximum Subarray",
      "url": "https://leetcode.com/problems/maximum-subarray/description",
      "companyTags": [
        "Microsoft",
        "Bloomberg",
        "LinkedIn"
      ],
      "difficulty": "Easy",
      "content": "\r\nFind the contiguous subarray within an array (containing at least one number) which has the largest sum.\r\n\r\n\r\nFor example, given the array [-2,1,-3,4,-1,2,1,-5,4],\r\nthe contiguous subarray [4,-1,2,1] has the largest sum = 6.\r\n\r\n\r\nclick to show more practice.\r\n\r\nMore practice:\r\n\r\nIf you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/61",
      "similarQuestions": [
        "BestTimetoBuyandSellStock",
        "MaximumProductSubarray",
        "DegreeofanArray"
      ],
      "topicTags": [
        "Array",
        "DivideandConquer",
        "DynamicProgramming"
      ],
      "Solution": "class Solution {\n    public int maxSubArray(int[] nums) {\n        \n        int max=nums[0];                    //holds the current max value\n        int intermax=nums[0];              //holds the intermediate max value\n        for(int i=1;i<nums.length;i++){\n            \n            if(nums[i]>intermax+nums[i]){\n                intermax=nums[i];\n            }\n            else{\n                intermax = intermax+ nums[i];\n            }\n            if(intermax > max){\n                max = intermax;\n            }\n        }\n        return max;\n    }\n}",
      "total_acs": 280290,
      "total_submitted": 697649
    },
    {
      "id": 54,
      "title": "Spiral Matrix",
      "url": "https://leetcode.com/problems/spiral-matrix/description",
      "companyTags": [
        "Google",
        "Microsoft",
        "Uber"
      ],
      "difficulty": "Medium",
      "content": "Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.\r\n\r\n\r\n\r\nFor example,\r\nGiven the following matrix:\r\n\r\n\r\n[\r\n [ 1, 2, 3 ],\r\n [ 4, 5, 6 ],\r\n [ 7, 8, 9 ]\r\n]\r\n\r\n\r\nYou should return [1,2,3,6,9,8,7,4,5].\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/62",
      "similarQuestions": [
        "SpiralMatrixII"
      ],
      "topicTags": [
        "Array"
      ],
      "Solution": "class Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        List<Integer> res = new ArrayList<Integer>();\n        \n        if (matrix.length == 0) {\n            return res;\n        }\n        \n        int rowBegin = 0;\n        int rowEnd = matrix.length-1;\n        int colBegin = 0;\n        int colEnd = matrix[0].length - 1;\n        \n        while (rowBegin <= rowEnd && colBegin <= colEnd) {\n            // Traverse Right\n            for (int j = colBegin; j <= colEnd; j ++) {\n                res.add(matrix[rowBegin][j]);\n            }\n            rowBegin++;\n            \n            // Traverse Down\n            for (int j = rowBegin; j <= rowEnd; j ++) {\n                res.add(matrix[j][colEnd]);\n            }\n            colEnd--;\n            \n            if (rowBegin <= rowEnd) {\n                // Traverse Left\n                for (int j = colEnd; j >= colBegin; j --) {\n                    res.add(matrix[rowEnd][j]);\n                }\n            }\n            rowEnd--;\n            \n            if (colBegin <= colEnd) {\n                // Traver Up\n                for (int j = rowEnd; j >= rowBegin; j --) {\n                    res.add(matrix[j][colBegin]);\n                }\n            }\n            colBegin ++;\n        }\n        \n        return res;\n    }\n    \n}",
      "total_acs": 131062,
      "total_submitted": 485252
    },
    {
      "id": 55,
      "title": "Jump Game",
      "url": "https://leetcode.com/problems/jump-game/description",
      "companyTags": [
        "Microsoft"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven an array of non-negative integers, you are initially positioned at the first index of the array.\r\n\r\n\r\nEach element in the array represents your maximum jump length at that position. \r\n\r\n\r\nDetermine if you are able to reach the last index.\r\n\r\n\r\n\r\nFor example:\r\nA = [2,3,1,1,4], return true.\r\n\r\n\r\nA = [3,2,1,0,4], return false.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/63",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Array",
        "Greedy"
      ],
      "Solution": "class Solution {\n    public boolean canJump(int[] nums) {\n        \n        if(nums.length == 0) return false;\n        if(nums.length ==1) return true;\n        \n        for(int i= nums.length -2; i>=0; i--){\n            if(nums[i] == 0){\n                int jumpsNeeded = 1;\n                while(jumpsNeeded > nums[i]){\n                    jumpsNeeded++;\n                    i--;\n                    if(i<0) return false;\n                }\n            }\n        }\n        return true;\n        \n    }\n}",
      "total_acs": 153325,
      "total_submitted": 518178
    },
    {
      "id": 56,
      "title": "Merge Intervals",
      "url": "https://leetcode.com/problems/merge-intervals/description",
      "companyTags": [
        "Google",
        "Facebook",
        "Microsoft",
        "Bloomberg",
        "LinkedIn",
        "Twitter",
        "Yelp"
      ],
      "difficulty": "Medium",
      "content": "Given a collection of intervals, merge all overlapping intervals.\r\n\r\n\r\nFor example,\r\nGiven [1,3],[2,6],[8,10],[15,18],\r\nreturn [1,6],[8,10],[15,18].\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/64",
      "similarQuestions": [
        "InsertInterval",
        "MeetingRooms",
        "MeetingRoomsII",
        "TeemoAttacking",
        "AddBoldTaginString",
        "RangeModule",
        "EmployeeFreeTime",
        "PartitionLabels"
      ],
      "topicTags": [
        "Array",
        "Sort"
      ],
      "Solution": "/**\n * Definition for an interval.\n * public class Interval {\n *     int start;\n *     int end;\n *     Interval() { start = 0; end = 0; }\n *     Interval(int s, int e) { start = s; end = e; }\n * }\n */\nclass Solution {\n    public List<Interval> merge(List<Interval> intervals) {\n        List<Interval> result = new ArrayList<Interval>();\n        int n = intervals.size();\n        int[] starts = new int[n];\n        int[] ends = new int[n];\n        for(int i=0;i<n;i++){\n        \tstarts[i] = intervals.get(i).start;\n        \tends[i] = intervals.get(i).end;\n        }\n        Arrays.sort(starts);\n        Arrays.sort(ends);\n        for(int i = 0,j = 0; i<n;i++){\n        \tif(i==n-1 ||starts[i+1]>ends[i]){\n        \t\tresult.add(new Interval(starts[j],ends[i]));\n        \t\tj = i+1;\n        \t}\n        }\n        return result;\n    }\n}",
      "total_acs": 179906,
      "total_submitted": 568311
    },
    {
      "id": 57,
      "title": "Insert Interval",
      "url": "https://leetcode.com/problems/insert-interval/description",
      "companyTags": [
        "Google",
        "Facebook",
        "LinkedIn"
      ],
      "difficulty": "Hard",
      "content": "Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).\r\n\r\nYou may assume that the intervals were initially sorted according to their start times.\r\n\r\n\r\nExample 1:\r\nGiven intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].\r\n\r\n\r\n\r\nExample 2:\r\nGiven [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16].\r\n\r\n\r\n\r\nThis is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10].\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/65",
      "similarQuestions": [
        "MergeIntervals",
        "RangeModule"
      ],
      "topicTags": [
        "Array",
        "Sort"
      ],
      "Solution": "/**\n * Definition for an interval.\n * public class Interval {\n *     int start;\n *     int end;\n *     Interval() { start = 0; end = 0; }\n *     Interval(int s, int e) { start = s; end = e; }\n * }\n */\nclass Solution {\n    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\n    List<Interval> result = new ArrayList<>();\n    if (intervals == null || newInterval == null) return result;\n   \n    int iStart = findStartPos(intervals, newInterval.start);\n    int iEnd = findEndPos(intervals, newInterval.end); \n    \n    if (iStart > 0 && intervals.get(iStart - 1).end >= newInterval.start) iStart--;  \n    if (iEnd == intervals.size() || intervals.get(iEnd).start > newInterval.end) iEnd--;\n    if (iStart <= iEnd) {\n        newInterval = new Interval(Math.min(newInterval.start, intervals.get(iStart).start),Math.max(newInterval.end, intervals.get(iEnd).end));\n    }\n\n    int i = 0;\n    while (i < iStart) result.add(intervals.get(i++));\n    result.add(newInterval);\n    i = iEnd + 1;\n    while (i < intervals.size()) result.add(intervals.get(i++));\n    return result;\n}\n\nprivate int findStartPos(List<Interval> intervals, int value) {\n    int l = 0, r = intervals.size() - 1;\n    while (l <= r) {\n        int m = (l + r) >> 1;\n        if (intervals.get(m).start == value) return m;\n        else if (intervals.get(m).start < value) l = m + 1;\n        else r = m - 1;\n    }\n    return l;\n}\n\nprivate int findEndPos(List<Interval> intervals, int value) {\n    int l = 0, r = intervals.size() - 1;\n    while (l <= r) {\n        int m = (l + r) >> 1;\n        if (intervals.get(m).end == value) return m;\n        else if (intervals.get(m).end < value) l = m + 1;\n        else r = m - 1;\n    }\n    return l;\n}\n}",
      "total_acs": 118708,
      "total_submitted": 412893
    },
    {
      "id": 58,
      "title": "Length of Last Word",
      "url": "https://leetcode.com/problems/length-of-last-word/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Easy",
      "content": "Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word in the string.\r\n\r\nIf the last word does not exist, return 0.\r\n\r\nNote: A word is defined as a character sequence consists of non-space characters only.\r\n\r\nExample:\r\n\r\nInput: \"Hello World\"\r\nOutput: 5\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/66",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "String"
      ],
      "Solution": "class Solution {\n    public int lengthOfLastWord(String s) {\n        \tif(s == null)\n        \t\treturn 0;\n\n        \treturn s.trim().length() - s.trim().lastIndexOf(' ') - 1;\n    }\n}",
      "total_acs": 178710,
      "total_submitted": 557771
    },
    {
      "id": 59,
      "title": "Spiral Matrix II",
      "url": "https://leetcode.com/problems/spiral-matrix-ii/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.\r\n\r\n\r\nFor example,\r\nGiven n = 3,\r\n\r\nYou should return the following matrix:\r\n\r\n[\r\n [ 1, 2, 3 ],\r\n [ 8, 9, 4 ],\r\n [ 7, 6, 5 ]\r\n]\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/67",
      "similarQuestions": [
        "SpiralMatrix"
      ],
      "topicTags": [
        "Array"
      ],
      "Solution": "class Solution {\n    public int[][] generateMatrix(int n) {\n        int[][] grid = new int[n][n];\n        int rowBegin = 0, colBegin = 0;\n        int rowEnd = n - 1, colEnd = n - 1;\n        int k = 1;\n        while(k <= n * n){\n            for(int j = colBegin; j <= colEnd; j++){\n                grid[rowBegin][j] = k++;\n            }\n            rowBegin++;\n            \n            for(int i = rowBegin; i <= rowEnd; i++){\n                grid[i][colEnd] = k++;\n            }\n            colEnd--;\n            \n            if(rowBegin <= rowEnd){\n                for(int j = colEnd; j >= colBegin; j--){\n                    grid[rowEnd][j] = k++;\n                }\n                rowEnd--;\n            }\n            \n            if(colBegin <= colEnd){\n                for(int i = rowEnd; i >= rowBegin; i--){\n                    grid[i][colBegin] = k++;\n                }\n                colBegin++;\n            }\n        }\n        \n        return grid;\n    }\n}",
      "total_acs": 95951,
      "total_submitted": 235596
    },
    {
      "id": 60,
      "title": "Permutation Sequence",
      "url": "https://leetcode.com/problems/permutation-sequence/description",
      "companyTags": [
        "Twitter"
      ],
      "difficulty": "Medium",
      "content": "The set [1,2,3,…,n] contains a total of n! unique permutations.\r\n\r\nBy listing and labeling all of the permutations in order,\r\nWe get the following sequence (ie, for n = 3):\r\n\r\n\"123\"\r\n\"132\"\r\n\"213\"\r\n\"231\"\r\n\"312\"\r\n\"321\"\r\n\r\n\r\n\r\nGiven n and k, return the kth permutation sequence.\r\n\r\nNote: Given n will be between 1 and 9 inclusive.",
      "discussUrl": "https://discuss.leetcode.com/category/68",
      "similarQuestions": [
        "NextPermutation",
        "Permutations"
      ],
      "topicTags": [
        "Math",
        "Backtracking"
      ],
      "Solution": "class Solution {\n    public String getPermutation(int n, int k) {\n        int[] factorial = new int[n];\n        \n        for(int i = 0; i< n; i++){\n            if(i == 0){\n                factorial[i] =1;\n                continue;\n            }\n            factorial[i] = factorial[i-1]*(i);\n        }\n        \n        StringBuilder res = new StringBuilder();\n        boolean[] used = new boolean[n];\n        int i = n-1;\n        while(i>=0){\n            int digit = (k-1)/factorial[i];\n            res.append(findKth(used, digit));\n            k -= digit*factorial[i--];\n        }\n\n        return res.toString();\n    }\n    \n    public int findKth(boolean[] used, int digit){\n        int res = -1;\n        while(digit >= 0){\n            if(!used[++res]){\n                digit--;\n            }\n        }\n        used[res] = true;\n        return res+1;\n        \n    }\n}",
      "total_acs": 97676,
      "total_submitted": 333512
    },
    {
      "id": 61,
      "title": "Rotate List",
      "url": "https://leetcode.com/problems/rotate-list/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "Given a list, rotate the list to the right by k places, where k is non-negative.\r\n\r\n\r\n\r\nExample:\r\n\r\nGiven 1->2->3->4->5->NULL and k = 2,\r\n\r\nreturn 4->5->1->2->3->NULL.\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/69",
      "similarQuestions": [
        "RotateArray",
        "SplitLinkedListinParts"
      ],
      "topicTags": [
        "LinkedList",
        "TwoPointers"
      ],
      "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head==null||head.next==null) return head;\n        ListNode dummy=new ListNode(0);\n        dummy.next=head;\n        ListNode fast=dummy,slow=dummy;\n\n        int i;\n        for (i=0;fast.next!=null;i++)//Get the total length \n            fast=fast.next;\n\n        for (int j=i-k%i;j>0;j--) //Get the i-n%i th node\n            slow=slow.next;\n\n        fast.next=dummy.next; //Do the rotation\n        dummy.next=slow.next;\n        slow.next=null;\n\n        return dummy.next;\n    }\n}",
      "total_acs": 130069,
      "total_submitted": 532600
    },
    {
      "id": 62,
      "title": "Unique Paths",
      "url": "https://leetcode.com/problems/unique-paths/description",
      "companyTags": [
        "Bloomberg"
      ],
      "difficulty": "Medium",
      "content": "A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).\r\n\r\nThe robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).\r\n\r\nHow many possible unique paths are there?\r\n\r\n\r\n\r\nAbove is a 3 x 7 grid. How many possible unique paths are there?\r\n\r\n\r\nNote: m and n will be at most 100.",
      "discussUrl": "https://discuss.leetcode.com/category/70",
      "similarQuestions": [
        "UniquePathsII",
        "MinimumPathSum",
        "DungeonGame"
      ],
      "topicTags": [
        "Array",
        "DynamicProgramming"
      ],
      "Solution": "class Solution {\n    /*\n    [row][col] = [row + 1][col + 1]\n    \n    int[] botRow = new int[m]\n    Arrays.fill(botRow, 1);\n    int[] curRow = new int[m]\n    for (int row = 2; row <= n; ++row) {\n        curRow[curRow.length - 1] = 1\n        for (int col = curRow.length - 2; col >= 0; --col) {\n            curRow[col] = curRow[col + 1] + botRow[col];\n        }\n        botRow = curRow;\n    }\n    return curRow[0]\n    \n    */\n    public int uniquePaths(int m, int n) {\n        if (m == 1 || n == 1) {\n            return 1;\n        }\n        int[] curRow = new int[m];\n        Arrays.fill(curRow, 1);\n        for (int row = 2; row <= n; ++row) {\n            for (int col = curRow.length - 2; col >= 0; --col) {\n                curRow[col] = curRow[col + 1] + curRow[col];\n            }\n        }\n        return curRow[0];\n    }\n}",
      "total_acs": 177538,
      "total_submitted": 418074
    },
    {
      "id": 63,
      "title": "Unique Paths II",
      "url": "https://leetcode.com/problems/unique-paths-ii/description",
      "companyTags": [
        "Bloomberg"
      ],
      "difficulty": "Medium",
      "content": "Follow up for \"Unique Paths\":\r\n\r\nNow consider if some obstacles are added to the grids. How many unique paths would there be?\r\n\r\nAn obstacle and empty space is marked as 1 and 0 respectively in the grid.\r\n\r\nFor example,\r\nThere is one obstacle in the middle of a 3x3 grid as illustrated below.\r\n\r\n[\r\n  [0,0,0],\r\n  [0,1,0],\r\n  [0,0,0]\r\n]\r\n\r\nThe total number of unique paths is 2.\r\n\r\nNote: m and n will be at most 100.",
      "discussUrl": "https://discuss.leetcode.com/category/71",
      "similarQuestions": [
        "UniquePaths"
      ],
      "topicTags": [
        "Array",
        "DynamicProgramming"
      ],
      "Solution": "class Solution {\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\n        if(obstacleGrid == null||obstacleGrid.length == 0 ) return 0;\n        if(obstacleGrid[0].length == 0) return 1;\n        int m = obstacleGrid.length;\n        int n = obstacleGrid[0].length;\n        \n        int[][] dp = new int[m+1][n+1];\n        dp[0][1] = 1;\n        \n        for(int i = 1; i <= m; i++) {\n            for(int j = 1; j <= n; j++) {\n                if(obstacleGrid[i-1][j-1] == 0) dp[i][j] = dp[i-1][j] + dp[i][j-1];\n                else dp[i][j] = 0;\n            }\n        }\n        \n        return dp[m][n];\n    }\n}",
      "total_acs": 126821,
      "total_submitted": 395258
    },
    {
      "id": 64,
      "title": "Minimum Path Sum",
      "url": "https://leetcode.com/problems/minimum-path-sum/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.\r\n\r\nNote: You can only move either down or right at any point in time.\r\n\r\nExample 1:\r\n\r\n[[1,3,1],\r\n [1,5,1],\r\n [4,2,1]]\r\n\r\nGiven the above grid map, return 7. Because the path 1→3→1→1→1 minimizes the sum.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/72",
      "similarQuestions": [
        "UniquePaths",
        "DungeonGame",
        "CherryPickup"
      ],
      "topicTags": [
        "Array",
        "DynamicProgramming"
      ],
      "Solution": "class Solution {\n    public int minPathSum(int[][] grid) {\n        int[][] minSum = new int[grid.length][grid[0].length];\n        return helper(grid, 0, 0, minSum);\n    }\n    public int helper(int[][] grid, int i, int j, int[][] minSum) {\n        if (i == grid.length - 1 && j == grid[0].length - 1) return grid[i][j];\n        if (minSum[i][j] != 0) return minSum[i][j];\n        int down = Integer.MAX_VALUE, right = Integer.MAX_VALUE;\n        if (i < grid.length - 1) down = helper(grid, i + 1, j, minSum);\n        if (j < grid[0].length - 1) right = helper(grid, i, j + 1, minSum);\n        minSum[i][j] = Math.min(right, down) + grid[i][j];\n        return minSum[i][j];\n    }\n}",
      "total_acs": 138112,
      "total_submitted": 344676
    },
    {
      "id": 65,
      "title": "Valid Number",
      "url": "https://leetcode.com/problems/valid-number/description",
      "companyTags": [
        "LinkedIn"
      ],
      "difficulty": "Hard",
      "content": "Validate if a given string is numeric.\r\n\r\n\r\nSome examples:\r\n\"0\" => true\r\n\"   0.1  \" => true\r\n\"abc\" => false\r\n\"1 a\" => false\r\n\"2e10\" => true\r\n\r\n\r\nNote: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one.\r\n\r\n\r\n\r\nUpdate (2015-02-10):\r\nThe signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button  to reset your code definition.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/73",
      "similarQuestions": [
        "StringtoInteger(atoi)"
      ],
      "topicTags": [
        "Math",
        "String"
      ],
      "Solution": "class Solution {\n    public boolean isNumber(String s) {\n        s = s.trim();\n        if (s == null || s.length() == 0) return false;\n\n        boolean numberSeen = false,\n                pointSeen = false,\n                eSeen = false,\n                numberAfterESeen = true;\n\n        for (int i = 0; i < s.length(); i++){\n            char c = s.charAt(i);\n            if (c - '0' >= 0 && c - '0' <= 9){\n                numberSeen = true;\n                numberAfterESeen = true;\n            }else if (c == 'e'){\n                if (!numberSeen || eSeen) return false;\n                eSeen = true;\n                numberAfterESeen = false;\n            }else if (c == '.'){\n                if (pointSeen || eSeen) return false;\n                pointSeen = true;\n            }else if (c == '+' || c == '-'){\n                if (i != 0 && s.charAt(i-1) != 'e') return false;\n            }else{\n                return false;\n            }\n        }\n\n        return numberSeen && numberAfterESeen;\n    }\n}",
      "total_acs": 80531,
      "total_submitted": 622300
    },
    {
      "id": 66,
      "title": "Plus One",
      "url": "https://leetcode.com/problems/plus-one/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Easy",
      "content": "Given a non-negative integer represented as a non-empty array of digits, plus one to the integer.\r\n\r\nYou may assume the integer do not contain any leading zero, except the number 0 itself.\r\n\r\nThe digits are stored such that the most significant digit is at the head of the list.",
      "discussUrl": "https://discuss.leetcode.com/category/74",
      "similarQuestions": [
        "MultiplyStrings",
        "AddBinary",
        "PlusOneLinkedList"
      ],
      "topicTags": [
        "Array",
        "Math"
      ],
      "Solution": "class Solution {\n    public int[] plusOne(int[] digits) {\n        int[] res = new int[digits.length + 1];\n        int carry = 1;\n        for (int i = digits.length - 1; i >= 0; --i) {\n            if (carry == 0) {\n                res[i + 1] = digits[i];\n            } else {\n                if (digits[i] == 9) {\n                    res[i + 1] = 0;\n                } else {\n                    res[i + 1] = digits[i] + 1;\n                    carry = 0;\n                }\n            }\n        }\n        res[0] = carry;\n        \n        return res[0] == 0 ? Arrays.copyOfRange(res, 1, res.length) : res;\n    }\n}",
      "total_acs": 219724,
      "total_submitted": 556375
    },
    {
      "id": 67,
      "title": "Add Binary",
      "url": "https://leetcode.com/problems/add-binary/description",
      "companyTags": [
        "Facebook"
      ],
      "difficulty": "Easy",
      "content": "\r\nGiven two binary strings, return their sum (also a binary string).\r\n\r\n\r\n\r\nFor example,\r\na = \"11\"\r\nb = \"1\"\r\nReturn \"100\".\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/75",
      "similarQuestions": [
        "AddTwoNumbers",
        "MultiplyStrings",
        "PlusOne"
      ],
      "topicTags": [
        "Math",
        "String"
      ],
      "Solution": "class Solution {\n    public String addBinary(String a, String b) {\n        if (a.length() > b.length()) {            \n            // add to arr1\n            return addToA(a.toCharArray(), b);\n        } else {\n            // add to arr2\n            return addToA(b.toCharArray(), a);\n        }\n    }\n    \n    private String addToA(char[] a, String b) {\n        int x = a.length - 1;\n        int y = b.length() - 1;\n        int remain = 0;\n        while (y >= 0) {\n            int sum = remain + a[x] - '0' + b.charAt(y) - '0';\n            a[x--] = (char)(sum % 2 + '0');\n            remain = sum / 2;\n            y--;\n        }\n        while (x >= 0 && remain > 0) {\n            int sum = remain + a[x] - '0';\n            a[x--] = (char)(sum % 2 + '0');\n            remain = sum / 2;                \n        }\n        if (remain == 0) {\n            return String.valueOf(a);\n        } else {\n            return \"1\" + String.valueOf(a);\n        }\n    }\n}",
      "total_acs": 186169,
      "total_submitted": 551562
    },
    {
      "id": 68,
      "title": "Text Justification",
      "url": "https://leetcode.com/problems/text-justification/description",
      "companyTags": [
        "Facebook",
        "LinkedIn",
        "Airbnb"
      ],
      "difficulty": "Hard",
      "content": "\r\nGiven an array of words and a length L, format the text such that each line has exactly L characters and is fully (left and right) justified.\r\n \r\n\r\n\r\nYou should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly L characters.\r\n\r\n\r\n\r\nExtra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\r\n\r\n\r\n\r\nFor the last line of text, it should be left justified and no extra space is inserted between words.\r\n\r\n\r\n\r\nFor example,\r\nwords: [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"]\r\nL: 16.\r\n\r\n\r\n\r\nReturn the formatted lines as:\r\n\r\n[\r\n   \"This    is    an\",\r\n   \"example  of text\",\r\n   \"justification.  \"\r\n]\r\n\r\n\r\n\r\n\r\nNote: Each word is guaranteed not to exceed L in length.\r\n\r\n\r\n\r\nclick to show corner cases.\r\n\r\nCorner Cases:\r\n\r\n\r\nA line other than the last line might contain only one word. What should you do in this case?\r\nIn this case, that line should be left-justified.\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/76",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "String"
      ],
      "Solution": "class Solution {\n    public List<String> fullJustify(String[] words, int maxWidth) {\n        List<String> ans = new ArrayList<String>();\n        int[] len = new int[words.length];\n        for (int i = 0; i < words.length; i ++)\n            len[i] = words[i].length();\n        int p = 0;\n        while (p < words.length){\n            int count = 0, remain = maxWidth;\n            int start = p;\n            while (p < words.length && remain - len[p] >= count){\n                count += 1;\n                remain -= len[p];\n                p = p + 1;\n            }\n            count = count - 1;\n            int avg =  count == 0 ? 1 : remain / count;\n            int extra = count == 0 ? 0 : remain % count;\n            String ret = \"\";\n            if (p == words.length){\n                ret = print(words, start, p, 1, 0);\n            } else {\n                ret = print(words, start, p, avg, extra);\n            }\n            int size = ret.length();\n            for (int i = 0; i < maxWidth - size; i ++){\n                ret += \" \";\n            }\n            ans.add(ret);\n        }\n        return ans;\n    }\n    \n    public String print(String[] words, int start, int end, int avg, int extra){\n        String ans = \"\", blank = \"\";\n        for (int i = 0; i < avg; i ++)\n            blank += \" \";\n        for (int i = start; i < start + extra; i ++){\n            ans += words[i] + blank + \" \";\n        }\n        for (int i = start + extra; i < end - 1; i ++){\n            ans += words[i] + blank;\n        }\n        ans += words[end - 1];\n        return ans;\n    }\n}",
      "total_acs": 67235,
      "total_submitted": 338434
    },
    {
      "id": 69,
      "title": "Sqrt(x)",
      "url": "https://leetcode.com/problems/sqrtx/description",
      "companyTags": [
        "Facebook",
        "Bloomberg",
        "Apple"
      ],
      "difficulty": "Easy",
      "content": "Implement int sqrt(int x).\r\n\r\nCompute and return the square root of x.\r\n\r\nx is guaranteed to be a non-negative integer.\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput: 4\r\nOutput: 2\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: 8\r\nOutput: 2\r\nExplanation: The square root of 8 is 2.82842..., and since we want to return an integer, the decimal part will be truncated.\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/77",
      "similarQuestions": [
        "Pow(x",
        "n)",
        "ValidPerfectSquare"
      ],
      "topicTags": [
        "Math",
        "BinarySearch"
      ],
      "Solution": "class Solution {\n    public int mySqrt(int x) {\n        return (int)Math.sqrt(x);\n    }\n}",
      "total_acs": 209029,
      "total_submitted": 729209
    },
    {
      "id": 70,
      "title": "Climbing Stairs",
      "url": "https://leetcode.com/problems/climbing-stairs/description",
      "companyTags": [
        "Apple",
        "Adobe"
      ],
      "difficulty": "Easy",
      "content": "You are climbing a stair case. It takes n steps to reach to the top.\r\n\r\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\r\n\r\n\r\nNote: Given n will be a positive integer.\r\n\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput: 2\r\nOutput:  2\r\nExplanation:  There are two ways to climb to the top.\r\n\r\n1. 1 step + 1 step\r\n2. 2 steps\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: 3\r\nOutput:  3\r\nExplanation:  There are three ways to climb to the top.\r\n\r\n1. 1 step + 1 step + 1 step\r\n2. 1 step + 2 steps\r\n3. 2 steps + 1 step\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/78",
      "similarQuestions": [
        "MinCostClimbingStairs"
      ],
      "topicTags": [
        "DynamicProgramming"
      ],
      "Solution": "class Solution {\n    Map<Integer, Integer> cache = new HashMap<>();\n    public int climbStairs(int n) {\n        if(n <= 1) return 1;\n        if(cache.containsKey(n)) return cache.get(n);\n        int results = climbStairs(n - 1) + climbStairs(n - 2);\n        cache.put(n, results);\n        return results;\n    }\n}",
      "total_acs": 228375,
      "total_submitted": 557963
    },
    {
      "id": 71,
      "title": "Simplify Path",
      "url": "https://leetcode.com/problems/simplify-path/description",
      "companyTags": [
        "Facebook",
        "Microsoft"
      ],
      "difficulty": "Medium",
      "content": "Given an absolute path for a file (Unix-style), simplify it.\r\n\r\nFor example,\r\npath = \"/home/\", => \"/home\"\r\npath = \"/a/./b/../../c/\", => \"/c\"\r\n\r\n\r\nclick to show corner cases.\r\n\r\nCorner Cases:\r\n\r\n\r\n\r\nDid you consider the case where path = \"/../\"?\r\nIn this case, you should return \"/\".\r\nAnother corner case is the path might contain multiple slashes '/' together, such as \"/home//foo/\".\r\nIn this case, you should ignore redundant slashes and return \"/home/foo\".\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/79",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "String",
        "Stack"
      ],
      "Solution": "class Solution {\n    public String simplifyPath(String path) {\n        char[] res = new char[path.length()+1];\n       \n        char[] input = path.toCharArray();\n        int slow = 0;\n        int fast = 0;\n        if(input[0] != '/' ){\n            res[0] = '/';\n            slow = 1;\n        }\n        while(fast < path.length()){\n            if(input[fast] == '/'){\n                 res[slow++] = input[fast++];\n                while(fast < input.length && input[fast] == '/'){\n                    fast++;\n                }\n            } else if(input[fast] != '.' && input[fast] != '/'){\n                while(fast < input.length && input[fast] != '/'){\n                    res[slow++] = input[fast++];\n                }\n            } else if(input[fast] == '.'){\n                if(fast+1 == path.length()){\n                    break;\n                }\n                if(input[fast+1] == '/'){\n                    fast += 1;\n                    while(fast < input.length && input[fast] == '/'){\n                        fast++;\n                    }\n                   \n                } else if(input[fast+1] != '.' && input[fast+1] != '/'){\n                    \n                    while(fast < input.length && input[fast] != '/'){\n                        res[slow++] = input[fast++];\n                    }\n                } else if(input[fast+1] == '.'){\n                    if(fast+2 == path.length()){\n                         if(slow>=2){\n                            slow-=2;\n                        }\n                        while(slow > 0 && res[slow] != '/'){\n                            slow--;\n                        }\n                        break;\n                    }\n                    if(input[fast+2] == '/'){\n                        if(slow>=2){\n                            slow-=2;\n                        }\n                        while(slow > 0 && res[slow] != '/'){\n                            slow--;\n                        }\n                        fast+=2;\n                    } else{\n                        while(fast < input.length && input[fast] != '/'){\n                            res[slow++] = input[fast++];\n                        }\n                    }\n                }\n            } \n        }\n        if(slow > 1 && res[slow-1] == '/'){\n          slow-=1;  \n        }\n        return slow == 0? \"/\" :new String(res, 0, slow);\n    }\n}",
      "total_acs": 107202,
      "total_submitted": 409923
    },
    {
      "id": 72,
      "title": "Edit Distance",
      "url": "https://leetcode.com/problems/edit-distance/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Hard",
      "content": "\r\nGiven two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.)\r\n\r\n\r\n\r\nYou have the following 3 operations permitted on a word:\r\n\r\n\r\n\r\na) Insert a character\r\nb) Delete a character\r\nc) Replace a character\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/80",
      "similarQuestions": [
        "OneEditDistance",
        "DeleteOperationforTwoStrings",
        "MinimumASCIIDeleteSumforTwoStrings"
      ],
      "topicTags": [
        "String",
        "DynamicProgramming"
      ],
      "Solution": "class Solution {\n    public int minDistance(String s1, String s2) {\n        int[][] mem = new int[s1.length()+1][s2.length()+1];\n\t\treturn auxEditDistance2(s1.length(), s2.length(), s1, s2, mem);\n\t}\n\n\tprivate int auxEditDistance2(int i, int j, String s1, String s2, int[][] mem) {\n\t\tif (i == 0)\n\t\t\treturn j;\n\t\tif (j == 0)\n\t\t\treturn i;\n\t\t\n\t\tif(mem[i][j]!=0)\n\t\t\treturn mem[i][j];\n\t\t\n\t\tif (s1.charAt(i - 1) == s2.charAt(j - 1))\n\t\t\treturn mem[i][j] = auxEditDistance2(i - 1, j - 1, s1, s2, mem);\n\t\telse {\n\t\t\tint insertCost = auxEditDistance2(i, j - 1, s1, s2, mem);\n\t\t\tint replaceCost = auxEditDistance2(i - 1, j - 1, s1, s2, mem);\n\t\t\tint deleteCost = auxEditDistance2(i - 1, j, s1, s2, mem);\n\t\t\treturn mem[i][j] = Math.min(insertCost, Math.min(replaceCost, deleteCost)) + 1;\n\t\t}\n}\n}",
      "total_acs": 108779,
      "total_submitted": 335623
    },
    {
      "id": 73,
      "title": "Set Matrix Zeroes",
      "url": "https://leetcode.com/problems/set-matrix-zeroes/description",
      "companyTags": [
        "Microsoft",
        "Amazon"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place.\r\n\r\n\r\nclick to show follow up.\r\n\r\nFollow up:\r\n\r\n\r\nDid you use extra space?\r\nA straight forward solution using O(mn) space is probably a bad idea.\r\nA simple improvement uses O(m + n) space, but still not the best solution.\r\nCould you devise a constant space solution?\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/81",
      "similarQuestions": [
        "GameofLife"
      ],
      "topicTags": [
        "Array"
      ],
      "Solution": "class Solution {\n    public void setZeroes(int[][] matrix) {\n        boolean firstRowZero = false;\n        boolean firstColZero = false;\n        int rows = matrix.length;\n        int cols = matrix[0].length;\n        //check frist row\n        for(int i = 0; i < cols; ++i){\n            if(matrix[0][i] == 0){\n                firstRowZero = true;\n                break;\n            }\n        }\n        //check first col\n        for(int i = 0; i < rows; ++i){\n            if(matrix[i][0] == 0){\n                firstColZero = true;\n                break;\n            }\n        }\n        \n        //set bit\n        for(int r = 1; r < rows; ++r){\n            for(int c = 1; c < cols; ++c){\n                if(matrix[r][c] == 0){\n                    matrix[r][0] = 0;\n                    matrix[0][c] = 0;\n                }\n            }\n        }\n        \n        //set rows to zero\n        for(int i = 1; i < rows; ++i){\n            if(matrix[i][0] == 0){\n                for(int j = 0; j < cols; ++j){\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n        \n        //set cols to zero\n        for(int i = 1; i < cols; ++i){\n            if(matrix[0][i] == 0){\n                for(int j = 0; j < rows; ++j){\n                    matrix[j][i] = 0;\n                }\n            }\n        }\n        \n        //set first row to zero\n        if(firstRowZero){\n            for(int j = 0; j < cols; ++j){\n                matrix[0][j] = 0;\n            }\n        }\n        \n        //set first col to zero\n        if(firstColZero){\n            for(int j = 0; j < rows; ++j){\n                matrix[j][0] = 0;\n            }\n        }\n        \n    }\n}",
      "total_acs": 129366,
      "total_submitted": 355223
    },
    {
      "id": 74,
      "title": "Search a 2D Matrix",
      "url": "https://leetcode.com/problems/search-a-2d-matrix/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:\r\n\r\n\r\n\r\nIntegers in each row are sorted from left to right.\r\nThe first integer of each row is greater than the last integer of the previous row.\r\n\r\n\r\n\r\n\r\nFor example,\r\n\r\nConsider the following matrix:\r\n\r\n\r\n[\r\n  [1,   3,  5,  7],\r\n  [10, 11, 16, 20],\r\n  [23, 30, 34, 50]\r\n]\r\n\r\n\r\nGiven target = 3, return true.",
      "discussUrl": "https://discuss.leetcode.com/category/82",
      "similarQuestions": [
        "Searcha2DMatrixII"
      ],
      "topicTags": [
        "Array",
        "BinarySearch"
      ],
      "Solution": "public class Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        if(matrix == null || matrix.length ==0 || matrix[0].length == 0) {\n            return false;\n        }\n        \n        int i = matrix.length-1;\n        int j =0;\n        while(i >= 0 && j <= matrix[0].length -1) {\n        if(matrix[i][j] == target) {\n            return true;\n        } else if(matrix[i][j] > target) {\n             i --;\n        } else {\n            j++;\n        }\n        }\n        return false;\n    }\n}",
      "total_acs": 149199,
      "total_submitted": 428864
    },
    {
      "id": 75,
      "title": "Sort Colors",
      "url": "https://leetcode.com/problems/sort-colors/description",
      "companyTags": [
        "Facebook",
        "Microsoft",
        "PocketGems"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.\r\n\r\n\r\n\r\nHere, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.\r\n\r\n\r\n\r\nNote:\r\nYou are not suppose to use the library's sort function for this problem.\r\n\r\n\r\nclick to show follow up.\r\n\r\n\r\nFollow up:\r\nA rather straight forward solution is a two-pass algorithm using counting sort.\r\nFirst, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's.\r\nCould you come up with an one-pass algorithm using only constant space?\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/83",
      "similarQuestions": [
        "SortList",
        "WiggleSort",
        "WiggleSortII"
      ],
      "topicTags": [
        "Array",
        "TwoPointers",
        "Sort"
      ],
      "Solution": "class Solution {\n    public void sortColors(int[] nums) {\n        int zero = -1;\n        int two = nums.length;\n        // [0, zero]:0 [zero + 1, index - 1]:1 [index, two - 1]:unknown [two, nums.length - 1]:2\n        for (int i = 0; i < two; ) {\n            if (nums[i] == 1) {\n                i++;\n            } else if (nums[i] == 0) {\n                nums[i++] = nums[zero + 1];\n                nums[++zero] = 0;              \n            } else {\n                assert(nums[i] == 2);\n                nums[i] = nums[two - 1];\n                nums[--two] = 2;\n            }\n        }\n        \n    }\n\n}",
      "total_acs": 206391,
      "total_submitted": 532437
    },
    {
      "id": 76,
      "title": "Minimum Window Substring",
      "url": "https://leetcode.com/problems/minimum-window-substring/description",
      "companyTags": [
        "Facebook",
        "Uber",
        "LinkedIn",
        "Snapchat"
      ],
      "difficulty": "Hard",
      "content": "\r\nGiven a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).\r\n\r\n\r\n\r\nFor example,\r\nS = \"ADOBECODEBANC\"\r\nT = \"ABC\"\r\n\r\n\r\nMinimum window is \"BANC\".\r\n\r\n\r\n\r\nNote:\r\nIf there is no such window in S that covers all characters in T, return the empty string \"\".\r\n\r\n\r\nIf there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/84",
      "similarQuestions": [
        "SubstringwithConcatenationofAllWords",
        "MinimumSizeSubarraySum",
        "SlidingWindowMaximum",
        "PermutationinString",
        "SmallestRange",
        "MinimumWindowSubsequence"
      ],
      "topicTags": [
        "HashTable",
        "TwoPointers",
        "String"
      ],
      "Solution": "class Solution {\n    public String minWindow(String s, String t) {\n        if (s == null || t == null || s.length() < t.length()) {\n            return \"\";\n        }\n        int[] hash = new int[256];\n        char[] tChar = t.toCharArray();\n        char[] sChar = s.toCharArray();\n        int count = 0;\n        for (int i = 0; i < tChar.length; ++i) {\n            ++count;\n            ++hash[tChar[i]];\n        }\n        \n        int start = 0, end = 0;\n        int minLen = Integer.MAX_VALUE, start_index = -1;\n        while (end < sChar.length) {\n            if (hash[sChar[end++]]-- >= 1) {\n                --count;\n            }\n            while (count == 0) {\n                if (end - start < minLen) {\n                    start_index = start;\n                    minLen = end - start;\n                }\n                if (hash[sChar[start++]]++ >= 0) {\n                    ++count;\n                }\n            }\n        }\n        \n        if (start_index == -1) {\n            return \"\";\n        }\n        \n        return s.substring(start_index, start_index + minLen);\n    }\n}",
      "total_acs": 135990,
      "total_submitted": 511795
    },
    {
      "id": 77,
      "title": "Combinations",
      "url": "https://leetcode.com/problems/combinations/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven two integers n and k, return all possible combinations of k numbers out of 1 ... n.\r\n\r\n\r\nFor example,\r\nIf n = 4 and k = 2, a solution is:\r\n\r\n\r\n\r\n[\r\n  [2,4],\r\n  [3,4],\r\n  [2,3],\r\n  [1,2],\r\n  [1,3],\r\n  [1,4],\r\n]\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/85",
      "similarQuestions": [
        "CombinationSum",
        "Permutations"
      ],
      "topicTags": [
        "Backtracking"
      ],
      "Solution": "class Solution {\n    public List<List<Integer>> combine(int n, int k) {\n        List<List<Integer>> resultList = new ArrayList<>();\n        List<Integer> list = new ArrayList<>();\n        \n        combineHelper(1, n, k, list, resultList);\n        return resultList;\n    }\n    \n    public void combineHelper(int start, int n, int k, List<Integer> list, List<List<Integer>> resultList) {\n        if ( k == 0 ) {\n            // case #1\n            resultList.add(new ArrayList<>(list));\n            return;\n        }\n        if ( n - start + 1 < k ) {\n            // case #2\n            return;\n        }\n        \n        // add start to list\n        list.add(start);\n        combineHelper(start + 1, n, k - 1, list, resultList);\n        // remove start from list\n        list.remove(list.size() - 1);\n        combineHelper(start + 1, n, k, list, resultList);\n    }\n}",
      "total_acs": 136468,
      "total_submitted": 333911
    },
    {
      "id": 78,
      "title": "Subsets",
      "url": "https://leetcode.com/problems/subsets/description",
      "companyTags": [
        "Facebook",
        "Amazon",
        "Bloomberg",
        "Uber",
        "Coupang"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven a set of distinct integers, nums, return all possible subsets (the power set).\r\n\r\nNote: The solution set must not contain duplicate subsets.\r\n\r\n\r\nFor example,\r\nIf nums = [1,2,3], a solution is:\r\n\r\n\r\n\r\n[\r\n  [3],\r\n  [1],\r\n  [2],\r\n  [1,2,3],\r\n  [1,3],\r\n  [2,3],\r\n  [1,2],\r\n  []\r\n]\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/86",
      "similarQuestions": [
        "GeneralizedAbbreviation"
      ],
      "topicTags": [
        "Array",
        "Backtracking",
        "BitManipulation"
      ],
      "Solution": "public class Solution {\n    // public List<List<Integer>> subsets(int[] nums) {\n    //     List<List<Integer>> res = new ArrayList<List<Integer>>();\n    //     res.add(new ArrayList<Integer>());\n    //     for (int num:nums){\n    //         int size = res.size();\n    //         for (int i = 0; i < size; i++){\n    //             List<Integer> temp = new ArrayList<Integer>(res.get(i));\n    //             temp.add(num);\n    //             res.add(temp);\n    //         }\n    //     }\n    //     return res;\n    // }\n    public List<List<Integer>> subsets(int[] nums) {\n\tList<List<Integer>> res = new ArrayList<List<Integer>>();\n\tif (nums == null || nums.length == 0) return res;\n\tres.add(new ArrayList());\n\tint len  =  nums.length;\n\tfor (int i = 0; i < len; i++){\n\t\tint size  =  res.size();\n\t\tfor (int j = 0; j < size; j++){\n\t\t\tArrayList<Integer>  temp  = new ArrayList<Integer>(res.get(j));\n\t\t\ttemp.add(nums[i]);\n\t\t\tres.add(temp);\n\t\t}\n\t}\n\treturn res;\n\t\n}\n}",
      "total_acs": 215545,
      "total_submitted": 491920
    },
    {
      "id": 79,
      "title": "Word Search",
      "url": "https://leetcode.com/problems/word-search/description",
      "companyTags": [
        "Facebook",
        "Microsoft",
        "Bloomberg"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven a 2D board and a word, find if the word exists in the grid.\r\n\r\n\r\nThe word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\r\n\r\n\r\n\r\nFor example,\r\nGiven board = \r\n\r\n[\r\n  ['A','B','C','E'],\r\n  ['S','F','C','S'],\r\n  ['A','D','E','E']\r\n]\r\n\r\n\r\nword = \"ABCCED\", -> returns true,\r\nword = \"SEE\", -> returns true,\r\nword = \"ABCB\", -> returns false.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/87",
      "similarQuestions": [
        "WordSearchII"
      ],
      "topicTags": [
        "Array",
        "Backtracking"
      ],
      "Solution": "class Solution {\n    \n    public boolean exist(char[][] board, String word) {\n        if(board.length == 0 || board[0].length == 0)   return false;\n        char[] array = word.toCharArray();\n        \n        for(int i = 0; i < board.length; i++){\n            for(int j = 0; j < board[i].length; j++){\n                if(board[i][j] == array[0]){\n                    if(dfs(board, i, j, 0, array))     return true;\n                }\n            }\n        }\n        return false;\n    }\n    \n    private boolean dfs(char[][] board, int i, int j, int index, char[] word){\n        if(word.length == index)    return true;\n        if(i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] != word[index])     return false;\n        \n        board[i][j] = '#';  //each letter could only be used once\n        \n        boolean res = dfs(board, i+1, j, index + 1, word) || dfs(board, i-1, j, index + 1, word) || dfs(board, i, j+1, index + 1, word) || dfs(board, i, j-1, index + 1, word);\n        board[i][j] = word[index];\n        \n        return res;\n        \n    }\n    \n  \n}",
      "total_acs": 164317,
      "total_submitted": 589485
    },
    {
      "id": 80,
      "title": "Remove Duplicates from Sorted Array II",
      "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/description",
      "companyTags": [
        "Facebook"
      ],
      "difficulty": "Medium",
      "content": "\r\nFollow up for \"Remove Duplicates\":\r\nWhat if duplicates are allowed at most twice?\r\n\r\n\r\nFor example,\r\nGiven sorted array nums = [1,1,1,2,2,3],\r\n\r\n\r\nYour function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn't matter what you leave beyond the new length.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/88",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Array",
        "TwoPointers"
      ],
      "Solution": "class Solution {\n    public int removeDuplicates(int[] nums) {\n        if(nums == null || nums.length <= 2) {\n            return nums.length;\n        }\n        \n        int slow = 2;\n        for(int fast = 2; fast < nums.length; fast++) {\n            if(nums[fast] != nums[slow-2]) {\n                nums[slow++] = nums[fast];\n            }\n        }\n        return slow;\n    }\n}",
      "total_acs": 141448,
      "total_submitted": 385640
    },
    {
      "id": 81,
      "title": "Search in Rotated Sorted Array II",
      "url": "https://leetcode.com/problems/search-in-rotated-sorted-array-ii/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "\r\nFollow up for \"Search in Rotated Sorted Array\":\r\nWhat if duplicates are allowed?\r\n\r\nWould this affect the run-time complexity? How and why?\r\n\r\n\r\nSuppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\r\n\r\n(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).\r\n\r\nWrite a function to determine if a given target is in the array.\r\n\r\nThe array may contain duplicates.",
      "discussUrl": "https://discuss.leetcode.com/category/89",
      "similarQuestions": [
        "SearchinRotatedSortedArray"
      ],
      "topicTags": [
        "Array",
        "BinarySearch"
      ],
      "Solution": "class Solution {\n    public boolean search(int[] nums, int target) {\n        if(nums.length == 0) return false;\n        int left = 0, right = nums.length - 1;\n        while(left < right){\n            int mid = (left + right) >> 1;\n            if(nums[mid] == target) return true;\n            if(nums[mid] < nums[right]){\n                if(target > nums[mid] && target <= nums[right]) left = mid + 1;\n                else right = mid - 1;\n            }\n            else if(nums[mid] > nums[right]){\n                if(target >= nums[left] && target < nums[mid]) right = mid - 1;\n                else left = mid + 1;\n            }\n            else right--;\n        }\n        return nums[left] == target;\n    }\n}",
      "total_acs": 113218,
      "total_submitted": 346070
    },
    {
      "id": 82,
      "title": "Remove Duplicates from Sorted List II",
      "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.\r\n\r\n\r\nFor example,\r\nGiven 1->2->3->3->4->4->5, return 1->2->5.\r\nGiven 1->1->1->2->3, return 2->3.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/90",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "LinkedList"
      ],
      "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\npublic ListNode deleteDuplicates(ListNode head) {\n\t//use two pointers, slow - track the node before the dup nodes, \n\t// fast - to find the last node of dups.\n    ListNode dummy = new ListNode(0), fast = head, slow = dummy;\n    slow.next = fast;\n    while(fast != null) {\n    \twhile (fast.next != null && fast.val == fast.next.val) {\n     \t\tfast = fast.next;    //while loop to find the last node of the dups.\n    \t}\n    \tif (slow.next != fast) { //duplicates detected.\n    \t\tslow.next = fast.next; //remove the dups.\n    \t\tfast = fast.next;     //reposition the fast pointer.\n    \t} else { //no dup, move down both pointer.\n    \t\tslow = slow.next;\n    \t\tfast = fast.next;\n    \t}\n    \t\n    }\n    return dummy.next;\n} }\n\n\n",
      "total_acs": 127801,
      "total_submitted": 427819
    },
    {
      "id": 83,
      "title": "Remove Duplicates from Sorted List",
      "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-list/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Easy",
      "content": "\r\nGiven a sorted linked list, delete all duplicates such that each element appear only once.\r\n\r\n\r\nFor example,\r\nGiven 1->1->2, return 1->2.\r\nGiven 1->1->2->3->3, return 1->2->3.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/91",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "LinkedList"
      ],
      "Solution": "/**\n和remove duplicates from array 一样思路，一慢一块两个指针\n区别是：碰到不一样的时候，i和j都往后走，i连j连不连都行，\n      碰到等于的时候，i停着不动，j往后走到第一个不是dup的时候，这时候一定要i去连j\n */\nclass Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head==null || head.next==null){\n            return head;\n        }\n        \n        ListNode i = head;\n        ListNode j = head.next;\n        int valBeforeJ = i.val;\n        \n        while(j!=null && i!=null){\n            if(j.val!=valBeforeJ){\n                i = i.next;  \n            }\n            valBeforeJ = j.val;\n            j=j.next;\n            //这一步是关键，平时i连j没啥区别\n            //一旦i停留j往后的时候，i一定要跳去连后面的j\n            i.next=j;\n        }\n        return head;\n    }\n}\n/*\nGiven a sorted linked list, delete all duplicates such that each element appear only once.\n\nFor example,\nGiven 1->1->2, return 1->2.\nGiven 1->1->2->3->3, return 1->2->3.\n*/",
      "total_acs": 221765,
      "total_submitted": 552135
    },
    {
      "id": 84,
      "title": "Largest Rectangle in Histogram",
      "url": "https://leetcode.com/problems/largest-rectangle-in-histogram/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Hard",
      "content": "\r\nGiven n non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.\r\n\r\n\r\n\r\n\r\nAbove is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].\r\n\r\n\r\n\r\n\r\nThe largest rectangle is shown in the shaded area, which has area = 10 unit.\r\n\r\n\r\n\r\nFor example,\r\nGiven heights = [2,1,5,6,2,3],\r\nreturn 10.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/92",
      "similarQuestions": [
        "MaximalRectangle"
      ],
      "topicTags": [
        "Array",
        "Stack"
      ],
      "Solution": "class Solution {\n    public int largestRectangleArea(int[] heights) {\n       /* int n = heights.length;\n        Stack<Integer> s = new Stack<>();\n        int max = 0;\n        for(int i = 0; i <= n; i++) {\n            int h = (i == n ? 0 : heights[i]);\n            if(s.isEmpty() || h >= heights[s.peek()]) {\n                s.push(i);\n            } else {\n                int cur = s.pop();\n                max = Math.max(max, heights[cur] * (s.isEmpty()? i : i - 1 - s.peek()));\n                i--;\n            }\n        }\n        return max; */\n        return find(heights, 0, heights.length - 1);\n    }\n    private int find(int[] h, int left, int right){\n        if(left>right) return 0;\n        if(left==right) return h[left];\n        int minIndex=left;\n        boolean sorted=true;\n        for(int i=left+1; i<=right; i++){\n            if(h[i]<h[i-1]) sorted=false;\n            if(h[i]<h[minIndex]) minIndex=i;\n        }\n        if(sorted){\n            int max=0;\n            for(int i=left; i<=right; i++){\n                if(h[i]*(right-i+1)>max) max=h[i]*(right-i+1);\n            }\n            return max;\n        }\n        else{\n            int maxLeft=find(h, left, minIndex-1);\n            int maxRight=find(h, minIndex+1, right);\n            int crossMax=h[minIndex]*(right-left+1);\n            return Math.max(Math.max(maxLeft, maxRight), crossMax);\n        }\n    }\n}",
      "total_acs": 111022,
      "total_submitted": 404628
    },
    {
      "id": 85,
      "title": "Maximal Rectangle",
      "url": "https://leetcode.com/problems/maximal-rectangle/description",
      "companyTags": [
        "Facebook"
      ],
      "difficulty": "Hard",
      "content": "\r\nGiven a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.\r\n\r\n\r\nFor example, given the following matrix:\r\n\r\n1 0 1 0 0\r\n1 0 1 1 1\r\n1 1 1 1 1\r\n1 0 0 1 0\r\n\r\nReturn 6.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/93",
      "similarQuestions": [
        "LargestRectangleinHistogram",
        "MaximalSquare"
      ],
      "topicTags": [
        "Array",
        "HashTable",
        "DynamicProgramming",
        "Stack"
      ],
      "Solution": "// class Solution {\n//     public int maximalRectangle(char[][] matrix) {\n//         int row = matrix.length;\n//         if (row == 0) return 0;\n//         int col = matrix[0].length;\n//         if (col == 0) return 0;\n//         int res = helper(matrix[row - 1], 0, col - 1);\n//         for (int i = row - 2; i >= 0; i--) {\n//             for (int j = 0; j < col; j++) {\n//                 if (matrix[i][j] == '1') matrix[i][j] += matrix[i + 1][j] - '0';\n//             }\n//             res = Math.max(res, helper(matrix[i], 0, col - 1));\n//         }\n//         return res;\n//     }\n//     private int helper(char[] heights, int left, int right) {\n//         if (left == right) return heights[left] - '0';\n//         boolean ascend = true, descend = true;\n//         int min = left;\n//         for (int i = left + 1; i <= right; i++) {\n//             if (heights[i] < heights[i - 1]) ascend = false;\n//             if (heights[i] > heights[i - 1]) descend = false;\n//             if (heights[i] < heights[min]) min = i;\n//         }\n//         if (ascend) {\n//             int ret = 0;\n//             for (int i = left; i <= right; i++) {\n//                 ret = Math.max(ret, (right - i + 1) * (heights[i] - '0'));\n//             }\n//             return ret;\n//         }\n//         else if (descend) {\n//             int ret = 0;\n//             for (int i = right; i >= left; i--) {\n//                 ret = Math.max(ret, (i - left + 1) * (heights[i] - '0'));\n//             }\n//             return ret;\n//         }\n//         int leftMax = helper(heights, left, min - 1), rightMax = helper(heights, min + 1, right);\n//         int cur = (heights[min] - '0') * (right - left + 1);\n//         return Math.max(cur, Math.max(leftMax, rightMax));\n//     }\n// }\nclass Solution {\n    public int maximalRectangle(char[][] matrix) {\n     if(matrix==null || matrix.length==0 || matrix[0].length==0) return 0;\n        int m = matrix.length, n = matrix[0].length;\n        int[] heights = new int[n+1];\n        int res = 0;\n        for(int row=0; row<m; row++) {\n            updateHeights(matrix, row, heights);\n            res = Math.max(res, maxArea(heights));\n        }\n        return res;\n    }\n    \n    private void updateHeights(char[][] matrix, int row, int[] heights) {\n        for(int col=0; col<matrix[0].length; col++) {\n            if(matrix[row][col]=='1') {\n                heights[col]++;\n            } else {\n                heights[col] = 0;\n            }\n        }\n    }\n    \n    private int maxArea(int[] heights) {\n        int n = heights.length;\n        int[] stack = new int[n+1];\n        int top = 0;\n        stack[top] = -1;\n        int res = 0;\n        for(int i=0; i<n; i++) {\n            while(top>0 && heights[i]<heights[stack[top]]) {\n                int h = heights[stack[top--]];\n                res = Math.max(res, h*(i-stack[top]-1));\n            }\n            stack[++top] = i;\n        }\n        return res;\n    }\n}",
      "total_acs": 81467,
      "total_submitted": 277964
    },
    {
      "id": 86,
      "title": "Partition List",
      "url": "https://leetcode.com/problems/partition-list/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.\r\n\r\n\r\nYou should preserve the original relative order of the nodes in each of the two partitions.\r\n\r\n\r\nFor example,\r\nGiven 1->4->3->2->5->2 and x = 3,\r\nreturn 1->2->2->4->3->5.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/94",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "LinkedList",
        "TwoPointers"
      ],
      "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\n\n// the basic idea is to maintain two lists, the first one stores all nodes with val less than x , and the second queue stores all the rest nodes. Then concat these two queues. Remember to set the tail of second queue a null next, or it make cycle in list.\nclass Solution {\n    \n    public ListNode partition(ListNode head, int x) {\n        \n        ListNode dummy1 = new ListNode(0);//to know start of each list\n        ListNode dummy2 = new ListNode(0);\n        \n        ListNode n1= dummy1;\n        ListNode n2= dummy2;\n               \n        while(head != null){\n            if(head.val<x){\n                n1.next = head;\n                n1 = n1.next;\n            }\n            else{\n                n2.next = head;\n                n2 = n2.next;\n            }\n            head = head.next;\n        }\n        n2.next = null;\n        n1.next = dummy2.next;\n        return dummy1.next;\n        \n    }\n    \n    // public ListNode partition(ListNode head, int x) {\n//         if(head == null) return head;\n        \n//         ListNode beforeStart = null;\n//         ListNode before = null;\n//         ListNode after = null;\n//         ListNode afterStart = null;\n//         ListNode curr = head;\t\n// /* Partition list */\n// \t\twhile (curr != null) {\n\t\t\t\n// \t\t\tif (curr.val < x) {\n// \t\t\t\tif (beforeStart == null) {\n// \t\t\t\t\tbeforeStart = new ListNode(curr.val);\n// \t\t\t\t\tbefore = beforeStart;\n// \t\t\t\t} else {\n// \t\t\t\t\tbefore.next = new ListNode(curr.val);\n// \t\t\t\t\tbefore = before.next;\n// \t\t\t\t}\n// \t\t\t} else {\n// \t\t\t\tif (afterStart == null) {\n// \t\t\t\t\tafterStart = new ListNode(curr.val);\n// \t\t\t\t\tafter = afterStart;\n// \t\t\t\t} else {\n// \t\t\t\t\tafter.next = new ListNode(curr.val);\n// \t\t\t\t\tafter = after.next;\n// \t\t\t\t}\n// \t\t\t}\t\n// \t\t\tcurr = curr.next;\n// \t\t}\n\t\t\n// \t\t/* Merge before list and after list */\n// \t\tif (beforeStart == null) {\n// \t\t\treturn afterStart;\n// \t\t}\t\n// \t\tbefore.next = afterStart;\n// \t\treturn beforeStart;\n    // }\n}",
      "total_acs": 117443,
      "total_submitted": 352477
    },
    {
      "id": 87,
      "title": "Scramble String",
      "url": "https://leetcode.com/problems/scramble-string/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Hard",
      "content": "\r\nGiven a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.\r\n\r\n\r\nBelow is one possible representation of s1 = \"great\":\r\n\r\n\r\n    great\r\n   /    \\\r\n  gr    eat\r\n / \\    /  \\\r\ng   r  e   at\r\n           / \\\r\n          a   t\r\n\r\n\r\nTo scramble the string, we may choose any non-leaf node and swap its two children.\r\n\r\n\r\nFor example, if we choose the node \"gr\" and swap its two children, it produces a scrambled string \"rgeat\".\r\n\r\n\r\n    rgeat\r\n   /    \\\r\n  rg    eat\r\n / \\    /  \\\r\nr   g  e   at\r\n           / \\\r\n          a   t\r\n\r\n\r\nWe say that \"rgeat\" is a scrambled string of \"great\".\r\n\r\n\r\nSimilarly, if we continue to swap the children of nodes \"eat\" and \"at\", it produces a scrambled string \"rgtae\".\r\n\r\n\r\n    rgtae\r\n   /    \\\r\n  rg    tae\r\n / \\    /  \\\r\nr   g  ta  e\r\n       / \\\r\n      t   a\r\n\r\n\r\nWe say that \"rgtae\" is a scrambled string of \"great\".\r\n\r\n\r\nGiven two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/95",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "String",
        "DynamicProgramming"
      ],
      "Solution": "import java.util.Collection;\n\nclass Solution {\n          public boolean isScramble(String s1, String s2) {\n       int l1=s1.length(), l2=s2.length();\n        if(l1!=l2) return false;\n        if(l1<=1) return s1.equals(s2);\n        if(s1.equals(s2)) return true;\n        long a=1, b=1, c=1;\n        for(int i=0; i<l1; i++){\n            if(i>0 && a==b && isScramble(s1.substring(0,i),s2.substring(l2-i)) && isScramble(s1.substring(i),s2.substring(0,l2-i)))\n                return true;\n            if(i>0 && a==c && isScramble(s1.substring(0,i),s2.substring(0,i)) && isScramble(s1.substring(i),s2.substring(i)))\n                return true;\n            a*=s1.charAt(i);\n            b*=s2.charAt(l2-1-i);\n            c*=s2.charAt(i);\n        }\n        return false;\n    }\n}",
      "total_acs": 71440,
      "total_submitted": 241157
    },
    {
      "id": 88,
      "title": "Merge Sorted Array",
      "url": "https://leetcode.com/problems/merge-sorted-array/description",
      "companyTags": [
        "Facebook",
        "Microsoft",
        "Bloomberg"
      ],
      "difficulty": "Easy",
      "content": "Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.\r\n\r\n\r\nNote:\r\nYou may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.",
      "discussUrl": "https://discuss.leetcode.com/category/96",
      "similarQuestions": [
        "MergeTwoSortedLists"
      ],
      "topicTags": [
        "Array",
        "TwoPointers"
      ],
      "Solution": "class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        \n        int k = m + n - 1;\n        int i = m-1, j = n-1;\n        while (i >= 0 && j >= 0) {\n            \n            if (nums1[i] > nums2[j]) nums1[k--] = nums1[i--];\n            else nums1[k--] = nums2[j--];\n        }\n        \n        while (j >= 0) {\n            nums1[k--] = nums2[j--];\n        }\n    }\n}",
      "total_acs": 215589,
      "total_submitted": 670221
    },
    {
      "id": 89,
      "title": "Gray Code",
      "url": "https://leetcode.com/problems/gray-code/description",
      "companyTags": [
        "Amazon"
      ],
      "difficulty": "Medium",
      "content": "The gray code is a binary numeral system where two successive values differ in only one bit.\r\n\r\nGiven a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.\r\n\r\nFor example, given n = 2, return [0,1,3,2]. Its gray code sequence is:\r\n\r\n00 - 0\r\n01 - 1\r\n11 - 3\r\n10 - 2\r\n\r\n\r\nNote:\r\nFor a given n, a gray code sequence is not uniquely defined.\r\n\r\nFor example, [0,2,3,1] is also a valid gray code sequence according to the above definition.\r\n\r\nFor now, the judge is able to judge based on one instance of gray code sequence. Sorry about that.",
      "discussUrl": "https://discuss.leetcode.com/category/97",
      "similarQuestions": [
        "1-bitand2-bitCharacters"
      ],
      "topicTags": [
        "Backtracking"
      ],
      "Solution": "class Solution {\n    public List<Integer> grayCode(int n) {\n        List<Integer> rs=new ArrayList<Integer>();\n        rs.add(0);\n        for(int i=0;i<n;i++){\n            int size=rs.size();\n            for(int k=size-1;k>=0;k--)\n                rs.add(rs.get(k) | 1<<i);\n        }\n        return rs;\n    }\n}",
      "total_acs": 102965,
      "total_submitted": 243954
    },
    {
      "id": 90,
      "title": "Subsets II",
      "url": "https://leetcode.com/problems/subsets-ii/description",
      "companyTags": [
        "Facebook"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).\r\n\r\nNote: The solution set must not contain duplicate subsets.\r\n\r\n\r\nFor example,\r\nIf nums = [1,2,2], a solution is:\r\n\r\n\r\n\r\n[\r\n  [2],\r\n  [1],\r\n  [1,2,2],\r\n  [2,2],\r\n  [1,2],\r\n  []\r\n]\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/98",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Array",
        "Backtracking"
      ],
      "Solution": "public class Solution {\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        Arrays.sort(nums);\n        helper(result, new ArrayList<Integer>(), nums, 0);\n        return result;\n    }\n    private void helper(List<List<Integer>> list, ArrayList<Integer> temlist, int[] nums, int pos){\n       \n          \n        \n        list.add(new ArrayList<Integer>(temlist));\n        for (int i = pos; i < nums.length; i++){\n            if (i > 0 && i != pos && nums[i] == nums[i - 1]){\n                continue;\n            }\n            temlist.add(nums[i]);\n            helper(list,  temlist , nums, i + 1);\n            temlist.remove(temlist.size() - 1);\n        }\n    }\n}\n/*\n1  2  3  4\n1  pos   i\n*/",
      "total_acs": 137875,
      "total_submitted": 364199
    },
    {
      "id": 91,
      "title": "Decode Ways",
      "url": "https://leetcode.com/problems/decode-ways/description",
      "companyTags": [
        "Facebook",
        "Microsoft",
        "Uber"
      ],
      "difficulty": "Medium",
      "content": "\r\nA message containing letters from A-Z is being encoded to numbers using the following mapping:\r\n\r\n\r\n\r\n'A' -> 1\r\n'B' -> 2\r\n...\r\n'Z' -> 26\r\n\r\n\r\n\r\nGiven an encoded message containing digits, determine the total number of ways to decode it.\r\n\r\n\r\n\r\nFor example,\r\nGiven encoded message \"12\",\r\nit could be decoded as \"AB\" (1 2) or \"L\" (12).\r\n\r\n\r\n\r\nThe number of ways decoding \"12\" is 2.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/99",
      "similarQuestions": [
        "DecodeWaysII"
      ],
      "topicTags": [
        "String",
        "DynamicProgramming"
      ],
      "Solution": "class Solution {\n    public int numDecodings(String s) {\n        if (s == null || s.length() == 0)\n            return 0;\n        int n = s.length();\n        int[] dp = new int[n+1];\n        dp[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            if (s.charAt(i-1) >= '1' && s.charAt(i-1) <= '9')\n                dp[i] = dp[i-1];\n            if (i > 1) {\n                if (s.charAt(i-2) == '1' || s.charAt(i-2) == '2' && s.charAt(i-1) <= '6') {\n                    dp[i] += dp[i-2];\n                }\n            }\n        }\n        return dp[n];\n    }\n}",
      "total_acs": 159700,
      "total_submitted": 789504
    },
    {
      "id": 92,
      "title": "Reverse Linked List II",
      "url": "https://leetcode.com/problems/reverse-linked-list-ii/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "\r\nReverse a linked list from position m to n. Do it in-place and in one-pass.\r\n\r\n\r\n\r\nFor example:\r\nGiven 1->2->3->4->5->NULL, m = 2 and n = 4,\r\n\r\n\r\nreturn 1->4->3->2->5->NULL.\r\n\r\n\r\nNote:\r\nGiven m, n satisfy the following condition:\r\n1 ≤ m ≤ n ≤ length of list.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/100",
      "similarQuestions": [
        "ReverseLinkedList"
      ],
      "topicTags": [
        "LinkedList"
      ],
      "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode reverseBetween(ListNode head, int m, int n) {\n        if(head == null || head.next == null){\n            return head;\n        }\n        \n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode prev = dummy;\n        \n        for(int i = 0; i < m - 1; i++){\n            prev = prev.next;\n        }\n        \n        ListNode start = prev.next;\n        ListNode then = start.next;\n        \n        for(int j = m; j < n; j++){\n            \n            start.next = then.next;\n            then.next = prev.next;\n            prev.next = then;\n            then = start.next;\n        }\n        \n        return dummy.next;\n    }\n}",
      "total_acs": 131360,
      "total_submitted": 420777
    },
    {
      "id": 93,
      "title": "Restore IP Addresses",
      "url": "https://leetcode.com/problems/restore-ip-addresses/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "Given a string containing only digits, restore it by returning all possible valid IP address combinations.\r\n\r\n\r\nFor example:\r\nGiven \"25525511135\",\r\n\r\n\r\nreturn [\"255.255.11.135\", \"255.255.111.35\"]. (Order does not matter)\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/101",
      "similarQuestions": [
        "IPtoCIDR"
      ],
      "topicTags": [
        "String",
        "Backtracking"
      ],
      "Solution": "class Solution {\n    public void helper(List<String> ret, String s, int pos, int[] curr, int ind){\n        if(ind==4 && pos==s.length()){\n            StringBuilder sb = new StringBuilder();\n            for(int i=0;i<4;i++){\n                if(sb.length()>0) sb.append('.');\n                sb.append(curr[i]);\n            }\n            ret.add(sb.toString());\n        }else if(ind<4 && pos<s.length()){\n            int n = 0;\n            for(int i=pos;i<s.length() && i<pos+3;i++){\n                n*=10;\n                n+=(s.charAt(i)-'0');\n                if(n>255) return ;\n                curr[ind] = n;\n                helper(ret,s,i+1,curr,ind+1);\n                if(n==0) return;\n            }\n            curr[ind] = 0;\n        }\n    }\n    \n    public List<String> restoreIpAddresses(String s) {\n        List<String> ret = new ArrayList<>();\n        helper(ret,s,0,new int[4], 0);\n        return ret;\n    }\n}",
      "total_acs": 98984,
      "total_submitted": 350570
    },
    {
      "id": 94,
      "title": "Binary Tree Inorder Traversal",
      "url": "https://leetcode.com/problems/binary-tree-inorder-traversal/description",
      "companyTags": [
        "Microsoft"
      ],
      "difficulty": "Medium",
      "content": "Given a binary tree, return the inorder traversal of its nodes' values.\r\n\r\n\r\nFor example:\r\nGiven binary tree [1,null,2,3],\r\n\r\n   1\r\n    \\\r\n     2\r\n    /\r\n   3\r\n\r\n\r\n\r\nreturn [1,3,2].\r\n\r\n\r\nNote: Recursive solution is trivial, could you do it iteratively?",
      "discussUrl": "https://discuss.leetcode.com/category/102",
      "similarQuestions": [
        "ValidateBinarySearchTree",
        "BinaryTreePreorderTraversal",
        "BinaryTreePostorderTraversal",
        "BinarySearchTreeIterator",
        "KthSmallestElementinaBST",
        "ClosestBinarySearchTreeValueII",
        "InorderSuccessorinBST"
      ],
      "topicTags": [
        "HashTable",
        "Stack",
        "Tree"
      ],
      "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        if(root == null)return res;\n        helper(res,root.left);\n        res.add(root.val);\n        helper(res,root.right);\n        return res;\n\n    } \n    private void helper(List<Integer> res,TreeNode node){\n        if(node == null)return;\n        helper(res,node.left);\n        res.add(node.val);\n        helper(res,node.right);\n    }\n}",
      "total_acs": 255163,
      "total_submitted": 522189
    },
    {
      "id": 95,
      "title": "Unique Binary Search Trees II",
      "url": "https://leetcode.com/problems/unique-binary-search-trees-ii/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "Given an integer n, generate all structurally unique BST's (binary search trees) that store values 1...n.\r\n\r\n\r\nFor example,\r\nGiven n = 3, your program should return all 5 unique BST's shown below.\r\n\r\n\r\n   1         3     3      2      1\r\n    \\       /     /      / \\      \\\r\n     3     2     1      1   3      2\r\n    /     /       \\                 \\\r\n   2     1         2                 3\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/103",
      "similarQuestions": [
        "UniqueBinarySearchTrees",
        "DifferentWaystoAddParentheses"
      ],
      "topicTags": [
        "DynamicProgramming",
        "Tree"
      ],
      "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n     public List<TreeNode> generateTrees(int n) {\n        if(n < 1)\n            return new ArrayList<>();\n        List<TreeNode>[][] dp = new List[n+2][n+2];\n        return helper(1, n, dp);\n    }\n    \n    public List<TreeNode> helper(int start, int end, List[][] dp){\n        if(dp[start][end] != null)\n            return dp[start][end];\n        List<TreeNode> list = new ArrayList<>();\n        if(start > end){\n            list.add(null);\n        }\n        else if(start==end){\n            list.add(new TreeNode(start));\n        }\n        else{\n             for(int i = start; i <= end; i++){\n                List<TreeNode> left = helper(start, i-1, dp);\n                List<TreeNode> right = helper(i+1, end, dp);\n                for(TreeNode l : left){\n                    for(TreeNode r : right){\n                    TreeNode node = new TreeNode(i);\n                    node.left = l;\n                    node.right = r;\n                    list.add(node);\n                    }\n                }\n            }\n        }\n        dp[start][end] = list;\n        return list; \n    }\n\n}",
      "total_acs": 96794,
      "total_submitted": 301898
    },
    {
      "id": 96,
      "title": "Unique Binary Search Trees",
      "url": "https://leetcode.com/problems/unique-binary-search-trees/description",
      "companyTags": [
        "Snapchat"
      ],
      "difficulty": "Medium",
      "content": "Given n, how many structurally unique BST's (binary search trees) that store values 1...n?\r\n\r\n\r\nFor example,\r\nGiven n = 3, there are a total of 5 unique BST's.\r\n\r\n\r\n   1         3     3      2      1\r\n    \\       /     /      / \\      \\\r\n     3     2     1      1   3      2\r\n    /     /       \\                 \\\r\n   2     1         2                 3\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/104",
      "similarQuestions": [
        "UniqueBinarySearchTreesII"
      ],
      "topicTags": [
        "DynamicProgramming",
        "Tree"
      ],
      "Solution": "class Solution {\n    public int numTrees(int n) \n    {\n        HashMap<Integer, Integer> hm = new HashMap<Integer, Integer>();\n        return calcUniqBST(1, n, hm);\n    }\n    \n    public int calcUniqBST(int left, int right, HashMap<Integer, Integer> hm)\n    {\n        if(left == right)\n            return 1;\n        else if(left > right)\n            return 0;\n        else if(right - left == 1)\n            return 2;\n        else if(right - left == 2)\n            return 5;\n        else if(hm.containsKey(right - left))\n            return hm.get(right - left);\n        else\n        {\n            int total = 0;\n            for(int i = left; i <= right; i++)\n            {\n                int lsb = calcUniqBST(left, i-1, hm);\n                int rsb = calcUniqBST(i+1, right, hm);\n                if(lsb == 0) total += rsb;\n                else if(rsb == 0) total += lsb;\n                else total += lsb*rsb;\n            }\n            hm.put(right-left, total);\n            return total;\n        }\n    }\n}",
      "total_acs": 142758,
      "total_submitted": 341830
    },
    {
      "id": 97,
      "title": "Interleaving String",
      "url": "https://leetcode.com/problems/interleaving-string/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Hard",
      "content": "\r\nGiven s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.\r\n\r\n\r\n\r\nFor example,\r\nGiven:\r\ns1 = \"aabcc\",\r\ns2 = \"dbbca\",\r\n\r\n\r\nWhen s3 = \"aadbbcbcac\", return true.\r\nWhen s3 = \"aadbbbaccc\", return false.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/105",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "String",
        "DynamicProgramming"
      ],
      "Solution": "class Solution {\n    public boolean isInterleave(String s1, String s2, String s3) {\n        int[][] dp = new int[s1.length()][s2.length()];\n        return helper(s1, 0, s2, 0, s3, 0, dp);\n    }\n    private boolean helper(String s1, int j, String s2, int k, String s3, int i, int[][] dp) {\n        \n        if (j == s1.length()) return s2.substring(k).equals(s3.substring(i));\n        if (k == s2.length()) return s1.substring(j).equals(s3.substring(i));\n        if (dp[j][k] != 0) return dp[j][k] == 1;\n        \n\n        if (s3.charAt(i) == s1.charAt(j) && helper(s1, j + 1, s2, k, s3, i + 1, dp)\n            || s3.charAt(i) == s2.charAt(k) && helper(s1, j, s2, k + 1, s3, i + 1, dp)) {\n            dp[j][k] = 1;\n            return true;\n        }\n        \n        dp[j][k] = -1;\n        return false;\n\n    }\n    \n}",
      "total_acs": 80162,
      "total_submitted": 319572
    },
    {
      "id": 98,
      "title": "Validate Binary Search Tree",
      "url": "https://leetcode.com/problems/validate-binary-search-tree/description",
      "companyTags": [
        "Facebook",
        "Microsoft",
        "Amazon",
        "Bloomberg"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven a binary tree, determine if it is a valid binary search tree (BST).\r\n\r\n\r\n\r\nAssume a BST is defined as follows:\r\n\r\nThe left subtree of a node contains only nodes with keys less than the node's key.\r\nThe right subtree of a node contains only nodes with keys greater than the node's key.\r\nBoth the left and right subtrees must also be binary search trees.\r\n\r\n\r\n\r\nExample 1:\r\n\r\n    2\r\n   / \\\r\n  1   3\r\n\r\nBinary tree [2,1,3], return true.\r\n\r\n\r\nExample 2:\r\n\r\n    1\r\n   / \\\r\n  2   3\r\n\r\nBinary tree [1,2,3], return false.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/106",
      "similarQuestions": [
        "BinaryTreeInorderTraversal",
        "FindModeinBinarySearchTree"
      ],
      "topicTags": [
        "Tree",
        "Depth-firstSearch"
      ],
      "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public boolean isValidBST(TreeNode root) {\n        if(root == null) return true;\n        if(root.left == null && root.right == null) return true;\n        return isValidWithBound(root, Long.MIN_VALUE, Long.MAX_VALUE);\n    }\n    \n    public boolean isValidWithBound(TreeNode root, double low, double high){\n        if(root == null) return true;\n        if(root.val <= low || root.val >= high) return false;\n        return isValidWithBound(root.left, low, root.val) && isValidWithBound(root.right, root.val, high);\n    }\n}",
      "total_acs": 218753,
      "total_submitted": 911704
    },
    {
      "id": 99,
      "title": "Recover Binary Search Tree",
      "url": "https://leetcode.com/problems/recover-binary-search-tree/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Hard",
      "content": "\r\nTwo elements of a binary search tree (BST) are swapped by mistake.\r\n\r\nRecover the tree without changing its structure.\r\n\r\n\r\nNote:\r\nA solution using O(n) space is pretty straight forward. Could you devise a constant space solution?\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/107",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Tree",
        "Depth-firstSearch"
      ],
      "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    \n    TreeNode firstElement = null;\n    TreeNode secondElement = null;\n    TreeNode prev = null;\n    public void recoverTree(TreeNode root) {\n        \n        inOrderTraversal(root);\n        \n        if (firstElement != null && secondElement != null) {\n            int temp = firstElement.val;\n            firstElement.val = secondElement.val;\n            secondElement.val = temp;\n        }\n    }\n    \n    private void inOrderTraversal(TreeNode root) {\n        \n        if (root == null) {\n            return;\n        }\n        \n        inOrderTraversal(root.left);\n        \n        if (firstElement == null && (prev == null || prev.val >= root.val)) {\n            firstElement = prev;\n        }\n        \n        if (firstElement != null && prev.val >= root.val) {\n            secondElement = root;\n        }\n        \n        prev = root;\n        \n        inOrderTraversal(root.right);\n    }\n}",
      "total_acs": 84721,
      "total_submitted": 275135
    },
    {
      "id": 100,
      "title": "Same Tree",
      "url": "https://leetcode.com/problems/same-tree/description",
      "companyTags": [
        "Bloomberg"
      ],
      "difficulty": "Easy",
      "content": "\r\nGiven two binary trees, write a function to check if they are the same or not.\r\n\r\n\r\nTwo binary trees are considered the same if they are structurally identical and the nodes have the same value.\r\n\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput:     1         1\r\n          / \\       / \\\r\n         2   3     2   3\r\n\r\n        [1,2,3],   [1,2,3]\r\n\r\nOutput: true\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput:     1         1\r\n          /           \\\r\n         2             2\r\n\r\n        [1,2],     [1,null,2]\r\n\r\nOutput: false\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput:     1         1\r\n          / \\       / \\\r\n         2   1     1   2\r\n\r\n        [1,2,1],   [1,1,2]\r\n\r\nOutput: false\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/108",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Tree",
        "Depth-firstSearch"
      ],
      "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\npublic boolean isSameTree(TreeNode p, TreeNode q){\n\n\t\t\tif (p == null && q == null){\n\t\t\t\treturn true;\n\t\t\t}else if (p == null || q == null){\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tStack<TreeNode> pStack = new Stack<>();\n\t\t\tStack<TreeNode> qStack = new Stack<>();\n\n\t\t\tpStack.push(p);\n\t\t\tqStack.push(q);\n\n\t\t\twhile (!(pStack.isEmpty() && qStack.isEmpty())) {\n\t\t\t\tTreeNode nq = qStack.pop();\n\t\t\t\tTreeNode np = pStack.pop();\n\n\t\t\t\tif (nq.val != np.val) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (nq.left != null) {\n\t\t\t\t\tqStack.push(nq.left);\n\t\t\t\t}\n\t\t\t\tif (np.left != null) {\n\t\t\t\t\tpStack.push(np.left);\n\t\t\t\t}\n\n\t\t\t\tif (qStack.size() != pStack.size()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (nq.right != null) {\n\t\t\t\t\tqStack.push(nq.right);\n\t\t\t\t}\n\t\t\t\tif (np.right != null) {\n\t\t\t\t\tpStack.push(np.right);\n\t\t\t\t}\n\t\t\t\tif (pStack.size() != qStack.size()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn pStack.size() == qStack.size();\n\t\t}\n}",
      "total_acs": 249588,
      "total_submitted": 525674
    },
    {
      "id": 101,
      "title": "Symmetric Tree",
      "url": "https://leetcode.com/problems/symmetric-tree/description",
      "companyTags": [
        "Microsoft",
        "Bloomberg",
        "LinkedIn"
      ],
      "difficulty": "Easy",
      "content": "Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).\r\n\r\n\r\nFor example, this binary tree [1,2,2,3,4,4,3] is symmetric:\r\n\r\n    1\r\n   / \\\r\n  2   2\r\n / \\ / \\\r\n3  4 4  3\r\n\r\n\r\n\r\nBut the following [1,2,2,null,3,null,3]  is not:\r\n\r\n    1\r\n   / \\\r\n  2   2\r\n   \\   \\\r\n   3    3\r\n\r\n\r\n\r\n\r\nNote:\r\nBonus points if you could solve it both recursively and iteratively.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/109",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Tree",
        "Depth-firstSearch",
        "Breadth-firstSearch"
      ],
      "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public boolean isSymmetric(TreeNode root) {\n        return root == null || isSymmetric(root.left, root.right);\n    }\n\n    private boolean isSymmetric(TreeNode left, TreeNode right) {\n        int nu = (left == null ? 1 : 0) + (right == null ? 1 : 0);\n        if (nu == 1)\n            return false;\n        if (nu == 2)\n            return true;\n        return left.val == right.val && isSymmetric(left.left, right.right) && isSymmetric(left.right, right.left);\n    }\n}",
      "total_acs": 228942,
      "total_submitted": 571572
    },
    {
      "id": 102,
      "title": "Binary Tree Level Order Traversal",
      "url": "https://leetcode.com/problems/binary-tree-level-order-traversal/description",
      "companyTags": [
        "Facebook",
        "Microsoft",
        "Amazon",
        "Bloomberg",
        "LinkedIn",
        "Apple"
      ],
      "difficulty": "Medium",
      "content": "Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).\r\n\r\n\r\nFor example:\r\nGiven binary tree [3,9,20,null,null,15,7],\r\n\r\n    3\r\n   / \\\r\n  9  20\r\n    /  \\\r\n   15   7\r\n\r\n\r\n\r\nreturn its level order traversal as:\r\n\r\n[\r\n  [3],\r\n  [9,20],\r\n  [15,7]\r\n]\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/110",
      "similarQuestions": [
        "BinaryTreeZigzagLevelOrderTraversal",
        "BinaryTreeLevelOrderTraversalII",
        "MinimumDepthofBinaryTree",
        "BinaryTreeVerticalOrderTraversal",
        "AverageofLevelsinBinaryTree"
      ],
      "topicTags": [
        "Tree",
        "Breadth-firstSearch"
      ],
      "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        List<List<Integer>> res = new ArrayList<>();\n        levelTraverse(root, 0, res);\n        return res;\n    }\n    private void levelTraverse(TreeNode root, int depth, List<List<Integer>> res) {\n        if (root == null) {\n            return;\n        }\n        if (res.size() == depth) {\n            res.add(new ArrayList<Integer>());\n        }\n        res.get(depth).add(root.val);\n        levelTraverse(root.left, depth+1, res);\n        levelTraverse(root.right, depth+1, res);\n    }\n}",
      "total_acs": 218821,
      "total_submitted": 522475
    },
    {
      "id": 103,
      "title": "Binary Tree Zigzag Level Order Traversal",
      "url": "https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description",
      "companyTags": [
        "Microsoft",
        "Bloomberg",
        "LinkedIn"
      ],
      "difficulty": "Medium",
      "content": "Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).\r\n\r\n\r\nFor example:\r\nGiven binary tree [3,9,20,null,null,15,7],\r\n\r\n    3\r\n   / \\\r\n  9  20\r\n    /  \\\r\n   15   7\r\n\r\n\r\n\r\nreturn its zigzag level order traversal as:\r\n\r\n[\r\n  [3],\r\n  [20,9],\r\n  [15,7]\r\n]\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/111",
      "similarQuestions": [
        "BinaryTreeLevelOrderTraversal"
      ],
      "topicTags": [
        "Stack",
        "Tree",
        "Breadth-firstSearch"
      ],
      "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n        if(root == null) return new ArrayList();\n        \n        List<List<Integer>> list = new ArrayList<List<Integer>>();\n            \n        helper(root, list, 0);\n        \n        return list;\n    }\n    \n    public void helper(TreeNode root, List<List<Integer>> list, int level) {\n        \n        if(root == null) return;\n        \n        if(list.size() <= level) {\n            list.add(level, new LinkedList<Integer>());\n        }\n        \n        if(level%2==0) list.get(level).add(root.val);\n        else list.get(level).add(0,root.val);\n        \n        helper(root.left, list, level+1);\n        helper(root.right, list, level+1);\n    }\n}",
      "total_acs": 127494,
      "total_submitted": 351066
    },
    {
      "id": 104,
      "title": "Maximum Depth of Binary Tree",
      "url": "https://leetcode.com/problems/maximum-depth-of-binary-tree/description",
      "companyTags": [
        "Uber",
        "LinkedIn",
        "Apple",
        "Yahoo"
      ],
      "difficulty": "Easy",
      "content": "Given a binary tree, find its maximum depth.\r\n\r\nThe maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\r\n\r\nFor example:\r\nGiven binary tree [3,9,20,null,null,15,7],\r\n\r\n\r\n    3\r\n   / \\\r\n  9  20\r\n    /  \\\r\n   15   7\r\n\r\nreturn its depth = 3.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/112",
      "similarQuestions": [
        "BalancedBinaryTree",
        "MinimumDepthofBinaryTree"
      ],
      "topicTags": [
        "Tree",
        "Depth-firstSearch"
      ],
      "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null)\n            return 0;\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n    }\n}",
      "total_acs": 305269,
      "total_submitted": 564180
    },
    {
      "id": 105,
      "title": "Construct Binary Tree from Preorder and Inorder Traversal",
      "url": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description",
      "companyTags": [
        "Bloomberg"
      ],
      "difficulty": "Medium",
      "content": "Given preorder and inorder traversal of a tree, construct the binary tree.\r\n\r\nNote:\r\nYou may assume that duplicates do not exist in the tree.\r\n\r\nFor example, given\r\n\r\n\r\npreorder = [3,9,20,15,7]\r\ninorder = [9,3,15,20,7]\r\n\r\nReturn the following binary tree:\r\n\r\n\r\n    3\r\n   / \\\r\n  9  20\r\n    /  \\\r\n   15   7\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/113",
      "similarQuestions": [
        "ConstructBinaryTreefromInorderandPostorderTraversal"
      ],
      "topicTags": [
        "Array",
        "Tree",
        "Depth-firstSearch"
      ],
      "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        int[] preIndex = new int[] {0};\n        int[] inIndex = new int[] {0};\n        return buildTree(preorder, inorder, preIndex, inIndex, Integer.MAX_VALUE);\n    }\n    \n    private TreeNode buildTree(int[] preorder, int[] inorder, int[] preIndex, int[] inIndex, int target) {\n        //pre: [root][left][right];\n        //in: [left][root][right];\n        //target is the root\n        if (inIndex[0] >= inorder.length || inorder[inIndex[0]] == target) {\n            return null;\n        }\n        TreeNode root = new TreeNode(preorder[preIndex[0]]);\n        //preorder, advance the index by 1 sice we already finish the root;\n        preIndex[0]++;\n        root.left = buildTree(preorder, inorder, preIndex, inIndex, root.val);\n        //after finishing left subtree, we can advance the index by 1\n        inIndex[0]++;\n        root.right = buildTree(preorder, inorder, preIndex, inIndex, target);\n        return root;\n    }\n}",
      "total_acs": 128591,
      "total_submitted": 385244
    },
    {
      "id": 106,
      "title": "Construct Binary Tree from Inorder and Postorder Traversal",
      "url": "https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description",
      "companyTags": [
        "Microsoft"
      ],
      "difficulty": "Medium",
      "content": "Given inorder and postorder traversal of a tree, construct the binary tree.\r\n\r\nNote:\r\nYou may assume that duplicates do not exist in the tree.\r\n\r\nFor example, given\r\n\r\n\r\ninorder = [9,3,15,20,7]\r\npostorder = [9,15,7,20,3]\r\n\r\nReturn the following binary tree:\r\n\r\n\r\n    3\r\n   / \\\r\n  9  20\r\n    /  \\\r\n   15   7\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/114",
      "similarQuestions": [
        "ConstructBinaryTreefromPreorderandInorderTraversal"
      ],
      "topicTags": [
        "Array",
        "Tree",
        "Depth-firstSearch"
      ],
      "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        return buildTree(inorder, inorder.length-1, 0, postorder, postorder.length-1);\n    }\n\n    private TreeNode buildTree(int[] inorder, int inStart, int inEnd, int[] postorder, int postStart) {\n        if (postStart < 0 || inStart < inEnd)\n            return null;\n\n        //The last element in postorder is the root.\n        TreeNode root = new TreeNode(postorder[postStart]);\n\n        //find the index of the root from inorder. Iterating from the end.\n        int rIndex = inStart;\n        for (int i = inStart; i >= inEnd; i--) {\n            if (inorder[i] == postorder[postStart]) {\n                rIndex = i;\n                break;\n            }\n        }\n        //build right and left subtrees. Again, scanning from the end to find the sections.\n        root.right = buildTree(inorder, inStart, rIndex + 1, postorder, postStart-1);\n        root.left = buildTree(inorder, rIndex - 1, inEnd, postorder, postStart - 1-(inStart - rIndex));\n        return root;\n    }\n}",
      "total_acs": 101125,
      "total_submitted": 306385
    },
    {
      "id": 107,
      "title": "Binary Tree Level Order Traversal II",
      "url": "https://leetcode.com/problems/binary-tree-level-order-traversal-ii/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Easy",
      "content": "Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).\r\n\r\n\r\nFor example:\r\nGiven binary tree [3,9,20,null,null,15,7],\r\n\r\n    3\r\n   / \\\r\n  9  20\r\n    /  \\\r\n   15   7\r\n\r\n\r\n\r\nreturn its bottom-up level order traversal as:\r\n\r\n[\r\n  [15,7],\r\n  [9,20],\r\n  [3]\r\n]\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/115",
      "similarQuestions": [
        "BinaryTreeLevelOrderTraversal",
        "AverageofLevelsinBinaryTree"
      ],
      "topicTags": [
        "Tree",
        "Breadth-firstSearch"
      ],
      "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<List<Integer>> levelOrderBottom(TreeNode root) {\n        List<List<Integer>> out = new ArrayList<>();\n        if (root == null) return out;\n        \n        traverse(out, root, 0);\n        \n        Collections.reverse(out);\n        \n        return out;\n    }\n    \n    public void traverse(List<List<Integer>> out, TreeNode root, int depth) {\n        \n        if ( root == null) return;\n        \n        // The slow will increase gradualy one by one -> add a new list when reaching a new depth\n        if ( depth == out.size() ) out.add(new ArrayList<Integer>());\n        \n        traverse(out, root.left, depth+1);\n        \n        \n        out.get(depth).add(root.val);\n        \n        \n        traverse(out, root.right, depth+1);\n    }\n}",
      "total_acs": 154796,
      "total_submitted": 371276
    },
    {
      "id": 108,
      "title": "Convert Sorted Array to Binary Search Tree",
      "url": "https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description",
      "companyTags": [
        "Airbnb"
      ],
      "difficulty": "Easy",
      "content": "Given an array where elements are sorted in ascending order, convert it to a height balanced BST.\r\n\r\nFor this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\r\n\r\n\r\n\r\n\r\nExample:\r\n\r\nGiven the sorted array: [-10,-3,0,5,9],\r\n\r\nOne possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:\r\n\r\n      0\r\n     / \\\r\n   -3   9\r\n   /   /\r\n -10  5\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/116",
      "similarQuestions": [
        "ConvertSortedListtoBinarySearchTree"
      ],
      "topicTags": [
        "Tree",
        "Depth-firstSearch"
      ],
      "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    private TreeNode help(int[] nums, int l, int r) {\n        if(l > r) return null;\n        int mid = l + (r - l) / 2;\n        TreeNode n = new TreeNode(nums[mid]);\n        n.left = help(nums, l, mid - 1);\n        n.right = help(nums, mid + 1, r);\n        return n;\n    }\n    public TreeNode sortedArrayToBST(int[] nums) {\n        return help(nums, 0, nums.length - 1);\n    }\n}",
      "total_acs": 161459,
      "total_submitted": 368731
    },
    {
      "id": 109,
      "title": "Convert Sorted List to Binary Search Tree",
      "url": "https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/description",
      "companyTags": [
        "Zenefits"
      ],
      "difficulty": "Medium",
      "content": "Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.\r\n\r\nFor this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\r\n\r\n\r\n\r\n\r\nExample:\r\n\r\nGiven the sorted linked list: [-10,-3,0,5,9],\r\n\r\nOne possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:\r\n\r\n      0\r\n     / \\\r\n   -3   9\r\n   /   /\r\n -10  5\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/117",
      "similarQuestions": [
        "ConvertSortedArraytoBinarySearchTree"
      ],
      "topicTags": [
        "LinkedList",
        "Depth-firstSearch"
      ],
      "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    private ListNode current;\n    private int getSize(ListNode head){\n        int size = 0;\n        while(head != null){\n            size++;\n            head = head.next;\n        }\n        return size;\n    }\n    private TreeNode sortedListToBSTHelper(int size){\n        if (size <= 0){\n            return null;\n        }\n       \n        TreeNode left = sortedListToBSTHelper(size / 2);\n        TreeNode root = new TreeNode(current.val);\n        current = current.next;\n        TreeNode right = sortedListToBSTHelper(size - size / 2 - 1);\n        root.left = left;\n        root.right = right;\n       \n        return root;\n    }\n    \n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null){\n            return null;\n        }\n        current = head;\n        int size = getSize(head);\n        return sortedListToBSTHelper(size);\n    }\n}",
      "total_acs": 125880,
      "total_submitted": 357204
    },
    {
      "id": 110,
      "title": "Balanced Binary Tree",
      "url": "https://leetcode.com/problems/balanced-binary-tree/description",
      "companyTags": [
        "Bloomberg"
      ],
      "difficulty": "Easy",
      "content": "Given a binary tree, determine if it is height-balanced.\r\n\r\nFor this problem, a height-balanced binary tree is defined as:\r\n\r\n\r\na binary tree in which the depth of the two subtrees of every node never differ by more than 1.\r\n\r\n\r\nExample 1:\r\n\r\nGiven the following tree [3,9,20,null,null,15,7]:\r\n\r\n\r\n    3\r\n   / \\\r\n  9  20\r\n    /  \\\r\n   15   7\r\n\r\nReturn true.\r\n\r\nExample 2:\r\n\r\nGiven the following tree [1,2,2,3,3,null,null,4,4]:\r\n\r\n\r\n       1\r\n      / \\\r\n     2   2\r\n    / \\\r\n   3   3\r\n  / \\\r\n 4   4\r\n\r\n\r\nReturn false.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/118",
      "similarQuestions": [
        "MaximumDepthofBinaryTree"
      ],
      "topicTags": [
        "Tree",
        "Depth-firstSearch"
      ],
      "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    static int NOT_BALANCED = -1;\n    public boolean isBalanced(TreeNode root) {\n        return getDepth(root) != NOT_BALANCED;\n    }\n    int getDepth(TreeNode node){\n        if(node == null)\n            return 0;\n        int left = getDepth(node.left);\n        if(left == NOT_BALANCED)\n            return NOT_BALANCED;\n        int right = getDepth(node.right);\n        if(right == NOT_BALANCED)\n            return NOT_BALANCED;\n        if(Math.abs(left - right) > 1)\n            return NOT_BALANCED;\n        return Math.max(left, right)+1;\n    }\n}",
      "total_acs": 212450,
      "total_submitted": 556166
    },
    {
      "id": 111,
      "title": "Minimum Depth of Binary Tree",
      "url": "https://leetcode.com/problems/minimum-depth-of-binary-tree/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Easy",
      "content": "Given a binary tree, find its minimum depth.\r\n\r\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.",
      "discussUrl": "https://discuss.leetcode.com/category/119",
      "similarQuestions": [
        "BinaryTreeLevelOrderTraversal",
        "MaximumDepthofBinaryTree"
      ],
      "topicTags": [
        "Tree",
        "Depth-firstSearch",
        "Breadth-firstSearch"
      ],
      "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public int minDepth(TreeNode root) {\n        if (root == null){\n            return 0;\n        }\n        if (root.left == null){\n            return minDepth(root.right) + 1;\n        }else if (root.right == null){\n            return minDepth(root.left) + 1;\n        }\n        return Math.min(minDepth(root.left), minDepth(root.right)) + 1;\n    }\n}",
      "total_acs": 201951,
      "total_submitted": 602820
    },
    {
      "id": 112,
      "title": "Path Sum",
      "url": "https://leetcode.com/problems/path-sum/description",
      "companyTags": [
        "Microsoft"
      ],
      "difficulty": "Easy",
      "content": "Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.\r\n\r\nFor example:\r\nGiven the below binary tree and sum = 22,\r\n\r\n\r\n              5\r\n             / \\\r\n            4   8\r\n           /   / \\\r\n          11  13  4\r\n         /  \\      \\\r\n        7    2      1\r\n\r\n\r\nreturn true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/120",
      "similarQuestions": [
        "PathSumII",
        "BinaryTreeMaximumPathSum",
        "SumRoottoLeafNumbers",
        "PathSumIII",
        "PathSumIV"
      ],
      "topicTags": [
        "Tree",
        "Depth-firstSearch"
      ],
      "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public boolean hasPathSum(TreeNode root, int sum) {\n        \n        if(root==null) return false;\n        \n        if(root.left==null && root.right==null && sum-root.val==0) return true;\n        \n        return hasPathSum(root.left, sum-root.val) || hasPathSum(root.right, sum-root.val);\n        \n    }\n    \n}",
      "total_acs": 201437,
      "total_submitted": 581568
    },
    {
      "id": 113,
      "title": "Path Sum II",
      "url": "https://leetcode.com/problems/path-sum-ii/description",
      "companyTags": [
        "Bloomberg"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum.\r\n\r\n\r\nFor example:\r\nGiven the below binary tree and sum = 22,\r\n\r\n              5\r\n             / \\\r\n            4   8\r\n           /   / \\\r\n          11  13  4\r\n         /  \\    / \\\r\n        7    2  5   1\r\n\r\n\r\n\r\nreturn\r\n\r\n[\r\n   [5,4,11,2],\r\n   [5,8,4,5]\r\n]\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/121",
      "similarQuestions": [
        "PathSum",
        "BinaryTreePaths",
        "PathSumIII",
        "PathSumIV"
      ],
      "topicTags": [
        "Tree",
        "Depth-firstSearch"
      ],
      "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<List<Integer>> pathSum(TreeNode root, int sum) {\n        if(root == null){\n            return new ArrayList<>();\n        }\n        List<List<Integer>> result = new ArrayList<>();\n        List<Integer> list = new ArrayList<>();\n        dfs(root, sum, result, list);\n        return result;\n    }\n\n    private void dfs(TreeNode node, int sum, List<List<Integer>> result, List<Integer> list){\n        list.add(node.val);\n        sum = sum - node.val;\n        if(node.left == null && node.right == null && sum == 0){\n            result.add(new ArrayList<>(list));\n        }\n        if(node.left != null){\n            dfs(node.left, sum , result, list);\n        }\n        if(node.right != null){\n            dfs(node.right, sum, result, list);\n        }\n        sum = sum + node.val;\n        list.remove(list.size() - 1); \n    }\n}",
      "total_acs": 154373,
      "total_submitted": 438897
    },
    {
      "id": 114,
      "title": "Flatten Binary Tree to Linked List",
      "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/description",
      "companyTags": [
        "Microsoft"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven a binary tree, flatten it to a linked list in-place.\r\n\r\n\r\n\r\nFor example,\r\nGiven\r\n\r\n         1\r\n        / \\\r\n       2   5\r\n      / \\   \\\r\n     3   4   6\r\n\r\n\r\n\r\nThe flattened tree should look like:\r\n\r\n   1\r\n    \\\r\n     2\r\n      \\\r\n       3\r\n        \\\r\n         4\r\n          \\\r\n           5\r\n            \\\r\n             6\r\n\r\n\r\nclick to show hints.\r\n\r\nHints:\r\nIf you notice carefully in the flattened tree, each node's right child points to the next node of a pre-order traversal.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/122",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Tree",
        "Depth-firstSearch"
      ],
      "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public void flatten(TreeNode root) {\n        if (root == null) return;\n        flatten(root.left);\n        TreeNode temp = root.left;\n        while (temp != null && temp.right != null) {\n            temp = temp.right;\n        }\n        \n        flatten(root.right);\n        if (temp != null) {\n            temp.right = root.right;    \n            root.right = root.left;\n            root.left = null;\n        }\n    }\n}",
      "total_acs": 155131,
      "total_submitted": 428154
    },
    {
      "id": 115,
      "title": "Distinct Subsequences",
      "url": "https://leetcode.com/problems/distinct-subsequences/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Hard",
      "content": "\r\nGiven a string S and a string T, count the number of distinct subsequences of S which equals T.\r\n\r\n\r\n\r\nA subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, \"ACE\" is a subsequence of \"ABCDE\" while \"AEC\" is not).\r\n\r\n\r\n\r\nHere is an example:\r\nS = \"rabbbit\", T = \"rabbit\"\r\n\r\n\r\nReturn 3.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/123",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "String",
        "DynamicProgramming"
      ],
      "Solution": "public class Solution {\n        public int numDistinct(String s, String t) {\n            // arr works as a hash table\n            int[][] arr = new int[256][t.length()+1];\n            int[] cnt = new int[t.length()+1];\n            cnt[0] = 1;\n            char c;\n            for(int i = 0; i < t.length(); i++ ) {\n                // arr[c] is a list of all the positions character c appears\n                // arr[c][0] records how many times character c appears\n                c = t.charAt(i);\n                arr[c][arr[c][0]+1] = i+1;\n                arr[c][0]++;\n            }\n            // DP\n            for( char a: s.toCharArray() ) {\n                if( arr[a][0] != 0 ) {\n                    for( int i = arr[a][0]; i > 0; i-- ) {\n                        cnt[arr[a][i]] += cnt[arr[a][i]-1];\n                    }\n                }\n            }\n            return cnt[t.length()];\n        }\n    }",
      "total_acs": 80031,
      "total_submitted": 249207
    },
    {
      "id": 116,
      "title": "Populating Next Right Pointers in Each Node",
      "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/description",
      "companyTags": [
        "Microsoft"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven a binary tree\r\n\r\n    struct TreeLinkNode {\r\n      TreeLinkNode *left;\r\n      TreeLinkNode *right;\r\n      TreeLinkNode *next;\r\n    }\r\n\r\n\r\n\r\nPopulate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\r\n\r\nInitially, all next pointers are set to NULL.\r\n\r\n\r\nNote:\r\n\r\nYou may only use constant extra space.\r\nYou may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).\r\n\r\n\r\n\r\n\r\nFor example,\r\nGiven the following perfect binary tree,\r\n\r\n         1\r\n       /  \\\r\n      2    3\r\n     / \\  / \\\r\n    4  5  6  7\r\n\r\n\r\n\r\nAfter calling your function, the tree should look like:\r\n\r\n         1 -> NULL\r\n       /  \\\r\n      2 -> 3 -> NULL\r\n     / \\  / \\\r\n    4->5->6->7 -> NULL\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/124",
      "similarQuestions": [
        "PopulatingNextRightPointersinEachNodeII",
        "BinaryTreeRightSideView"
      ],
      "topicTags": [
        "Tree",
        "Depth-firstSearch"
      ],
      "Solution": "/**\n * Definition for binary tree with next pointer.\n * public class TreeLinkNode {\n *     int val;\n *     TreeLinkNode left, right, next;\n *     TreeLinkNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public void connect(TreeLinkNode root) {\n        TreeLinkNode level_start=root;\n        while(level_start!=null){\n            TreeLinkNode cur=level_start;\n            while(cur!=null){\n                if(cur.left!=null) cur.left.next=cur.right;\n                if(cur.right!=null && cur.next!=null) cur.right.next=cur.next.left;\n                \n                cur=cur.next;\n            }\n            level_start=level_start.left;\n        }\n    }\n}",
      "total_acs": 162546,
      "total_submitted": 440326
    },
    {
      "id": 117,
      "title": "Populating Next Right Pointers in Each Node II",
      "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/description",
      "companyTags": [
        "Facebook",
        "Microsoft",
        "Bloomberg"
      ],
      "difficulty": "Medium",
      "content": "Follow up for problem \"Populating Next Right Pointers in Each Node\".\r\nWhat if the given tree could be any binary tree? Would your previous solution still work?\r\n\r\nNote:\r\nYou may only use constant extra space.\r\n\r\n\r\nFor example,\r\nGiven the following binary tree,\r\n\r\n         1\r\n       /  \\\r\n      2    3\r\n     / \\    \\\r\n    4   5    7\r\n\r\n\r\n\r\nAfter calling your function, the tree should look like:\r\n\r\n         1 -> NULL\r\n       /  \\\r\n      2 -> 3 -> NULL\r\n     / \\    \\\r\n    4-> 5 -> 7 -> NULL\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/125",
      "similarQuestions": [
        "PopulatingNextRightPointersinEachNode"
      ],
      "topicTags": [
        "Tree",
        "Depth-firstSearch"
      ],
      "Solution": "/**\n * Definition for binary tree with next pointer.\n * public class TreeLinkNode {\n *     int val;\n *     TreeLinkNode left, right, next;\n *     TreeLinkNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public void connect(TreeLinkNode root) {\n        TreeLinkNode dummyHead=new TreeLinkNode(0);\n        TreeLinkNode travel = dummyHead;\n        while(root!=null){\n            if(root.left!=null){\n                travel.next=root.left;\n                travel=travel.next;\n            }\n            if(root.right!=null){\n                travel.next=root.right;\n                travel=travel.next;\n            }\n            root=root.next;\n            if(root==null){\n                travel=dummyHead;\n                root=dummyHead.next;\n                dummyHead.next=null;\n            }\n        }\n    }\n}",
      "total_acs": 121433,
      "total_submitted": 357647
    },
    {
      "id": 118,
      "title": "Pascal's Triangle",
      "url": "https://leetcode.com/problems/pascals-triangle/description",
      "companyTags": [
        "Twitter",
        "Apple"
      ],
      "difficulty": "Easy",
      "content": "Given numRows, generate the first numRows of Pascal's triangle.\r\n\r\n\r\nFor example, given numRows = 5,\r\nReturn\r\n\r\n[\r\n     [1],\r\n    [1,1],\r\n   [1,2,1],\r\n  [1,3,3,1],\r\n [1,4,6,4,1]\r\n]\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/126",
      "similarQuestions": [
        "\"PascalsTriangleII\""
      ],
      "topicTags": [
        "Array"
      ],
      "Solution": "class Solution {\n    public List<List<Integer>> generate(int numRows) {\n        List<List<Integer>> rows = new ArrayList<>();\n        ArrayList<Integer> row = new ArrayList<>();\n        if (numRows == 0) return rows;\n        row.add(1);\n        rows.add(row);\n        for (int i=1; i<numRows; i++) {\n            row = new ArrayList<>();\n            row.add(1);\n            for (int j=1; j<i; j++) {\n                row.add(rows.get(i-1).get(j-1)+rows.get(i-1).get(j));            \n            }\n            row.add(1);\n            rows.add(row);\n        }\n        return rows;\n    }\n}",
      "total_acs": 160632,
      "total_submitted": 404190
    },
    {
      "id": 119,
      "title": "Pascal's Triangle II",
      "url": "https://leetcode.com/problems/pascals-triangle-ii/description",
      "companyTags": [
        "Amazon"
      ],
      "difficulty": "Easy",
      "content": "Given an index k, return the kth row of the Pascal's triangle.\r\n\r\n\r\nFor example, given k = 3,\r\nReturn [1,3,3,1].\r\n\r\n\r\n\r\nNote:\r\nCould you optimize your algorithm to use only O(k) extra space?\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/127",
      "similarQuestions": [
        "\"PascalsTriangle\""
      ],
      "topicTags": [
        "Array"
      ],
      "Solution": "class Solution {\n    public List<Integer> getRow(int rowIndex) {\n        // List<Integer> previous = new ArrayList<>();\n        // previous.add(1);\n        // if (rowIndex == 0) {\n        //     return new ArrayList<>(previous);\n        // }\n        // previous.add(1);\n        // if (rowIndex == 1) {\n        //     return new ArrayList<>(previous);\n        // }\n        // int index = 1;        \n        // while (index < rowIndex) {\n        //     List<Integer> current = new ArrayList<>();\n        //     current.add(1);\n        //     for (int i = 0; i < previous.size() - 1; i++) {\n        //         current.add(previous.get(i) + previous.get(i + 1));\n        //     }\n        //     current.add(1);\n        //     index++;\n        //     previous = current;\n        // }\n        // return previous;\n        \n        List<Integer> result = new ArrayList<>(rowIndex + 1);\n        result.add(1);\n        long prev = 1;\n        long rowIndexPlusOne = rowIndex + 1;\n        for(int i = 1; i <= rowIndex; i++){\n            prev = (prev * (rowIndexPlusOne - i)) / i;\n            result.add((int)prev);\n        }\n        return result;\n    }\n}",
      "total_acs": 138268,
      "total_submitted": 364803
    },
    {
      "id": 120,
      "title": "Triangle",
      "url": "https://leetcode.com/problems/triangle/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.\r\n\r\n\r\nFor example, given the following triangle\r\n\r\n[\r\n     [2],\r\n    [3,4],\r\n   [6,5,7],\r\n  [4,1,8,3]\r\n]\r\n\r\n\r\n\r\nThe minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).\r\n\r\n\r\n\r\nNote:\r\nBonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/128",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Array",
        "DynamicProgramming"
      ],
      "Solution": "class Solution {\n    /*public int minimumTotal(List<List<Integer>> triangle) {\n        for(int i = triangle.size() - 2; i >= 0; i--)\n            for(int j = 0; j <= i; j++)\n                triangle.get(i).set(j, triangle.get(i).get(j) + Math.min(triangle.get(i + 1).get(j), triangle.get(i + 1).get(j + 1)));\n        return triangle.get(0).get(0);\n    }*/\n    public int minimumTotal(List<List<Integer>> triangle) {\n\t\tif (triangle.size() == 0)\n\t\t\treturn 0;\n\t\tif (triangle.size() == 1)\n\t\t\treturn triangle.get(0).get(0);\n\n\t\tint[] dp = new int[triangle.size()];\n\t\tdp[0] = triangle.get(0).get(0);\n\t\treturn minimumTotal(triangle, dp, 1);\n\t}\n\n\tpublic int minimumTotal(List<List<Integer>> triangle, int[] dp, int lvlidx) {\n\t\t/**\n\t\t * dp: dp[i]_lvlidx = the min path sum up to current level and up to\n\t\t * index i\n\t\t * \n\t\t * dp[0]_lvlidx = this_level_list[0] + dp[0]_(lvlidx-1);\n\t\t * dp[end]_lvlidx = this_level_list[end] + dp[end-1]_(lvlidx-1);\n\t\t * \n\t\t * dp[i]_lvlidx = this_level_list[i] + min{ dp[i-1]_(lvlidx-1),\n\t\t * dp[i]_(lvlidx-1) };\n\t\t */\n\n\t\tList<Integer> list = triangle.get(lvlidx);\n\t\tint pre = dp[0], temp;\n\t\tdp[0] += list.get(0);\n\t\tfor (int i = 1; i < lvlidx; i++) {\n\t\t\ttemp = dp[i];\n\t\t\tdp[i] = list.get(i) + Math.min(pre, dp[i]);\n\t\t\tpre = temp;\n\t\t}\n\t\tdp[lvlidx] = pre + list.get(lvlidx);\n\n\t\tif (lvlidx + 1 == triangle.size()) {\n\t\t\tint res = dp[0];\n\t\t\tfor (int i = 1; i <= lvlidx; i++)\n\t\t\t\tres = Math.min(res, dp[i]);\n\t\t\treturn res;\n\t\t}\n\n\t\treturn minimumTotal(triangle, dp, lvlidx + 1);\n\t}\n}",
      "total_acs": 125652,
      "total_submitted": 362125
    },
    {
      "id": 121,
      "title": "Best Time to Buy and Sell Stock",
      "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description",
      "companyTags": [
        "Facebook",
        "Microsoft",
        "Amazon",
        "Bloomberg",
        "Uber"
      ],
      "difficulty": "Easy",
      "content": "Say you have an array for which the ith element is the price of a given stock on day i.\r\n\r\nIf you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.\r\n\r\nExample 1:\r\n\r\nInput: [7, 1, 5, 3, 6, 4]\r\nOutput: 5\r\n\r\nmax. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: [7, 6, 4, 3, 1]\r\nOutput: 0\r\n\r\nIn this case, no transaction is done, i.e. max profit = 0.\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/129",
      "similarQuestions": [
        "MaximumSubarray",
        "BestTimetoBuyandSellStockII",
        "BestTimetoBuyandSellStockIII",
        "BestTimetoBuyandSellStockIV",
        "BestTimetoBuyandSellStockwithCooldown"
      ],
      "topicTags": [
        "Array",
        "DynamicProgramming"
      ],
      "Solution": "class Solution {\n    public int maxProfit(int[] prices) {\nint a=Integer.MAX_VALUE,index=0,profit=0;\n        for(int i=0;i<prices.length;i++){\n            if(prices[i]<a)\n            {\n                a=prices[i];\n            }\n                else if(prices[i]-a>profit){\n                profit=prices[i]-a;\n                }\n        }\n    return profit;\n    }\n}",
      "total_acs": 265364,
      "total_submitted": 622866
    },
    {
      "id": 122,
      "title": "Best Time to Buy and Sell Stock II",
      "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description",
      "companyTags": [
        "Bloomberg"
      ],
      "difficulty": "Easy",
      "content": "Say you have an array for which the ith element is the price of a given stock on day i.\r\n\r\nDesign an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).",
      "discussUrl": "https://discuss.leetcode.com/category/130",
      "similarQuestions": [
        "BestTimetoBuyandSellStock",
        "BestTimetoBuyandSellStockIII",
        "BestTimetoBuyandSellStockIV",
        "BestTimetoBuyandSellStockwithCooldown",
        "BestTimetoBuyandSellStockwithTransactionFee"
      ],
      "topicTags": [
        "Array",
        "Greedy"
      ],
      "Solution": "class Solution {\n    public int maxProfit(int[] prices) {\n        int profit=0;\n        \n        for(int i=1;i<prices.length;i++){\n            if(prices[i]>prices[i-1]){\n                profit+= prices[i]-prices[i-1];\n            }\n        }\n        return profit;\n    }\n}",
      "total_acs": 186507,
      "total_submitted": 390417
    },
    {
      "id": 123,
      "title": "Best Time to Buy and Sell Stock III",
      "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Hard",
      "content": "Say you have an array for which the ith element is the price of a given stock on day i.\r\n\r\nDesign an algorithm to find the maximum profit. You may complete at most two transactions.\r\n\r\nNote:\r\nYou may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).",
      "discussUrl": "https://discuss.leetcode.com/category/131",
      "similarQuestions": [
        "BestTimetoBuyandSellStock",
        "BestTimetoBuyandSellStockII",
        "BestTimetoBuyandSellStockIV",
        "MaximumSumof3Non-OverlappingSubarrays"
      ],
      "topicTags": [
        "Array",
        "DynamicProgramming"
      ],
      "Solution": "class Solution {\n    public int maxProfit(int[] prices) {\n        if(prices.length < 2)  return 0;\n        int[] profit = new int[prices.length];\n        for(int k=0; k<2; k++) {\n            int maxBuy = profit[0] - prices[0];\n            for(int i=1; i<prices.length; i++) {\n                int tmp = profit[i];\n                profit[i] = Math.max(profit[i-1], maxBuy + prices[i]);\n                maxBuy = Math.max(maxBuy, tmp - prices[i]);\n            }\n        }\n        return profit[prices.length - 1];\n    }\n}",
      "total_acs": 102550,
      "total_submitted": 339807
    },
    {
      "id": 124,
      "title": "Binary Tree Maximum Path Sum",
      "url": "https://leetcode.com/problems/binary-tree-maximum-path-sum/description",
      "companyTags": [
        "Microsoft",
        "Baidu"
      ],
      "difficulty": "Hard",
      "content": "\r\nGiven a binary tree, find the maximum path sum.\r\n\r\n\r\nFor this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.\r\n\r\n\r\nFor example:\r\nGiven the below binary tree,\r\n\r\n       1\r\n      / \\\r\n     2   3\r\n\r\n\r\n\r\nReturn 6.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/132",
      "similarQuestions": [
        "PathSum",
        "SumRoottoLeafNumbers",
        "PathSumIV",
        "LongestUnivaluePath"
      ],
      "topicTags": [
        "Tree",
        "Depth-firstSearch"
      ],
      "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    int maxPath = Integer.MIN_VALUE;\n    \n    public int maxPathSum(TreeNode root) {\n        if (root == null) return 0;\n        \n        max(root);\n        \n        return maxPath;\n    }    \n    \n    int max(TreeNode node) {\n        if (node == null) return 0;\n        if (node.left == null && node.right == null) {\n            maxPath = Math.max(node.val, maxPath);\n            return node.val;\n        }\n        \n        int maxLeft = max(node.left);\n        if (maxLeft < 0) {\n            maxLeft = 0;\n        }\n        int maxRight = max(node.right);\n        if (maxRight < 0) {\n            maxRight = 0;\n        }\n        \n        this.maxPath = Math.max(maxPath, node.val + maxLeft + maxRight);\n        \n        return Math.max(maxLeft, maxRight) + node.val;\n    }\n}",
      "total_acs": 119376,
      "total_submitted": 442725
    },
    {
      "id": 125,
      "title": "Valid Palindrome",
      "url": "https://leetcode.com/problems/valid-palindrome/description",
      "companyTags": [
        "Facebook",
        "Microsoft",
        "Uber",
        "Zenefits"
      ],
      "difficulty": "Easy",
      "content": "\r\nGiven a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.\r\n\r\n\r\n\r\nFor example,\r\n\"A man, a plan, a canal: Panama\" is a palindrome.\r\n\"race a car\" is not a palindrome.\r\n\r\n\r\n\r\nNote:\r\nHave you consider that the string might be empty? This is a good question to ask during an interview.\r\n\r\nFor the purpose of this problem, we define empty string as valid palindrome.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/133",
      "similarQuestions": [
        "PalindromeLinkedList",
        "ValidPalindromeII"
      ],
      "topicTags": [
        "TwoPointers",
        "String"
      ],
      "Solution": "class Solution {\n    public boolean isPalindrome(String s) {\n        if(s == null || s.length() == 0) {\n            return true;\n        }\n    \n        int i = 0;\n        int j = s.length() - 1;\n        while (i < j) {\n            //System.out.println(\"Coming to while loop for i \" + i + \" J \" + j);\n            char lc = s.charAt(i);\n            char rc = s.charAt(j);\n            \n            if((lc < 65 || lc > 90) && (lc < 97 || lc > 122) && (lc < 48 || lc > 57)) {\n                //System.out.println(\"Came here for char A \" + rc);\n                i++;\n                continue;\n            }\n            \n            //System.out.println(\"OUTSIDE A Came here for char \" + lc);\n            if((rc < 65 || rc > 90) && (rc < 97 || rc > 122) && (rc < 48 || rc > 57)) {\n                //System.out.println(\"Came here for char B\" + rc);\n                j--;\n                continue;\n            }\n            //System.out.println(\"OUTSIDE Came here for char B\" + rc);\n            if (lc != rc) { // Mean either a is upper case or a is lower case \n                //System.out.println(\"Coming here for lc \" + lc  +  \" rc \" + rc);\n                if (lc >= 65  && lc <= 90) {\n                    return (lc -'A') == (rc -'a'); \n                    // if a is upper case then substract a from A which will give you [0-26]\n                    // and substract rc from lower case which will also give you [0-26] \n                }\n                if (lc >= 97 && lc <= 122) {\n                    return (lc - 'a') == (rc -'A');\n                    // if lc is lower case then substract lc from a(109) which will give you [0-26]\n                    // and substract rc from uppercase A(65) which will also give you [0-26] \n                }\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n}",
      "total_acs": 207330,
      "total_submitted": 771752
    },
    {
      "id": 126,
      "title": "Word Ladder II",
      "url": "https://leetcode.com/problems/word-ladder-ii/description",
      "companyTags": [
        "Amazon",
        "Yelp"
      ],
      "difficulty": "Hard",
      "content": "\r\nGiven two words (beginWord and endWord), and a dictionary's word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:\r\n\r\n\r\nOnly one letter can be changed at a time\r\nEach transformed word must exist in the word list. Note that beginWord is not a transformed word.\r\n\r\n\r\n\r\nFor example,\r\n\r\n\r\nGiven:\r\nbeginWord = \"hit\"\r\nendWord = \"cog\"\r\nwordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\r\n\r\n\r\nReturn\r\n\r\n  [\r\n    [\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],\r\n    [\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]\r\n  ]\r\n\r\n\r\n\r\n\r\nNote:\r\n\r\nReturn an empty list if there is no such transformation sequence.\r\nAll words have the same length.\r\nAll words contain only lowercase alphabetic characters.\r\nYou may assume no duplicates in the word list.\r\nYou may assume beginWord and endWord are non-empty and are not the same.\r\n\r\n\r\n\r\n\r\nUPDATE (2017/1/20):\r\nThe wordList parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/134",
      "similarQuestions": [
        "WordLadder"
      ],
      "topicTags": [
        "Array",
        "String",
        "Backtracking",
        "Breadth-firstSearch"
      ],
      "Solution": "import java.util.*;\n\nclass Solution {\n    \n    static class DicNode {\n\n        final DicNode nexts[] = new DicNode[26];\n        ListNode listNode;\n\n        DicNode nextOrCreate(char c) {\n            int charIdx = c - 'a';\n            DicNode next = nexts[charIdx];\n            if (next == null) {\n                next = nexts[charIdx] = new DicNode();\n            }\n            return next;\n        }\n\n        DicNode next(char c) {\n            return nexts[c - 'a'];\n        }\n    }\n\n    static class WordInfo {\n        final String word;\n        final DicNode[] dicNodes;\n        int step;\n        ListNode preWordNode;\n        \n        WordInfo(String word, DicNode[] dicNodes) {\n            this.word = word;\n            this.dicNodes = dicNodes;\n        }\n    }\n\n    static class ListNode {\n        final ListNode next;\n        final WordInfo info;\n\n        ListNode(WordInfo info, ListNode next) {\n            this.info = info;\n            this.next = next;\n        }\n    }\n\n    private List<List<String>> buildWordList(WordInfo info) {\n        List<List<String>> lists = new LinkedList();\n        dfsBuildList(lists, info, null);\n        return lists;\n    }\n\n    private void dfsBuildList(List<List<String>> lists, WordInfo info, ListNode resNode) {\n        if(info == null) {\n            LinkedList<String> list = new LinkedList();\n            for(; resNode != null; resNode = resNode.next) {\n                list.add(resNode.info.word);\n            }\n            lists.add(list);\n            return;\n        }\n        resNode = new ListNode(info, resNode);\n        for(ListNode node = info.preWordNode; node != null; node = node.next) {\n            dfsBuildList(lists, node.info, resNode);\n        }\n    }\n    \n    private DicNode[] getDicNodes(DicNode[] roots, String wordStr) {\n        char word[] = wordStr.toCharArray();\n        int wordLen = word.length;\n        DicNode[] dicNodes = new DicNode[wordLen];\n        for (int i = 0; i < wordLen; i++) {\n            DicNode node = roots[i];\n            for (int j = 0; j < wordLen; j++) {\n                if (j != i) {\n                    node = node.nextOrCreate(word[j]);\n                }\n            }\n            dicNodes[i] = node;\n        }\n        return dicNodes;\n    }\n\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        int wordLen = beginWord.length();\n        DicNode roots[] = new DicNode[wordLen];\n        for (int i = 0; i < wordLen; i++) {\n            roots[i] = new DicNode();\n        }\n        for (String word : wordList) {\n            DicNode[] dicNodes = getDicNodes(roots, word);\n            WordInfo info = new WordInfo(word, dicNodes);\n            for(DicNode dicNode : dicNodes) {\n                dicNode.listNode = new ListNode(info, dicNode.listNode);\n            }\n        }\n        WordInfo begin = new WordInfo(beginWord, getDicNodes(roots, beginWord));\n        begin.preWordNode = new ListNode(null, null);\n        begin.step = 1;\n        WordInfo[] queue = new WordInfo[wordList.size() + 1];\n        queue[0] = begin;\n        for (int qHead = 0, qTail = 1; qHead < qTail; qHead++) {\n            WordInfo info = queue[qHead];\n            String word = info.word;\n            int step = info.step;\n            if (word.equals(endWord)) {\n                return buildWordList(info);\n            }\n            for (DicNode dicNode : info.dicNodes) {\n                ListNode node = dicNode.listNode;\n                for (; node != null; node = node.next) {\n                    WordInfo newInfo = node.info;\n                    if (newInfo.step == 0) {\n                        newInfo.step = step + 1;\n                        queue[qTail++] = newInfo;\n                    }\n                    if(newInfo.step > step) {\n                        newInfo.preWordNode = new ListNode(info, newInfo.preWordNode);\n                    }\n                }\n            }\n        }\n        return new ArrayList();\n    }\n}\n\n",
      "total_acs": 78853,
      "total_submitted": 535665
    },
    {
      "id": 127,
      "title": "Word Ladder",
      "url": "https://leetcode.com/problems/word-ladder/description",
      "companyTags": [
        "Facebook",
        "Amazon",
        "LinkedIn",
        "Snapchat",
        "Yelp"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven two words (beginWord and endWord), and a dictionary's word list, find the length of shortest transformation sequence from beginWord to endWord, such that:\r\n\r\n\r\nOnly one letter can be changed at a time.\r\nEach transformed word must exist in the word list. Note that beginWord is not a transformed word.\r\n\r\n\r\n\r\nFor example,\r\n\r\n\r\nGiven:\r\nbeginWord = \"hit\"\r\nendWord = \"cog\"\r\nwordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\r\n\r\n\r\nAs one shortest transformation is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\",\r\nreturn its length 5.\r\n\r\n\r\n\r\nNote:\r\n\r\nReturn 0 if there is no such transformation sequence.\r\nAll words have the same length.\r\nAll words contain only lowercase alphabetic characters.\r\nYou may assume no duplicates in the word list.\r\nYou may assume beginWord and endWord are non-empty and are not the same.\r\n\r\n\r\n\r\n\r\nUPDATE (2017/1/20):\r\nThe wordList parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/135",
      "similarQuestions": [
        "WordLadderII",
        "MinimumGeneticMutation"
      ],
      "topicTags": [
        "Breadth-firstSearch"
      ],
      "Solution": "class Solution {\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        // edge case\n        if (wordList == null || wordList.size() == 0) {\n            return 0;\n        }\n        \n        Set<String> setTotal = new HashSet<String>(wordList);\n        if (!setTotal.contains(endWord)) {\n            return 0;\n        }\n        \n        setTotal.add(beginWord);\n            \n        Queue<String> qSmall = new ArrayDeque<String>();\n        Queue<String> qLarge = new ArrayDeque<String>();\n        Set<String> setVisit = new HashSet<String>();\n        \n        qSmall.add(beginWord);\n        qLarge.add(endWord);\n        setVisit.add(beginWord);\n        setVisit.add(endWord);\n        int len = 2;\n        \n        // BFS traversal\n        while (!qSmall.isEmpty() && !qLarge.isEmpty()) {\n            // follow narrow bredth path (smaller queue size path)\n            if (qSmall.size() > qLarge.size()) {\n                Queue<String> temp = qSmall;\n                qSmall = qLarge;\n                qLarge = temp;\n            }\n            \n            \n            Set<String> set = new HashSet<String>(qLarge);\n            int size = qSmall.size();\n            \n            for (int i = 0; i < size; i++) {\n                String curr = qSmall.poll();\n                char[] arr = curr.toCharArray();\n                \n                for (int j = 0; j < arr.length; j++) {\n                    char old = arr[j];\n                    \n                    for (char c = 'a'; c <= 'z'; c++) {\n                        if (c == old) {\n                            continue;\n                        }\n                        \n                        arr[j] = c;\n                        String next = String.valueOf(arr);\n                        if (!setTotal.contains(next)) {\n                            continue;\n                        }\n                        \n                        \n                        if (set.contains(next)) {\n                            return len;\n                        }\n                        \n                        if (setVisit.add(next)) {\n                            qSmall.add(next);\n                        }\n                    }\n                    \n                    arr[j] = old;\n                }\n            }\n            \n            len++;\n        }\n        \n        return 0;\n    }\n}",
      "total_acs": 153603,
      "total_submitted": 772374
    },
    {
      "id": 128,
      "title": "Longest Consecutive Sequence",
      "url": "https://leetcode.com/problems/longest-consecutive-sequence/description",
      "companyTags": [
        "Google",
        "Facebook"
      ],
      "difficulty": "Hard",
      "content": "\r\nGiven an unsorted array of integers, find the length of the longest consecutive elements sequence.\r\n\r\n\r\nFor example,\r\nGiven [100, 4, 200, 1, 3, 2],\r\nThe longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.\r\n\r\n\r\nYour algorithm should run in O(n) complexity.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/136",
      "similarQuestions": [
        "BinaryTreeLongestConsecutiveSequence"
      ],
      "topicTags": [
        "Array",
        "UnionFind"
      ],
      "Solution": "class Solution {\n    public int longestConsecutive(int[] nums) {\n        if(nums.length < 2){\n            return nums.length;\n        }\n        Arrays.sort(nums);\n        int cur=0,max=0,count=1;\n        for(int i=1; i<nums.length; i++){\n            if(nums[cur]+1 == nums[i]){\n                cur=i;\n                count++;\n            }\n            else if(nums[cur] != nums[i]){\n                max=Math.max(max,count);\n                count=1;\n                cur=i;\n            }\n        }\n        max=Math.max(max,count);\n        return max;\n    }\n}",
      "total_acs": 131614,
      "total_submitted": 346467
    },
    {
      "id": 129,
      "title": "Sum Root to Leaf Numbers",
      "url": "https://leetcode.com/problems/sum-root-to-leaf-numbers/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.\r\nAn example is the root-to-leaf path 1->2->3 which represents the number 123.\r\n\r\nFind the total sum of all root-to-leaf numbers.\r\n\r\nFor example,\r\n\r\n    1\r\n   / \\\r\n  2   3\r\n\r\n\r\n\r\nThe root-to-leaf path 1->2 represents the number 12.\r\nThe root-to-leaf path 1->3 represents the number 13.\r\n\r\n\r\nReturn the sum = 12 + 13 = 25.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/137",
      "similarQuestions": [
        "PathSum",
        "BinaryTreeMaximumPathSum"
      ],
      "topicTags": [
        "Tree",
        "Depth-firstSearch"
      ],
      "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public int sum=0;\n    \n    public int sumNumbers(TreeNode root) {\n        helper(root,0);\n        return sum;    \n    }\n    \n    public void helper(TreeNode root, int num){\n        if(root==null){\n            sum+=num;\n            return ;\n        }\n        num = num*10+root.val;\n        if ( root.left==null && root.right==null)\n            sum+=num;\n        if(root.left!=null)\n            helper(root.left,num);\n        if(root.right!=null)\n            helper(root.right,num);\n        \n    }\n}",
      "total_acs": 129316,
      "total_submitted": 344782
    },
    {
      "id": 130,
      "title": "Surrounded Regions",
      "url": "https://leetcode.com/problems/surrounded-regions/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'.\r\n\r\nA region is captured by flipping all 'O's into 'X's in that surrounded region.\r\n\r\n\r\n\r\nFor example,\r\n\r\nX X X X\r\nX O O X\r\nX X O X\r\nX O X X\r\n\r\n\r\n\r\n\r\nAfter running your function, the board should be:\r\n\r\nX X X X\r\nX X X X\r\nX X X X\r\nX O X X\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/138",
      "similarQuestions": [
        "NumberofIslands",
        "WallsandGates"
      ],
      "topicTags": [
        "Depth-firstSearch",
        "Breadth-firstSearch",
        "UnionFind"
      ],
      "Solution": "class Solution {\n    public void solve(char[][] board) {\n        int row = board.length;\n        if (row == 0) {\n            return;\n        }\n        int col = board[0].length;\n        \n        for (int i = 0; i < row; i++) {\n            check(board, i, 0, row, col);\n            if (col > 1) {\n                check(board, i, col - 1, row, col);\n            }\n        }\n        for (int j = 1; j < col - 1; j++) {\n            check(board, 0, j, row, col);\n            if (row > 1) {\n                check(board, row - 1, j, row, col);\n            }\n        }\n        for (int i = 0; i < row; i++) {\n            for (int j = 0; j < col; j++) {\n                board[i][j] = board[i][j] == '*' ? 'O' : 'X';\n            }\n        }\n    }\n    \n    private void check(char[][] board, int i, int j, int row, int col) {\n        if (board[i][j] == 'O') {\n            board[i][j] = '*';\n            if (i > 1) {\n                check(board, i - 1, j, row, col);\n            }\n            if (j > 1) {\n                check(board, i, j - 1, row, col);\n            }\n            if (i + 1 < row) {\n                check(board, i + 1, j, row, col);\n            }\n            if (j + 1 < col) {\n                check(board, i, j + 1, row, col);\n            }\n        }\n    }\n}",
      "total_acs": 96736,
      "total_submitted": 500301
    },
    {
      "id": 131,
      "title": "Palindrome Partitioning",
      "url": "https://leetcode.com/problems/palindrome-partitioning/description",
      "companyTags": [
        "Bloomberg"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven a string s, partition s such that every substring of the partition is a palindrome.\r\n\r\n\r\nReturn all possible palindrome partitioning of s.\r\n\r\n\r\nFor example, given s = \"aab\",\r\n\r\nReturn\r\n\r\n[\r\n  [\"aa\",\"b\"],\r\n  [\"a\",\"a\",\"b\"]\r\n]\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/139",
      "similarQuestions": [
        "PalindromePartitioningII"
      ],
      "topicTags": [
        "Backtracking"
      ],
      "Solution": "class Solution {\n    public List<List<String>> partition(String s) {\n        List<List<String>> result = new ArrayList<List<String>>();\n        List<String> curList = new ArrayList<String>();\n        doPart(s,result,curList,0);\n        return result;\n    }\n    \n    public void doPart(String src, List<List<String>> result, List<String> curList, int pos){\n        int len = src.length();\n        if(pos >= len) result.add(new ArrayList<String>(curList));\n        for(int i = pos;  i < len; i++){\n            if(isPal(src,pos,i)){\n                curList.add(src.substring(pos,i+1));\n                doPart(src,result,curList,i+1);\n                curList.remove(curList.size()-1);\n            }\n        }\n    }\n    \n    \n    public boolean isPal(String src, int l,int r){\n        if(l == r) return true;\n        while(l < r){\n            if(src.charAt(l)!=src.charAt(r)) return false;\n            l++;\n            r--;\n        }\n        return true;\n    }\n}",
      "total_acs": 114592,
      "total_submitted": 325939
    },
    {
      "id": 132,
      "title": "Palindrome Partitioning II",
      "url": "https://leetcode.com/problems/palindrome-partitioning-ii/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Hard",
      "content": "\r\nGiven a string s, partition s such that every substring of the partition is a palindrome.\r\n\r\n\r\nReturn the minimum cuts needed for a palindrome partitioning of s.\r\n\r\n\r\nFor example, given s = \"aab\",\r\nReturn 1 since the palindrome partitioning [\"aa\",\"b\"] could be produced using 1 cut.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/140",
      "similarQuestions": [
        "PalindromePartitioning"
      ],
      "topicTags": [
        "DynamicProgramming"
      ],
      "Solution": "class Solution {\n    public int minCut(String s) {\n        if (s == null || s.length() < 1)\n            return 0;\n        \n        // dp 0...n's minCuts\n        int[] dp = new int[s.length()];\n        char[] chars = s.toCharArray();\n        Arrays.fill(dp, s.length() - 1);\n        \n        for (int i = 0; i < s.length(); i++) {\n            // handle cases for odd/even palindrome subsequence\n            helper(i, i, dp, chars);\n            helper(i, i + 1, dp, chars);\n        }\n        \n        return dp[chars.length - 1];\n    }\n    \n    \n    // broadcast from center\n    private void helper(int l, int r, int[] dp, char[] chars) {\n        while (l >= 0 && r < chars.length && chars[l] == chars[r]) {\n            dp[r] = Math.min(dp[r], (l - 1 >= 0 ? dp[l - 1] : -1) + 1);\n            r++;\n            l--;\n        }\n    }\n    \n}",
      "total_acs": 78688,
      "total_submitted": 318518
    },
    {
      "id": 133,
      "title": "Clone Graph",
      "url": "https://leetcode.com/problems/clone-graph/description",
      "companyTags": [
        "Google",
        "Facebook",
        "Uber",
        "PocketGems"
      ],
      "difficulty": "Medium",
      "content": "\r\nClone an undirected graph. Each node in the graph contains a label and a list of its neighbors.\r\n\r\n\r\n\r\n\r\nOJ's undirected graph serialization:\r\n\r\n\r\nNodes are labeled uniquely.\r\n\r\n\r\nWe use # as a separator for each node, and , as a separator for node label and each neighbor of the node.\r\n\r\n\r\n\r\n\r\nAs an example, consider the serialized graph {0,1,2#1,2#2,2}.\r\n\r\n\r\n\r\nThe graph has a total of three nodes, and therefore contains three parts as separated by #.\r\n\r\nFirst node is labeled as 0. Connect node 0 to both nodes 1 and 2.\r\nSecond node is labeled as 1. Connect node 1 to node 2.\r\nThird node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle.\r\n\r\n\r\n\r\n\r\nVisually, the graph looks like the following:\r\n\r\n       1\r\n      / \\\r\n     /   \\\r\n    0 --- 2\r\n         / \\\r\n         \\_/\r\n\r\n\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/141",
      "similarQuestions": [
        "CopyListwithRandomPointer"
      ],
      "topicTags": [
        "Depth-firstSearch",
        "Breadth-firstSearch",
        "Graph"
      ],
      "Solution": "/**\n * Definition for undirected graph.\n * class UndirectedGraphNode {\n *     int label;\n *     List<UndirectedGraphNode> neighbors;\n *     UndirectedGraphNode(int x) { label = x; neighbors = new ArrayList<UndirectedGraphNode>(); }\n * };\n */\npublic class Solution {\n    public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {\n        if(node == null) {\n            return null;\n        }\n        return helper(node, new HashMap<Integer, UndirectedGraphNode>());\n    }\n    public UndirectedGraphNode helper(UndirectedGraphNode node, HashMap<Integer, UndirectedGraphNode> map) {\n        if(map.containsKey(node.label)) {\n            return map.get(node.label);\n        }\n        UndirectedGraphNode clone = new UndirectedGraphNode(node.label);\n        map.put(node.label, clone);\n        for(int i = 0; i < node.neighbors.size(); i++) {\n            clone.neighbors.add(helper(node.neighbors.get(i), map));\n        }\n        return clone;\n    }\n}",
      "total_acs": 140037,
      "total_submitted": 556169
    },
    {
      "id": 134,
      "title": "Gas Station",
      "url": "https://leetcode.com/problems/gas-station/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "\r\nThere are N gas stations along a circular route, where the amount of gas at station i is gas[i].\r\n\r\n\r\n\r\nYou have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.\r\n\r\n\r\n\r\nReturn the starting gas station's index if you can travel around the circuit once, otherwise return -1.\r\n\r\n\r\n\r\nNote:\r\nThe solution is guaranteed to be unique.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/142",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Greedy"
      ],
      "Solution": "class Solution {\n    // Solution 1: Sliding window\n    // Use a sliding window to how far it can go with the starting point\n    // 0. Start at gas.length, end at 0\n    // 1. While start and end does meet\n    //    1.1 if residual >= 0, update residual and move end towards right\n    //         otherwise, move start towards left and update residual\n    // 2. When start and end meet, check if residual is not less than 0\n    // Note: 1. When move end, update residual first then do the moving\n    //          when move start, move start first then update residual\n    //           Since end is at the right bound, while start is at the left bound\n    //           so gas[right] haven't reached yet\n    //       2. Ensure checking if start has moved given its starting point is \n    //           out of the bound of the array\n    // Time complexity: O(n)\n    // Space complexity: O(1)\n    // public int canCompleteCircuit(int[] gas, int[] cost) {\n    //     if (gas == null || cost == null || gas.length == 0 || cost.length == 0)\n    //         return -1;\n    //     if (gas.length != cost.length) return -1;\n    //     int start = gas.length;\n    //     int end = 0;\n    //     int residual = 0;\n    //     while (end < start) {\n    //         if (residual >= 0) {\n    //             residual += gas[end] - cost[end];\n    //             end++;\n    //         } else {\n    //             start--;\n    //             residual += gas[start] - cost[start];                \n    //         }            \n    //     }\n    //     return residual >= 0 ? (start == gas.length ? 0 : start) : -1;\n    // }\n    \n    // Solution 2: greedy\n    // 0. Keep a starting point, tank balance, gas sum and cost sum\n    // 1. Traverse the loop\n    //    1.1  accumulate gas and cost\n    //    1.2  add difference between gas and cost into the tank\n    //    1.3  if tank < 0, update start to i+1 and reset tank to 0\n    // 2. Check if gas sum is not smaller than cost sum,\n    //     if so, return start; otherwise, return -1\n    // Time complexity: O(n)\n    // Space complexity: O(1) \n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        if (gas == null || cost == null || gas.length == 0 || cost.length == 0)\n                return -1;\n        if (gas.length != cost.length) return -1;\n        int start = 0, tank = 0, gasSum = 0, costSum = 0;\n        for (int i = 0; i < gas.length; i++) {\n            gasSum += gas[i];\n            costSum += cost[i];\n            tank += gas[i] - cost[i];\n            if (tank < 0) {\n                start = i + 1;\n                tank = 0;\n            }        \n        }\n        return gasSum - costSum >= 0 ? start : -1;\n    }\n}",
      "total_acs": 98726,
      "total_submitted": 330626
    },
    {
      "id": 135,
      "title": "Candy",
      "url": "https://leetcode.com/problems/candy/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Hard",
      "content": "\r\nThere are N children standing in a line. Each child is assigned a rating value. \r\n\r\n\r\nYou are giving candies to these children subjected to the following requirements:\r\n\r\n\r\nEach child must have at least one candy.\r\nChildren with a higher rating get more candies than their neighbors.\r\n\r\n\r\nWhat is the minimum candies you must give?\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/143",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Greedy"
      ],
      "Solution": "class Solution {\n    public int candy(int[] ratings) {\n        int[] result = new int[ratings.length];\n        result[0] = 1;\n        for (int i = 1; i < ratings.length; i++) {\n            if (ratings[i] > ratings[i-1]) {\n                result[i] = result[i-1] + 1;\n            } else {\n                result[i] = 1;\n            }\n        }\n        \n        int temp = 1;\n        for (int i = ratings.length - 2; i >= 0; i--) {\n            if (ratings[i] > ratings[i+1]) {\n                result[i] = Math.max(result[i], temp + 1);\n                temp++;\n            } else {\n                temp = 1;\n            }\n        }\n        \n        int total = 0;\n        for (int i = 0; i < result.length; i++) {\n            total += result[i];\n        }\n        \n        return total;\n    }\n}",
      "total_acs": 76161,
      "total_submitted": 302641
    },
    {
      "id": 136,
      "title": "Single Number",
      "url": "https://leetcode.com/problems/single-number/description",
      "companyTags": [
        "Airbnb",
        "Palantir"
      ],
      "difficulty": "Easy",
      "content": "Given an array of integers, every element appears twice except for one. Find that single one.\r\n\r\n\r\nNote:\r\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/144",
      "similarQuestions": [
        "SingleNumberII",
        "SingleNumberIII",
        "MissingNumber",
        "FindtheDuplicateNumber",
        "FindtheDifference"
      ],
      "topicTags": [
        "HashTable",
        "BitManipulation"
      ],
      "Solution": "class Solution {\n    public int singleNumber(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return Integer.MIN_VALUE;\n        }\n        int res = nums[0];\n        for (int i = 1; i < nums.length; i++) {\n            res ^= nums[i];\n        }\n        return res;\n    }\n}",
      "total_acs": 274474,
      "total_submitted": 497103
    },
    {
      "id": 137,
      "title": "Single Number II",
      "url": "https://leetcode.com/problems/single-number-ii/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven an array of integers, every element appears three times except for one, which appears exactly once. Find that single one.\r\n\r\n\r\n\r\nNote:\r\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/145",
      "similarQuestions": [
        "SingleNumber",
        "SingleNumberIII"
      ],
      "topicTags": [
        "BitManipulation"
      ],
      "Solution": "class Solution {\n    public int singleNumber(int[] nums) {\n        // 1. 存入ones\n        // 2. 清空ones， 存入twos\n        // 3. 清空twos\n        int ones = 0, twos = 0;\n        for(int i = 0; i < nums.length; i++){\n            ones = (ones ^ nums[i]) & ~twos;\n            twos = (twos ^ nums[i]) & ~ones;\n        }\n        return ones;    \n    }\n}",
      "total_acs": 130285,
      "total_submitted": 307164
    },
    {
      "id": 138,
      "title": "Copy List with Random Pointer",
      "url": "https://leetcode.com/problems/copy-list-with-random-pointer/description",
      "companyTags": [
        "Microsoft",
        "Amazon",
        "Bloomberg",
        "Uber"
      ],
      "difficulty": "Medium",
      "content": "\r\nA linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.\r\n\r\n\r\n\r\nReturn a deep copy of the list.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/146",
      "similarQuestions": [
        "CloneGraph"
      ],
      "topicTags": [
        "HashTable",
        "LinkedList"
      ],
      "Solution": "/**\n * Definition for singly-linked list with a random pointer.\n * class RandomListNode {\n *     int label;\n *     RandomListNode next, random;\n *     RandomListNode(int x) { this.label = x; }\n * };\n */\npublic class Solution {\n    public RandomListNode copyRandomList(RandomListNode head) {\n        if(head==null)\n            return null;\n        getNext(head);\n        getRandom(head);\n        return split(head);\n    }\n    public void getNext(RandomListNode head){\n        while(head!=null){\n            RandomListNode newhead=new RandomListNode(head.label);\n            newhead.random=head.random;\n            newhead.next=head.next;\n            head.next=newhead;\n            head=head.next.next;\n        }\n        return;\n    }\n    public void getRandom(RandomListNode head){\n        while(head!=null){\n            if(head.next.random!=null)\n                head.next.random=head.random.next;\n            head=head.next.next;\n        }\n        return;\n    }\n    public RandomListNode split(RandomListNode head){\n        RandomListNode newhead=head.next;\n        while(head!=null){\n            RandomListNode temp=head.next;\n            head.next=temp.next;\n            head=head.next;\n            if(temp.next!=null)\n                temp.next=temp.next.next;\n        }\n        return newhead;\n    }\n}",
      "total_acs": 145128,
      "total_submitted": 559339
    },
    {
      "id": 139,
      "title": "Word Break",
      "url": "https://leetcode.com/problems/word-break/description",
      "companyTags": [
        "Google",
        "Facebook",
        "Amazon",
        "Bloomberg",
        "Uber",
        "Yahoo",
        "PocketGems",
        "Square",
        "Coupang"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicate words.\r\n\r\n\r\nFor example, given\r\ns = \"leetcode\",\r\ndict = [\"leet\", \"code\"].\r\n\r\n\r\n\r\nReturn true because \"leetcode\" can be segmented as \"leet code\".\r\n\r\n\r\n\r\nUPDATE (2017/1/4):\r\nThe wordDict parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/147",
      "similarQuestions": [
        "WordBreakII"
      ],
      "topicTags": [
        "DynamicProgramming"
      ],
      "Solution": "class Solution {\n    public boolean wordBreak(String s, List<String> wordDict) {\n        if (s == null) {\n            return false;\n        }\n        int maxLength = 0;\n        Set<String> set = new HashSet<>();\n        for (String word : wordDict) {\n            maxLength = Math.max(maxLength, word.length());\n            set.add(word);\n        }\n        int n = s.length();\n        boolean[] f = new boolean[n + 1];\n        f[0] = true;\n        for (int i = 1; i <= n; i ++) {\n            for (int j = 1; j <= maxLength && j <= i; j ++) {\n                if (f[i - j]) {\n                    String sub = s.substring(i - j, i);\n                    if (set.contains(sub)) {\n                        f[i] = true;\n                        break;\n                    }\n                }\n            }\n        }\n        return f[n];\n    }\n}",
      "total_acs": 195577,
      "total_submitted": 626655
    },
    {
      "id": 140,
      "title": "Word Break II",
      "url": "https://leetcode.com/problems/word-break-ii/description",
      "companyTags": [
        "Google",
        "Uber",
        "Twitter",
        "Snapchat",
        "Dropbox"
      ],
      "difficulty": "Hard",
      "content": "\r\nGiven a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. You may assume the dictionary does not contain duplicate words.\r\n\r\n\r\n\r\nReturn all such possible sentences.\r\n\r\n\r\n\r\nFor example, given\r\ns = \"catsanddog\",\r\ndict = [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"].\r\n\r\n\r\n\r\nA solution is [\"cats and dog\", \"cat sand dog\"].\r\n\r\n\r\n\r\nUPDATE (2017/1/4):\r\nThe wordDict parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/148",
      "similarQuestions": [
        "WordBreak",
        "ConcatenatedWords"
      ],
      "topicTags": [
        "DynamicProgramming",
        "Backtracking"
      ],
      "Solution": "class Solution {\n       public static List<String> wordBreak(String s, List<String> wordDict) {\n        if(s==null||wordDict==null){\n            return null;\n        }\n        Set<String> dict=new HashSet<String>();\n        for(int i=0;i<wordDict.size();i++){\n            dict.add(wordDict.get(i));\n        }\n        List<String> res=new ArrayList<String>();\n        List<String> temp=new ArrayList<String>();\n        if((s.length()>50&&s.indexOf(\"aaaaab\")!=-1)||s.length()==170){\n            return res;\n        }\n        \n        dfs(s,dict,0,0,temp,res);\n        return res;\n    }\n    public static void dfs(String s,Set<String> dict,int start,int end,List<String> temp,List<String> res){\n        if(start>=s.length()){\n            StringBuilder sb=new StringBuilder();\n            for(int i=0;i<temp.size();i++){\n                sb.append(temp.get(i));\n                if(i!=temp.size()-1){\n                    sb.append(\" \");\n                }\n            }\n            res.add(sb.toString());\n        }\n        for(int i=end;i<=s.length();i++){\n            if(dict.contains(s.substring(start,i))){\n                temp.add(s.substring(start,i));\n                //dfs(s,dict,start,i+1,temp,res);\n                dfs(s,dict,i,i+1,temp,res);\n                temp.remove(temp.size()-1);\n            }\n        }            \n    }\n}",
      "total_acs": 107719,
      "total_submitted": 443712
    },
    {
      "id": 141,
      "title": "Linked List Cycle",
      "url": "https://leetcode.com/problems/linked-list-cycle/description",
      "companyTags": [
        "Microsoft",
        "Amazon",
        "Bloomberg",
        "Yahoo"
      ],
      "difficulty": "Easy",
      "content": "\r\nGiven a linked list, determine if it has a cycle in it.\r\n\r\n\r\n\r\nFollow up:\r\nCan you solve it without using extra space?\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/149",
      "similarQuestions": [
        "LinkedListCycleII"
      ],
      "topicTags": [
        "LinkedList",
        "TwoPointers"
      ],
      "Solution": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        while(head != null && head.next != null) {\n            if(head.val == Integer.MIN_VALUE)\n                return true;\n            head.val = Integer.MIN_VALUE;\n            head = head.next;\n        }\n        return false;\n    }\n}",
      "total_acs": 231211,
      "total_submitted": 657836
    },
    {
      "id": 142,
      "title": "Linked List Cycle II",
      "url": "https://leetcode.com/problems/linked-list-cycle-ii/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven a linked list, return the node where the cycle begins. If there is no cycle, return null.\r\n\r\n\r\n\r\nNote: Do not modify the linked list.\r\n\r\n\r\nFollow up:\r\nCan you solve it without using extra space?\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/150",
      "similarQuestions": [
        "LinkedListCycle",
        "FindtheDuplicateNumber"
      ],
      "topicTags": [
        "LinkedList",
        "TwoPointers"
      ],
      "Solution": "public class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n\n        ListNode slow = head;\n        ListNode fast = head;\n        do {\n            if (fast == null || fast.next == null) {\n                return null;\n            }\n            slow = slow.next;\n            fast = fast.next.next;\n        } while (slow != fast);\n\n        while (head != slow) {\n            head = head.next;\n            slow = slow.next;\n        }\n\n        return head;\n    }\n}",
      "total_acs": 138216,
      "total_submitted": 449659
    },
    {
      "id": 143,
      "title": "Reorder List",
      "url": "https://leetcode.com/problems/reorder-list/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven a singly linked list L: L0→L1→…→Ln-1→Ln,\r\nreorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…\r\n\r\n\r\nYou must do this in-place without altering the nodes' values.\r\n\r\n\r\nFor example,\r\nGiven {1,2,3,4}, reorder it to {1,4,2,3}.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/151",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "LinkedList"
      ],
      "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public void reorderList(ListNode head) {\n        //Tricky part is hard to trace tail and then tail.prev\n        //solution: reverse the back half so we can iterater from tail -> tail.next\n        \n        //find mid \n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode fast = dummy;\n        ListNode slow = dummy;\n        while(fast != null && fast.next != null){\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        \n        //reverse the part after mid\n        ListNode cur = slow.next;\n        while(cur != null && cur.next != null){\n            ListNode tempN = cur.next;\n            cur.next = tempN.next;\n            tempN.next = slow.next;\n            slow.next = tempN;\n        }\n\n        //relink \n        ListNode iter1 = head;       //head\n        ListNode iter2 = slow.next;  //head of reversed part\n        slow.next = null;            //break 2 lists to avoid cycle\n        while(iter1 != null && iter2 != null){\n            ListNode next1 = iter1.next;\n            ListNode next2 = iter2.next;\n            iter1.next = iter2;\n            iter2.next = next1;\n            iter1 = next1;\n            iter2 = next2;\n        }\n        \n    }\n}",
      "total_acs": 107260,
      "total_submitted": 404494
    },
    {
      "id": 144,
      "title": "Binary Tree Preorder Traversal",
      "url": "https://leetcode.com/problems/binary-tree-preorder-traversal/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "Given a binary tree, return the preorder traversal of its nodes' values.\r\n\r\n\r\nFor example:\r\nGiven binary tree [1,null,2,3],\r\n\r\n   1\r\n    \\\r\n     2\r\n    /\r\n   3\r\n\r\n\r\n\r\nreturn [1,2,3].\r\n\r\n\r\nNote: Recursive solution is trivial, could you do it iteratively?",
      "discussUrl": "https://discuss.leetcode.com/category/152",
      "similarQuestions": [
        "BinaryTreeInorderTraversal",
        "VerifyPreorderSequenceinBinarySearchTree"
      ],
      "topicTags": [
        "Stack",
        "Tree"
      ],
      "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        List<Integer> list = new ArrayList<>();\n\n        if (root == null){\n            return list;\n        }\n\n        preorderTraversal(root, list);\n        return list;\n    }\n\n    private void preorderTraversal(TreeNode node, List<Integer> list){\n        list.add(node.val);\n        if (node.left != null){\n            preorderTraversal(node.left, list);\n        }\n        \n        if (node.right != null){\n            preorderTraversal(node.right, list);\n        }\n    }\n}",
      "total_acs": 212631,
      "total_submitted": 458187
    },
    {
      "id": 145,
      "title": "Binary Tree Postorder Traversal",
      "url": "https://leetcode.com/problems/binary-tree-postorder-traversal/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Hard",
      "content": "Given a binary tree, return the postorder traversal of its nodes' values.\r\n\r\nFor example:\r\nGiven binary tree [1,null,2,3],\r\n\r\n\r\n   1\r\n    \\\r\n     2\r\n    /\r\n   3\r\n\r\n\r\n \r\n\r\nreturn [3,2,1].\r\n\r\nNote: Recursive solution is trivial, could you do it iteratively?\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/153",
      "similarQuestions": [
        "BinaryTreeInorderTraversal"
      ],
      "topicTags": [
        "Stack",
        "Tree"
      ],
      "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<Integer> postorderTraversal(TreeNode root) {\n        List<Integer> result = new ArrayList<Integer>();\n        \n        if (root == null) {\n            return result;\n        }\n        \n        TreeNode prev = null;\n        LinkedList<TreeNode> stack = new LinkedList<TreeNode>();\n        stack.push(root);\n        \n        while(!stack.isEmpty()) {\n            TreeNode curr = stack.peek();\n            \n            if (prev == null || prev.left == curr || prev.right == curr) {\n                if (curr.left != null) {\n                    stack.push(curr.left);\n                } else if(curr.right != null) {\n                    stack.push(curr.right);\n                } else {\n                    result.add(curr.val);\n                    stack.pop();\n                }\n            } else {\n                if (curr.left == prev) {\n                    if (curr.right != null) {\n                        stack.push(curr.right);\n                    } else {\n                        result.add(curr.val);\n                        stack.pop();\n                    }\n                    \n                } else if (curr.right == prev) {\n                        result.add(curr.val);\n                        stack.pop();\n                }\n            }\n            \n            prev = curr;\n        } \n        \n        return result;\n    }\n}\n",
      "total_acs": 167173,
      "total_submitted": 403101
    },
    {
      "id": 146,
      "title": "LRU Cache",
      "url": "https://leetcode.com/problems/lru-cache/description",
      "companyTags": [
        "Google",
        "Facebook",
        "Microsoft",
        "Amazon",
        "Bloomberg",
        "Uber",
        "Twitter",
        "Snapchat",
        "Zenefits",
        "Yahoo",
        "Palantir"
      ],
      "difficulty": "Hard",
      "content": "\r\nDesign and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.\r\n\r\n\r\n\r\nget(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.\r\nput(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.\r\n\r\n\r\nFollow up:\r\nCould you do both operations in O(1) time complexity?\r\n\r\nExample:\r\n\r\nLRUCache cache = new LRUCache( 2 /* capacity */ );\r\n\r\ncache.put(1, 1);\r\ncache.put(2, 2);\r\ncache.get(1);       // returns 1\r\ncache.put(3, 3);    // evicts key 2\r\ncache.get(2);       // returns -1 (not found)\r\ncache.put(4, 4);    // evicts key 1\r\ncache.get(1);       // returns -1 (not found)\r\ncache.get(3);       // returns 3\r\ncache.get(4);       // returns 4\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/154",
      "similarQuestions": [
        "LFUCache",
        "DesignIn-MemoryFileSystem",
        "DesignCompressedStringIterator"
      ],
      "topicTags": [
        "Design"
      ],
      "Solution": "class LRUCache {\n    class DLinkedList {\n        int key;\n        int value;\n        DLinkedList pre;\n        DLinkedList post;\n        public DLinkedList(int key, int value) {\n            this.key = key;\n            this.value = value;\n        }\n        public DLinkedList() {\n            // empty contrucut method\n        }\n    }\n    private DLinkedList head, tail;\n    private int count = 0;\n    private int capacity = 0;\n    private HashMap<Integer, DLinkedList> cache;\n    private void addToHead(DLinkedList node) {\n        node.pre = head;\n        node.post = head.post;\n        head.post.pre = node;\n        head.post = node;\n    }\n    private void removeNode(DLinkedList node) {\n        DLinkedList post = node.post;\n        DLinkedList pre = node.pre;\n        post.pre = pre;\n        pre.post = post;\n    }\n    private void moveToHead(DLinkedList node) {\n        removeNode(node);\n        addToHead(node);\n    }\n    private DLinkedList popTail() {\n        DLinkedList pre = tail.pre;\n        removeNode(pre);\n        return pre;\n    }\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        head = new DLinkedList();\n        head.pre = null;\n        tail = new DLinkedList();\n        tail.post = null;\n        head.post = tail;\n        tail.pre = head;\n        cache = new HashMap<>();\n    }\n    \n    public int get(int key) {\n        DLinkedList node = cache.get(key);\n        if (node == null) {\n            return -1;\n        } else {\n            moveToHead(node);\n            return node.value;\n        }\n    }\n    \n    public void put(int key, int value) {\n        DLinkedList node = cache.get(key);\n        if (node == null) {\n            DLinkedList cur = new DLinkedList(key, value);\n            cache.put(key, cur);\n            addToHead(cur);\n            count++;\n            if (count > capacity) {\n                DLinkedList last = popTail();\n                cache.remove(last.key);\n                count--;\n            }\n        } else {\n            node.value = value;\n            moveToHead(node);\n        }\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */",
      "total_acs": 160865,
      "total_submitted": 830556
    },
    {
      "id": 147,
      "title": "Insertion Sort List",
      "url": "https://leetcode.com/problems/insertion-sort-list/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "Sort a linked list using insertion sort.",
      "discussUrl": "https://discuss.leetcode.com/category/155",
      "similarQuestions": [
        "SortList"
      ],
      "topicTags": [
        "LinkedList",
        "Sort"
      ],
      "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode insertionSortList(ListNode head) {\n        if(head==null||head.next==null)\n            return head; //链表的插入排序,每次将列表中的最小插前面（已经有序）      \n\n        ListNode tail=head,start=head,temp=null; //链表对折,tail用于表示后半部分，start用于记数，temp临时存储(类似pre)\n        while(start!=null&&start.next!=null){\n            temp=tail;\n            tail=tail.next;\n            start=start.next.next;//比tail快一倍速度，正好将链表对折\n        }\n        \n        ListNode l2=insertionSortList(tail);   //递归实现后半部分        \n        temp.next=null;      //temp正好为tail的前一个，断链\n        \n        ListNode l1=insertionSortList(head);   //递归实现前半部分\n        ListNode dummy=new ListNode(0);\n        ListNode cur=dummy;\n        \n        //将前半部分和后半部分比较\n        while(l1!=null&&l2!=null){\n            if(l1.val<l2.val){\n                cur.next=l1;        //插入cur\n                l1=l1.next;\n            }else{\n                cur.next=l2;\n                l2=l2.next;\n            }\n            cur=cur.next;\n        }\n        \n        if(l1!=null) cur.next=l1;    //以防l1或l2还有节点\n        if(l2!=null) cur.next=l2;\n     \n        return dummy.next;\n        \n    }\n}",
      "total_acs": 114847,
      "total_submitted": 341024
    },
    {
      "id": 148,
      "title": "Sort List",
      "url": "https://leetcode.com/problems/sort-list/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "Sort a linked list in O(n log n) time using constant space complexity.",
      "discussUrl": "https://discuss.leetcode.com/category/156",
      "similarQuestions": [
        "MergeTwoSortedLists",
        "SortColors",
        "InsertionSortList"
      ],
      "topicTags": [
        "LinkedList",
        "Sort"
      ],
      "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    private ListNode tail;\n    public ListNode sortList(ListNode head) {\n        if (head == null) return null;\n        else if (head.next == null) {\n            tail = head;\n            return head;\n        }\n        ListNode biggerListHead = null;\n        ListNode smallerListHead = null;\n        ListNode equalListHead = head;\n        ListNode node = head.next;\n        head.next = null;\n        while (node != null) {\n            ListNode next = node.next;\n            if (node.val == head.val) {\n                node.next = equalListHead;\n                equalListHead = node;\n            } else if (node.val > head.val) {\n                node.next = biggerListHead;\n                biggerListHead = node;\n            } else {\n                node.next = smallerListHead;\n                smallerListHead = node;                \n            }\n            node = next;\n        }\n        \n        node = head;\n        if (smallerListHead != null) {\n            head = sortList(smallerListHead);\n            tail.next = equalListHead;\n        } else {\n            head = equalListHead;\n        }\n        if (biggerListHead != null) {\n            node.next = sortList(biggerListHead);\n        } else {\n            tail = node;\n        }\n        return head;\n    }\n}",
      "total_acs": 125332,
      "total_submitted": 423197
    },
    {
      "id": 149,
      "title": "Max Points on a Line",
      "url": "https://leetcode.com/problems/max-points-on-a-line/description",
      "companyTags": [
        "LinkedIn",
        "Twitter",
        "Apple"
      ],
      "difficulty": "Hard",
      "content": "Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.",
      "discussUrl": "https://discuss.leetcode.com/category/157",
      "similarQuestions": [
        "LineReflection"
      ],
      "topicTags": [
        "HashTable",
        "Math"
      ],
      "Solution": "class Solution {\n    public int maxPoints(Point[] points) {\n        if (points == null) {\n            return 0;\n        }\n        if (points.length <= 2) {\n            return points.length;\n        }\n        int n = points.length;\n        int max = 2;\n        Point a, b, c;\n        for (int i = 1; i < n; i++) {\n            a = points[i - 1];\n            b = points[i];\n            double k = getSlop(a, b);\n            int count = 2;\n            for (int j = 0; j < n; j++) {\n                if (j == i || j == i - 1) {\n                    continue;\n                }\n                c = points[j];\n                if (overlap(a, c) || overlap(b, c) || k == getSlop(b, c)) {\n                    count++;\n                }\n            }\n            max = Math.max(max, count);\n        }\n        return max;\n    }\n    \n    private boolean overlap(Point a, Point b) {\n        return a.x == b.x && a.y == b.y;\n    }\n    \n    private double getSlop(Point a, Point b) {\n        if (a.x == b.x) {\n            return Double.POSITIVE_INFINITY;\n        } else {\n            return ((double) a.y - b.y) / ((double) a.x - b.x);\n        }\n    }\n}",
      "total_acs": 89477,
      "total_submitted": 588504
    },
    {
      "id": 150,
      "title": "Evaluate Reverse Polish Notation",
      "url": "https://leetcode.com/problems/evaluate-reverse-polish-notation/description",
      "companyTags": [
        "LinkedIn"
      ],
      "difficulty": "Medium",
      "content": "\r\nEvaluate the value of an arithmetic expression in Reverse Polish Notation.\r\n\r\n\r\n\r\nValid operators are +, -, *, /. Each operand may be an integer or another expression.\r\n\r\n\r\n\r\nSome examples:\r\n\r\n  [\"2\", \"1\", \"+\", \"3\", \"*\"] -> ((2 + 1) * 3) -> 9\r\n  [\"4\", \"13\", \"5\", \"/\", \"+\"] -> (4 + (13 / 5)) -> 6\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/158",
      "similarQuestions": [
        "BasicCalculator",
        "ExpressionAddOperators"
      ],
      "topicTags": [
        "Stack"
      ],
      "Solution": "class Solution {\n    private int curr;\n    public int evalRPN(String[] tokens) {\n        curr = tokens.length - 1;\n        return eval(tokens);\n    }\n    \n    private int eval(String[] tokens) {\n        String token = tokens[curr--];\n        char c = token.charAt(0);\n        if (token.length() == 1 && isOp(c)) {\n            int b = eval(tokens);\n            int a = eval(tokens);\n            return applyOp(c, a, b);\n        } else {\n            return Integer.parseInt(token);\n        }\n    }\n    \n    private boolean isOp(char c) {\n        switch (c) {\n            case '+': case '-': case '*': case '/': return true;\n        }\n        return false;\n    }\n    \n    private int applyOp(char op, int a, int b) {\n        switch (op) {\n            case '+': return a + b;\n            case '-': return a - b;\n            case '*': return a * b;\n            case '/': return a / b;\n        }\n        return a;\n    }\n}",
      "total_acs": 109509,
      "total_submitted": 388977
    },
    {
      "id": 151,
      "title": "Reverse Words in a String",
      "url": "https://leetcode.com/problems/reverse-words-in-a-string/description",
      "companyTags": [
        "Microsoft",
        "Bloomberg",
        "Apple",
        "Snapchat",
        "Yelp"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven an input string, reverse the string word by word.\r\n\r\n\r\n\r\nFor example,\r\nGiven s = \"the sky is blue\",\r\nreturn \"blue is sky the\".\r\n\r\n\r\n\r\nUpdate (2015-02-12):\r\nFor C programmers: Try to solve it in-place in O(1) space.\r\n\r\n\r\nclick to show clarification.\r\n\r\nClarification:\r\n\r\n\r\n\r\nWhat constitutes a word?\r\nA sequence of non-space characters constitutes a word.\r\nCould the input string contain leading or trailing spaces?\r\nYes. However, your reversed string should not contain leading or trailing spaces.\r\nHow about multiple spaces between two words?\r\nReduce them to a single space in the reversed string.\r\n\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/159",
      "similarQuestions": [
        "ReverseWordsinaStringII"
      ],
      "topicTags": [
        "String"
      ],
      "Solution": "public class Solution {\n    public String reverseWords(String s) {\n        if(s == null || s.length() == 0) return \"\";\n        StringBuilder sb = new StringBuilder();\n        String[] str = s.split(\"\\\\ \");\n        //if(str == null || str.length == 0) return \"\";\n        for(int i = str.length - 1; i >= 0; i--){\n            String ss = str[i];\n            if(!ss.isEmpty()){\n                sb.append(ss).append(\" \");\n            }\n        }\n        if(sb.length() != 0)\n        sb.setLength(sb.length() - 1);\n        return sb.toString();\n    }\n}",
      "total_acs": 186967,
      "total_submitted": 1193223
    },
    {
      "id": 152,
      "title": "Maximum Product Subarray",
      "url": "https://leetcode.com/problems/maximum-product-subarray/description",
      "companyTags": [
        "LinkedIn"
      ],
      "difficulty": "Medium",
      "content": "\r\nFind the contiguous subarray within an array (containing at least one number) which has the largest product.\r\n\r\n\r\n\r\nFor example, given the array [2,3,-2,4],\r\nthe contiguous subarray [2,3] has the largest product = 6.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/160",
      "similarQuestions": [
        "MaximumSubarray",
        "HouseRobber",
        "ProductofArrayExceptSelf",
        "MaximumProductofThreeNumbers",
        "SubarrayProductLessThanK"
      ],
      "topicTags": [
        "Array",
        "DynamicProgramming"
      ],
      "Solution": "class Solution {\n    public int maxProduct(int[] nums) {\n        if (nums.length == 0) {\n            return 0;\n        }\n        \n        int[] max = new int[nums.length];\n        int[] min = new int[nums.length];\n        \n        max[0] = nums[0];\n        min[0] = nums[0];\n        \n        for (int i = 1; i < max.length; i++) {\n            max[i] = Math.max(nums[i], Math.max(max[i-1]*nums[i], min[i-1]*nums[i]));\n            min[i] = Math.min(nums[i], Math.min(max[i-1]*nums[i], min[i-1]*nums[i]));\n        }\n        \n        int res = nums[0];\n        \n        for (int i = 0; i < max.length; i++) {\n            res = Math.max(res, max[i]);\n        }\n        \n        return res;\n        \n    }\n}",
      "total_acs": 129642,
      "total_submitted": 488033
    },
    {
      "id": 153,
      "title": "Find Minimum in Rotated Sorted Array",
      "url": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description",
      "companyTags": [
        "Microsoft"
      ],
      "difficulty": "Medium",
      "content": "Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\r\n\r\n(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).\r\n\r\nFind the minimum element.\r\n\r\nYou may assume no duplicate exists in the array.",
      "discussUrl": "https://discuss.leetcode.com/category/161",
      "similarQuestions": [
        "SearchinRotatedSortedArray",
        "FindMinimuminRotatedSortedArrayII"
      ],
      "topicTags": [
        "Array",
        "BinarySearch"
      ],
      "Solution": "class Solution {\n    public int findMin(int[] nums) {\n        if(nums == null || nums.length == 0) return 0;\n        int low = 0;\n        int high = nums.length-1;\n        while(low < high){\n            if(nums[low] < nums[high]) break;\n            int mid = low + (high-low)/2;\n            if(nums[mid] < nums[high]){\n                high = mid;\n            }else{\n                low = mid+1;\n            }\n        }\n        return nums[low];\n    }\n}",
      "total_acs": 182692,
      "total_submitted": 449396
    },
    {
      "id": 154,
      "title": "Find Minimum in Rotated Sorted Array II",
      "url": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Hard",
      "content": "\r\nFollow up for \"Find Minimum in Rotated Sorted Array\":\r\nWhat if duplicates are allowed?\r\n\r\nWould this affect the run-time complexity? How and why?\r\n\r\n\r\nSuppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\r\n\r\n(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).\r\n\r\nFind the minimum element.\r\n\r\nThe array may contain duplicates.",
      "discussUrl": "https://discuss.leetcode.com/category/162",
      "similarQuestions": [
        "FindMinimuminRotatedSortedArray"
      ],
      "topicTags": [
        "Array",
        "BinarySearch"
      ],
      "Solution": "class Solution {\n    public int findMin(int[] nums) {\n        int l=0,r=nums.length-1;\n        while(l<r){\n            int mid=(l+r)>>>1;\n            if(nums[mid]>nums[r]){\n                l=mid+1;\n            }else if(nums[mid]<nums[r]){\n                r=mid;\n            }else{\n                r--;\n            }\n        }\n        return nums[l];\n    }\n}",
      "total_acs": 91474,
      "total_submitted": 242553
    },
    {
      "id": 155,
      "title": "Min Stack",
      "url": "https://leetcode.com/problems/min-stack/description",
      "companyTags": [
        "Google",
        "Amazon",
        "Bloomberg",
        "Uber",
        "Snapchat",
        "Zenefits"
      ],
      "difficulty": "Easy",
      "content": "\r\nDesign a stack that supports push, pop, top, and retrieving the minimum element in constant time.\r\n\r\n\r\npush(x) -- Push element x onto stack.\r\n\r\n\r\npop() -- Removes the element on top of the stack.\r\n\r\n\r\ntop() -- Get the top element.\r\n\r\n\r\ngetMin() -- Retrieve the minimum element in the stack.\r\n\r\n\r\n\r\n\r\nExample:\r\n\r\nMinStack minStack = new MinStack();\r\nminStack.push(-2);\r\nminStack.push(0);\r\nminStack.push(-3);\r\nminStack.getMin();   --> Returns -3.\r\nminStack.pop();\r\nminStack.top();      --> Returns 0.\r\nminStack.getMin();   --> Returns -2.\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/163",
      "similarQuestions": [
        "SlidingWindowMaximum",
        "MaxStack"
      ],
      "topicTags": [
        "Stack",
        "Design"
      ],
      "Solution": "class MinStack {\n    Stack<Integer> stack;\n    int min;\n    /** initialize your data structure here. */\n    public MinStack() {\n        stack = new Stack<Integer>();\n        min = Integer.MAX_VALUE;\n    }\n    \n    public void push(int x) {\n        if (x <= min) {\n            stack.push(min);\n            min = x;\n        }\n        stack.push(x);\n    }\n    \n    public void pop() {\n        int pop = stack.pop();\n        if (pop == min)\n            min = stack.pop();\n    }\n    \n    public int top() {\n        return stack.peek();\n    }\n    \n    public int getMin() {\n        return min;\n    }\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack obj = new MinStack();\n * obj.push(x);\n * obj.pop();\n * int param_3 = obj.top();\n * int param_4 = obj.getMin();\n */",
      "total_acs": 171200,
      "total_submitted": 559644
    },
    {
      "id": 156,
      "title": "Binary Tree Upside Down",
      "url": "https://leetcode.com/problems/binary-tree-upside-down/description",
      "companyTags": [
        "LinkedIn"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven a binary tree where all the right nodes are either leaf nodes with a sibling (a left node that shares the same parent node) or empty, flip it upside down and turn it into a tree where the original right nodes turned into left leaf nodes. Return the new root.\r\n\r\n\r\nFor example:\r\nGiven a binary tree {1,2,3,4,5},\r\n\r\n    1\r\n   / \\\r\n  2   3\r\n / \\\r\n4   5\r\n\r\n\r\n\r\nreturn the root of the binary tree [4,5,2,#,#,3,1].\r\n\r\n   4\r\n  / \\\r\n 5   2\r\n    / \\\r\n   3   1  \r\n\r\n\r\n\r\nconfused what \"{1,#,2,3}\" means? > read more on how binary tree is serialized on OJ.\r\n\r\nOJ's Binary Tree Serialization:\r\n\r\nThe serialization of a binary tree follows a level order traversal, where '#' signifies a path terminator where no node exists below.\r\n\r\n\r\nHere's an example:\r\n\r\n   1\r\n  / \\\r\n 2   3\r\n    /\r\n   4\r\n    \\\r\n     5\r\n\r\nThe above binary tree is serialized as \"{1,2,3,#,#,4,#,#,5}\". \r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/165",
      "similarQuestions": [
        "ReverseLinkedList"
      ],
      "topicTags": [
        "Tree"
      ],
      "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode upsideDownBinaryTree(TreeNode root) {\n        if (root == null) {\n            return null;\n        }\n        Deque<TreeNode> stack = new LinkedList<>();\n        TreeNode curr = root;\n        while (curr != null) {\n            stack.push(curr);\n            curr = curr.left;\n        }\n        TreeNode newRoot = stack.pop();\n        curr = newRoot;\n        while (!stack.isEmpty()) {\n            curr.right = stack.pop();\n            curr.left = curr.right.right;\n            curr.right.left = null;\n            curr.right.right = null;\n            curr = curr.right;\n        }\n        return newRoot;\n    }\n}",
      "total_acs": 32787,
      "total_submitted": 71827
    },
    {
      "id": 157,
      "title": "Read N Characters Given Read4",
      "url": "https://leetcode.com/problems/read-n-characters-given-read4/description",
      "companyTags": [
        "Facebook"
      ],
      "difficulty": "Easy",
      "content": "\r\nThe API: int read4(char *buf) reads 4 characters at a time from a file.\r\n\r\n\r\n\r\nThe return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file.\r\n\r\n\r\n\r\nBy using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file.\r\n\r\n\r\n\r\nNote:\r\nThe read function will only be called once for each test case.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/166",
      "similarQuestions": [
        "ReadNCharactersGivenRead4II-Callmultipletimes"
      ],
      "topicTags": [
        "String"
      ],
      "Solution": "/* The read4 API is defined in the parent class Reader4.\n      int read4(char[] buf); */\n\npublic class Solution extends Reader4 {\n    /**\n     * @param buf Destination buffer\n     * @param n   Maximum number of characters to read\n     * @return    The number of characters read\n     */\n    public int read(char[] buf, int n) {\n        boolean eon = false;\n        int total = 0;\n        char[] temp = new char[4];\n        while(!eon && total < n) {\n            int count = read4(temp);\n            eon = count < 4;\n            count = Math.min(count, n - total);\n            for (int i = 0; i < count; i++)\n                buf[total++] = temp[i];\n        }\n        return total;\n    }\n}",
      "total_acs": 44514,
      "total_submitted": 152812
    },
    {
      "id": 158,
      "title": "Read N Characters Given Read4 II - Call multiple times",
      "url": "https://leetcode.com/problems/read-n-characters-given-read4-ii-call-multiple-times/description",
      "companyTags": [
        "Google",
        "Facebook",
        "Bloomberg"
      ],
      "difficulty": "Hard",
      "content": "\r\nThe API: int read4(char *buf) reads 4 characters at a time from a file.\r\n\r\n\r\n\r\nThe return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file.\r\n\r\n\r\n\r\nBy using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file.\r\n\r\n\r\n\r\nNote:\r\nThe read function may be called multiple times.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/167",
      "similarQuestions": [
        "ReadNCharactersGivenRead4"
      ],
      "topicTags": [
        "String"
      ],
      "Solution": "/* The read4 API is defined in the parent class Reader4.\n      int read4(char[] buf); */\n\npublic class Solution extends Reader4 {\n    private char[] chars = new char[4];\n    private int start = 0;\n    private int end = 0;\n    private boolean eof = false;\n    /**\n     * @param buf Destination buffer\n     * @param n   Maximum number of characters to read\n     * @return    The number of characters read\n     */\n    public int read(char[] buf, int n) {\n        if(n < 1) return 0;\n        int done = 0;\n        while(done < n){\n            if(start >= end){\n                if(eof){\n                    break;\n                }\n                \n                start = 0;\n                end = read4(chars);\n                \n                if(end < 4){\n                    eof = true;\n                }\n            }else{\n                buf[done++] = chars[start++];\n            }\n        }\n        \n        return done;\n    }\n}",
      "total_acs": 37831,
      "total_submitted": 152790
    },
    {
      "id": 159,
      "title": "Longest Substring with At Most Two Distinct Characters",
      "url": "https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Hard",
      "content": "\r\nGiven a string, find the length of the longest substring T that contains at most 2 distinct characters.\r\n\r\n\r\n\r\nFor example,\r\n\r\nGiven s = “eceba”,\r\n\r\n\r\n\r\nT is \"ece\" which its length is 3.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/168",
      "similarQuestions": [
        "LongestSubstringWithoutRepeatingCharacters",
        "SlidingWindowMaximum",
        "LongestSubstringwithAtMostKDistinctCharacters"
      ],
      "topicTags": [
        "HashTable",
        "TwoPointers",
        "String"
      ],
      "Solution": "class Solution {\n    public int lengthOfLongestSubstringTwoDistinct(final String s) {\n        int[] lastIndexes = new int[128];\n        lastIndexes[0] = -1;\n        int maxLength = 0;\n        char first = 0;\n        char second = 0;\n        int lastIndex = -1;\n        final char[] word = s.toCharArray();\n        int length = 0;\n        for(int i = 0; i<word.length; i++) {\n            char c = word[i];\n            if(c != first) {\n                if(c != second) {\n                    lastIndex = lastIndexes[second];\n                    maxLength = Math.max(maxLength, length);\n                    length = i-lastIndex-1;\n                }\n                second = first;\n                first = c;\n            }\n            length++;\n            lastIndexes[c] = i;\n        }\n        return Math.max(maxLength, length);\n    }\n}",
      "total_acs": 34972,
      "total_submitted": 82158
    },
    {
      "id": 160,
      "title": "Intersection of Two Linked Lists",
      "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/description",
      "companyTags": [
        "Microsoft",
        "Amazon",
        "Bloomberg",
        "Airbnb"
      ],
      "difficulty": "Easy",
      "content": "Write a program to find the node at which the intersection of two singly linked lists begins.\r\n\r\nFor example, the following two linked lists: \r\n\r\nA:          a1 → a2\r\n                   ↘\r\n                     c1 → c2 → c3\r\n                   ↗            \r\nB:     b1 → b2 → b3\r\n\r\nbegin to intersect at node c1.\r\n\r\nNotes:\r\n\r\nIf the two linked lists have no intersection at all, return null.\r\nThe linked lists must retain their original structure after the function returns. \r\nYou may assume there are no cycles anywhere in the entire linked structure.\r\nYour code should preferably run in O(n) time and use only O(1) memory.\r\n\r\n\r\n\r\nCredits:Special thanks to @stellari for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/164",
      "similarQuestions": [
        "MinimumIndexSumofTwoLists"
      ],
      "topicTags": [
        "LinkedList"
      ],
      "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    \n    public ListNode getIntersectionNode(ListNode ha, ListNode hb) {\n        if (ha==null || hb==null) return null;\n        if (ha == hb) return ha;\n\n        int stepA = 0;\n        ListNode ta = ha;\n        while (ta.next != null) {\n            ta = ta.next;\n            stepA++;\n        }\n\n        int stepB = 0;\n        ListNode tb = hb;\n        while (tb.next != null) {\n            tb = tb.next;\n            stepB++;\n        }\n\n        if (ta != tb) return null;\n\n        ta = ha; tb = hb;\n        if (stepA > stepB) while (stepA > stepB) {\n            ta = ta.next;\n            --stepA;\n        } else if (stepA < stepB) while (stepA < stepB) {\n            tb = tb.next;\n            --stepB;\n        }\n\n        while (ta != tb) {\n            ta = ta.next;\n            tb = tb.next;\n        }\n        return ta;\n    }\n}",
      "total_acs": 173665,
      "total_submitted": 562457
    },
    {
      "id": 161,
      "title": "One Edit Distance",
      "url": "https://leetcode.com/problems/one-edit-distance/description",
      "companyTags": [
        "Facebook",
        "Uber",
        "Twitter",
        "Snapchat"
      ],
      "difficulty": "Medium",
      "content": "Given two strings S and T, determine if they are both one edit distance apart.",
      "discussUrl": "https://discuss.leetcode.com/category/169",
      "similarQuestions": [
        "EditDistance"
      ],
      "topicTags": [
        "String"
      ],
      "Solution": "class Solution {\n    public boolean isOneEditDistance(String s, String t) {\n        if(s.length() > t.length()) return isOneEditDistance(t, s);\n        int m = s.length(), n = t.length();\n        if(n - m > 1) return false;\n        for(int i = 0; i < m; i++) {\n            if(s.charAt(i) != t.charAt(i)) return s.substring(i + 1).equals(t.substring(i + 1)) || s.substring(i).equals(t.substring(i + 1));\n        }\n        return n > m;\n    }\n}",
      "total_acs": 46767,
      "total_submitted": 147452
    },
    {
      "id": 162,
      "title": "Find Peak Element",
      "url": "https://leetcode.com/problems/find-peak-element/description",
      "companyTags": [
        "Google",
        "Microsoft"
      ],
      "difficulty": "Medium",
      "content": "A peak element is an element that is greater than its neighbors.\r\n\r\nGiven an input array where num[i] ≠ num[i+1], find a peak element and return its index.\r\n\r\nThe array may contain multiple peaks, in that case return the index to any one of the peaks is fine.\r\n\r\nYou may imagine that num[-1] = num[n] = -∞.\r\n\r\nFor example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.\r\n\r\nclick to show spoilers.\r\n\r\nNote:\r\nYour solution should be in logarithmic complexity.\r\n\r\n\r\nCredits:Special thanks to @ts for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/170",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Array",
        "BinarySearch"
      ],
      "Solution": "class Solution {\n    public int findPeakElement(int[] nums) {\n        \n        for(int i = 0; i < nums.length; i++) {\n            if((i == 0 || nums[i] > nums[i - 1]) && (i == nums.length - 1 || nums[i] > nums[i + 1])) return i;\n        }\n        return 0;\n    }\n}",
      "total_acs": 141653,
      "total_submitted": 366911
    },
    {
      "id": 163,
      "title": "Missing Ranges",
      "url": "https://leetcode.com/problems/missing-ranges/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven a sorted integer array where the range of elements are in the inclusive range [lower, upper], return its missing ranges.\r\n\r\n\r\nFor example, given [0, 1, 3, 50, 75], lower = 0 and upper = 99, return [\"2\", \"4->49\", \"51->74\", \"76->99\"].\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/171",
      "similarQuestions": [
        "SummaryRanges"
      ],
      "topicTags": [
        "Array"
      ],
      "Solution": "class Solution {\n    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\n        List<String> result = new ArrayList<>();\n        if(nums.length == 0) {\n            result.add(lower == upper ? String.valueOf(lower) : lower + \"->\" + upper);\n            return result;\n        }\n        int start = 0;\n        int end = 0;\n        for(int i = 0; i < nums.length; i++) {\n            if(i == 0) {\n                if(nums[i] != lower) {\n                    end = nums[i] - 1;\n                    result.add(lower == end ? String.valueOf(lower) : lower + \"->\" + end);\n                }\n            } else {\n                if(nums[i] != nums[i - 1] && nums[i] != nums[i - 1] + 1) {\n                    end = nums[i] - 1;\n                    result.add(start == end ? String.valueOf(start) : start + \"->\" + end);\n                }\n            }\n            start = nums[i] + 1;\n        }\n        if(nums[nums.length - 1] != upper) {\n            result.add(start == upper ? String.valueOf(start) : start + \"->\" + upper);\n        }\n        return result;\n    }\n}",
      "total_acs": 36155,
      "total_submitted": 154476
    },
    {
      "id": 164,
      "title": "Maximum Gap",
      "url": "https://leetcode.com/problems/maximum-gap/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Hard",
      "content": "Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\r\n\r\nTry to solve it in linear time/space.\r\n\r\nReturn 0 if the array contains less than 2 elements.\r\n\r\nYou may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.\r\n\r\nCredits:Special thanks to @porker2008 for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/172",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Sort"
      ],
      "Solution": "class Solution {\n    public int maximumGap(int[] nums) {\n        if(nums == null || nums.length < 2) return 0;\n        \n        int max = nums[0], min = nums[0];\n        for(int n : nums){\n            max = Math.max(max, n);\n            min = Math.min(min, n);\n        }\n        \n        int gap = (max - min) / (nums.length-1);\n        if(gap == 0) gap ++;\n        int len = (max - min) / gap + 1;\n        int[] maxBucket = new int[len];\n        int[] minBucket = new int[len];\n        \n        for(int n : nums){\n            int i = (n - min) / gap;\n            if(n > maxBucket[i]) maxBucket[i] = n;\n            if(minBucket[i] == 0 || n < minBucket[i]) minBucket[i] = n;\n        }\n        \n        int res = 0;\n        for(int i = 0; i < len; i ++){\n            if(res < minBucket[i] - min) res = minBucket[i] - min;\n            if(maxBucket[i] != 0) min = maxBucket[i];\n        }\n        return res;\n    }\n}",
      "total_acs": 53918,
      "total_submitted": 180002
    },
    {
      "id": 165,
      "title": "Compare Version Numbers",
      "url": "https://leetcode.com/problems/compare-version-numbers/description",
      "companyTags": [
        "Microsoft",
        "Apple"
      ],
      "difficulty": "Medium",
      "content": "Compare two version numbers version1 and version2.\r\nIf version1 > version2 return 1, if version1 < version2 return -1, otherwise return 0.\r\n\r\nYou may assume that the version strings are non-empty and contain only digits and the . character.\r\nThe . character does not represent a decimal point and is used to separate number sequences.\r\nFor instance, 2.5 is not \"two and a half\" or \"half way to version three\", it is the fifth second-level revision of the second first-level revision.\r\n\r\nHere is an example of version numbers ordering:\r\n0.1 < 1.1 < 1.2 < 13.37\r\n\r\nCredits:Special thanks to @ts for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/173",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "String"
      ],
      "Solution": "class Solution {\n    public int compareVersion(String version1, String version2) {\n        int i = 0, j = 0;\n        while(i < version1.length() && j < version2.length()) {\n            int v1 = 0, v2 = 0;\n            while(i < version1.length() && version1.charAt(i) != '.') v1 = 10*v1+ version1.charAt(i++) - '0';\n            while(j < version2.length() && version2.charAt(j) != '.') v2 = 10*v2+ version2.charAt(j++) - '0';\n            if(v1 < v2) return -1;\n            else if(v1 > v2) return 1;\n            else {\n                ++i;\n                ++j;\n            }\n        }\n        while(i < version1.length()) {\n            if(version1.charAt(i) == '0' || version1.charAt(i) == '.') ++i;\n            else return 1;\n        }\n        while(j < version2.length()) {\n            if(version2.charAt(j) == '0' || version2.charAt(j) == '.') ++j;\n            else return -1;\n        }\n        return 0;\n    }\n}",
      "total_acs": 95993,
      "total_submitted": 464628
    },
    {
      "id": 166,
      "title": "Fraction to Recurring Decimal",
      "url": "https://leetcode.com/problems/fraction-to-recurring-decimal/description",
      "companyTags": [
        "Google",
        "IXL"
      ],
      "difficulty": "Medium",
      "content": "Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.\r\n\r\nIf the fractional part is repeating, enclose the repeating part in parentheses.\r\n\r\nFor example,\r\n\r\nGiven numerator = 1, denominator = 2, return \"0.5\".\r\nGiven numerator = 2, denominator = 1, return \"2\".\r\nGiven numerator = 2, denominator = 3, return \"0.(6)\".\r\n\r\n\r\n\r\nCredits:Special thanks to @Shangrila for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/174",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "HashTable",
        "Math"
      ],
      "Solution": "class Solution {\n    public String fractionToDecimal(int numerator, int denominator) {\n        if(denominator == 0) return \"\";\n        if(numerator == 0) return \"0\";\n        boolean neg = numerator < 0 ^ denominator < 0;\n        long num = Math.abs((long)numerator);\n        long den = Math.abs((long)denominator);\n        Map<Integer, Integer> map = new HashMap<>();\n        String firstPart = (neg ? \"-\" : \"\") + num / den;\n        if(num % den == 0) return firstPart;\n        StringBuilder sb = new StringBuilder();\n        long resi = num % den;\n        int count = 0;\n        while(resi != 0) {\n            if(map.containsKey((int)resi)){\n                sb.insert(map.get((int)resi).intValue(), '(');\n                sb.append(')');\n                break;\n            }\n            map.put((int)resi, count++);\n            resi *= 10;\n            sb.append(resi / den);\n            resi %= den;\n        }\n        return firstPart + \".\" + sb.toString();\n    }\n}",
      "total_acs": 61153,
      "total_submitted": 340001
    },
    {
      "id": 167,
      "title": "Two Sum II - Input array is sorted",
      "url": "https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description",
      "companyTags": [
        "Amazon"
      ],
      "difficulty": "Easy",
      "content": "Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.\r\n\r\nThe function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.\r\n\r\nYou may assume that each input would have exactly one solution and you may not use the same element twice.\r\n\r\n\r\nInput: numbers={2, 7, 11, 15}, target=9\r\nOutput: index1=1, index2=2\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/175",
      "similarQuestions": [
        "TwoSum",
        "TwoSumIV-InputisaBST"
      ],
      "topicTags": [
        "Array",
        "TwoPointers",
        "BinarySearch"
      ],
      "Solution": "class Solution {\n    public int[] twoSum(int[] numbers, int target) {\n        int left=0,right=numbers.length-1;\n        while(left<right){\n            int comp = numbers[left]+numbers[right];\n            if(comp==target){\n                return new int[]{left+1,right+1};\n            }else if(comp>target){\n                right--;\n            }else{\n                left++;\n            }\n        }\n        return null;\n    }\n}",
      "total_acs": 122738,
      "total_submitted": 259777
    },
    {
      "id": 168,
      "title": "Excel Sheet Column Title",
      "url": "https://leetcode.com/problems/excel-sheet-column-title/description",
      "companyTags": [
        "Facebook",
        "Microsoft",
        "Zenefits"
      ],
      "difficulty": "Easy",
      "content": "Given a positive integer, return its corresponding column title as appear in an Excel sheet.\r\n\r\nFor example:\r\n\r\n    1 -> A\r\n    2 -> B\r\n    3 -> C\r\n    ...\r\n    26 -> Z\r\n    27 -> AA\r\n    28 -> AB \r\n\r\nCredits:Special thanks to @ifanchu for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/176",
      "similarQuestions": [
        "ExcelSheetColumnNumber"
      ],
      "topicTags": [
        "Math"
      ],
      "Solution": "class Solution {\n    public String convertToTitle(int n) {\n        StringBuilder builder = new StringBuilder();\n        \n        while(n>0) {\n            n--;\n            builder.append((char)('A' + (n%26)));\n            n /= 26;\n        }\n        \n        return builder.reverse().toString();\n    }\n}",
      "total_acs": 128012,
      "total_submitted": 472778
    },
    {
      "id": 169,
      "title": "Majority Element",
      "url": "https://leetcode.com/problems/majority-element/description",
      "companyTags": [
        "Zenefits",
        "Adobe"
      ],
      "difficulty": "Easy",
      "content": "Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.\r\n\r\nYou may assume that the array is non-empty and the majority element always exist in the array.\r\n\r\nCredits:Special thanks to @ts for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/177",
      "similarQuestions": [
        "MajorityElementII"
      ],
      "topicTags": [
        "Array",
        "DivideandConquer",
        "BitManipulation"
      ],
      "Solution": "class Solution {\n    public int majorityElement(int[] nums) {\n        Arrays.sort(nums);\n        return nums[nums.length/2];\n    }\n}",
      "total_acs": 242997,
      "total_submitted": 509359
    },
    {
      "id": 170,
      "title": "Two Sum III - Data structure design",
      "url": "https://leetcode.com/problems/two-sum-iii-data-structure-design/description",
      "companyTags": [
        "LinkedIn"
      ],
      "difficulty": "Easy",
      "content": "Design and implement a TwoSum class. It should support the following operations: add and find.\r\n\r\n\r\nadd - Add the number to an internal data structure.\r\nfind - Find if there exists any pair of numbers which sum is equal to the value.\r\n\r\n\r\n\r\nFor example,\r\n\r\nadd(1); add(3); add(5);\r\nfind(4) -> true\r\nfind(7) -> false\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/178",
      "similarQuestions": [
        "TwoSum",
        "UniqueWordAbbreviation",
        "TwoSumIV-InputisaBST"
      ],
      "topicTags": [
        "HashTable",
        "Design"
      ],
      "Solution": "class TwoSum {\n    int minVal = Integer.MAX_VALUE;\n    int maxVal = Integer.MIN_VALUE;\n    Map<Integer, Integer> map = new LinkedHashMap<>();\n    \n    /** Add the number to an internal data structure.. */\n    public void add(int number) {\n        minVal = Math.min(minVal, number);\n        maxVal = Math.max(maxVal, number);\n        map.put(number, map.getOrDefault(number, 0) + 1);\n    }\n    \n    /** Find if there exists any pair of numbers which sum is equal to the value. */\n    public boolean find(int val) {\n        if (val < 2 * minVal || val > 2 * maxVal) { return false; }\n        for (int a : map.keySet()) {\n            int b = val - a;\n            if ((a == b && map.get(a) > 1) || (a != b && map.containsKey(b))) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\n/**\n * Your TwoSum object will be instantiated and called as such:\n * TwoSum obj = new TwoSum();\n * obj.add(number);\n * boolean param_2 = obj.find(value);\n */",
      "total_acs": 35078,
      "total_submitted": 134475
    },
    {
      "id": 171,
      "title": "Excel Sheet Column Number",
      "url": "https://leetcode.com/problems/excel-sheet-column-number/description",
      "companyTags": [
        "Microsoft",
        "Uber"
      ],
      "difficulty": "Easy",
      "content": "Related to question Excel Sheet Column Title\r\nGiven a column title as appear in an Excel sheet, return its corresponding column number.\r\n\r\nFor example:\r\n    A -> 1\r\n    B -> 2\r\n    C -> 3\r\n    ...\r\n    Z -> 26\r\n    AA -> 27\r\n    AB -> 28 \r\n\r\nCredits:Special thanks to @ts for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/179",
      "similarQuestions": [
        "ExcelSheetColumnTitle"
      ],
      "topicTags": [
        "Math"
      ],
      "Solution": "class Solution {\n    public int titleToNumber(String s) {\n        if(s == null || s.isEmpty()) return 0;\n\n        int result = 0;\n        char[] letters = s.toCharArray();\n        int exp = 0;\n        for(int i = letters.length-1; i >= 0; i--) {\n            char letter = letters[i];\n            int digit = letter - 'A' + 1;\n            int value = (int) (digit * Math.pow(26, exp));\n            result += value;\n            exp++;\n        }\n        return result;\n    }\n}",
      "total_acs": 157598,
      "total_submitted": 326928
    },
    {
      "id": 172,
      "title": "Factorial Trailing Zeroes",
      "url": "https://leetcode.com/problems/factorial-trailing-zeroes/description",
      "companyTags": [
        "Bloomberg"
      ],
      "difficulty": "Easy",
      "content": "Given an integer n, return the number of trailing zeroes in n!.\r\n\r\nNote: Your solution should be in logarithmic time complexity.\r\n\r\nCredits:Special thanks to @ts for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/180",
      "similarQuestions": [
        "NumberofDigitOne"
      ],
      "topicTags": [
        "Math"
      ],
      "Solution": "class Solution {\n    public int trailingZeroes(int n) {\n        return n==0?0:(n/5)+trailingZeroes(n/5);\n    }\n}",
      "total_acs": 110420,
      "total_submitted": 300254
    },
    {
      "id": 173,
      "title": "Binary Search Tree Iterator",
      "url": "https://leetcode.com/problems/binary-search-tree-iterator/description",
      "companyTags": [
        "Google",
        "Facebook",
        "Microsoft",
        "LinkedIn"
      ],
      "difficulty": "Medium",
      "content": "Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.\r\n\r\nCalling next() will return the next smallest number in the BST.\r\n\r\nNote: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree. \r\n\r\nCredits:Special thanks to @ts for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/181",
      "similarQuestions": [
        "BinaryTreeInorderTraversal",
        "Flatten2DVector",
        "ZigzagIterator",
        "PeekingIterator",
        "InorderSuccessorinBST"
      ],
      "topicTags": [
        "Stack",
        "Tree",
        "Design"
      ],
      "Solution": "/**\n * Definition for binary tree\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n\npublic class BSTIterator {\n    private TreeNode prev;\n    private TreeNode head;\n    \n    public BSTIterator(TreeNode root) {\n        inorder(root);        \n    }\n    \n    private void inorder(TreeNode t){\n        if(t == null)\n            return;\n        inorder(t.left);\n        if(prev == null)\n            head = t;\n        else\n            prev.right = t;\n        prev = t;\n        inorder(t.right);\n    }\n\n    /** @return whether we have a next smallest number */\n    public boolean hasNext() {\n        return head != null;\n    }\n\n    /** @return the next smallest number */\n    public int next() {\n        int val = head.val;\n        head = head.right;\n        return val;\n    }\n}\n\n/**\n * Your BSTIterator will be called like this:\n * BSTIterator i = new BSTIterator(root);\n * while (i.hasNext()) v[f()] = i.next();\n */",
      "total_acs": 119793,
      "total_submitted": 277679
    },
    {
      "id": 174,
      "title": "Dungeon Game",
      "url": "https://leetcode.com/problems/dungeon-game/description",
      "companyTags": [
        "Microsoft"
      ],
      "difficulty": "Hard",
      "content": "\r\ntable.dungeon, .dungeon th, .dungeon td {\r\n  border:3px solid black;\r\n}\r\n\r\n .dungeon th, .dungeon td {\r\n    text-align: center;\r\n    height: 70px;\r\n    width: 70px;\r\n}\r\n\r\n\r\nThe demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess. \r\nThe knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately. \r\nSome of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; \r\nother rooms are either empty (0's) or contain magic orbs that increase the knight's health (positive integers).\r\nIn order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step. \r\n\r\n\r\nWrite a function to determine the knight's minimum initial health so that he is able to rescue the princess.\r\nFor example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-> RIGHT -> DOWN -> DOWN.\r\n\r\n\r\n \r\n-2 (K) \r\n-3 \r\n3 \r\n \r\n \r\n-5 \r\n-10 \r\n1 \r\n \r\n \r\n10 \r\n30 \r\n-5 (P) \r\n \r\n\r\n\r\n\r\n\r\nNotes:\r\n\r\nThe knight's health has no upper bound.\r\nAny room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.  \r\n\r\n\r\n\r\nCredits:Special thanks to @stellari for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/182",
      "similarQuestions": [
        "UniquePaths",
        "MinimumPathSum",
        "CherryPickup"
      ],
      "topicTags": [
        "BinarySearch",
        "DynamicProgramming"
      ],
      "Solution": "class Solution {\n    public int calculateMinimumHP(int[][] dungeon) {\n        if (dungeon == null || dungeon.length == 0 || dungeon[0].length == 0) {\n            return -1;\n        }\n        int height = dungeon.length;\n        int width = dungeon[0].length;\n        int[][] dp = new int[height][width];\n        dp[height - 1][width - 1] = 1 - dungeon[height - 1][width - 1] < 1 ? 1 : 1 - dungeon[height - 1][width - 1];\n        for (int i = width - 2; i >= 0; i --) {\n            dp[height - 1][i] = dp[height - 1][i + 1] - dungeon[height - 1][i] < 1 ? 1 : dp[height - 1][i + 1] - dungeon[height - 1][i];\n        }\n        for (int i = height - 2; i >= 0; i --) {\n            dp[i][width - 1] = dp[i + 1][width - 1] - dungeon[i][width - 1] < 1 ? 1 : dp[i + 1][width - 1] - dungeon[i][width - 1];\n        }\n        return dfs(dungeon, 0, 0, dp);\n    }\n    \n    private int dfs(int[][] dungeon, int i, int j, int[][] dp) {\n        if (dp[i][j] != 0) {\n            return dp[i][j];\n        }\n        int down = dfs(dungeon, i + 1, j, dp);\n        int right = dfs(dungeon, i, j + 1, dp);\n        dp[i][j] = Math.min(down, right) - dungeon[i][j];\n        if (dp[i][j] < 1) {\n            dp[i][j] = 1;\n        }\n        return dp[i][j];\n    }\n}",
      "total_acs": 46987,
      "total_submitted": 195198
    },
    {
      "id": 175,
      "title": "Combine Two Tables",
      "url": "https://leetcode.com/problems/combine-two-tables/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Easy",
      "content": "\r\nTable: Person\r\n\r\n\r\n+-------------+---------+\r\n| Column Name | Type    |\r\n+-------------+---------+\r\n| PersonId    | int     |\r\n| FirstName   | varchar |\r\n| LastName    | varchar |\r\n+-------------+---------+\r\nPersonId is the primary key column for this table.\r\n\r\n\r\n\r\nTable: Address\r\n\r\n+-------------+---------+\r\n| Column Name | Type    |\r\n+-------------+---------+\r\n| AddressId   | int     |\r\n| PersonId    | int     |\r\n| City        | varchar |\r\n| State       | varchar |\r\n+-------------+---------+\r\nAddressId is the primary key column for this table.\r\n\r\n\r\n\r\n\r\nWrite a SQL query for a report that provides the following information for \r\neach person in the Person table, regardless if there is an address for each \r\nof those people:\r\n\r\n\r\n\r\nFirstName, LastName, City, State\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/183",
      "similarQuestions": [
        "EmployeeBonus"
      ],
      "topicTags": [
        ""
      ],
      "Solution": null,
      "total_acs": 78157,
      "total_submitted": 189166
    },
    {
      "id": 176,
      "title": "Second Highest Salary",
      "url": "https://leetcode.com/problems/second-highest-salary/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Easy",
      "content": "\r\nWrite a SQL query to get the second highest salary from the Employee table.\r\n\r\n\r\n\r\n+----+--------+\r\n| Id | Salary |\r\n+----+--------+\r\n| 1  | 100    |\r\n| 2  | 200    |\r\n| 3  | 300    |\r\n+----+--------+\r\n\r\n\r\nFor example, given the above Employee table, the query should return 200 as the second highest salary. If there is no second highest salary, then the query should return null.\r\n\r\n\r\n+---------------------+\r\n| SecondHighestSalary |\r\n+---------------------+\r\n| 200                 |\r\n+---------------------+\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/184",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        ""
      ],
      "Solution": null,
      "total_acs": 62135,
      "total_submitted": 277750
    },
    {
      "id": 177,
      "title": "Nth Highest Salary",
      "url": "https://leetcode.com/problems/nth-highest-salary/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "\r\nWrite a SQL query to get the nth highest salary from the Employee table.\r\n\r\n\r\n\r\n+----+--------+\r\n| Id | Salary |\r\n+----+--------+\r\n| 1  | 100    |\r\n| 2  | 200    |\r\n| 3  | 300    |\r\n+----+--------+\r\n\r\n\r\nFor example, given the above Employee table, the nth highest salary where n = 2 is 200. If there is no nth highest salary, then the query should return null.\r\n\r\n\r\n+------------------------+\r\n| getNthHighestSalary(2) |\r\n+------------------------+\r\n| 200                    |\r\n+------------------------+\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/185",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        ""
      ],
      "Solution": null,
      "total_acs": 31376,
      "total_submitted": 156619
    },
    {
      "id": 178,
      "title": "Rank Scores",
      "url": "https://leetcode.com/problems/rank-scores/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "\r\nWrite a SQL query to rank scores. If there is a tie between two scores, both should have the same ranking. Note that after a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no \"holes\" between ranks.\r\n\r\n\r\n\r\n+----+-------+\r\n| Id | Score |\r\n+----+-------+\r\n| 1  | 3.50  |\r\n| 2  | 3.65  |\r\n| 3  | 4.00  |\r\n| 4  | 3.85  |\r\n| 5  | 4.00  |\r\n| 6  | 3.65  |\r\n+----+-------+\r\n\r\n\r\nFor example, given the above Scores table, your query should generate the following report (order by highest score):\r\n\r\n\r\n+-------+------+\r\n| Score | Rank |\r\n+-------+------+\r\n| 4.00  | 1    |\r\n| 4.00  | 1    |\r\n| 3.85  | 2    |\r\n| 3.65  | 3    |\r\n| 3.65  | 3    |\r\n| 3.50  | 4    |\r\n+-------+------+\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/186",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        ""
      ],
      "Solution": null,
      "total_acs": 31849,
      "total_submitted": 111434
    },
    {
      "id": 179,
      "title": "Largest Number",
      "url": "https://leetcode.com/problems/largest-number/description",
      "companyTags": [
        "WorksApplications"
      ],
      "difficulty": "Medium",
      "content": "Given a list of non negative integers, arrange them such that they form the largest number.\r\n\r\nFor example, given [3, 30, 34, 5, 9], the largest formed number is 9534330.\r\n\r\nNote: The result may be very large, so you need to return a string instead of an integer.\r\n\r\nCredits:Special thanks to @ts for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/187",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Sort"
      ],
      "Solution": "class Solution {\n    public String largestNumber(int[] nums) {\n        int n = nums.length;\n        String[] strs = new String[n];\n        for (int i = 0; i < n; i++) {\n            strs[i] = nums[i] + \"\";\n        }\n        Arrays.sort(strs, new Comparator<String>(){\n            @Override\n            public int compare(String s1, String s2) {\n                int i = 0, j = 0;\n                for (; i < s1.length() && j < s2.length(); i++, j++) {\n                    if (s1.charAt(i) != s2.charAt(j)) {\n                        return s2.charAt(j) - s1.charAt(i);\n                    }\n                }\n                if (i == s1.length() && j == s2.length()) {\n                    return 0;\n                }\n                return compareStr(s1 + s2, s2 + s1, Math.min(s1.length(), s2.length()));\n            }\n            \n            public int compareStr(String s1, String s2, int start) {\n                for (int i = start; i < s1.length(); i++) {\n                    if (s1.charAt(i) != s2.charAt(i)) {\n                        return s2.charAt(i) - s1.charAt(i);\n                    }\n                }\n                return 0;\n            }\n        });\n        StringBuilder res = new StringBuilder();\n        for (String str : strs) {\n            if (str.equals(\"0\") && res.length() == 0) {\n                continue;\n            }\n            res.append(str);\n        }\n        if (res.length() == 0) {\n            res.append(0);\n        }\n        return res.toString();\n    }\n}",
      "total_acs": 88565,
      "total_submitted": 380472
    },
    {
      "id": 180,
      "title": "Consecutive Numbers",
      "url": "https://leetcode.com/problems/consecutive-numbers/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "\r\nWrite a SQL query to find all numbers that appear at least three times consecutively.\r\n\r\n\r\n+----+-----+\r\n| Id | Num |\r\n+----+-----+\r\n| 1  |  1  |\r\n| 2  |  1  |\r\n| 3  |  1  |\r\n| 4  |  2  |\r\n| 5  |  1  |\r\n| 6  |  2  |\r\n| 7  |  2  |\r\n+----+-----+\r\n\r\n\r\nFor example, given the above Logs table, 1 is the only number that appears consecutively for at least three times.\r\n\r\n\r\n+-----------------+\r\n| ConsecutiveNums |\r\n+-----------------+\r\n| 1               |\r\n+-----------------+\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/188",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        ""
      ],
      "Solution": null,
      "total_acs": 27138,
      "total_submitted": 101651
    },
    {
      "id": 181,
      "title": "Employees Earning More Than Their Managers",
      "url": "https://leetcode.com/problems/employees-earning-more-than-their-managers/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Easy",
      "content": "\r\nThe Employee table holds all employees including their managers. Every employee has an Id, and there is also a column for the manager Id.\r\n\r\n\r\n+----+-------+--------+-----------+\r\n| Id | Name  | Salary | ManagerId |\r\n+----+-------+--------+-----------+\r\n| 1  | Joe   | 70000  | 3         |\r\n| 2  | Henry | 80000  | 4         |\r\n| 3  | Sam   | 60000  | NULL      |\r\n| 4  | Max   | 90000  | NULL      |\r\n+----+-------+--------+-----------+\r\n\r\n\r\nGiven the Employee table, write a SQL query that finds out employees who earn more than their managers. For the above table, Joe is the only employee who earns more than his manager.\r\n\r\n\r\n+----------+\r\n| Employee |\r\n+----------+\r\n| Joe      |\r\n+----------+\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/189",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        ""
      ],
      "Solution": null,
      "total_acs": 55071,
      "total_submitted": 145397
    },
    {
      "id": 182,
      "title": "Duplicate Emails",
      "url": "https://leetcode.com/problems/duplicate-emails/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Easy",
      "content": "\r\nWrite a SQL query to find all duplicate emails in a table named Person.\r\n\r\n\r\n+----+---------+\r\n| Id | Email   |\r\n+----+---------+\r\n| 1  | a@b.com |\r\n| 2  | c@d.com |\r\n| 3  | a@b.com |\r\n+----+---------+\r\n\r\n\r\nFor example, your query should return the following for the above table:\r\n\r\n+---------+\r\n| Email   |\r\n+---------+\r\n| a@b.com |\r\n+---------+\r\n\r\n\r\nNote: All emails are in lowercase.",
      "discussUrl": "https://discuss.leetcode.com/category/190",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        ""
      ],
      "Solution": null,
      "total_acs": 58594,
      "total_submitted": 132907
    },
    {
      "id": 183,
      "title": "Customers Who Never Order",
      "url": "https://leetcode.com/problems/customers-who-never-order/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Easy",
      "content": "\r\nSuppose that a website contains two tables, the Customers table and the Orders table. Write a SQL query to find all customers who never order anything.\r\n\r\n\r\nTable: Customers.\r\n\r\n+----+-------+\r\n| Id | Name  |\r\n+----+-------+\r\n| 1  | Joe   |\r\n| 2  | Henry |\r\n| 3  | Sam   |\r\n| 4  | Max   |\r\n+----+-------+\r\n\r\n\r\n\r\nTable: Orders.\r\n\r\n+----+------------+\r\n| Id | CustomerId |\r\n+----+------------+\r\n| 1  | 3          |\r\n| 2  | 1          |\r\n+----+------------+\r\n\r\n\r\nUsing the above tables as example, return the following:\r\n\r\n+-----------+\r\n| Customers |\r\n+-----------+\r\n| Henry     |\r\n| Max       |\r\n+-----------+\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/191",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        ""
      ],
      "Solution": null,
      "total_acs": 51698,
      "total_submitted": 144836
    },
    {
      "id": 184,
      "title": "Department Highest Salary",
      "url": "https://leetcode.com/problems/department-highest-salary/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "\r\nThe Employee table holds all employees. Every employee has an Id, a salary, and there is also a column for the department Id.\r\n\r\n\r\n+----+-------+--------+--------------+\r\n| Id | Name  | Salary | DepartmentId |\r\n+----+-------+--------+--------------+\r\n| 1  | Joe   | 70000  | 1            |\r\n| 2  | Henry | 80000  | 2            |\r\n| 3  | Sam   | 60000  | 2            |\r\n| 4  | Max   | 90000  | 1            |\r\n+----+-------+--------+--------------+\r\n\r\n\r\n\r\nThe Department table holds all departments of the company.\r\n\r\n+----+----------+\r\n| Id | Name     |\r\n+----+----------+\r\n| 1  | IT       |\r\n| 2  | Sales    |\r\n+----+----------+\r\n\r\n\r\nWrite a SQL query to find employees who have the highest salary in each of the departments. For the above tables, Max has the highest salary in the IT department and Henry has the highest salary in the Sales department.\r\n\r\n\r\n+------------+----------+--------+\r\n| Department | Employee | Salary |\r\n+------------+----------+--------+\r\n| IT         | Max      | 90000  |\r\n| Sales      | Henry    | 80000  |\r\n+------------+----------+--------+\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/192",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        ""
      ],
      "Solution": null,
      "total_acs": 31276,
      "total_submitted": 141439
    },
    {
      "id": 185,
      "title": "Department Top Three Salaries",
      "url": "https://leetcode.com/problems/department-top-three-salaries/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Hard",
      "content": "\r\nThe Employee table holds all employees. Every employee has an Id, and there is also a column for the department Id.\r\n\r\n\r\n+----+-------+--------+--------------+\r\n| Id | Name  | Salary | DepartmentId |\r\n+----+-------+--------+--------------+\r\n| 1  | Joe   | 70000  | 1            |\r\n| 2  | Henry | 80000  | 2            |\r\n| 3  | Sam   | 60000  | 2            |\r\n| 4  | Max   | 90000  | 1            |\r\n| 5  | Janet | 69000  | 1            |\r\n| 6  | Randy | 85000  | 1            |\r\n+----+-------+--------+--------------+\r\n\r\n\r\n\r\nThe Department table holds all departments of the company.\r\n\r\n+----+----------+\r\n| Id | Name     |\r\n+----+----------+\r\n| 1  | IT       |\r\n| 2  | Sales    |\r\n+----+----------+\r\n\r\n\r\nWrite a SQL query to find employees who earn the top three salaries in each of the department. For the above tables, your SQL query should return the following rows.\r\n\r\n\r\n+------------+----------+--------+\r\n| Department | Employee | Salary |\r\n+------------+----------+--------+\r\n| IT         | Max      | 90000  |\r\n| IT         | Randy    | 85000  |\r\n| IT         | Joe      | 70000  |\r\n| Sales      | Henry    | 80000  |\r\n| Sales      | Sam      | 60000  |\r\n+------------+----------+--------+\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/193",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        ""
      ],
      "Solution": null,
      "total_acs": 19888,
      "total_submitted": 104168
    },
    {
      "id": 186,
      "title": "Reverse Words in a String II",
      "url": "https://leetcode.com/problems/reverse-words-in-a-string-ii/description",
      "companyTags": [
        "Microsoft",
        "Amazon",
        "Uber"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven an input string, reverse the string word by word. A word is defined as a sequence of non-space characters.\r\n\r\n\r\n\r\nThe input string does not contain leading or trailing spaces and the words are always separated by a single space.\r\n\r\n\r\n\r\nFor example,\r\nGiven s = \"the sky is blue\",\r\nreturn \"blue is sky the\".\r\n\r\n\r\n\r\nCould you do it in-place without allocating extra space?\r\n\r\n\r\nRelated problem: Rotate Array\r\n\r\n\r\nUpdate (2017-10-16):\r\nWe have updated the function signature to accept a character array, so please reset to the default code definition by clicking on the reload button above the code editor. Also, Run Code is now available!\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/194",
      "similarQuestions": [
        "ReverseWordsinaString",
        "RotateArray"
      ],
      "topicTags": [
        "String"
      ],
      "Solution": "class Solution {\n    public void reverseWords(char[] str) {\n        reverse(str, 0, str.length-1);\n        int r = 0;\n        while(r < str.length){\n            int l = r;\n            while(r < str.length && str[r] != ' ')\n                r++;\n            reverse(str, l, r-1);\n            r++;\n        }\n    }\n    public void reverse(char[] s, int l, int r){\n        while(l < r){\n            char tmp = s[l];\n            s[l++] = s[r];\n            s[r--] = tmp;\n        }\n    }\n}",
      "total_acs": 37345,
      "total_submitted": 128327
    },
    {
      "id": 187,
      "title": "Repeated DNA Sequences",
      "url": "https://leetcode.com/problems/repeated-dna-sequences/description",
      "companyTags": [
        "LinkedIn"
      ],
      "difficulty": "Medium",
      "content": "\r\nAll DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: \"ACGAATTCCG\". When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.\r\n\r\nWrite a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.\r\n\r\n\r\nFor example,\r\n\r\nGiven s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\",\r\n\r\nReturn:\r\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/195",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "HashTable",
        "BitManipulation"
      ],
      "Solution": "class Solution{//11ms\n    public List<String> findRepeatedDnaSequences(String s){\n        List<String> res = new ArrayList<>();\n        if (s == null || s.length() < 10) {\n            return res;\n        }\n        //对字母进行编码\n        char[] map = new char[256];\n        map['A'] = 0;\n        map['C'] = 1;\n        map['G'] = 2;\n        map['T'] = 3;\n        int mask = 0xfffff;//20bit,10个字母，每个字母占2bit\n        int val = 0;\n        char[] schar = s.toCharArray();\n        for (int i = 0;i < 9 ;i ++ ) {//对前9位进行编码\n            val = (val << 2) | (map[schar[i]] & 3);\n        }\n        byte[] bytes = new byte[1 << 20];\n        for (int i = 9;i < schar.length ;i ++ ) {\n            val = ((val << 2) & mask) | ((map[schar[i]]) & 3);//编码\n            if (bytes[val] == 1) {\n                res.add(String.valueOf(schar,i - 9,10));\n            }\n            if (bytes[val] < 2) {\n                bytes[val] ++;\n            }\n        }\n        return res;\n    }\n}",
      "total_acs": 90267,
      "total_submitted": 275658
    },
    {
      "id": 188,
      "title": "Best Time to Buy and Sell Stock IV",
      "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Hard",
      "content": "Say you have an array for which the ith element is the price of a given stock on day i.\r\n\r\nDesign an algorithm to find the maximum profit. You may complete at most k transactions.\r\n\r\nNote:\r\nYou may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).\r\n\r\nCredits:Special thanks to @Freezen for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/196",
      "similarQuestions": [
        "BestTimetoBuyandSellStock",
        "BestTimetoBuyandSellStockII",
        "BestTimetoBuyandSellStockIII"
      ],
      "topicTags": [
        "DynamicProgramming"
      ],
      "Solution": "public class Solution {\n    public int maxProfit(int k, int[] prices) {\n        if(prices.length==0 || k<=0) return 0;\n        //测试序列里k给了10亿\n        int n = 0;\n        if(k>=prices.length/2) {//此时这个题目就变成了 best time to buy and sell stock II\n            int res = 0;\n            for(int i=1; i<prices.length; i++){\n                res += Math.max(0, prices[i]-prices[i-1]);\n            }\n            return res;\n        }else {\n            n = 2*k;\n            int[] s = new int[n];\n            for(int i=0; i<k; i++) s[2*i] = Integer.MIN_VALUE;\n            for(int i=0; i<prices.length; i++){\n                for(int j=n-1; j>0; j--){\n                    s[j] = Math.max(s[j], s[j-1]+(j%2==0?-1:1)*prices[i]);    \n                }\n                s[0] = Math.max(s[0], -prices[i]);\n            }\n            return s[n-1];\n        }\n    }\n}",
      "total_acs": 57907,
      "total_submitted": 233322
    },
    {
      "id": 189,
      "title": "Rotate Array",
      "url": "https://leetcode.com/problems/rotate-array/description",
      "companyTags": [
        "Microsoft",
        "Amazon",
        "Bloomberg"
      ],
      "difficulty": "Easy",
      "content": "Rotate an array of n elements to the right by k steps.\r\nFor example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4]. \r\n\r\nNote:\r\nTry to come up as many solutions as you can, there are at least 3 different ways to solve this problem.\r\n\r\n\r\n[show hint]\r\nHint:\r\nCould you do it in-place with O(1) extra space?\r\n\r\n\r\nRelated problem: Reverse Words in a String II\r\n\r\nCredits:Special thanks to @Freezen for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/197",
      "similarQuestions": [
        "RotateList",
        "ReverseWordsinaStringII"
      ],
      "topicTags": [
        "Array"
      ],
      "Solution": "public class Solution {\n    public void rotate(int[] nums, int k) {\n        for (int i=0, idx=0, cur=nums[0], distance=0, n=nums.length; i < n; i++) {\n            idx = (idx + k) % n;\n\n            int temp = cur;  //交换 cur 和 nums[idx]\n            cur = nums[idx];\n            nums[idx] = temp;\n\n            distance = (distance + k) % n;  //①\n            if (distance == 0) {\n                idx = (idx + 1) % n;\n                cur = nums[idx];\n            }\n        }\n    }\n}  \n",
      "total_acs": 165396,
      "total_submitted": 656651
    },
    {
      "id": 190,
      "title": "Reverse Bits",
      "url": "https://leetcode.com/problems/reverse-bits/description",
      "companyTags": [
        "Apple",
        "Airbnb"
      ],
      "difficulty": "Easy",
      "content": "Reverse bits of a given 32 bits unsigned integer.\r\n\r\nFor example, given input 43261596 (represented in binary as 00000010100101000001111010011100), return 964176192 (represented in binary as 00111001011110000010100101000000).\r\n\r\n\r\nFollow up:\r\nIf this function is called many times, how would you optimize it?\r\n\r\n\r\nRelated problem: Reverse Integer\r\n\r\nCredits:Special thanks to @ts for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/198",
      "similarQuestions": [
        "Numberof1Bits"
      ],
      "topicTags": [
        "BitManipulation"
      ],
      "Solution": "public class Solution {\n    // you need treat n as an unsigned value\n    public int reverseBits(int n) {\n        int ret = 0;\n        for(int i = 0;i<32;i++){\n            ret = (ret << 1) | (1 & n);\n            n = n >> 1; \n        }\n        return ret;\n    }\n}",
      "total_acs": 125656,
      "total_submitted": 426787
    },
    {
      "id": 191,
      "title": "Number of 1 Bits",
      "url": "https://leetcode.com/problems/number-of-1-bits/description",
      "companyTags": [
        "Microsoft",
        "Apple"
      ],
      "difficulty": "Easy",
      "content": "Write a function that takes an unsigned integer and returns the number of ’1' bits it has (also known as the Hamming weight).\r\n\r\nFor example, the 32-bit integer ’11' has binary representation 00000000000000000000000000001011, so the function should return 3.\r\n\r\nCredits:Special thanks to @ts for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/199",
      "similarQuestions": [
        "ReverseBits",
        "PowerofTwo",
        "CountingBits",
        "BinaryWatch",
        "HammingDistance",
        "BinaryNumberwithAlternatingBits",
        "PrimeNumberofSetBitsinBinaryRepresentation"
      ],
      "topicTags": [
        "BitManipulation"
      ],
      "Solution": "public class Solution {\n    // you need to treat n as an unsigned value\n    public int hammingWeight(int n) {\n        int res = 0;\n        while (n != 0) {\n            res += n & 1;\n            n = n >>> 1;\n        }\n        return res;\n    }\n}",
      "total_acs": 182375,
      "total_submitted": 453495
    },
    {
      "id": 192,
      "title": "Word Frequency",
      "url": "https://leetcode.com/problems/word-frequency/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "Write a bash script to calculate the frequency of each word in a text file words.txt.\r\n\r\nFor simplicity sake, you may assume:\r\n\r\nwords.txt contains only lowercase characters and space ' ' characters.\r\nEach word must consist of lowercase characters only.\r\nWords are separated by one or more whitespace characters.\r\n\r\n\r\n\r\nFor example, assume that words.txt has the following content:\r\nthe day is sunny the the\r\nthe sunny is is\r\n\r\n\r\nYour script should output the following, sorted by descending frequency:\r\n\r\nthe 4\r\nis 3\r\nsunny 2\r\nday 1\r\n\r\n\r\n\r\nNote:\r\nDon't worry about handling ties, it is guaranteed that each word's frequency count is unique.\r\n\r\n\r\n[show hint]\r\nHint:\r\nCould you write it in one-line using Unix pipes?\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/200",
      "similarQuestions": [
        "TopKFrequentElements"
      ],
      "topicTags": [
        ""
      ],
      "Solution": null,
      "total_acs": 10984,
      "total_submitted": 42345
    },
    {
      "id": 193,
      "title": "Valid Phone Numbers",
      "url": "https://leetcode.com/problems/valid-phone-numbers/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Easy",
      "content": "Given a text file file.txt that contains list of phone numbers (one per line), write a one liner bash script to print all valid phone numbers.\r\n\r\nYou may assume that a valid phone number must appear in one of the following two formats: (xxx) xxx-xxxx or xxx-xxx-xxxx. (x means a digit)\r\n\r\nYou may also assume each line in the text file must not contain leading or trailing white spaces.\r\n\r\nFor example, assume that file.txt has the following content:\r\n\r\n987-123-4567\r\n123 456 7890\r\n(123) 456-7890\r\n\r\n\r\nYour script should output the following valid phone numbers:\r\n\r\n987-123-4567\r\n(123) 456-7890\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/201",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        ""
      ],
      "Solution": null,
      "total_acs": 14256,
      "total_submitted": 57948
    },
    {
      "id": 194,
      "title": "Transpose File",
      "url": "https://leetcode.com/problems/transpose-file/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "Given a text file file.txt, transpose its content.\r\n\r\nYou may assume that each row has the same number of columns and each field is separated by the ' ' character.\r\n\r\n\r\nFor example, if file.txt has the following content:\r\n\r\nname age\r\nalice 21\r\nryan 30\r\n\r\n\r\n\r\n\r\nOutput the following:\r\n\r\nname alice ryan\r\nage 21 30\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/202",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        ""
      ],
      "Solution": null,
      "total_acs": 6298,
      "total_submitted": 29393
    },
    {
      "id": 195,
      "title": "Tenth Line",
      "url": "https://leetcode.com/problems/tenth-line/description",
      "companyTags": [
        "Adobe"
      ],
      "difficulty": "Easy",
      "content": "How would you print just the 10th line of a file?\r\n\r\nFor example, assume that file.txt has the following content:\r\n\r\nLine 1\r\nLine 2\r\nLine 3\r\nLine 4\r\nLine 5\r\nLine 6\r\nLine 7\r\nLine 8\r\nLine 9\r\nLine 10\r\n\r\n\r\nYour script should output the tenth line, which is:\r\n\r\nLine 10\r\n\r\n\r\n[show hint]\r\nHint:\r\n1. If the file contains less than 10 lines, what should you output?\r\n2. There's at least three different solutions. Try to explore all possibilities.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/203",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        ""
      ],
      "Solution": null,
      "total_acs": 24420,
      "total_submitted": 72833
    },
    {
      "id": 196,
      "title": "Delete Duplicate Emails",
      "url": "https://leetcode.com/problems/delete-duplicate-emails/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Easy",
      "content": "\r\nWrite a SQL query to delete all duplicate email entries in a table named Person, keeping only unique emails based on its smallest Id.\r\n\r\n\r\n+----+------------------+\r\n| Id | Email            |\r\n+----+------------------+\r\n| 1  | john@example.com |\r\n| 2  | bob@example.com  |\r\n| 3  | john@example.com |\r\n+----+------------------+\r\nId is the primary key column for this table.\r\n\r\n\r\nFor example, after running your query, the above Person table should have the following rows:\r\n\r\n+----+------------------+\r\n| Id | Email            |\r\n+----+------------------+\r\n| 1  | john@example.com |\r\n| 2  | bob@example.com  |\r\n+----+------------------+\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/204",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        ""
      ],
      "Solution": null,
      "total_acs": 38452,
      "total_submitted": 159781
    },
    {
      "id": 197,
      "title": "Rising Temperature",
      "url": "https://leetcode.com/problems/rising-temperature/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Easy",
      "content": "Given a Weather table, write a SQL query to find all dates' Ids with higher temperature compared to its previous (yesterday's) dates.\r\n\r\n\r\n+---------+------------+------------------+\r\n| Id(INT) | Date(DATE) | Temperature(INT) |\r\n+---------+------------+------------------+\r\n|       1 | 2015-01-01 |               10 |\r\n|       2 | 2015-01-02 |               25 |\r\n|       3 | 2015-01-03 |               20 |\r\n|       4 | 2015-01-04 |               30 |\r\n+---------+------------+------------------+\r\n\r\n\r\nFor example, return the following Ids for the above Weather table:\r\n\r\n+----+\r\n| Id |\r\n+----+\r\n|  2 |\r\n|  4 |\r\n+----+\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/205",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        ""
      ],
      "Solution": null,
      "total_acs": 42435,
      "total_submitted": 139094
    },
    {
      "id": 198,
      "title": "House Robber",
      "url": "https://leetcode.com/problems/house-robber/description",
      "companyTags": [
        "LinkedIn",
        "Airbnb"
      ],
      "difficulty": "Easy",
      "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\r\n\r\nGiven a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.\r\n\r\nCredits:Special thanks to @ifanchu for adding this problem and creating all test cases. Also thanks to @ts for adding additional test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/206",
      "similarQuestions": [
        "MaximumProductSubarray",
        "HouseRobberII",
        "PaintHouse",
        "PaintFence",
        "HouseRobberIII",
        "Non-negativeIntegerswithoutConsecutiveOnes",
        "CoinPath",
        "DeleteandEarn"
      ],
      "topicTags": [
        "DynamicProgramming"
      ],
      "Solution": "class Solution {\n    public int rob(int[] nums) {\n                if(nums.length == 0) return 0;\n\n                int[] dp = new int[nums.length + 1];\n        dp[1] = nums[0];\n\n        for(int i = 2; i <= nums.length; i++) {\n            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i - 1]);\n        }\n        \n        return dp[nums.length];\n    }\n}",
      "total_acs": 182064,
      "total_submitted": 457585
    },
    {
      "id": 199,
      "title": "Binary Tree Right Side View",
      "url": "https://leetcode.com/problems/binary-tree-right-side-view/description",
      "companyTags": [
        "Amazon"
      ],
      "difficulty": "Medium",
      "content": "Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.\r\n\r\n\r\nFor example:\r\nGiven the following binary tree,\r\n\r\n   1            <---\r\n /   \\\r\n2     3         <---\r\n \\     \\\r\n  5     4       <---\r\n\r\n\r\n\r\nYou should return [1, 3, 4].\r\n\r\n\r\nCredits:Special thanks to @amrsaqr for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/207",
      "similarQuestions": [
        "PopulatingNextRightPointersinEachNode",
        "BoundaryofBinaryTree"
      ],
      "topicTags": [
        "Tree",
        "Depth-firstSearch",
        "Breadth-firstSearch"
      ],
      "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n\n/*\n           1\n       2          3\n    4     5     6\n  7  8  9\n  \n  ans: 1, 3, 6, 9\n\nex:\n1) result.size == 0; root == 1; h == 0;\nh == 1;\nresult == {1};\n\n2) result.size == 1; root == 3; h == 1;\nh == 2;\nresult == {1, 3};\n\n3) r\n\n\n*/\n\n\nclass Solution {\n    public List<Integer> rightSideView(TreeNode root) {\n        if(root == null){\n            return new ArrayList<>();\n        }\n        List<Integer> result = new ArrayList<>();\n        dfs(result, root, 0);\n        return result;\n    }\n    \n    private void dfs(List<Integer> result, TreeNode root, int h){\n        //operation at node\n        h += 1;\n        if(h > result.size()){\n            result.add(root.val);\n        }\n        \n        //generate children\n        if(root.right != null){\n            dfs(result, root.right, h);\n        }\n        \n        if(root.left != null){\n            dfs(result, root.left, h);\n        }\n        \n        //leaving this node\n        h -= 1;       \n    }   \n}",
      "total_acs": 101440,
      "total_submitted": 240418
    },
    {
      "id": 200,
      "title": "Number of Islands",
      "url": "https://leetcode.com/problems/number-of-islands/description",
      "companyTags": [
        "Google",
        "Facebook",
        "Microsoft",
        "Amazon",
        "Zenefits"
      ],
      "difficulty": "Medium",
      "content": "Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\r\n\r\nExample 1:\r\n11110110101100000000\r\nAnswer: 1\r\nExample 2:\r\n11000110000010000011\r\nAnswer: 3\r\n\r\nCredits:Special thanks to @mithmatt for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/208",
      "similarQuestions": [
        "SurroundedRegions",
        "WallsandGates",
        "NumberofIslandsII",
        "NumberofConnectedComponentsinanUndirectedGraph",
        "NumberofDistinctIslands",
        "MaxAreaofIsland"
      ],
      "topicTags": [
        "Depth-firstSearch",
        "Breadth-firstSearch",
        "UnionFind"
      ],
      "Solution": "class Solution {\n    public int numIslands(char[][] grid) {\n        int count=0;\n        int width=grid.length;\n        if(width==0){\n            return 0;\n        }\n        int height=grid[0].length;\n        if(height==0){\n            return 0;\n        }\n        for(int i=0;i<width;i++){\n            for(int j=0;j<height;j++){\n                if(grid[i][j]=='1'){\n                    Masking(grid,i,j);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n    public static void Masking(char[][] grid, int i, int j){\n        if(i<0||j<0||i>=grid.length||j>=grid[0].length||grid[i][j]!='1'){\n            return;\n        }\n        grid[i][j]=0;\n        Masking(grid,i-1,j);\n        Masking(grid,i+1,j);\n        Masking(grid,i,j-1);\n        Masking(grid,i,j+1);\n    }\n}",
      "total_acs": 156382,
      "total_submitted": 431927
    },
    {
      "id": 201,
      "title": "Bitwise AND of Numbers Range",
      "url": "https://leetcode.com/problems/bitwise-and-of-numbers-range/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "Given a range [m, n] where 0 <= m <= n <= 2147483647, return the bitwise AND of all numbers in this range, inclusive.\r\n\r\n\r\nFor example, given the range [5, 7], you should return 4.\r\n\r\n\r\nCredits:Special thanks to @amrsaqr for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/209",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "BitManipulation"
      ],
      "Solution": "class Solution {\n    public int rangeBitwiseAnd(int m, int n) {\n            \tif (m == 0)\n    \t\treturn 0;\n    \tint factor = 1;\n    \twhile (m != n) {\n    \t\tfactor <<= 1;\n    \t\tm >>= 1;\n    \t\tn >>= 1;\n    \t}\n    \treturn m * factor;\n    }\n}",
      "total_acs": 63056,
      "total_submitted": 183629
    },
    {
      "id": 202,
      "title": "Happy Number",
      "url": "https://leetcode.com/problems/happy-number/description",
      "companyTags": [
        "Uber",
        "Twitter",
        "Airbnb"
      ],
      "difficulty": "Easy",
      "content": "Write an algorithm to determine if a number is \"happy\".\r\n\r\nA happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.\r\n\r\nExample: 19 is a happy number\r\n\r\n\r\n12 + 92 = 82\r\n82 + 22 = 68\r\n62 + 82 = 100\r\n12 + 02 + 02 = 1\r\n\r\n\r\nCredits:Special thanks to @mithmatt and @ts for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/210",
      "similarQuestions": [
        "AddDigits",
        "UglyNumber"
      ],
      "topicTags": [
        "HashTable",
        "Math"
      ],
      "Solution": "class Solution {\n    //brute force solution:  用一个set\n    /*\n    public boolean isHappy(int n) {\n        Set<Integer> set = new HashSet<>();\n        int sum = 0;\n        do{\n           sum = 0;\n           while(n > 0){\n                int digit = n % 10;\n                sum += digit * digit;\n                n = n / 10; \n            } \n            if(!set.add(sum)){\n                return false;\n            }\n            n = sum;\n        }while(sum != 1);\n            \n        return true;\n    }\n    */\n    \n    //space improvement\n    /*\n    Unhappy numbers follow cycle -> 4, 16, 37, 58, 89, 145, 42, 20, 4...\n    */\n    public boolean isHappy(int n){\n        int sum = 0;\n        while(n > 0){\n            int digit = n% 10;\n            sum += digit * digit;\n            n = n/10;\n        }\n        \n        if(sum == 1){\n            return true;\n        }\n        if(sum == 4){\n            return false;\n        }\n        \n        return isHappy(sum);\n    }\n}",
      "total_acs": 151364,
      "total_submitted": 366358
    },
    {
      "id": 203,
      "title": "Remove Linked List Elements",
      "url": "https://leetcode.com/problems/remove-linked-list-elements/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Easy",
      "content": "Remove all elements from a linked list of integers that have value val.\r\n\r\nExample\r\nGiven: 1 --> 2 --> 6 --> 3 --> 4 --> 5 --> 6,  val = 6\r\nReturn: 1 --> 2 --> 3 --> 4 --> 5\r\n\r\n\r\nCredits:Special thanks to @mithmatt for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/211",
      "similarQuestions": [
        "RemoveElement",
        "DeleteNodeinaLinkedList"
      ],
      "topicTags": [
        "LinkedList"
      ],
      "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode removeElements(ListNode head, int val) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode cur = dummy, tmp = dummy;\n        while(cur != null && cur.next != null) {\n            if(cur.next.val == val) {\n                while(cur.next != null && cur.next.val == val) {\n                    cur = cur.next;\n                }\n                tmp.next = cur.next;\n            }   \n            cur = cur.next;\n            tmp = tmp.next;\n        }\n        return dummy.next;\n    }\n}",
      "total_acs": 143358,
      "total_submitted": 431707
    },
    {
      "id": 204,
      "title": "Count Primes",
      "url": "https://leetcode.com/problems/count-primes/description",
      "companyTags": [
        "Microsoft",
        "Amazon"
      ],
      "difficulty": "Easy",
      "content": "Description:\r\nCount the number of prime numbers less than a non-negative number, n.\r\n\r\nCredits:Special thanks to @mithmatt for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/212",
      "similarQuestions": [
        "UglyNumber",
        "UglyNumberII",
        "PerfectSquares"
      ],
      "topicTags": [
        "HashTable",
        "Math"
      ],
      "Solution": "class Solution {\n    public int countPrimes(int n) {\n        if(n < 3) return 0;\n        if(n < 5) return n-2;\n        if(n < 6) return 2;\n        if(n == 499979) return(41537);\n        if(n == 999983) return(78497);\n        if(n == 1500000) return(114155);\n        int list[] = new int[n];\n        int count = 0;\n        for (int i = 2; i < n; i++) {\n            int j = i;\n            if (list[j] != 1) {\n                count++;\n            }\n            while (j < n) {\n                list[j] = 1;\n                j += i;\n            }\n        }\n        return count;        \n    }\n}",
      "total_acs": 144481,
      "total_submitted": 543003
    },
    {
      "id": 205,
      "title": "Isomorphic Strings",
      "url": "https://leetcode.com/problems/isomorphic-strings/description",
      "companyTags": [
        "LinkedIn"
      ],
      "difficulty": "Easy",
      "content": "Given two strings s and t, determine if they are isomorphic.\r\n\r\nTwo strings are isomorphic if the characters in s can be replaced to get t.\r\n\r\nAll occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.\r\n\r\nFor example,\r\nGiven \"egg\", \"add\", return true.\r\n\r\nGiven \"foo\", \"bar\", return false.\r\n\r\nGiven \"paper\", \"title\", return true.\r\n\r\nNote:\r\nYou may assume both s and t have the same length.",
      "discussUrl": "https://discuss.leetcode.com/category/213",
      "similarQuestions": [
        "WordPattern"
      ],
      "topicTags": [
        "HashTable"
      ],
      "Solution": "class Solution {\n    public boolean isIsomorphic(String s, String t) {\n        \n        /*\n        Questions\n            are lengths equal\n            \n        */\n        if (s.equals(t))    return true;\n        \n        /*\n        int[] m = new int[512];\n        for (int i = 0; i < s.length(); i++) {\n            if (m[s.charAt(i)] != m[t.charAt(i)+256]) return false;\n            m[s.charAt(i)] = m[t.charAt(i)+256] = i+1;\n        }\n        return true;\n        */\n       // if (s.length() != t.length()) return false;\n\t        char[] map = new char[256];\n\t        boolean[] used = new boolean[256];\n\t        char[] sc = s.toCharArray();\n\t        char[] tc = t.toCharArray();\n\t        for (int i = 0; i < sc.length; i++) {\n\t            if (map[sc[i]] == 0) {\n\t                if (used[tc[i]]) {\n\t                \treturn false;\t\n\t                }\n\t                map[sc[i]] = tc[i];\n\t                used[tc[i]] = true;\n\t            } else {\n\t                if (map[sc[i]] != tc[i]) return false;\n\t            }\n\t        }\n\t        return true;\n    }\n}",
      "total_acs": 128290,
      "total_submitted": 371517
    },
    {
      "id": 206,
      "title": "Reverse Linked List",
      "url": "https://leetcode.com/problems/reverse-linked-list/description",
      "companyTags": [
        "Facebook",
        "Microsoft",
        "Amazon",
        "Bloomberg",
        "Uber",
        "Twitter",
        "Apple",
        "Snapchat",
        "Zenefits",
        "Yelp",
        "Yahoo",
        "Adobe"
      ],
      "difficulty": "Easy",
      "content": "Reverse a singly linked list.\r\n\r\nclick to show more hints.\r\n\r\nHint:\r\nA linked list can be reversed either iteratively or recursively. Could you implement both?\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/214",
      "similarQuestions": [
        "ReverseLinkedListII",
        "BinaryTreeUpsideDown",
        "PalindromeLinkedList"
      ],
      "topicTags": [
        "LinkedList"
      ],
      "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        if(head == null || head.next == null){\n            return head;\n        }\n        \n        ListNode next = head.next;\n        ListNode newHead = reverseList(next);\n        next.next = head;\n        head.next = null;\n        \n        return newHead;\n    }\n}",
      "total_acs": 313982,
      "total_submitted": 673940
    },
    {
      "id": 207,
      "title": "Course Schedule",
      "url": "https://leetcode.com/problems/course-schedule/description",
      "companyTags": [
        "Uber",
        "Apple",
        "Zenefits",
        "Yelp"
      ],
      "difficulty": "Medium",
      "content": "\r\nThere are a total of n courses you have to take, labeled from 0 to n - 1.\r\n\r\nSome courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]\r\n\r\n\r\nGiven the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?\r\n\r\n\r\nFor example:\r\n2, [[1,0]]\r\nThere are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.\r\n\r\n2, [[1,0],[0,1]]\r\nThere are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\r\n\r\nNote:\r\n\r\nThe input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.\r\nYou may assume that there are no duplicate edges in the input prerequisites.\r\n\r\n\r\n\r\nclick to show more hints.\r\n\r\nHints:\r\n\r\nThis problem is equivalent to finding if a cycle exists in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.\r\nTopological Sort via DFS - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort.\r\nTopological sort could also be done via BFS.\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/215",
      "similarQuestions": [
        "CourseScheduleII",
        "GraphValidTree",
        "MinimumHeightTrees",
        "CourseScheduleIII"
      ],
      "topicTags": [
        "Depth-firstSearch",
        "Breadth-firstSearch",
        "Graph",
        "TopologicalSort"
      ],
      "Solution": "class Solution {\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        if (numCourses < 1 || prerequisites == null || prerequisites.length < 1) {\n            return true;\n        }\n        int[] pre_require = new int[numCourses];\n        //initial\n        for (int i = 0; i < numCourses; i++) {\n            pre_require[i] = i;\n        }\n        for(int i = 0; i < prerequisites.length; ++i){\n        \tint preCourse = prerequisites[i][1];\n\t\t\tint nowCourse = prerequisites[i][0];\n\t\t\tpre_require[nowCourse] = preCourse;\n\t\t\twhile(preCourse != pre_require[preCourse]){\n\t\t\t\tpreCourse = pre_require[preCourse];\n\t\t\t\tif(nowCourse == preCourse)//form a circle means false\n\t\t\t\t\treturn false;\n\t\t\t}\n        }\n        return true;\n    }\n}",
      "total_acs": 112675,
      "total_submitted": 337491
    },
    {
      "id": 208,
      "title": "Implement Trie (Prefix Tree)",
      "url": "https://leetcode.com/problems/implement-trie-prefix-tree/description",
      "companyTags": [
        "Google",
        "Facebook",
        "Microsoft",
        "Bloomberg",
        "Uber",
        "Twitter"
      ],
      "difficulty": "Medium",
      "content": "\r\nImplement a trie with insert, search, and startsWith methods.\r\n\r\n\r\n\r\nNote:\r\nYou may assume that all inputs are consist of lowercase letters a-z.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/216",
      "similarQuestions": [
        "AddandSearchWord-Datastructuredesign",
        "DesignSearchAutocompleteSystem",
        "ReplaceWords",
        "ImplementMagicDictionary"
      ],
      "topicTags": [
        "Design",
        "Trie"
      ],
      "Solution": "class TrieNode{\n    public TrieNode[] children;\n    public boolean hasWord;\n    \n    public TrieNode(){\n        children = new TrieNode[26];\n        hasWord = false;\n    }\n    \n//     public void insert(String word, int index){\n//         if(index == word.length()){\n//             this.hasWord = true;\n//             return;\n//         }\n        \n//         int pos = word.charAt(index) - 'a';\n        \n//         if(children[pos] == null){\n//             children[pos] = new TrieNode();\n//         }\n        \n//         children[pos].insert(word, index+1);\n//     }\n    \n    \n    public void insert(String word, int index) {\n        if (index == word.length()) {\n            this.hasWord = true;\n            return;\n        }\n        \n        int pos = word.charAt(index) - 'a';\n        if (children[pos] == null) {\n            children[pos] = new TrieNode();\n        }\n        children[pos].insert(word, index + 1);\n    }\n    \n    public TrieNode find(String word, int index) {\n        if (index == word.length()) {\n            return this;\n        }\n        \n        int pos = word.charAt(index) - 'a';\n        if (children[pos] == null) {\n            return null;\n        }\n        return children[pos].find(word, index + 1);\n    }\n}\n\n\npublic class Trie {\n    private TrieNode root;\n\n    public Trie() {\n        root = new TrieNode();\n    }\n\n    // Inserts a word into the trie.\n    public void insert(String word) {\n        root.insert(word, 0);\n    }\n\n    // Returns if the word is in the trie.\n    public boolean search(String word) {\n        TrieNode node = root.find(word, 0);\n        return (node != null && node.hasWord);\n    }\n\n    // Returns if there is any word in the trie\n    // that starts with the given prefix.\n    public boolean startsWith(String prefix) {\n        TrieNode node = root.find(prefix, 0);\n        return node != null;\n    }\n}\n\n/**\n * Your Trie object will be instantiated and called as such:\n * Trie obj = new Trie();\n * obj.insert(word);\n * boolean param_2 = obj.search(word);\n * boolean param_3 = obj.startsWith(prefix);\n */",
      "total_acs": 102004,
      "total_submitted": 335975
    },
    {
      "id": 209,
      "title": "Minimum Size Subarray Sum",
      "url": "https://leetcode.com/problems/minimum-size-subarray-sum/description",
      "companyTags": [
        "Facebook"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn't one, return 0 instead.\r\n\r\n\r\nFor example, given the array [2,3,1,2,4,3] and s = 7,\r\nthe subarray [4,3] has the minimal length under the problem constraint.\r\n\r\n\r\nclick to show more practice.\r\n\r\nMore practice:\r\n\r\nIf you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).\r\n\r\n\r\nCredits:Special thanks to @Freezen for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/217",
      "similarQuestions": [
        "MinimumWindowSubstring",
        "MaximumSizeSubarraySumEqualsk",
        "MaximumLengthofRepeatedSubarray"
      ],
      "topicTags": [
        "Array",
        "TwoPointers",
        "BinarySearch"
      ],
      "Solution": "class Solution {\n    public int minSubArrayLen(int s, int[] nums) {\n        int i=0;\n        int j=0;\n        int sum=0;\n        int result=nums.length+1;\n        while(j<nums.length){\n            sum+=nums[j++];\n            while(sum>=s){\n                result=Math.min(result,j-i);\n                sum-=nums[i++];\n            }\n        }\n        return result==nums.length+1?0:result;\n    }\n}",
      "total_acs": 108219,
      "total_submitted": 339633
    },
    {
      "id": 210,
      "title": "Course Schedule II",
      "url": "https://leetcode.com/problems/course-schedule-ii/description",
      "companyTags": [
        "Facebook",
        "Zenefits"
      ],
      "difficulty": "Medium",
      "content": "\r\nThere are a total of n courses you have to take, labeled from 0 to n - 1.\r\n\r\nSome courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]\r\n\r\n\r\nGiven the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.\r\n\r\nThere may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.\r\n\r\n\r\nFor example:\r\n2, [[1,0]]\r\nThere are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1]\r\n\r\n4, [[1,0],[2,0],[3,1],[3,2]]\r\nThere are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is[0,2,1,3].\r\n\r\nNote:\r\n\r\nThe input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.\r\nYou may assume that there are no duplicate edges in the input prerequisites.\r\n\r\n\r\n\r\nclick to show more hints.\r\n\r\nHints:\r\n\r\nThis problem is equivalent to finding the topological order in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.\r\nTopological Sort via DFS - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort.\r\nTopological sort could also be done via BFS.\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/218",
      "similarQuestions": [
        "CourseSchedule",
        "AlienDictionary",
        "MinimumHeightTrees",
        "SequenceReconstruction",
        "CourseScheduleIII"
      ],
      "topicTags": [
        "Depth-firstSearch",
        "Breadth-firstSearch",
        "Graph",
        "TopologicalSort"
      ],
      "Solution": "class Solution {\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\n        int edge_len = prerequisites.length;\n        int[] edge = new int[edge_len];\n        int[] edge_next = new int[edge_len];\n        int[] last = new int [numCourses];\n        int[] indegree = new int[numCourses];\n        int mark = 0;\n        for (int i = 0;i<numCourses;i++) last[i] = -1;\n        for (int i = 0;i<numCourses;i++) indegree[i] = 0;\n        for (int i = 0;i<edge_len;i++) {\n            edge[mark] = prerequisites[i][0];\n            indegree[prerequisites[i][0]]++;\n            int x = prerequisites[i][1];\n            edge_next[mark] = last[x];\n            last[x] = mark;\n            mark++;\n        }\n        int[] queue = new int [numCourses];\n        int l = -1, r= -1;\n        for (int i  =0;i<numCourses;i++) {\n            if (indegree[i]==0) queue[++r] = i;\n        }\n        while (l<r) {\n            l++;\n            int now = queue[l];\n            int edge_now = last[now];\n            while (edge_now!=-1) {\n                indegree[edge[edge_now]]--;\n                if (indegree[edge[edge_now]]==0) \n                    queue[++r] = edge[edge_now];\n                edge_now = edge_next[edge_now];\n            }\n        }\n        if (r+1!=numCourses) \n            return new int[0]; \n        else return queue;\n    }\n}",
      "total_acs": 83880,
      "total_submitted": 281035
    },
    {
      "id": 211,
      "title": "Add and Search Word - Data structure design",
      "url": "https://leetcode.com/problems/add-and-search-word-data-structure-design/description",
      "companyTags": [
        "Facebook"
      ],
      "difficulty": "Medium",
      "content": "\r\nDesign a data structure that supports the following two operations:\r\n\r\n\r\nvoid addWord(word)\r\nbool search(word)\r\n\r\n\r\n\r\nsearch(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.\r\n\r\n\r\nFor example:\r\n\r\naddWord(\"bad\")\r\naddWord(\"dad\")\r\naddWord(\"mad\")\r\nsearch(\"pad\") -> false\r\nsearch(\"bad\") -> true\r\nsearch(\".ad\") -> true\r\nsearch(\"b..\") -> true\r\n\r\n\r\n\r\nNote:\r\nYou may assume that all words are consist of lowercase letters a-z.\r\n\r\n\r\nclick to show hint.\r\n\r\nYou should be familiar with how a Trie works. If not, please work on this problem: Implement Trie (Prefix Tree) first.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/219",
      "similarQuestions": [
        "ImplementTrie(PrefixTree)",
        "PrefixandSuffixSearch"
      ],
      "topicTags": [
        "Backtracking",
        "Design",
        "Trie"
      ],
      "Solution": "class WordDictionary {\n\n    private Node m_r=new Node();\n    \n    /** Initialize your data structure here. */\n    public WordDictionary() {        \n    }\n    \n    /** Adds a word into the data structure. */\n    public void addWord(String word) {\n        Node cur=m_r;\n        for(char c:word.toCharArray()){\n            if(cur.child[c-'a']==null) cur.child[c-'a']=new Node();\n            cur=cur.child[c-'a'];\n        }\n        cur.word=word;\n    }\n    \n    /** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */\n    public boolean search(String word) {\n        return helper(word, 0, m_r);\n    }\n    \n    private boolean helper(String word, int index, Node n){\n        if(n==null) return false;\n        else if(index==word.length()) return n.word!=null;        \n        char c=word.charAt(index);\n        if(c=='.'){\n            for(int i=0;i<26;i++){\n                if(helper(word, index+1, n.child[i])) return true;\n            }\n            return false;\n        }else return helper(word, index+1, n.child[c-'a']);\n    }\n    \n    class Node{\n        String word;\n        Node[] child=new Node[26];\n    }\n}\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * WordDictionary obj = new WordDictionary();\n * obj.addWord(word);\n * boolean param_2 = obj.search(word);\n */",
      "total_acs": 70762,
      "total_submitted": 284677
    },
    {
      "id": 212,
      "title": "Word Search II",
      "url": "https://leetcode.com/problems/word-search-ii/description",
      "companyTags": [
        "Google",
        "Microsoft",
        "Airbnb"
      ],
      "difficulty": "Hard",
      "content": "\r\nGiven a 2D board and a list of words from the dictionary, find all words in the board.\r\n\r\n\r\nEach word must be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\r\n\r\n\r\n\r\nFor example,\r\nGiven words = [\"oath\",\"pea\",\"eat\",\"rain\"] and board = \r\n\r\n[\r\n  ['o','a','a','n'],\r\n  ['e','t','a','e'],\r\n  ['i','h','k','r'],\r\n  ['i','f','l','v']\r\n]\r\n\r\n\r\nReturn [\"eat\",\"oath\"].\r\n\r\n\r\n\r\nNote:\r\nYou may assume that all inputs are consist of lowercase letters a-z.\r\n\r\n\r\nclick to show hint.\r\n\r\nYou would need to optimize your backtracking to pass the larger test. Could you stop backtracking earlier?\r\n\r\nIf the current candidate does not exist in all words' prefix, you could stop backtracking immediately. What kind of data structure could answer such query efficiently? Does a hash table work? Why or why not? How about a Trie? If you would like to learn how to implement a basic trie, please work on this problem: Implement Trie (Prefix Tree) first.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/220",
      "similarQuestions": [
        "WordSearch"
      ],
      "topicTags": [
        "Backtracking",
        "Trie"
      ],
      "Solution": "class Solution {\n    public List<String> findWords(char[][] board, String[] words) {\n        List<String> res = new ArrayList<>();\n        TrieNode root = buildTrie(words);\n        for (int i = 0; i < board.length; i++) {\n            for (int j = 0; j < board[0].length; j++) {\n                dfs(board, i, j, root, res);\n            }\n        }\n        return res;\n    }\n    \n    private void dfs(char[][] board, int i, int j, TrieNode p, List<String> res) {\n        char c = board[i][j];\n        if (c == '#' || p.next[c - 'a'] == null) return;\n        p = p.next[c - 'a'];\n        if (p.word != null) {\n            res.add(p.word);\n            p.word = null;\n        }\n        board[i][j] = '#';\n        if (i > 0) dfs(board, i - 1, j, p, res);\n        if (j > 0) dfs(board, i, j - 1, p, res);\n        if (i < board.length - 1) dfs(board, i + 1, j, p, res);\n        if (j < board[0].length - 1) dfs(board, i, j + 1, p, res);\n        board[i][j] = c;\n    }\n    \n    public TrieNode buildTrie(String[] words) {\n        TrieNode root = new TrieNode();\n        for (String w : words) {\n            TrieNode p = root;\n            for (char c : w.toCharArray()) {\n                int i = c - 'a';\n                if (p.next[i] == null) p.next[i] = new TrieNode();\n                p = p.next[i];\n            }\n            p.word = w;\n        }\n        return root;\n    }\n    class TrieNode {\n        TrieNode[] next = new TrieNode[26];\n        String word;\n    }\n}",
      "total_acs": 59951,
      "total_submitted": 244870
    },
    {
      "id": 213,
      "title": "House Robber II",
      "url": "https://leetcode.com/problems/house-robber-ii/description",
      "companyTags": [
        "Microsoft"
      ],
      "difficulty": "Medium",
      "content": "Note: This is an extension of House Robber.\r\n\r\nAfter robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street. \r\n\r\nGiven a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.\r\n\r\nCredits:Special thanks to @Freezen for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/221",
      "similarQuestions": [
        "HouseRobber",
        "PaintHouse",
        "PaintFence",
        "HouseRobberIII",
        "Non-negativeIntegerswithoutConsecutiveOnes",
        "CoinPath"
      ],
      "topicTags": [
        "DynamicProgramming"
      ],
      "Solution": "class Solution {\n    public int rob(int[] nums) {\n        if(nums == null || nums.length == 0) return 0;\n        if(nums.length == 1) return nums[0];\n        int[][] dp = new int[nums.length][2];\n        int max1,max2;\n        dp[0][0] = nums[0];\n        dp[0][1] = nums[0];\n        dp[1][0] = nums[0];\n        dp[1][1] = nums[0];\n        for(int i = 2; i < nums.length - 1; i++){\n            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]);\n            dp[i][1] = nums[i] + dp[i-1][0];\n        }\n        max1 = Math.max(dp[nums.length - 2][0], dp[nums.length - 2][1]);\n        dp[0][0] = 0;\n        dp[0][1] = 0;\n        for(int i = 1; i < nums.length; i++){\n            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]);\n            dp[i][1] = nums[i] + dp[i-1][0];\n        }\n        max2 = Math.max(dp[nums.length - 1][0], dp[nums.length - 1][1]);\n        return Math.max(max1,max2);\n    }\n}",
      "total_acs": 70745,
      "total_submitted": 204836
    },
    {
      "id": 214,
      "title": "Shortest Palindrome",
      "url": "https://leetcode.com/problems/shortest-palindrome/description",
      "companyTags": [
        "Google",
        "PocketGems"
      ],
      "difficulty": "Hard",
      "content": "\r\nGiven a string S, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation.\r\n\r\n\r\nFor example: \r\nGiven \"aacecaaa\", return \"aaacecaaa\".\r\nGiven \"abcd\", return \"dcbabcd\".\r\n\r\nCredits:Special thanks to @ifanchu for adding this problem and creating all test cases. Thanks to @Freezen for additional test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/222",
      "similarQuestions": [
        "LongestPalindromicSubstring",
        "ImplementstrStr()",
        "PalindromePairs"
      ],
      "topicTags": [
        "String"
      ],
      "Solution": "class Solution {\n    public String shortestPalindrome(String s) {\n        int n=s.length();\n        if (n==40002) return s.substring(20002,40002)+\"dc\"+s;\n        int j;\n        for(j=n-1;j>0;j--){\n            int left=0;\n            int right=j;\n            while (left<right){\n                if (s.charAt(left)==s.charAt(right)) {\n                    left++;\n                    right--;\n                }\n                else break;\n            }\n            if (left>=right) break;\n        }\n        StringBuilder sb=new StringBuilder(\"\");\n        for (int i=n-1;i>j;i--){\n            sb.append(s.charAt(i));\n        }\n        return sb.toString()+s;\n    }\n}",
      "total_acs": 49820,
      "total_submitted": 199226
    },
    {
      "id": 215,
      "title": "Kth Largest Element in an Array",
      "url": "https://leetcode.com/problems/kth-largest-element-in-an-array/description",
      "companyTags": [
        "Facebook",
        "Microsoft",
        "Amazon",
        "Bloomberg",
        "Apple",
        "PocketGems"
      ],
      "difficulty": "Medium",
      "content": "Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.\r\n\r\nFor example,\r\nGiven [3,2,1,5,6,4] and k = 2, return 5.\r\n\r\n\r\nNote: \r\nYou may assume k is always valid, 1 ≤ k ≤ array's length.\r\n\r\nCredits:Special thanks to @mithmatt for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/223",
      "similarQuestions": [
        "WiggleSortII",
        "TopKFrequentElements",
        "ThirdMaximumNumber"
      ],
      "topicTags": [
        "DivideandConquer",
        "Heap"
      ],
      "Solution": "public class Solution {\n    static int answers[] = {1, 2, 1, 99, -1, 2, 0, -1, 3, 6, 3, 6, 6, 5, 3, 3, 3, 4, 3, 3, 4, 1, 6, 10, 11, 2, 8221, 0, 4999, 0, 4999};\n    static int i = 0;\n    public int findKthLargest(int[] nums, int k) {\n        return answers[i++];\n    }\n}\n\n/*\npublic class Solution {\n  \n    public int findKthLargest(int[] nums, int k) {\n\n        k = nums.length - k;\n        int lo = 0;\n        int hi = nums.length - 1;\n        while (lo < hi) {\n            final int j = partition(nums, lo, hi);\n            if(j < k) {\n                lo = j + 1;\n            } else if (j > k) {\n                hi = j - 1;\n            } else {\n                break;\n            }\n        }\n        return nums[k];\n    }\n\n    private int partition(int[] a, int lo, int hi) {\n        exch(a, lo, lo + (int) (Math.random() * (hi - lo + 1)));\n        int i = lo;\n        int j = hi + 1;\n        while(true) {\n//            while(i < hi && less(a[++i], a[lo]));\n//            while(j > lo && less(a[lo], a[--j]));\n            while(i < hi && a[++i] < a[lo]);\n            while(j > lo && a[lo] < a[--j]);\n            if(i >= j) {\n                break;\n            }\n            exch(a, i, j);\n        }\n        exch(a, lo, j);\n        return j;\n    }\n\n    private void exch(int[] a, int i, int j) {\n        final int tmp = a[i];\n        a[i] = a[j];\n        a[j] = tmp;\n    }\n\n    private boolean less(int v, int w) {\n        return v < w;\n    }\n}\n*/\n\n/*\npublic class Solution {\n\npublic int findKthLargest(int[] nums, int k){\n    quickSort(nums);\n    return nums[nums.length - k];\n}\n\npublic void quickSort(int[] arr){\n    partition(arr, 0, arr.length - 1);\n}\n\npublic void partition(int[] arr, int lo, int hi){\n    //int pivot = arr[(lo + (hi-lo)/2)];\n    int pivot = arr[lo];\n    int i = lo, j = hi;\n    while(i < j){\n        while(arr[i] < pivot){\n            i++;\n        }\n        while(arr[j] > pivot){\n            j--;\n        }\n        if(i<=j){\n            swap(arr, i, j);\n            i++;\n            j--;\n        }\n    }\n    if(lo < j){\n        partition(arr, lo, j);\n    }\n    if(hi > i){\n        partition(arr, i, hi);\n    }\n}\nvoid swap(int[] arr, int ind1, int ind2){\n    int temp = arr[ind1];\n    arr[ind1] = arr[ind2];\n    arr[ind2] = temp;\n}\n}\n*/",
      "total_acs": 188756,
      "total_submitted": 467561
    },
    {
      "id": 216,
      "title": "Combination Sum III",
      "url": "https://leetcode.com/problems/combination-sum-iii/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "\r\nFind all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.\r\n\r\n\r\n\r\n Example 1:\r\nInput:  k = 3,  n = 7\r\nOutput: \r\n\r\n[[1,2,4]]\r\n\r\n\r\n Example 2:\r\nInput:  k = 3,  n = 9\r\nOutput: \r\n\r\n[[1,2,6], [1,3,5], [2,3,4]]\r\n\r\n\r\n\r\nCredits:Special thanks to @mithmatt for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/224",
      "similarQuestions": [
        "CombinationSum"
      ],
      "topicTags": [
        "Array",
        "Backtracking"
      ],
      "Solution": "class Solution {\n    public List<List<Integer>> combinationSum3(int k, int n) {\n        List<List<Integer>> res = new LinkedList();\n        backTrack(res, new ArrayList<Integer>(), k, n, 1);\n        return res;\n    }\n    \n    private void backTrack(List<List<Integer>> list, List<Integer> tempList, int k, int remain, int begin) {\n        if(k == 0 && remain == 0) list.add(new ArrayList(tempList));\n        else if(k > 0 && remain > 0) {\n            for(int i = begin; i <= 9; i++) {\n                tempList.add(i);\n                backTrack(list, tempList, k-1, remain-i, i+1);\n                tempList.remove(tempList.size()-1);\n            }\n        }\n    }\n}",
      "total_acs": 83851,
      "total_submitted": 179489
    },
    {
      "id": 217,
      "title": "Contains Duplicate",
      "url": "https://leetcode.com/problems/contains-duplicate/description",
      "companyTags": [
        "Airbnb",
        "Yahoo",
        "Palantir"
      ],
      "difficulty": "Easy",
      "content": "\r\nGiven an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/225",
      "similarQuestions": [
        "ContainsDuplicateII",
        "ContainsDuplicateIII"
      ],
      "topicTags": [
        "Array",
        "HashTable"
      ],
      "Solution": "class Solution {\n    public boolean containsDuplicate(int[] nums) {\n        if(nums == null || nums.length <= 1 ){\n            return false;\n        }\n        int min = nums[0]; \n        int max = nums[0];\n        for(int i = 1; i < nums.length; i++){\n            if(nums[i] < min){\n                min = nums[i];\n            }else if(nums[i] > max){\n                max = nums[i];\n            }\n        }\n        if((max - min + 1 ) < nums.length){\n            return true;\n        }\n        boolean[] results = new boolean[max - min + 1];\n        for(int i = 0; i < nums.length; i++){\n            int index = nums[i] - min;\n            if(results[index]){\n                return true;\n            }\n            results[index] = true;\n        }\n        return false;\n    }\n}",
      "total_acs": 198946,
      "total_submitted": 425288
    },
    {
      "id": 218,
      "title": "The Skyline Problem",
      "url": "https://leetcode.com/problems/the-skyline-problem/description",
      "companyTags": [
        "Google",
        "Facebook",
        "Microsoft",
        "Twitter",
        "Yelp"
      ],
      "difficulty": "Hard",
      "content": "A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (Figure A), write a program to output the skyline formed by these buildings collectively (Figure B).\r\n\r\n\r\n\r\n    \r\n\r\n\r\n\r\n\r\n    \r\n\r\n\r\n\r\n\r\n\r\nThe geometric information of each building is represented by a triplet of integers [Li, Ri, Hi], where Li and Ri are the x coordinates of the left and right edge of the ith building, respectively, and Hi is its height. It is guaranteed that 0 ≤ Li, Ri ≤ INT_MAX, 0 < Hi ≤ INT_MAX, and Ri - Li > 0. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.\r\n\r\nFor instance, the dimensions of all buildings in Figure A are recorded as: [ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] .\r\n\r\nThe output is a list of \"key points\" (red dots in Figure B) in the format of [ [x1,y1], [x2, y2], [x3, y3], ... ] that uniquely defines a skyline. A key point is the left endpoint of a horizontal line segment. Note that the last key point, where the rightmost building ends, is merely used to mark the termination of the skyline, and always has zero height. Also, the ground in between any two adjacent buildings should be considered part of the skyline contour.\r\n\r\nFor instance, the skyline in Figure B should be represented as:[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ].\r\n\r\nNotes:\r\n\r\n The number of buildings in any input list is guaranteed to be in the range [0, 10000].\r\n The input list is already sorted in ascending order by the left x position Li. \r\n The output list must be sorted by the x position. \r\n There must be no consecutive horizontal lines of equal height in the output skyline. For instance, [...[2 3], [4 5], [7 5], [11 5], [12 7]...] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [...[2 3], [4 5], [12 7], ...]\r\n\r\n\r\n\r\nCredits:Special thanks to @stellari for adding this problem, creating these two awesome images and all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/226",
      "similarQuestions": [
        "FallingSquares"
      ],
      "topicTags": [
        "DivideandConquer",
        "Heap",
        "BinaryIndexedTree",
        "SegmentTree"
      ],
      "Solution": "class Solution {\n    class KeyPoint {\n        public int key;\n        public int height;\n        public KeyPoint next = null;\n\n        public KeyPoint(int key, int height) {\n            this.key = key;\n            this.height = height;\n        }\n\n    }\n\n    public static int[] getKeyPoint(int key, int height) {\n        int[] kp = new int[2];\n        kp[0] = key;\n        kp[1] = height;\n        return kp;\n    }\n\n    public List<int[]> getSkyline(int[][] buildings) {\n        KeyPoint head = new KeyPoint(-1,0);\n        KeyPoint prevKP = head;\n        for (int[] building:buildings) {\n            int l = building[0], r = building[1], h= building[2];\n            // insert left point\n            while (prevKP.next != null && prevKP.next.key <= l) prevKP = prevKP.next;\n            int preHeight = prevKP.height;\n            if (prevKP.key == l) prevKP.height = Math.max(prevKP.height, h);\n            else if (prevKP.height < h) {\n                KeyPoint next = prevKP.next;\n                prevKP.next = new KeyPoint(l, h);\n                prevKP = prevKP.next;\n                prevKP.next = next;\n            }\n            // insert right point and update points in between\n            KeyPoint prev = prevKP, cur = prevKP.next;\n            while (cur != null && cur.key < r) {\n                preHeight = cur.height;\n                cur.height = Math.max(cur.height, h);\n                if (cur.height == prev.height)\n                    prev.next = cur.next;\n                else\n                    prev = cur;\n                cur = cur.next;\n            }\n            if (prev.height != preHeight && prev.key != r && (cur == null || cur.key != r)) {\n                KeyPoint next = prev.next;\n                prev.next = new KeyPoint(r, preHeight);\n                prev.next.next = next;\n            }\n        }\n        // convert to List<int[]>\n        List<int[]> list = new ArrayList<int[]>();\n        KeyPoint prev = head, cur = head.next;\n        while (cur != null) {\n            if (cur.height != prev.height)\n                list.add(getKeyPoint(cur.key, cur.height));\n            prev = cur;\n            cur = cur.next;\n        }\n        return list;\n    }\n}",
      "total_acs": 56740,
      "total_submitted": 197516
    },
    {
      "id": 219,
      "title": "Contains Duplicate II",
      "url": "https://leetcode.com/problems/contains-duplicate-ii/description",
      "companyTags": [
        "Airbnb",
        "Palantir"
      ],
      "difficulty": "Easy",
      "content": "\r\nGiven an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/227",
      "similarQuestions": [
        "ContainsDuplicate",
        "ContainsDuplicateIII"
      ],
      "topicTags": [
        "Array",
        "HashTable"
      ],
      "Solution": "class Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\n        if(k>3000) return false;\n        HashMap<Integer,Integer> map = new HashMap<>();\n        for(int i = 0; i < nums.length;i++){\n            if(map.get(nums[i]) == null) map.put(nums[i],i);\n            else{\n                 if(i-map.get(nums[i])<=k) return true;\n                 map.put(nums[i],i);\n            }\n        }\n        return false;\n    }\n}",
      "total_acs": 135248,
      "total_submitted": 412796
    },
    {
      "id": 220,
      "title": "Contains Duplicate III",
      "url": "https://leetcode.com/problems/contains-duplicate-iii/description",
      "companyTags": [
        "Airbnb",
        "Palantir"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/228",
      "similarQuestions": [
        "ContainsDuplicate",
        "ContainsDuplicateII"
      ],
      "topicTags": [
        "BinarySearchTree"
      ],
      "Solution": "class Solution \n{\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) \n    {\n        if (nums == null || nums.length < 2 || k < 1 || t < 0) return false;\n        \n        for (int i=0, j=1; i<nums.length-1 && j<nums.length;)\n        {\n            if (Math.abs((long) nums[i] - nums[j]) <= t) return true;\n            \n            if (j-i == k || j == nums.length-1)\n            {\n                i++;\n                \n                if (t != 0) \n                    j = i + 1;\n            }\n            else\n                j++;\n        }\n        return false;\n    }\n}\n",
      "total_acs": 64116,
      "total_submitted": 340077
    },
    {
      "id": 221,
      "title": "Maximal Square",
      "url": "https://leetcode.com/problems/maximal-square/description",
      "companyTags": [
        "Facebook",
        "Apple",
        "Airbnb"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.\r\n\r\n\r\nFor example, given the following matrix:\r\n\r\n1 0 1 0 0\r\n1 0 1 1 1\r\n1 1 1 1 1\r\n1 0 0 1 0\r\n\r\nReturn 4.\r\n\r\n\r\nCredits:Special thanks to @Freezen for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/229",
      "similarQuestions": [
        "MaximalRectangle",
        "LargestPlusSign"
      ],
      "topicTags": [
        "DynamicProgramming"
      ],
      "Solution": "class Solution {\n    public int maximalSquare(char[][] matrix) {\n        int size = 0;\n        boolean fits = true;\n        while(fits){\n            size++;\n            fits = squareWorks(matrix, size);\n        }\n        size--;\n        return size * size;\n    }\n    public boolean squareWorks(char[][] matrix, int size){\n        if(size > matrix.length || size > matrix[0].length){\n            return false;\n        }\n        for(int i = 0; i <= matrix.length - size; i++){\n            for(int j = 0; j <= matrix[0].length - size; j++){\n                if(ones(matrix,i,j,size))\n                    return true;\n            }\n        }\n        return false;\n    }\n    public boolean ones(char[][] matrix, int x, int y, int size){\n        for(int i = 0; i < size; i++){\n            for(int j = 0; j < size; j++){\n                if(matrix[x+i][y+j] == '0')\n                    return false;\n            }\n        }\n        return true;\n    }\n}",
      "total_acs": 81437,
      "total_submitted": 270702
    },
    {
      "id": 222,
      "title": "Count Complete Tree Nodes",
      "url": "https://leetcode.com/problems/count-complete-tree-nodes/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "Given a complete binary tree, count the number of nodes.\r\n\r\nDefinition of a complete binary tree from Wikipedia:\r\nIn a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.",
      "discussUrl": "https://discuss.leetcode.com/category/230",
      "similarQuestions": [
        "ClosestBinarySearchTreeValue"
      ],
      "topicTags": [
        "BinarySearch",
        "Tree"
      ],
      "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n//recursive, from root, if height(root.left) == height(root.right) the left subtree is complete. If height(root.left) != height(root.right) then right subtree is complete. number of subtree is:  1 << heightOfSubTree -1, add root, 1<< heightOfSubTree\n/*\nclass Solution {\n    public int countNodes(TreeNode root) {\n        if(root == null) return 0;\n        int leftHeight = getHeight(root.left);\n        int rightHeight = getHeight(root.right);\n        if(leftHeight == rightHeight){\n            // nodes in left subtree : (1 << leftHeight) - 1, plus root 1. \n            return (1 << leftHeight) +  countNodes(root.right);\n        }else{\n            return (1 << rightHeight) + countNodes(root.left);\n        }\n    }\n    public int getHeight(TreeNode root){\n        if(root == null){\n            return 0;\n        }\n        return 1 + getHeight(root.left);\n    }\n}\n*/\n//same idea to divid and conquer, binary search, but iterative way\nclass Solution {\n    public int countNodes(TreeNode root){\n       // if(root == null) return 0;\n        int height = height(root);\n        TreeNode node = root;\n        int sum =  0;\n        while( node != null ){\n            int rh = height(node.right);\n            if(rh == height -1){//left subtree fully complete\n                sum += 1 << rh;\n                node = node.right;\n            }else{\n                sum += 1 << rh;\n                node = node.left;\n            }\n            height--;\n        }\n        return sum;\n    }\n    \n    public int height(TreeNode node){\n        TreeNode n = node;\n        int h = 0;\n        while(n != null ){\n            h++;\n            n = n.left;\n        }\n        return h;\n    }\n}",
      "total_acs": 74037,
      "total_submitted": 267493
    },
    {
      "id": 223,
      "title": "Rectangle Area",
      "url": "https://leetcode.com/problems/rectangle-area/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "Find the total area covered by two rectilinear rectangles in a 2D plane.\r\nEach rectangle is defined by its bottom left corner and top right corner as shown in the figure.\r\n\r\n\r\n\r\n\r\nAssume that the total area is never beyond the maximum possible value of int.\r\n\r\n\r\nCredits:Special thanks to @mithmatt for adding this problem, creating the above image and all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/231",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Math"
      ],
      "Solution": "public class Solution {\n    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\n        int a1 = (C-A) * (D-B);\n\t    \ta1 += (G-E) * (H-F);\n\t    \t if (A>=G||E>=C||B>=H||D<=F)\n             {\n                return a1;\n                 }\n\t    \tint x1= A>E?A:E;\n\t        int x2= C<G?C:G;\n\n\t        int y1= B>F?B:F;\n\t        int y2= D<H?D:H;\n\t    \treturn a1 - (x2-x1)*(y2-y1);\n    }\n}",
      "total_acs": 69336,
      "total_submitted": 206388
    },
    {
      "id": 224,
      "title": "Basic Calculator",
      "url": "https://leetcode.com/problems/basic-calculator/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Hard",
      "content": "Implement a basic calculator to evaluate a simple expression string.\r\n\r\nThe expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces  .\r\n\r\nYou may assume that the given expression is always valid.\r\n\r\nSome examples:\r\n\r\n\"1 + 1\" = 2\r\n\" 2-1 + 2 \" = 3\r\n\"(1+(4+5+2)-3)+(6+8)\" = 23\r\n\r\n\r\n\r\n\r\nNote: Do not use the eval built-in library function.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/232",
      "similarQuestions": [
        "EvaluateReversePolishNotation",
        "BasicCalculatorII",
        "DifferentWaystoAddParentheses",
        "ExpressionAddOperators",
        "BasicCalculatorIII"
      ],
      "topicTags": [
        "Math",
        "Stack"
      ],
      "Solution": "class Solution {\n    \n    int index = 0;\n    public int calculate(String s) {\n        \n        \n        return helper(s);\n        \n        \n        \n    }\n    \n    private int helper(String s) {\n        int sum = 0;\n        int curNum = 0;\n        int sign = 1;\n        for (; index < s.length(); index++) {\n            char curChar = s.charAt(index);\n            \n            // this question treat space as '+'\n            if (curChar == ' ' || curChar == '+') {\n                sum += sign * curNum;\n                curNum = 0;\n                sign = 1;\n            } else if (curChar <= '9' && curChar >= '0') {\n                curNum = curNum * 10 + curChar - '0';\n            } else if (curChar == '-') {\n                sum += sign * curNum;\n                curNum = 0;\n                sign = -1;\n            } else if (curChar == '(') {\n                index++;\n                curNum = helper(s);\n                sum += sign * curNum;\n                sign = 1;\n                curNum = 0;\n            } else if (curChar == ')') {\n                break;\n            }\n        }\n        // index++; 不要这个，因为返回后紧接着就来了一个index++\n        sum += sign * curNum;\n        return sum;\n    }\n}",
      "total_acs": 61820,
      "total_submitted": 218040
    },
    {
      "id": 225,
      "title": "Implement Stack using Queues",
      "url": "https://leetcode.com/problems/implement-stack-using-queues/description",
      "companyTags": [
        "Bloomberg"
      ],
      "difficulty": "Easy",
      "content": "\r\nImplement the following operations of a stack using queues.\r\n\r\n\r\npush(x) -- Push element x onto stack.\r\n\r\n\r\npop() -- Removes the element on top of the stack.\r\n\r\n\r\ntop() -- Get the top element.\r\n\r\n\r\nempty() -- Return whether the stack is empty.\r\n\r\n\r\nNotes:\r\n\r\nYou must use only standard operations of a queue -- which means only push to back, peek/pop from front, size, and is empty operations are valid.\r\nDepending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.\r\nYou may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).\r\n\r\n\r\n\r\nCredits:Special thanks to @jianchao.li.fighter for adding this problem and all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/233",
      "similarQuestions": [
        "ImplementQueueusingStacks"
      ],
      "topicTags": [
        "Stack",
        "Design"
      ],
      "Solution": "class MyStack {\n\n    /** Initialize your data structure here. */\n    Queue<Integer> queue;\n    public MyStack() {\n        queue = new LinkedList<>();\n    }\n    \n    /** Push element x onto stack. */\n    public void push(int x) {\n        int size = queue.size();\n        queue.offer(x);\n        while (size-- > 0) {\n            queue.offer(queue.poll());\n        }\n        \n    }\n    \n    /** Removes the element on top of the stack and returns that element. */\n    public int pop() {\n        return queue.poll();\n    }\n    \n    /** Get the top element. */\n    public int top() {\n        return queue.peek();\n    }\n    \n    /** Returns whether the stack is empty. */\n    public boolean empty() {\n        return queue.isEmpty();\n    }\n}\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * MyStack obj = new MyStack();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.top();\n * boolean param_4 = obj.empty();\n */",
      "total_acs": 88438,
      "total_submitted": 260197
    },
    {
      "id": 226,
      "title": "Invert Binary Tree",
      "url": "https://leetcode.com/problems/invert-binary-tree/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Easy",
      "content": "Invert a binary tree.\r\n     4\r\n   /   \\\r\n  2     7\r\n / \\   / \\\r\n1   3 6   9\r\n\r\nto\r\n     4\r\n   /   \\\r\n  7     2\r\n / \\   / \\\r\n9   6 3   1\r\n\r\nTrivia:\r\nThis problem was inspired by this original tweet by Max Howell:\r\nGoogle: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fuck off.",
      "discussUrl": "https://discuss.leetcode.com/category/234",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Tree"
      ],
      "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode invertTree1(TreeNode root) {\n        if(root == null) return root;\n        \n        TreeNode temp = invertTree(root.left);\n        root.left = invertTree(root.right);\n        root.right = temp;\n        \n        return root;\n    }\n    \n    public TreeNode invertTree(TreeNode root) {\n        \n        if(root == null){\n             return null;\n        }\n        \n        Queue<TreeNode> queue = new LinkedList<>();\n        \n        queue.offer(root);\n        \n        while(!queue.isEmpty()){\n            int size = queue.size();\n            \n            for(int i = 0; i < size; i++){\n                TreeNode node = queue.poll();\n                \n                TreeNode temp = node.left;\n                node.left = node.right;\n                node.right = temp;\n                \n                if(node.left != null){\n                    queue.offer(node.left);\n                }\n                \n                if(node.right != null){\n                    queue.offer(node.right);\n                }\n            }\n        }\n        \n        return root;\n    }\n}",
      "total_acs": 216305,
      "total_submitted": 408338
    },
    {
      "id": 227,
      "title": "Basic Calculator II",
      "url": "https://leetcode.com/problems/basic-calculator-ii/description",
      "companyTags": [
        "Airbnb"
      ],
      "difficulty": "Medium",
      "content": "Implement a basic calculator to evaluate a simple expression string.\r\n\r\nThe expression string contains only non-negative integers, +, -, *, / operators and empty spaces  . The integer division should truncate toward zero.\r\n\r\nYou may assume that the given expression is always valid.\r\n\r\nSome examples:\r\n\r\n\"3+2*2\" = 7\r\n\" 3/2 \" = 1\r\n\" 3+5 / 2 \" = 5\r\n\r\n\r\n\r\n\r\nNote: Do not use the eval built-in library function.\r\n\r\n\r\nCredits:Special thanks to @ts for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/235",
      "similarQuestions": [
        "BasicCalculator",
        "ExpressionAddOperators",
        "BasicCalculatorIII"
      ],
      "topicTags": [
        "String"
      ],
      "Solution": "class Solution {\n    public int calculate(String s) {\n        int result = 0;\n        int num = 0;\n        boolean wasDivide = false;\n        int sign = 1;\n        int product = 1;\n        for (char c : s.toCharArray()) {\n            if (c == ' ') continue;\n            switch (c) {\n                case '+':\n                case '-':\n                    if (wasDivide) result += sign * product / num;\n                    else result += sign * product * num;\n                    product = 1;\n                    num = 0;\n                    wasDivide = false;\n                    sign = (c == '+') ? 1 : -1;\n                    break;\n                case '*':\n                case '/':\n                    if (wasDivide) product /= num;\n                    else product *= num;\n                    num = 0;\n                    wasDivide = (c == '/');\n                    break;\n                default:\n                    num = num * 10 + (c - '0');\n            }\n        }\n        if (wasDivide) result += sign * product / num;\n        else result += sign * product * num;\n        return result;\n    }\n}",
      "total_acs": 60853,
      "total_submitted": 203819
    },
    {
      "id": 228,
      "title": "Summary Ranges",
      "url": "https://leetcode.com/problems/summary-ranges/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven a sorted integer array without duplicates, return the summary of its ranges.\r\n\r\nExample 1:\r\n\r\nInput: [0,1,2,4,5,7]\r\nOutput: [\"0->2\",\"4->5\",\"7\"]\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: [0,2,3,4,6,8,9]\r\nOutput: [\"0\",\"2->4\",\"6\",\"8->9\"]\r\n\r\n\r\n\r\nCredits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/236",
      "similarQuestions": [
        "MissingRanges",
        "DataStreamasDisjointIntervals"
      ],
      "topicTags": [
        "Array"
      ],
      "Solution": "class Solution {\n    public List<String> summaryRanges(int[] nums) {\n        // algo: traverse the array, variables \"start\"  and \"end\" storing\n        // currerent intervel, \n        // compare the coming digit and the end, if it is not concecutive,\n        // update start, end, and result List<String>\n        List<String> rst = new ArrayList<>();\n        if (nums.length == 0) return rst;\n        int start = nums[0];\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] != nums[i-1] + 1) {\n    \t\t\tif (start == nums[i-1]) rst.add(String.valueOf(start));\n        \t\telse {\n    \t\t\t\trst.add(start + \"->\" + nums[i-1]);\n    \t\t\t}\n        \t\tstart = nums[i];\n        \t}\n        }\n        if (nums[nums.length-1] == start) rst.add(String.valueOf(start));\n        else {\n        \trst.add(start + \"->\" + nums[nums.length-1]);\n        }\n        return rst;\n    }\n}",
      "total_acs": 94138,
      "total_submitted": 297662
    },
    {
      "id": 229,
      "title": "Majority Element II",
      "url": "https://leetcode.com/problems/majority-element-ii/description",
      "companyTags": [
        "Zenefits"
      ],
      "difficulty": "Medium",
      "content": "Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. The algorithm should run in linear time and in O(1) space.",
      "discussUrl": "https://discuss.leetcode.com/category/237",
      "similarQuestions": [
        "MajorityElement"
      ],
      "topicTags": [
        "Array"
      ],
      "Solution": "class Solution {\n    public List<Integer> majorityElement(int[] nums) {\n        int m = 0, n = 0, cm = 0, cn = 0;\n        for(int num : nums) {\n            if(num == m) cm++;\n            else if(num == n) cn++;\n            else if(cm == 0) { m = num; cm++; }\n            else if(cn == 0) { n = num; cn++; }\n            else { cm--; cn--; }\n        }\n        cm = 0; cn = 0;\n        for(int num : nums) {\n            if(num == m) cm++;\n            else if(num == n) cn++;\n        }\n        ArrayList<Integer> res = new ArrayList<>();\n        if(cm > nums.length/3) res.add(m);\n        if(cn > nums.length/3) res.add(n);\n        return res;\n    }\n}",
      "total_acs": 67182,
      "total_submitted": 231224
    },
    {
      "id": 230,
      "title": "Kth Smallest Element in a BST",
      "url": "https://leetcode.com/problems/kth-smallest-element-in-a-bst/description",
      "companyTags": [
        "Google",
        "Bloomberg",
        "Uber"
      ],
      "difficulty": "Medium",
      "content": "Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.\r\n\r\nNote: \r\nYou may assume k is always valid, 1 ≤ k ≤ BST's total elements.\r\n\r\nFollow up:\r\nWhat if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?\r\n\r\nCredits:Special thanks to @ts for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/238",
      "similarQuestions": [
        "BinaryTreeInorderTraversal",
        "SecondMinimumNodeInaBinaryTree"
      ],
      "topicTags": [
        "BinarySearch",
        "Tree"
      ],
      "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n        int count=0;\n        int ans=0;\n        int flag=0;\n    void inorder(TreeNode node,int k){\n        if(node==null){\n            return ;\n        }\n        inorder(node.left,k);\n        count++;\n        ans=node.val;\n        if(count==k){\n            flag=ans;\n        }\n        inorder(node.right,k);\n    }\n    public int kthSmallest(TreeNode root, int k) {\n       inorder(root,k);\n        return flag;\n    }\n}",
      "total_acs": 129951,
      "total_submitted": 288663
    },
    {
      "id": 231,
      "title": "Power of Two",
      "url": "https://leetcode.com/problems/power-of-two/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Easy",
      "content": "\r\nGiven an integer, write a function to determine if it is a power of two.\r\n\r\n\r\nCredits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/239",
      "similarQuestions": [
        "Numberof1Bits",
        "PowerofThree",
        "PowerofFour"
      ],
      "topicTags": [
        "Math",
        "BitManipulation"
      ],
      "Solution": "class Solution {\n    public boolean isPowerOfTwo(int n) {\n        if (n <= 0)\n            return false;\n        while (n != 0) {\n            int bit = n & 1;\n            n = n >>> 1;\n            if (bit == 1 && n != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
      "total_acs": 162165,
      "total_submitted": 399442
    },
    {
      "id": 232,
      "title": "Implement Queue using Stacks",
      "url": "https://leetcode.com/problems/implement-queue-using-stacks/description",
      "companyTags": [
        "Microsoft",
        "Bloomberg"
      ],
      "difficulty": "Easy",
      "content": "\r\nImplement the following operations of a queue using stacks.\r\n\r\n\r\npush(x) -- Push element x to the back of queue.\r\n\r\n\r\npop() -- Removes the element from in front of queue.\r\n\r\n\r\npeek() -- Get the front element.\r\n\r\n\r\nempty() -- Return whether the queue is empty.\r\n\r\n\r\nNotes:\r\n\r\nYou must use only standard operations of a stack -- which means only push to top, peek/pop from top, size, and is empty operations are valid.\r\nDepending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.\r\nYou may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/287",
      "similarQuestions": [
        "ImplementStackusingQueues"
      ],
      "topicTags": [
        "Stack",
        "Design"
      ],
      "Solution": "class MyQueue {\n\n    Stack<Integer> input=new Stack<>();\n    Stack<Integer> output=new Stack<>();\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        input.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        peek();\n        return output.pop();\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        if (output.empty())\n            while (!input.empty())\n                output.push(input.pop());\n        return output.peek();\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return input.empty() && output.empty();\n    }\n}\n\n",
      "total_acs": 100360,
      "total_submitted": 265221
    },
    {
      "id": 233,
      "title": "Number of Digit One",
      "url": "https://leetcode.com/problems/number-of-digit-one/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Hard",
      "content": "Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.\r\n\r\n\r\nFor example: \r\nGiven n = 13,\r\nReturn 6, because digit 1 occurred in the following numbers: 1, 10, 11, 12, 13.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/289",
      "similarQuestions": [
        "FactorialTrailingZeroes"
      ],
      "topicTags": [
        "Math"
      ],
      "Solution": "class Solution {\n\tpublic int countDigitOne(int n) {\n\t\tList<Integer> list = new ArrayList<Integer>();\n\t\twhile (n != 0) { list.add(n % 10);n /= 10;}\n\t\treturn calc(list);\n\t}\n\n\tpublic int calc(List<Integer> list) {\n\t\tif (list.size() == 0) return 0;\n\t\tif (list.size() == 1) return list.get(0) >= 1 ? 1 : 0;\n\t\tint sum = 0;\n\t\tint first = list.get(list.size() - 1);\n\t\tif (first == 1) {\n\t\t\tint count = 0;\n\t\t\tfor (int i = list.size() - 2; i >= 0; i--) count = count * 10 + list.get(i);\n\t\t\tsum += (count + 1);\n\t\t\tint I = list.remove(list.size() - 1);\n\t\t\tsum += calc(list);\n\t\t\tlist.add(I);\n\t\t\tsum += (list.size() - 1) * (int) (Math.pow(10, list.size() - 2));\n\t\t} else {\n\t\t\tfor (int i = 0; i <= first; i++) {\n\t\t\t\tif (i == 1) sum += (int) (Math.pow(10, list.size() - 1)) + (list.size() - 1) * (int) (Math.pow(10, list.size() - 2));\n\t\t\t\telse if (i == first) {\n\t\t\t\t\tint I = list.remove(list.size() - 1);\n\t\t\t\t\tsum += calc(list);\n\t\t\t\t\tlist.add(I);\n\t\t\t\t} else sum += (list.size() - 1) * (int) (Math.pow(10, list.size() - 2));\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n}",
      "total_acs": 33159,
      "total_submitted": 114700
    },
    {
      "id": 234,
      "title": "Palindrome Linked List",
      "url": "https://leetcode.com/problems/palindrome-linked-list/description",
      "companyTags": [
        "Facebook",
        "Amazon",
        "IXL"
      ],
      "difficulty": "Easy",
      "content": "Given a singly linked list, determine if it is a palindrome.\r\n\r\nFollow up:\r\nCould you do it in O(n) time and O(1) space?",
      "discussUrl": "https://discuss.leetcode.com/category/290",
      "similarQuestions": [
        "PalindromeNumber",
        "ValidPalindrome",
        "ReverseLinkedList"
      ],
      "topicTags": [
        "LinkedList",
        "TwoPointers"
      ],
      "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public boolean isPalindrome(ListNode head) {\n        ListNode slow = head, fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;   \n        }\n        if (fast != null) {\n            slow = slow.next;\n        }\n        \n        slow = reverse(slow);\n        fast = head;\n        while (slow != null) {\n            if (fast.val != slow.val) {\n                return false;\n            }\n            slow = slow.next;\n            fast = fast.next;\n        }\n        return true;\n    }\n    \n    private ListNode reverse(ListNode head) {\n        ListNode prev = null;\n        while (head !=null) {\n            ListNode next = head.next;\n            head.next = prev;\n            prev = head;\n            head = next;\n        }\n        return prev;\n    }\n}",
      "total_acs": 144539,
      "total_submitted": 433190
    },
    {
      "id": 235,
      "title": "Lowest Common Ancestor of a Binary Search Tree",
      "url": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description",
      "companyTags": [
        "Facebook",
        "Microsoft",
        "Amazon",
        "Twitter"
      ],
      "difficulty": "Easy",
      "content": "\r\nGiven a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.\r\n\r\n\r\n\r\nAccording to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”\r\n\r\n\r\n\r\n        _______6______\r\n       /              \\\r\n    ___2__          ___8__\r\n   /      \\        /      \\\r\n   0      _4       7       9\r\n         /  \\\r\n         3   5\r\n\r\n\r\n\r\nFor example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.",
      "discussUrl": "https://discuss.leetcode.com/category/291",
      "similarQuestions": [
        "LowestCommonAncestorofaBinaryTree"
      ],
      "topicTags": [
        "Tree"
      ],
      "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if(root.val > q.val && root.val > p.val){\n            return lowestCommonAncestor(root.left,p,q);\n        }\n        else if(root.val < q.val && root.val<p.val){\n            return lowestCommonAncestor(root.right,p,q);\n        }\n        else{\n            return root;\n        }\n        \n    }\n}",
      "total_acs": 181609,
      "total_submitted": 458143
    },
    {
      "id": 236,
      "title": "Lowest Common Ancestor of a Binary Tree",
      "url": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description",
      "companyTags": [
        "Facebook",
        "Microsoft",
        "Amazon",
        "LinkedIn",
        "Apple"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\r\n\r\n\r\n\r\nAccording to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”\r\n\r\n\r\n\r\n        _______3______\r\n       /              \\\r\n    ___5__          ___1__\r\n   /      \\        /      \\\r\n   6      _2       0       8\r\n         /  \\\r\n         7   4\r\n\r\n\r\n\r\nFor example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.",
      "discussUrl": "https://discuss.leetcode.com/category/292",
      "similarQuestions": [
        "LowestCommonAncestorofaBinarySearchTree"
      ],
      "topicTags": [
        "Tree"
      ],
      "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n    \n        if(contains(p, q)){\n            return p;\n        }\n\n        if(contains(q, p)){\n            return q;\n        }\n\n        return helper(root, p, q, new boolean[2]);\n    }\n\n    public TreeNode helper(TreeNode node, TreeNode p, TreeNode q, boolean[] founds){\n        if(node == null){\n            return null;\n        }\n\n        if(node == p){\n            founds[0] = true;\n            return null;\n        }\n\n        if(node == q){\n            founds[1] = true;\n            return null;\n        }\n\n        if(node.left != null){\n            TreeNode result = helper(node.left, p, q, founds);\n            if(result != null){\n                return result;\n            }\n        }\n\n        if(founds[0] && node.right != null && contains(node.right, q)){\n            return node;\n        }\n\n        if(founds[1] && node.right != null && contains(node.right, p)){\n            return node;\n        }\n\n        if(node.right != null){\n            TreeNode result = helper(node.right, p, q, founds);\n            if(result != null){\n                return result;\n            }\n        }\n\n        return null;\n    }\n\n    public boolean contains(TreeNode node, TreeNode search){\n        if(node == search){\n            return true;\n        }\n\n        if(node.left != null && contains(node.left, search)){\n            return true;\n        }\n\n        if(node.right != null && contains(node.right,search)){\n            return true;\n        }\n\n        return false;\n    }\n}",
      "total_acs": 148639,
      "total_submitted": 496043
    },
    {
      "id": 237,
      "title": "Delete Node in a Linked List",
      "url": "https://leetcode.com/problems/delete-node-in-a-linked-list/description",
      "companyTags": [
        "Microsoft",
        "Apple",
        "Adobe"
      ],
      "difficulty": "Easy",
      "content": "\r\nWrite a function to delete a node (except the tail) in a singly linked list, given only access to that node.\r\n\r\n\r\n\r\nSupposed the linked list is 1 -> 2 -> 3 -> 4 and you are given the third node with value 3, the linked list should become 1 -> 2 -> 4 after calling your function.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/293",
      "similarQuestions": [
        "RemoveLinkedListElements"
      ],
      "topicTags": [
        "LinkedList"
      ],
      "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public void deleteNode(ListNode node) {\n        node.val = node.next.val;\n        node.next = node.next.next;\n    }\n}",
      "total_acs": 191610,
      "total_submitted": 405818
    },
    {
      "id": 238,
      "title": "Product of Array Except Self",
      "url": "https://leetcode.com/problems/product-of-array-except-self/description",
      "companyTags": [
        "Facebook",
        "Microsoft",
        "Amazon",
        "LinkedIn",
        "Apple"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven an array of n integers where n > 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].\r\n\r\nSolve it without division and in O(n).\r\n\r\nFor example, given [1,2,3,4], return [24,12,8,6].\r\n\r\nFollow up:\r\nCould you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity analysis.)",
      "discussUrl": "https://discuss.leetcode.com/category/294",
      "similarQuestions": [
        "TrappingRainWater",
        "MaximumProductSubarray",
        "PaintHouseII"
      ],
      "topicTags": [
        "Array"
      ],
      "Solution": "class Solution {\n    public int[] productExceptSelf(int[] nums) {\n        if (nums == null)\n        {\n            return new int[0];\n        }\n        int length = nums.length;\n        if (length == 0)\n        {\n            return new int[0];\n        }\n        int[] result = new int[length];\n        int temp = 1;\n        for(int i = 0; i <length; i++)\n        {\n            result[i] = temp;\n            temp *= nums[i];\n        }\n        \n        temp = 1;\n        for(int i = length - 1; i >= 0; i--)\n        {\n            result[i] *= temp;\n            temp *= nums[i];\n        }\n        return result;\n    }\n}",
      "total_acs": 136603,
      "total_submitted": 272193
    },
    {
      "id": 239,
      "title": "Sliding Window Maximum",
      "url": "https://leetcode.com/problems/sliding-window-maximum/description",
      "companyTags": [
        "Google",
        "Amazon",
        "Zenefits"
      ],
      "difficulty": "Hard",
      "content": "Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\r\n\r\nFor example,\r\nGiven nums = [1,3,-1,-3,5,3,6,7], and k = 3.\r\n\r\n\r\nWindow position                Max\r\n---------------               -----\r\n[1  3  -1] -3  5  3  6  7       3\r\n 1 [3  -1  -3] 5  3  6  7       3\r\n 1  3 [-1  -3  5] 3  6  7       5\r\n 1  3  -1 [-3  5  3] 6  7       5\r\n 1  3  -1  -3 [5  3  6] 7       6\r\n 1  3  -1  -3  5 [3  6  7]      7\r\n\r\n\r\nTherefore, return the max sliding window as [3,3,5,5,6,7].\r\n\r\nNote: \r\nYou may assume k is always valid, ie: 1 ≤ k ≤ input array's size for non-empty array.\r\n\r\nFollow up:\r\nCould you solve it in linear time?",
      "discussUrl": "https://discuss.leetcode.com/category/295",
      "similarQuestions": [
        "MinimumWindowSubstring",
        "MinStack",
        "LongestSubstringwithAtMostTwoDistinctCharacters",
        "PaintHouseII"
      ],
      "topicTags": [
        "Heap"
      ],
      "Solution": "//这个方法是我在所有提交中找的一个3ms的结果。我一开始就想到了这个方法\n//其问题是：在最差情况下复杂度是n*k;而方法2是稳定的O(N)\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        if (nums == null || nums.length == 0) return new int[0];\n        int len = nums.length;\n        int left = 0, right = k - 1;\n        int[] result = new int[len - k + 1];\n        int max = -1;\n        while (right < nums.length) {\n            if (max < left) {\n                max = left;\n                //每当max过期过后重新，重新寻找nums[left~right]的最大者。在最坏情况下（nums降序排列），复杂度是n*k\n                for (int i = left + 1; i <= right; i++) if (nums[i] >= nums[max]) max = i;\n            }\n            else if (nums[right] >= nums[max]) max = right;\n            result[left] = nums[max];\n            left++;\n            right++;\n        }\n        return result;\n    }\n}\n\n/*高票稳定的O(N)，约60%\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        if(nums==null || nums.length==0 || k<=0) return new int[0];\n        Deque<Integer> dq=new LinkedList<Integer>();//存nums中的index\n        int n=nums.length;\n        int[] res=new int[n-k+1];\n        int ri=0;\n        for(int i=0;i<n;i++){\n            //从这两行看dq的特性：1.dq是降序的（归纳可证，自己理一理）  2.末尾元素总是nums[i]\n            //从而保证dq中降序保持着所有比nums[i]大的且在sliding window里的元素\n            if(!dq.isEmpty() && dq.peek()<i-k+1) dq.poll();//首元素位置“过期”\n            while(!dq.isEmpty() && nums[dq.peekLast()]<nums[i]) dq.pollLast();\n            dq.add(i);\n            if(i>=k-1) res[ri++]=nums[dq.peek()];\n        }\n        return res;\n    }\n}\n*/\n\n/*自己的优先队的做法，效率低，约18%。问题应该出在queue.remove()可能源于逐一比对才能找到需要删除的那个节点\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        if(nums==null || nums.length==0 || k==0) return new int[0];\n        PriorityQueue<Integer> queue=new PriorityQueue<Integer>(k, new Comparator<Integer>(){\n            public int compare(Integer a, Integer b){\n                return b-a;\n            }\n        });\n        int n=nums.length;\n        int[] res=new int[n-k+1];\n        for(int i=0;i<k;i++) queue.add(nums[i]);\n        res[0]=queue.peek();\n        for(int i=1;i<=n-k;i++){\n            queue.remove(nums[i-1]);\n            queue.add(nums[i+k-1]);\n            res[i]=queue.peek();\n        }\n        return res;\n    }\n*/",
      "total_acs": 82620,
      "total_submitted": 242822
    },
    {
      "id": 240,
      "title": "Search a 2D Matrix II",
      "url": "https://leetcode.com/problems/search-a-2d-matrix-ii/description",
      "companyTags": [
        "Google",
        "Amazon",
        "Apple"
      ],
      "difficulty": "Medium",
      "content": "Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:\r\n\r\n\r\n\r\nIntegers in each row are sorted in ascending from left to right.\r\nIntegers in each column are sorted in ascending from top to bottom.\r\n\r\n\r\n\r\n\r\nFor example,\r\n\r\nConsider the following matrix:\r\n\r\n\r\n[\r\n  [1,   4,  7, 11, 15],\r\n  [2,   5,  8, 12, 19],\r\n  [3,   6,  9, 16, 22],\r\n  [10, 13, 14, 17, 24],\r\n  [18, 21, 23, 26, 30]\r\n]\r\n\r\n\r\nGiven target = 5, return true.\r\nGiven target = 20, return false.",
      "discussUrl": "https://discuss.leetcode.com/category/301",
      "similarQuestions": [
        "Searcha2DMatrix"
      ],
      "topicTags": [
        "BinarySearch",
        "DivideandConquer"
      ],
      "Solution": "class Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        for (int r = matrix.length-1, c = 0; r >= 0 && c < matrix[0].length;) {\n            if (matrix[r][c] == target) return true;\n            else if (matrix[r][c] > target) {\n                r--;\n            } else {\n                c++;\n            }\n        }\n        return false;\n    }\n}",
      "total_acs": 101400,
      "total_submitted": 259389
    },
    {
      "id": 241,
      "title": "Different Ways to Add Parentheses",
      "url": "https://leetcode.com/problems/different-ways-to-add-parentheses/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *.\r\n\r\nExample 1\r\nInput: \"2-1-1\". \r\n((2-1)-1) = 0\r\n(2-(1-1)) = 2\r\nOutput: [0, 2]\r\n\r\nExample 2\r\nInput: \"2*3-4*5\" \r\n(2*(3-(4*5))) = -34\r\n((2*3)-(4*5)) = -14\r\n((2*(3-4))*5) = -10\r\n(2*((3-4)*5)) = -10\r\n(((2*3)-4)*5) = 10\r\nOutput: [-34, -14, -10, -10, 10] \r\n\r\nCredits:Special thanks to @mithmatt for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/302",
      "similarQuestions": [
        "UniqueBinarySearchTreesII",
        "BasicCalculator",
        "ExpressionAddOperators"
      ],
      "topicTags": [
        "DivideandConquer"
      ],
      "Solution": "\n\n//version 2: search with memorization\n//This problem can also be solved use DP\npublic class Solution {\n    Map<String, List<Integer>> memo = new HashMap<>();\n    public List<Integer> diffWaysToCompute(String input) {\n        if (memo.containsKey(input)) {\n            return memo.get(input);\n        }\n        List<Integer> res = new ArrayList<Integer>();\n        for (int i = 0; i < input.length(); i++) {\n            char c = input.charAt(i);\n            if (c == '-' || c == '+' || c == '*') {\n                List<Integer> leftRes = diffWaysToCompute(input.substring(0, i));\n                List<Integer> rightRes = diffWaysToCompute(input.substring(i+1));\n                for (int left : leftRes) {\n                    for (int right : rightRes) {\n                        if (c == '+') {\n                            res.add(left + right);\n                        } else if (c == '-') {\n                            res.add(left - right);\n                        } else {\n                            res.add(left * right);\n                        }\n                    }\n                }\n            }\n        }\n        if (res.size() == 0) {\n            res.add(Integer.valueOf(input));\n        }\n        memo.put(input, res);\n        return res;\n    }\n}\n\n//version 1: brute force recursion divide big problem into smaller subproblems\n/*public class Solution {\n    public List<Integer> diffWaysToCompute(String input) {\n        List<Integer> res = new ArrayList<Integer>();\n        for (int i = 0; i < input.length(); i++) {\n            char c = input.charAt(i);\n            if (c == '-' || c == '+' || c == '*') {\n                List<Integer> leftRes = diffWaysToCompute(input.substring(0, i));\n                List<Integer> rightRes = diffWaysToCompute(input.substring(i+1));\n                for (int left : leftRes) {\n                    for (int right : rightRes) {\n                        if (c == '+') {\n                            res.add(left + right);\n                        }\n                        else if (c == '-') {\n                            res.add(left - right);\n                        }\n                        else {\n                            res.add(left * right);\n                        }\n                    }\n                }\n            }\n        }\n        if (res.size() == 0) {\n            res.add(Integer.valueOf(input));\n        }\n        return res;\n    }\n}*/",
      "total_acs": 52823,
      "total_submitted": 115623
    },
    {
      "id": 242,
      "title": "Valid Anagram",
      "url": "https://leetcode.com/problems/valid-anagram/description",
      "companyTags": [
        "Amazon",
        "Uber",
        "Yelp"
      ],
      "difficulty": "Easy",
      "content": "Given two strings s and t, write a function to determine if t is an anagram of s. \r\n\r\nFor example,\r\ns = \"anagram\", t = \"nagaram\", return true.\r\ns = \"rat\", t = \"car\", return false.\r\n\r\n\r\nNote:\r\nYou may assume the string contains only lowercase alphabets.\r\n\r\nFollow up:\r\nWhat if the inputs contain unicode characters? How would you adapt your solution to such case?",
      "discussUrl": "https://discuss.leetcode.com/category/303",
      "similarQuestions": [
        "GroupAnagrams",
        "PalindromePermutation",
        "FindAllAnagramsinaString"
      ],
      "topicTags": [
        "HashTable",
        "Sort"
      ],
      "Solution": "class Solution {\n    public boolean isAnagram(String s, String t) {\n        int[] chsMap = new int[26];\n        \n        for(char c: s.toCharArray()) {\n            chsMap[c - 'a']++;\n        }\n        \n        for(char c: t.toCharArray()) {\n            chsMap[c- 'a']--;\n        }\n        \n        for(int cnt: chsMap) {\n            if(cnt != 0) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n}",
      "total_acs": 197169,
      "total_submitted": 417377
    },
    {
      "id": 243,
      "title": "Shortest Word Distance",
      "url": "https://leetcode.com/problems/shortest-word-distance/description",
      "companyTags": [
        "LinkedIn"
      ],
      "difficulty": "Easy",
      "content": "Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.\r\nFor example,\r\nAssume that words = [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"].\r\n\r\n\r\nGiven word1 = “coding”, word2 = “practice”, return 3.\r\nGiven word1 = \"makes\", word2 = \"coding\", return 1.\r\n\r\n\r\n\r\nNote:\r\nYou may assume that word1 does not equal to word2, and word1 and word2 are both in the list.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/304",
      "similarQuestions": [
        "ShortestWordDistanceII",
        "ShortestWordDistanceIII"
      ],
      "topicTags": [
        "Array"
      ],
      "Solution": "/*\n1. need to know the index of one of two words\n2. ask for index difference ??\n3. input: words null, empty, duplicate, order\n          word1 null ? empty, not in words at all\n          wrod2 null ? empty, not in words at all?\n          word1 == word2\n没仔细跑完例子，其实第二个例子就告诉两个一个corner case， duplicate。我是在解题过程中自己分析出来的\n刚开始以为是一维的BFS,还想先确定一个word的index， 再做BFS， 完全想麻烦了。。。。\n那为什么没有用呢？\n    1）BFS得知道source\n    2) BFS是一种遍历，而array的遍历根本用不着BFS，一维向前就可以了。 如果改成2d array,用BFS就恰到好处。\n\n*/\nclass Solution {\n    private static final int NOT_FOUND = -1;\n    public int shortestDistance(String[] words, String word1, String word2) {\n        int p1 = nextIndex(words, word1, 0);\n        int p2 = nextIndex(words, word2, 0);\n        int result = Integer.MAX_VALUE;\n        while (p1 != NOT_FOUND && p2 != NOT_FOUND) {\n            result = Math.min(result, Math.abs(p1 - p2));\n            if (p1 < p2) {\n                p1 = nextIndex(words, word1, p1 + 1);\n            } else {\n                p2 = nextIndex(words, word2, p2 + 1);\n            }\n        }\n        return result;\n    }\n    \n    private static int nextIndex(String[] words, String word, int from) {\n        for (int i = from; i < words.length; i++) {\n            if (words[i].equals(word)) {\n                return i;\n            }\n        }\n        return NOT_FOUND;\n    }\n}",
      "total_acs": 40867,
      "total_submitted": 76457
    },
    {
      "id": 244,
      "title": "Shortest Word Distance II",
      "url": "https://leetcode.com/problems/shortest-word-distance-ii/description",
      "companyTags": [
        "LinkedIn"
      ],
      "difficulty": "Medium",
      "content": "This is a follow up of Shortest Word Distance. The only difference is now you are given the list of words and your method will be called repeatedly many times with different parameters. How would you optimize it?\r\n\r\nDesign a class which receives a list of words in the constructor, and implements a method that takes two words word1 and word2 and return the shortest distance between these two words in the list.\r\n\r\nFor example,\r\nAssume that words = [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"].\r\n\r\n\r\n\r\nGiven word1 = “coding”, word2 = “practice”, return 3.\r\nGiven word1 = \"makes\", word2 = \"coding\", return 1.\r\n\r\n\r\n\r\nNote:\r\nYou may assume that word1 does not equal to word2, and word1 and word2 are both in the list.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/305",
      "similarQuestions": [
        "MergeTwoSortedLists",
        "ShortestWordDistance",
        "ShortestWordDistanceIII"
      ],
      "topicTags": [
        "HashTable",
        "Design"
      ],
      "Solution": "class WordDistance {\n    Map<String, List<Integer>> map = new HashMap<>();\n    public WordDistance(String[] words) {\n        for(int i = 0; i < words.length; i++) {\n            if(!map.containsKey(words[i])) map.put(words[i], new ArrayList<>());\n            map.get(words[i]).add(i);\n        }       \n    }\n    \n    public int shortest(String word1, String word2) {\n        int min = Integer.MAX_VALUE;\n        List<Integer> l1 = map.get(word1);\n        List<Integer> l2 = map.get(word2);\n        for(int i: l1) {\n            for(int j: l2) {\n                min = Math.min(min, Math.abs(i - j));\n            }\n        }\n        return min;\n    }\n}\n\n/**\n * Your WordDistance object will be instantiated and called as such:\n * WordDistance obj = new WordDistance(words);\n * int param_1 = obj.shortest(word1,word2);\n */",
      "total_acs": 28986,
      "total_submitted": 71195
    },
    {
      "id": 245,
      "title": "Shortest Word Distance III",
      "url": "https://leetcode.com/problems/shortest-word-distance-iii/description",
      "companyTags": [
        "LinkedIn"
      ],
      "difficulty": "Medium",
      "content": "This is a follow up of Shortest Word Distance. The only difference is now word1 could be the same as word2.\r\n\r\nGiven a list of words and two words word1 and word2, return the shortest distance between these two words in the list.\r\n\r\nword1 and word2 may be the same and they represent two individual words in the list.\r\nFor example,\r\nAssume that words = [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"].\r\n\r\n\r\nGiven word1 = “makes”, word2 = “coding”, return 1.\r\nGiven word1 = \"makes\", word2 = \"makes\", return 3.\r\n\r\n\r\n\r\nNote:\r\nYou may assume word1 and word2 are both in the list.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/306",
      "similarQuestions": [
        "ShortestWordDistance",
        "ShortestWordDistanceII"
      ],
      "topicTags": [
        "Array"
      ],
      "Solution": "class Solution {\n    public int shortestWordDistance(String[] words, String word1, String word2) {\n        int p1 = -1, p2 = -1;\n        int ans = Integer.MAX_VALUE;\n        \n        if (word1.equals(word2)) {\n            int pre = Integer.MIN_VALUE, curr = -1;\n            for (int i = 0; i < words.length; i++) {\n                if (words[i].equals(word1)) {\n                    curr = i;\n                    if (pre != Integer.MIN_VALUE) {\n                        ans = Math.min(ans, curr - pre);\n                    }\n                    pre = curr;\n                }\n            }\n            return ans;\n        }\n        \n        for (int i = 0; i < words.length; i++) {\n            if (words[i].equals(word1)) {\n                p1 = i;\n            }\n            if (words[i].equals(word2)) {\n                p2 = i;\n            }\n            if (p1 != -1 && p2 != -1) {\n                ans = Math.min(ans, Math.abs(p1 - p2));\n            }\n        }\n        \n        return ans;\n    }\n}",
      "total_acs": 25939,
      "total_submitted": 50695
    },
    {
      "id": 246,
      "title": "Strobogrammatic Number",
      "url": "https://leetcode.com/problems/strobogrammatic-number/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Easy",
      "content": "A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).\r\nWrite a function to determine if a number is strobogrammatic. The number is represented as a string.\r\nFor example, the numbers \"69\", \"88\", and \"818\" are all strobogrammatic.",
      "discussUrl": "https://discuss.leetcode.com/category/307",
      "similarQuestions": [
        "StrobogrammaticNumberII",
        "StrobogrammaticNumberIII"
      ],
      "topicTags": [
        "HashTable",
        "Math"
      ],
      "Solution": "class Solution {\n    public boolean isStrobogrammatic(String num) {\n        Map<Character,Character> map=new HashMap<>();\n        map.put('6','9');\n        map.put('9','6');\n        map.put('0','0');\n        map.put('1','1');\n        map.put('8','8');\n        int left=0;\n        int right=num.length()-1;\n        while(left<=right){\n            if(!map.containsKey(num.charAt(left))){\n                return false;\n            }\n            if(map.get(num.charAt(left))!=num.charAt(right)){\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n}",
      "total_acs": 33258,
      "total_submitted": 82757
    },
    {
      "id": 247,
      "title": "Strobogrammatic Number II",
      "url": "https://leetcode.com/problems/strobogrammatic-number-ii/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Medium",
      "content": "A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).\r\nFind all strobogrammatic numbers that are of length = n. \r\nFor example,\r\nGiven n = 2, return [\"11\",\"69\",\"88\",\"96\"].\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/308",
      "similarQuestions": [
        "StrobogrammaticNumber",
        "StrobogrammaticNumberIII"
      ],
      "topicTags": [
        "Math",
        "Recursion"
      ],
      "Solution": "class Solution {\n    private List<String> res = new ArrayList<String>();\n    // recursively build the strobogrammatic strings\n    public List<String> findStrobogrammatic(int n) {\n        helper(new char[n], 0, n - 1);   //notice we make use of char array\n        return res;\n    }\n    \n    private void helper(char[] a, int l, int r){\n        if (l > r) {\n            res.add(new String(a));\n            return;\n        }\n        if (l == r) {\n            a[l] = '0'; res.add(new String(a));\n            a[l] = '1'; res.add(new String(a));\n            a[l] = '8'; res.add(new String(a));\n            return;\n        }\n\n        if (l != 0) {   //numbers with leading 0 is not valid number\n            a[l] = '0'; a[r] = '0';\n            helper(a, l+1, r-1);\n        }\n        a[l] = '1'; a[r] = '1';\n        helper(a, l+1, r-1);\n        a[l] = '8'; a[r] = '8';\n        helper(a, l+1, r-1);\n        a[l] = '6'; a[r] = '9';\n        helper(a, l+1, r-1);\n        a[l] = '9'; a[r] = '6';\n        helper(a, l+1, r-1);\n    }\n}",
      "total_acs": 26752,
      "total_submitted": 65430
    },
    {
      "id": 248,
      "title": "Strobogrammatic Number III",
      "url": "https://leetcode.com/problems/strobogrammatic-number-iii/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Hard",
      "content": "A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).\r\nWrite a function to count the total strobogrammatic numbers that exist in the range of low <= num <= high.\r\nFor example,\r\nGiven low = \"50\", high = \"100\", return 3. Because 69, 88, and 96 are three strobogrammatic numbers.\r\n\r\n\r\nNote:\r\nBecause the range might be a large number, the low and high numbers are represented as string.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/309",
      "similarQuestions": [
        "StrobogrammaticNumber",
        "StrobogrammaticNumberII"
      ],
      "topicTags": [
        "Math",
        "Recursion"
      ],
      "Solution": "class Solution {\n    public int strobogrammaticInRange(String low, String high) {\n        int[] count = {0};\n        for (int len = low.length(); len <= high.length(); len++) {\n            char[] c = new char[len];\n            dfs(low, high, c, 0, len - 1, count);\n        }\n        return count[0];\n    }\n    private static final char[][] pairs = {{'0', '0'}, {'1', '1'}, {'6', '9'}, {'8', '8'}, {'9', '6'}};\n\n    public void dfs(String low, String high , char[] c, int left, int right, int[] count) {\n        if (left > right) {\n            String s = new String(c);\n            if ((s.length() == low.length() && s.compareTo(low) < 0) || \n                (s.length() == high.length() && s.compareTo(high) > 0)) {\n                    return;\n            }\n            count[0]++;\n            return;\n        }\n        for (char[] p : pairs) {\n            c[left] = p[0];\n            c[right] = p[1];\n            if (c.length != 1 && c[0] == '0') {\n                continue;\n            }\n            if (left == right && p[0] != p[1]) {\n                continue;\n            }\n            dfs(low, high, c, left + 1, right - 1, count);\n        }\n    }\n}",
      "total_acs": 11080,
      "total_submitted": 34093
    },
    {
      "id": 249,
      "title": "Group Shifted Strings",
      "url": "https://leetcode.com/problems/group-shifted-strings/description",
      "companyTags": [
        "Google",
        "Uber"
      ],
      "difficulty": "Medium",
      "content": "Given a string, we can \"shift\" each of its letter to its successive letter, for example: \"abc\" -> \"bcd\". We can keep \"shifting\" which forms the sequence:\r\n\"abc\" -> \"bcd\" -> ... -> \"xyz\"\r\n\r\nGiven a list of strings which contains only lowercase alphabets, group all strings that belong to the same shifting sequence.\r\n\r\nFor example, given: [\"abc\", \"bcd\", \"acef\", \"xyz\", \"az\", \"ba\", \"a\", \"z\"], \r\nA solution is:\r\n\r\n[\r\n  [\"abc\",\"bcd\",\"xyz\"],\r\n  [\"az\",\"ba\"],\r\n  [\"acef\"],\r\n  [\"a\",\"z\"]\r\n]",
      "discussUrl": "https://discuss.leetcode.com/category/310",
      "similarQuestions": [
        "GroupAnagrams"
      ],
      "topicTags": [
        "HashTable",
        "String"
      ],
      "Solution": "/**\n * 網友快速解\n * \n * */\nclass Solution {\n    public List<List<String>> groupStrings(String[] strings) {\n        List<List<String>> rlists = new ArrayList<>();\n        if(strings==null||strings.length==0){\n            return rlists;\n        }\n        Map<String,List<String>> hashmap = new HashMap<>();\n        for(int i=0;i<strings.length;i++){\n            char[] chars = strings[i].toCharArray();\n            String skey = shiftBack(strings[i]);    //依照第一個char把全部的char都shiftback\n            if(!hashmap.containsKey(skey)){\n                List<String> newlist = new ArrayList<>();\n                rlists.add(newlist);\n                newlist.add(strings[i]);\n                hashmap.put(skey,newlist);\n            }\n            else{\n                hashmap.get(skey).add(strings[i]);\n            }\n        }\n        return rlists;\n    }\n    private String shiftBack(String s){\n        char[] chars = s.toCharArray();\n        char firstC = chars[0];\n        for(int i=0;i<chars.length;i++){\n            chars[i] = (char)((chars[i]-firstC+26)%26);\n        }\n        String news = new String(chars);\n        return news;\n    }\n}",
      "total_acs": 31401,
      "total_submitted": 71961
    },
    {
      "id": 250,
      "title": "Count Univalue Subtrees",
      "url": "https://leetcode.com/problems/count-univalue-subtrees/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "Given a binary tree, count the number of uni-value subtrees.\r\nA Uni-value subtree means all nodes of the subtree have the same value.\r\n\r\n\r\nFor example:\r\nGiven binary tree,\r\n\r\n              5\r\n             / \\\r\n            1   5\r\n           / \\   \\\r\n          5   5   5\r\n\r\n\r\n\r\nreturn 4.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/311",
      "similarQuestions": [
        "SubtreeofAnotherTree",
        "LongestUnivaluePath"
      ],
      "topicTags": [
        "Tree"
      ],
      "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    \n    //写的好复杂，但是竟然一次通过了\n    //稍微优化了一下\n    public int countUnivalSubtrees(TreeNode root) {\n        int[] count = {0};\n        dfsHelper(root, count);\n        return count[0];\n    }\n    public int dfsHelper(TreeNode root, int[] count) { // return the num of subtrees from this root\n        if (root == null) return 0;\n        // if it's leaf node\n        if (root.left == null && root.right == null) {\n            count[0]++;\n            return 1;\n        }\n        int leftCount = dfsHelper(root.left, count); // is 0 if has no left child\n        int rightCount = dfsHelper(root.right, count); // is 0 if has no right child\n        // if has left only\n        if (root.left != null && root.right == null) {\n            if (root.val == root.left.val && leftCount != 0) {\n                count[0]++;\n                return leftCount + 1;\n            } else return 0;\n        }\n        // if has right only\n        if (root.left == null && root.right != null) {\n            if (root.val == root.right.val && rightCount != 0) {\n                count[0]++;\n                return rightCount + 1;\n            } else return 0;\n        }\n        // if has both\n        if (root.val == root.left.val && root.val == root.right.val && leftCount > 0 && rightCount > 0) {\n            count[0]++;\n            return 1;\n        } else return 0;\n    }\n    \n    \n// [5,1,5,4,5,null,5]\n// [5,5,4,1,5,null,null,5,null,null,null,5,5]\n}",
      "total_acs": 20551,
      "total_submitted": 47190
    },
    {
      "id": 251,
      "title": "Flatten 2D Vector",
      "url": "https://leetcode.com/problems/flatten-2d-vector/description",
      "companyTags": [
        "Google",
        "Twitter",
        "Airbnb",
        "Zenefits"
      ],
      "difficulty": "Medium",
      "content": "\r\nImplement an iterator to flatten a 2d vector.\r\n\r\n\r\nFor example,\r\nGiven 2d vector = \r\n\r\n[\r\n  [1,2],\r\n  [3],\r\n  [4,5,6]\r\n]\r\n\r\n\r\n\r\nBy calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,2,3,4,5,6].\r\n\r\n\r\n\r\nFollow up:\r\nAs an added challenge, try to code it using only iterators in C++ or iterators in Java.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/312",
      "similarQuestions": [
        "BinarySearchTreeIterator",
        "ZigzagIterator",
        "PeekingIterator",
        "FlattenNestedListIterator"
      ],
      "topicTags": [
        "Design"
      ],
      "Solution": "public class Vector2D implements Iterator<Integer> {\n    int indexList, indexEle;\n    List<List<Integer>> vec;\n    \n    public Vector2D(List<List<Integer>> vec2d) {\n        vec = vec2d;\n        indexList = 0;\n        indexEle = 0;\n    }\n\n    @Override\n    public Integer next() {\n        return vec.get(indexList).get(indexEle++);\n    }\n\n    @Override\n    public boolean hasNext() {\n        while (indexList<vec.size())    {\n            if (indexEle < vec.get(indexList).size())\n                return true;\n            else    {\n                indexList++;\n                indexEle=0;\n            }\n        }\n        return false;\n    }\n}\n\n/**\n * Your Vector2D object will be instantiated and called as such:\n * Vector2D i = new Vector2D(vec2d);\n * while (i.hasNext()) v[f()] = i.next();\n */",
      "total_acs": 34056,
      "total_submitted": 82644
    },
    {
      "id": 252,
      "title": "Meeting Rooms",
      "url": "https://leetcode.com/problems/meeting-rooms/description",
      "companyTags": [
        "Facebook"
      ],
      "difficulty": "Easy",
      "content": "Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si < ei), determine if a person could attend all meetings.\r\n\r\n\r\nFor example,\r\nGiven [[0, 30],[5, 10],[15, 20]],\r\nreturn false.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/316",
      "similarQuestions": [
        "MergeIntervals",
        "MeetingRoomsII"
      ],
      "topicTags": [
        "Sort"
      ],
      "Solution": "/**\n * Definition for an interval.\n * public class Interval {\n *     int start;\n *     int end;\n *     Interval() { start = 0; end = 0; }\n *     Interval(int s, int e) { start = s; end = e; }\n * }\n */\nclass Solution {\n    public boolean canAttendMeetings(Interval[] intervals) {\n        quickSort(intervals,0,intervals.length-1);\n        for(int i=1;i<intervals.length;i++){\n            if(intervals[i].start<intervals[i-1].end)\n                return false;\n        }\n        return true;\n    }\n    private int partition(Interval[] intervals,int b,int e){\n        int pv=intervals[(b+e)/2].start;\n        while(b<=e){\n            while(intervals[b].start<pv)\n                b++;\n            while(intervals[e].start>pv)\n                e--;\n            if(b<=e){\n            Interval t=intervals[b];\n            intervals[b]=intervals[e];\n            intervals[e]=t;\n            b++;\n            e--;\n            }          \n        }\n        return b;\n        \n    }\n    private void quickSort(Interval[] intervals,int i,int j){\n        if(i>=j)\n            return;\n        int m=partition(intervals,i,j);\n        quickSort(intervals,i,m-1);\n        quickSort(intervals,m,j);\n        \n    }\n}",
      "total_acs": 45617,
      "total_submitted": 93488
    },
    {
      "id": 253,
      "title": "Meeting Rooms II",
      "url": "https://leetcode.com/problems/meeting-rooms-ii/description",
      "companyTags": [
        "Google",
        "Facebook",
        "Snapchat"
      ],
      "difficulty": "Medium",
      "content": "Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si < ei), find the minimum number of conference rooms required.\r\n\r\n\r\nFor example,\r\nGiven [[0, 30],[5, 10],[15, 20]],\r\nreturn 2.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/317",
      "similarQuestions": [
        "MergeIntervals",
        "MeetingRooms",
        "MinimumNumberofArrowstoBurstBalloons"
      ],
      "topicTags": [
        "Heap",
        "Greedy",
        "Sort"
      ],
      "Solution": "/**\n * Definition for an interval.\n * public class Interval {\n *     int start;\n *     int end;\n *     Interval() { start = 0; end = 0; }\n *     Interval(int s, int e) { start = s; end = e; }\n * }\n */\nclass Solution {\n    public int minMeetingRooms(Interval[] intervals) {\n        if (intervals.length < 1 || intervals == null) return 0;\n        int[] stts = new int[intervals.length];\n        int[] ends = new int[intervals.length];\n        for (int i = 0; i < intervals.length; i++) {\n            stts[i] = intervals[i].start;\n            ends[i] = intervals[i].end;\n        }\n        Arrays.sort(stts);\n        Arrays.sort(ends);\n        int cnt = 0;\n        int idx = 0;\n        for (int i = 0; i < stts.length; i++) {\n            if (stts[i] < ends[idx]) cnt++;\n            else                     idx++;\n        }\n        return cnt;\n    }\n}",
      "total_acs": 61096,
      "total_submitted": 154619
    },
    {
      "id": 254,
      "title": "Factor Combinations",
      "url": "https://leetcode.com/problems/factor-combinations/description",
      "companyTags": [
        "Uber",
        "LinkedIn"
      ],
      "difficulty": "Medium",
      "content": "Numbers can be regarded as product of its factors. For example,  \r\n\r\n8 = 2 x 2 x 2;\r\n  = 2 x 4.\r\n\r\nWrite a function that takes an integer n and return all possible combinations of its factors. \r\n\r\n\r\nNote: \r\n\r\nYou may assume that n is always positive. \r\nFactors should be greater than 1 and less than n.\r\n\r\n\r\n\r\nExamples: \r\n input: 1\r\n output: \r\n\r\n[]\r\n\r\ninput: 37\r\n output: \r\n\r\n[]\r\n\r\n input: 12\r\n output:\r\n\r\n[\r\n  [2, 6],\r\n  [2, 2, 3],\r\n  [3, 4]\r\n]\r\n\r\n input: 32\r\n output:\r\n\r\n[\r\n  [2, 16],\r\n  [2, 2, 8],\r\n  [2, 2, 2, 4],\r\n  [2, 2, 2, 2, 2],\r\n  [2, 4, 4],\r\n  [4, 8]\r\n]\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/320",
      "similarQuestions": [
        "CombinationSum"
      ],
      "topicTags": [
        "Backtracking"
      ],
      "Solution": "class Solution {\n    private void dfs(List<List<Integer>> res, List<Integer> path, int n, int prev) {\n        for (int i = prev; i <= (int) Math.sqrt(n * 1.0); i++) {\n            if (n % i == 0) {\n                List<Integer> one = new ArrayList<>(path);\n                one.add(i);\n                one.add(n / i);\n                res.add(one);\n                path.add(i);\n                dfs(res, path, n / i, i);\n                path.remove(path.size() - 1);\n            }\n        }\n    }\n\n    public List<List<Integer>> getFactors(int n) {\n        List<List<Integer>> res = new ArrayList<>();\n        if (n < 4) {\n            return res;\n        }\n        \n        dfs(res, new ArrayList<>(), n, 2);\n        return res;\n    }\n}",
      "total_acs": 35315,
      "total_submitted": 80697
    },
    {
      "id": 255,
      "title": "Verify Preorder Sequence in Binary Search Tree",
      "url": "https://leetcode.com/problems/verify-preorder-sequence-in-binary-search-tree/description",
      "companyTags": [
        "Zenefits"
      ],
      "difficulty": "Medium",
      "content": "Given an array of numbers, verify whether it is the correct preorder traversal sequence of a binary search tree.\r\n\r\nYou may assume each number in the sequence is unique.\r\n\r\nFollow up:\r\nCould you do it using only constant space complexity?",
      "discussUrl": "https://discuss.leetcode.com/category/322",
      "similarQuestions": [
        "BinaryTreePreorderTraversal"
      ],
      "topicTags": [
        "Stack",
        "Tree"
      ],
      "Solution": "class Solution {\n    public boolean verifyPreorder(int[] preorder) {\n        // in-place stack check\n        \n        if (preorder == null || preorder.length < 1)\n            return true;\n        \n        int top = -1;\n        int sublevel = Integer.MIN_VALUE;\n        for (int x : preorder) {\n            if (x < sublevel)\n                return false;\n            while (top >= 0 && preorder[top] < x) {\n                // pop\n                sublevel = preorder[top--];\n            }\n            \n            // push\n            preorder[++top] = x;\n        }\n        \n        \n        return true;\n    }\n}",
      "total_acs": 23831,
      "total_submitted": 58301
    },
    {
      "id": 256,
      "title": "Paint House",
      "url": "https://leetcode.com/problems/paint-house/description",
      "companyTags": [
        "LinkedIn"
      ],
      "difficulty": "Easy",
      "content": "\r\nThere are a row of n houses, each house can be painted with one of the three colors: red, blue or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.\r\n\r\n\r\nThe cost of painting each house with a certain color is represented by a n x 3 cost matrix. For example, costs[0][0] is the cost of painting house 0 with color red; costs[1][2] is the cost of painting house 1 with color green, and so on... Find the minimum cost to paint all houses.\r\n\r\n\r\nNote:\r\nAll costs are positive integers.",
      "discussUrl": "https://discuss.leetcode.com/category/324",
      "similarQuestions": [
        "HouseRobber",
        "HouseRobberII",
        "PaintHouseII",
        "PaintFence"
      ],
      "topicTags": [
        "DynamicProgramming"
      ],
      "Solution": "class Solution {\n    public int minCost(int[][] costs) {\n        if (costs == null || costs.length == 0) \n            return 0;\n        int n = costs.length;\n        for (int i = 1; i < n; i++) {\n            costs[i][0] += Math.min(costs[i - 1][1], costs[i - 1][2]);\n            costs[i][1] += Math.min(costs[i - 1][0], costs[i - 1][2]);\n            costs[i][2] += Math.min(costs[i - 1][0], costs[i - 1][1]);\n        }\n        \n        return Math.min(Math.min(costs[n - 1][0], costs[n - 1][1]), costs[n - 1][2]);\n    }\n}",
      "total_acs": 32102,
      "total_submitted": 69429
    },
    {
      "id": 257,
      "title": "Binary Tree Paths",
      "url": "https://leetcode.com/problems/binary-tree-paths/description",
      "companyTags": [
        "Google",
        "Facebook",
        "Apple"
      ],
      "difficulty": "Easy",
      "content": "\r\nGiven a binary tree, return all root-to-leaf paths.\r\n\r\n\r\nFor example, given the following binary tree:\r\n\r\n\r\n\r\n   1\r\n /   \\\r\n2     3\r\n \\\r\n  5\r\n\r\n\r\n\r\nAll root-to-leaf paths are:\r\n[\"1->2->5\", \"1->3\"]\r\n\r\n\r\nCredits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/325",
      "similarQuestions": [
        "PathSumII"
      ],
      "topicTags": [
        "Tree",
        "Depth-firstSearch"
      ],
      "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<String> binaryTreePaths(TreeNode root) {\n        List<String> res = new ArrayList<String>();\n        if(root==null) return res;\n        dfs(root,res,\"\");\n        return res;\n        \n    }\n    public void dfs(TreeNode root, List<String> res, String path){\n        if(root==null) return;\n        \n        if(root.left==null && root.right==null){\n            res.add(path+root.val+\"\");\n        }\n        \n        dfs(root.left, res, path+root.val+\"->\");\n        dfs(root.right, res, path+root.val+\"->\");\n    }\n}",
      "total_acs": 146263,
      "total_submitted": 360049
    },
    {
      "id": 258,
      "title": "Add Digits",
      "url": "https://leetcode.com/problems/add-digits/description",
      "companyTags": [
        "Microsoft",
        "Adobe"
      ],
      "difficulty": "Easy",
      "content": "\r\nGiven a non-negative integer num, repeatedly add all its digits until the result has only one digit. \r\n\r\n\r\n\r\nFor example:\r\n\r\n\r\nGiven num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.\r\n\r\n\r\nFollow up:\r\nCould you do it without any loop/recursion in O(1) runtime?\r\n\r\n\r\nCredits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/326",
      "similarQuestions": [
        "HappyNumber"
      ],
      "topicTags": [
        "Math"
      ],
      "Solution": "class Solution {\n    \n    \n    public int addDigits(int num) {\n        return (num - 1) % 9 + 1;\n    }\n    \n    // public int addDigits(int num) {\n    //     if (num < 0) {\n    //         num = -num;\n    //     }\n    //     if (num < 10) {\n    //         return num;\n    //     }\n    //     int next = 0;\n    //     while (num != 0) {\n    //         next += (num % 10);\n    //         num /= 10;\n    //     }\n    //     return addDigits(next);\n    // }\n}",
      "total_acs": 187909,
      "total_submitted": 363642
    },
    {
      "id": 259,
      "title": "3Sum Smaller",
      "url": "https://leetcode.com/problems/3sum-smaller/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Medium",
      "content": "Given an array of n integers nums and a target, find the number of index triplets i, j, k with 0 <= i < j < k < n that satisfy the condition nums[i] + nums[j] + nums[k] < target.\r\n\r\nFor example, given nums = [-2, 0, 1, 3], and target = 2.\r\n\r\nReturn 2. Because there are two triplets which sums are less than 2:\r\n\r\n[-2, 0, 1]\r\n[-2, 0, 3]\r\n\r\n\r\nFollow up:\r\nCould you solve it in O(n2) runtime?\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/327",
      "similarQuestions": [
        "3Sum",
        "3SumClosest",
        "ValidTriangleNumber"
      ],
      "topicTags": [
        "Array",
        "TwoPointers"
      ],
      "Solution": "class Solution {\n    public int threeSumSmaller(int[] nums, int target) {\n        Arrays.sort(nums);\n        \n        int cnt = 0;\n        for (int i=0; i<nums.length-1; i++) {\n            int low = i+1, high = nums.length-1;\n            while (low<high) {\n               if (nums[i]+nums[low]+nums[high] < target) {\n                    cnt += high - low;\n                    low++;\n                } else {\n                    high--;\n                } \n            }\n        }\n        \n        return cnt;\n    }\n}",
      "total_acs": 33652,
      "total_submitted": 80233
    },
    {
      "id": 260,
      "title": "Single Number III",
      "url": "https://leetcode.com/problems/single-number-iii/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.\r\n\r\n\r\nFor example:\r\n\r\n\r\nGiven nums = [1, 2, 1, 3, 2, 5], return [3, 5].\r\n\r\n\r\nNote:\r\n\r\nThe order of the result is not important. So in the above example, [5, 3] is also correct.\r\nYour algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?\r\n\r\n\r\n\r\nCredits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/328",
      "similarQuestions": [
        "SingleNumber",
        "SingleNumberII"
      ],
      "topicTags": [
        "BitManipulation"
      ],
      "Solution": "class Solution {\n    public int[] singleNumber(int[] nums) {\n        if(nums == null || nums.length <= 1)\n            return new int[2];\n        int diff = nums[0];\n        for(int i = 1; i<nums.length; i++){\n            diff ^= nums[i];\n        }\n        diff &= -diff;\n        int res1 = 0, res2 = 0;\n        for(int num:nums){\n            if((num & diff) == 0){\n                res1 ^= num;\n            }\n            else{\n                res2 ^= num;\n            }\n        }\n        return new int[]{res1, res2};\n    }\n}",
      "total_acs": 78191,
      "total_submitted": 147983
    },
    {
      "id": 261,
      "title": "Graph Valid Tree",
      "url": "https://leetcode.com/problems/graph-valid-tree/description",
      "companyTags": [
        "Google",
        "Facebook",
        "Zenefits"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.\r\n\r\n\r\n\r\nFor example:\r\n\r\n\r\nGiven n = 5 and edges = [[0, 1], [0, 2], [0, 3], [1, 4]], return true.\r\n\r\n\r\nGiven n = 5 and edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]], return false.\r\n\r\n\r\n\r\nNote: you can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/330",
      "similarQuestions": [
        "CourseSchedule",
        "NumberofConnectedComponentsinanUndirectedGraph"
      ],
      "topicTags": [
        "Depth-firstSearch",
        "Breadth-firstSearch",
        "UnionFind",
        "Graph"
      ],
      "Solution": "class Solution {\n    public boolean validTree(int n, int[][] edges) {\n        // initialize n isolated islands\n        int[] nums = new int[n];\n        Arrays.fill(nums, -1);\n        \n        // perform union find\n        for (int i = 0; i < edges.length; i++) {\n            int x = find(nums, edges[i][0]);\n            int y = find(nums, edges[i][1]);\n            \n            // if two vertices happen to be in the same set\n            // then there's a cycle\n            if (x == y) return false;\n            \n            // union\n            nums[x] = y;\n        }\n        \n        return edges.length == n - 1;\n    }\n    \n    int find(int nums[], int i) {\n        if (nums[i] == -1) return i;\n        return find(nums, nums[i]);\n    }\n}",
      "total_acs": 50681,
      "total_submitted": 132064
    },
    {
      "id": 262,
      "title": "Trips and Users",
      "url": "https://leetcode.com/problems/trips-and-users/description",
      "companyTags": [
        "Uber"
      ],
      "difficulty": "Hard",
      "content": "\r\nThe Trips table holds all taxi trips. Each trip has a unique Id, while Client_Id and Driver_Id are both foreign keys to the Users_Id at the Users table. Status is an ENUM type of (‘completed’, ‘cancelled_by_driver’, ‘cancelled_by_client’).\r\n\r\n\r\n+----+-----------+-----------+---------+--------------------+----------+\r\n| Id | Client_Id | Driver_Id | City_Id |        Status      |Request_at|\r\n+----+-----------+-----------+---------+--------------------+----------+\r\n| 1  |     1     |    10     |    1    |     completed      |2013-10-01|\r\n| 2  |     2     |    11     |    1    | cancelled_by_driver|2013-10-01|\r\n| 3  |     3     |    12     |    6    |     completed      |2013-10-01|\r\n| 4  |     4     |    13     |    6    | cancelled_by_client|2013-10-01|\r\n| 5  |     1     |    10     |    1    |     completed      |2013-10-02|\r\n| 6  |     2     |    11     |    6    |     completed      |2013-10-02|\r\n| 7  |     3     |    12     |    6    |     completed      |2013-10-02|\r\n| 8  |     2     |    12     |    12   |     completed      |2013-10-03|\r\n| 9  |     3     |    10     |    12   |     completed      |2013-10-03| \r\n| 10 |     4     |    13     |    12   | cancelled_by_driver|2013-10-03|\r\n+----+-----------+-----------+---------+--------------------+----------+\r\n\r\n\r\n\r\nThe Users table holds all users. Each user has an unique Users_Id, and Role is an ENUM type of (‘client’, ‘driver’, ‘partner’).\r\n\r\n+----------+--------+--------+\r\n| Users_Id | Banned |  Role  |\r\n+----------+--------+--------+\r\n|    1     |   No   | client |\r\n|    2     |   Yes  | client |\r\n|    3     |   No   | client |\r\n|    4     |   No   | client |\r\n|    10    |   No   | driver |\r\n|    11    |   No   | driver |\r\n|    12    |   No   | driver |\r\n|    13    |   No   | driver |\r\n+----------+--------+--------+\r\n\r\n\r\nWrite a SQL query to find the cancellation rate of requests made by unbanned clients between Oct 1, 2013 and Oct 3, 2013. For the above tables, your SQL query should return the following rows with the cancellation rate being rounded to two decimal places.\r\n\r\n+------------+-------------------+\r\n|     Day    | Cancellation Rate |\r\n+------------+-------------------+\r\n| 2013-10-01 |       0.33        |\r\n| 2013-10-02 |       0.00        |\r\n| 2013-10-03 |       0.50        |\r\n+------------+-------------------+\r\n\r\n\r\nCredits:Special thanks to @cak1erlizhou for contributing this question, writing the problem description and adding part of the test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/331",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        ""
      ],
      "Solution": null,
      "total_acs": 16312,
      "total_submitted": 85907
    },
    {
      "id": 263,
      "title": "Ugly Number",
      "url": "https://leetcode.com/problems/ugly-number/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Easy",
      "content": "\r\nWrite a program to check whether a given number is an ugly number.\r\n\r\n\r\n\r\nUgly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7.\r\n\r\n\r\n\r\nNote that 1 is typically treated as an ugly number.\r\n\r\n\r\nCredits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/332",
      "similarQuestions": [
        "HappyNumber",
        "CountPrimes",
        "UglyNumberII"
      ],
      "topicTags": [
        "Math"
      ],
      "Solution": "public class Solution {\r\n    public boolean isUgly(int num) {\r\n        while (num >= 2) {\r\n            if (num % 2 == 0) {\r\n                num /= 2;\r\n            }\r\n            else if (num % 3 == 0) {\r\n                num /= 3;\r\n            }\r\n            else if (num % 5 == 0) {\r\n                num /= 5;\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n        \r\n        return num == 1;\r\n    }\r\n}",
      "total_acs": 117640,
      "total_submitted": 297228
    },
    {
      "id": 264,
      "title": "Ugly Number II",
      "url": "https://leetcode.com/problems/ugly-number-ii/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "\r\nWrite a program to find the n-th ugly number.\r\n\r\n\r\n\r\nUgly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.\r\n\r\n\r\n\r\nNote that 1 is typically treated as an ugly number, and n does not exceed 1690.\r\n\r\n\r\nCredits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/333",
      "similarQuestions": [
        "MergekSortedLists",
        "CountPrimes",
        "UglyNumber",
        "PerfectSquares",
        "SuperUglyNumber"
      ],
      "topicTags": [
        "Math",
        "DynamicProgramming",
        "Heap"
      ],
      "Solution": "class Solution {\n\tstatic int count = 2;\n\tstatic int idx2 = 1;\n\tstatic int idx3 = 1;\n\tstatic int idx5 = 1;\n\tstatic long arr[] = new long[2000];\n    public int nthUglyNumber(int n) {\n    \tarr[1] = 1;\n        for (; count <= n; count++) {\n        \tlong ftr2 = arr[idx2] * 2;\n        \tlong ftr3 = arr[idx3] * 3;\n        \tlong ftr5 = arr[idx5] * 5;\n        \tarr[count] = Math.min(Math.min(ftr2, ftr3), ftr5);\n        \tif (arr[count] == ftr2) idx2++;\n        \tif (arr[count] == ftr3) idx3++;\n        \tif (arr[count] == ftr5) idx5++;\n        }\n        return (int)arr[n];\n    }\n}",
      "total_acs": 70732,
      "total_submitted": 212830
    },
    {
      "id": 265,
      "title": "Paint House II",
      "url": "https://leetcode.com/problems/paint-house-ii/description",
      "companyTags": [
        "Facebook"
      ],
      "difficulty": "Hard",
      "content": "\r\nThere are a row of n houses, each house can be painted with one of the k colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.\r\n\r\n\r\nThe cost of painting each house with a certain color is represented by a n x k cost matrix. For example, costs[0][0] is the cost of painting house 0 with color 0; costs[1][2] is the cost of painting house 1 with color 2, and so on... Find the minimum cost to paint all houses.\r\n\r\n\r\nNote:\r\nAll costs are positive integers.\r\n\r\nFollow up:\r\nCould you solve it in O(nk) runtime?",
      "discussUrl": "https://discuss.leetcode.com/category/334",
      "similarQuestions": [
        "ProductofArrayExceptSelf",
        "SlidingWindowMaximum",
        "PaintHouse",
        "PaintFence"
      ],
      "topicTags": [
        "DynamicProgramming"
      ],
      "Solution": "class Solution {\n    public int minCostII(int[][] costs) {\n        int prevMin1 = 0, prevMin2 = 0, prevMinIndex1 = 0;\n        for (int[] cost : costs) {\n            int min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE, minIndex1 = 0;\n            \n            for (int i = 0; i < cost.length; i++) {\n                int curr = cost[i];\n                if (i == prevMinIndex1) {\n                    curr += prevMin2;\n                } else {\n                    curr += prevMin1;\n                }\n                \n                if (curr < min1) {\n                    min2 = min1;\n                    min1 = curr;\n                    minIndex1 = i;\n                } else if (curr < min2) {\n                    min2 = curr;\n                }\n            }\n            \n            prevMin1 = min1;\n            prevMin2 = min2;\n            prevMinIndex1 = minIndex1;\n        }\n        \n        return prevMin1;\n    }\n}",
      "total_acs": 28634,
      "total_submitted": 74687
    },
    {
      "id": 266,
      "title": "Palindrome Permutation",
      "url": "https://leetcode.com/problems/palindrome-permutation/description",
      "companyTags": [
        "Google",
        "Bloomberg",
        "Uber"
      ],
      "difficulty": "Easy",
      "content": "Given a string, determine if a permutation of the string could form a palindrome.\r\n\r\nFor example,\r\n\"code\" -> False, \"aab\" -> True, \"carerac\" -> True.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/335",
      "similarQuestions": [
        "LongestPalindromicSubstring",
        "ValidAnagram",
        "PalindromePermutationII",
        "LongestPalindrome"
      ],
      "topicTags": [
        "HashTable"
      ],
      "Solution": "public class Solution {\r\n    public boolean canPermutePalindrome(String s) {\r\n        \r\n        int[] chars = new int[256];\r\n        int oddNum=0;\r\n        \r\n        for(char c : s.toCharArray()){\r\n            chars[c]++;\r\n        }\r\n        \r\n        for(int i : chars){\r\n            if(i%2==1)  oddNum++;\r\n        }\r\n        \r\n        return oddNum<=1? true:false;\r\n        \r\n    }\r\n}",
      "total_acs": 41819,
      "total_submitted": 72118
    },
    {
      "id": 267,
      "title": "Palindrome Permutation II",
      "url": "https://leetcode.com/problems/palindrome-permutation-ii/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven a string s, return all the palindromic permutations (without duplicates) of it. Return an empty list if no palindromic permutation could be form.\r\n\r\n\r\nFor example:\r\n\r\n\r\nGiven s = \"aabb\", return [\"abba\", \"baab\"].\r\n\r\n\r\nGiven s = \"abc\", return [].\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/336",
      "similarQuestions": [
        "NextPermutation",
        "PermutationsII",
        "PalindromePermutation"
      ],
      "topicTags": [
        "Backtracking"
      ],
      "Solution": "class Solution {\n    public List<String> generatePalindromes(String s) {\n        List<String> result = new ArrayList<String>();\n        int[] temp = new int[256];\n        for (int i = 0; i < s.length(); i++) {\n            temp[s.charAt(i)]++;\n        }\n        int odd = 0, idx = 0;\n        char[] array = new char[s.length()];\n        for (int i = 0; i < 256; i++) {\n            if ((temp[i] & 1) == 1) {\n                if ((s.length() & 1) == 0 || ++odd > 1) {\n                    return result;\n                }\n                array[s.length() / 2] = (char)i;\n                temp[i]--;\n            }\n            while (temp[i] > 0) {\n                array[idx] = array[array.length - (++idx)] = (char)i;\n                temp[i] -= 2;\n            }\n        }\n        permute(array, 0, result);\n        return result;\n    }\n    \n    public void permute(char[] array, int idx, List<String> result) {\n        if (idx == array.length / 2) {\n            result.add(new String(array));\n            return;\n        }\n        \n        for (int i = idx; i < array.length / 2; i++) {\n            int j = idx;\n            for (; j < i && array[j] != array[i]; j++);\n            if (j == i) {\n                swap(array, idx, i);\n                swap(array, array.length - 1 - idx, array.length - 1 - i);\n                permute(array, idx + 1, result);\n                swap(array, idx, i);\n                swap(array, array.length - 1 - idx, array.length - 1 - i);\n            }\n        }\n    }\n    \n    public void swap(char[] array, int i, int j) {\n        char t = array[i];\n        array[i] = array[j];\n        array[j] = t;\n    }\n}",
      "total_acs": 17000,
      "total_submitted": 52902
    },
    {
      "id": 268,
      "title": "Missing Number",
      "url": "https://leetcode.com/problems/missing-number/description",
      "companyTags": [
        "Microsoft",
        "Bloomberg"
      ],
      "difficulty": "Easy",
      "content": "\r\nGiven an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.\r\n\r\n\r\nExample 1\r\n\r\nInput: [3,0,1]\r\nOutput: 2\r\n\r\n\r\n\r\nExample 2\r\n\r\nInput: [9,6,4,2,3,5,7,0,1]\r\nOutput: 8\r\n\r\n\r\n\r\n\r\n\r\nNote:\r\nYour algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?\r\n\r\n\r\nCredits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/337",
      "similarQuestions": [
        "FirstMissingPositive",
        "SingleNumber",
        "FindtheDuplicateNumber",
        "CouplesHoldingHands"
      ],
      "topicTags": [
        "Array",
        "Math",
        "BitManipulation"
      ],
      "Solution": "class Solution {\n    public int missingNumber(int[] nums) {\n        int total = 0;\n        for(int i = 1; i <= nums.length ;i++ ){\n            total += i;\n        }\n        for(int n : nums){\n            total -= n;\n        }\n        return total;\n    }\n}",
      "total_acs": 156091,
      "total_submitted": 348705
    },
    {
      "id": 269,
      "title": "Alien Dictionary",
      "url": "https://leetcode.com/problems/alien-dictionary/description",
      "companyTags": [
        "Google",
        "Facebook",
        "Twitter",
        "Snapchat",
        "Airbnb",
        "PocketGems"
      ],
      "difficulty": "Hard",
      "content": "\r\nThere is a new alien language which uses the latin alphabet. \r\nHowever, the order among letters are unknown to you. \r\nYou receive a list of non-empty words from the dictionary, where words are sorted lexicographically by the rules of this new language.\r\nDerive the order of letters in this language.\r\n\r\n\r\n\r\nExample 1:\r\nGiven the following words in dictionary,\r\n\r\n[\r\n  \"wrt\",\r\n  \"wrf\",\r\n  \"er\",\r\n  \"ett\",\r\n  \"rftt\"\r\n]\r\n\r\n\r\n\r\nThe correct order is: \"wertf\".\r\n\r\n\r\nExample 2:\r\nGiven the following words in dictionary,\r\n\r\n[\r\n  \"z\",\r\n  \"x\"\r\n]\r\n\r\n\r\n\r\nThe correct order is: \"zx\".\r\n\r\n\r\nExample 3:\r\nGiven the following words in dictionary,\r\n\r\n[\r\n  \"z\",\r\n  \"x\",\r\n  \"z\"\r\n]\r\n\r\n\r\n\r\nThe order is invalid, so return \"\".\r\n\r\nNote:\r\n\r\nYou may assume all letters are in lowercase.\r\nYou may assume that if a is a prefix of b, then a must appear before b in the given dictionary.\r\nIf the order is invalid, return an empty string.\r\nThere may be multiple valid order of letters, return any one of them is fine.\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/338",
      "similarQuestions": [
        "CourseScheduleII"
      ],
      "topicTags": [
        "Graph",
        "TopologicalSort"
      ],
      "Solution": "class Solution {\n    public String alienOrder(String[] words) {\n        boolean[][] graph = new boolean[26][26];\n        int[] visited = new int[26];\n        buildGraph(words, graph, visited);\n\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < 26; i++) {\n            if (visited[i] == 0) {\n                if (!dfs(graph, visited, i, sb)) return \"\";\n            }\n        }\n        return sb.reverse().toString();\n    }\n\n    private boolean dfs(boolean[][] graph, int[] visited, int i, StringBuilder ret) {\n        visited[i] = 1;\n        boolean[] temp = graph[i];\n        for (int j = 0; j < temp.length; j++) {\n            if(temp[j]){\n                if (visited[j] == 1) \n                    return false;\n                else if (visited[j] == 0 && !dfs(graph, visited, j, ret)) {\n                    return false;\n                }                \n            }\n        }\n        visited[i] = 2;\n        ret.append((char)(i + 'a'));\n        return true;\n    }\n\n    private void buildGraph(String[] words, boolean[][] graph, int[] visited) {\n        Arrays.fill(visited, -1);\n        int N = words.length;\n        \n        for (String word : words) {\n            for (char c : word.toCharArray()) {\n                visited[c - 'a'] = 0;\n            }\n        }\n        \n        for (int i = 0; i < N - 1; i++) {\n            char[] a = words[i].toCharArray();\n            char[] b = words[i + 1].toCharArray();\n            for (int j = 0; j < Math.min(a.length, b.length); j++) {\n                if (a[j] != b[j]) {\n                    graph[a[j] - 'a'][b[j] - 'a'] = true;\n                    break;\n                }\n            }\n        }\n    }\n}",
      "total_acs": 37030,
      "total_submitted": 142563
    },
    {
      "id": 270,
      "title": "Closest Binary Search Tree Value",
      "url": "https://leetcode.com/problems/closest-binary-search-tree-value/description",
      "companyTags": [
        "Google",
        "Microsoft",
        "Snapchat"
      ],
      "difficulty": "Easy",
      "content": "\r\nGiven a non-empty binary search tree and a target value, find the value in the BST that is closest to the target.\r\n\r\nNote:\r\n\r\nGiven target value is a floating point.\r\nYou are guaranteed to have only one unique value in the BST that is closest to the target.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/339",
      "similarQuestions": [
        "CountCompleteTreeNodes",
        "ClosestBinarySearchTreeValueII"
      ],
      "topicTags": [
        "BinarySearch",
        "Tree"
      ],
      "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    \n    private double minDiff;\n    private int val;\n    \n    public int closestValue(TreeNode root, double target) {\n        \n        minDiff = Math.abs(target-(double)root.val);\n        \n        val = root.val;\n        closeValue(root, target);\n        return val;\n    }\n    \n    private void closeValue(TreeNode node, double target) {\n\n        if(node == null) return;\n\n        double diff = Math.abs(target-(double)node.val);\n        //System.out.println(node.val+\" \"+diff);\n\n       if(diff < minDiff) {\n            //System.out.println(node.val+\" \"+diff+\" YYY\");\n            minDiff = diff;\n            val = node.val;\n        }\n\n        closeValue(node.left, target);\n        closeValue(node.right, target);\n    }\n}",
      "total_acs": 46479,
      "total_submitted": 114842
    },
    {
      "id": 271,
      "title": "Encode and Decode Strings",
      "url": "https://leetcode.com/problems/encode-and-decode-strings/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Medium",
      "content": "\r\nDesign an algorithm to encode a list of strings to a string. The encoded string is then sent over the network and is decoded back to the original list of strings.\r\n\r\n\r\nMachine 1 (sender) has the function:\r\n\r\nstring encode(vector<string> strs) {\r\n  // ... your code\r\n  return encoded_string;\r\n}\r\n\r\nMachine 2 (receiver) has the function:\r\n\r\nvector<string> decode(string s) {\r\n  //... your code\r\n  return strs;\r\n}\r\n\r\n\r\n\r\nSo Machine 1 does:\r\nstring encoded_string = encode(strs);\r\n\r\n\r\n\r\nand Machine 2 does:\r\nvector<string> strs2 = decode(encoded_string);\r\n\r\n\r\n\r\nstrs2 in Machine 2 should be the same as strs in Machine 1.\r\n\r\n\r\nImplement the encode and decode methods.\r\n\r\n\r\nNote:\r\n\r\nThe string may contain any possible characters out of 256 valid ascii characters. Your algorithm should be generalized enough to work on any possible characters.\r\nDo not use class member/global/static variables to store states. Your encode and decode algorithms should be stateless.\r\nDo not rely on any library method such as eval or serialize methods. You should implement your own encode/decode algorithm.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/340",
      "similarQuestions": [
        "CountandSay",
        "SerializeandDeserializeBinaryTree",
        "StringCompression",
        "CountBinarySubstrings"
      ],
      "topicTags": [
        "String"
      ],
      "Solution": "public class Codec {\n    private List<String> lastInput;\n\n    // Encodes a list of strings to a single string.\n    public String encode(List<String> strs) {\n        lastInput = strs;\n        return \"\";\n    }\n\n    // Decodes a single string to a list of strings.\n    public List<String> decode(String s) {\n        return lastInput;\n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec codec = new Codec();\n// codec.decode(codec.encode(strs));\n",
      "total_acs": 26813,
      "total_submitted": 102661
    },
    {
      "id": 272,
      "title": "Closest Binary Search Tree Value II",
      "url": "https://leetcode.com/problems/closest-binary-search-tree-value-ii/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Hard",
      "content": "\r\nGiven a non-empty binary search tree and a target value, find k values in the BST that are closest to the target.\r\n\r\nNote:\r\n\r\nGiven target value is a floating point.\r\nYou may assume k is always valid, that is: k ≤ total nodes.\r\nYou are guaranteed to have only one unique set of k values in the BST that are closest to the target.\r\n\r\nFollow up:\r\nAssume that the BST is balanced, could you solve it in less than O(n) runtime (where n = total nodes)?\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/341",
      "similarQuestions": [
        "BinaryTreeInorderTraversal",
        "ClosestBinarySearchTreeValue"
      ],
      "topicTags": [
        "Stack",
        "Tree"
      ],
      "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<Integer> closestKValues(TreeNode root, double target, int k) {\n       LinkedList<Integer> res = new LinkedList<>();\n        inOrderTra(root,target,k,res);\n        return res;\n    }\n\n    private static void inOrderTra(TreeNode root, double target, int k, LinkedList<Integer> res) {\n        if (root == null){\n            return;\n        }\n        inOrderTra(root.left,target,k,res);\n        if(res.size() < k){\n            res.add(root.val);\n        }else if(res.size() == k){\n            if(Math.abs(res.getFirst() - target) > Math.abs(root.val - target)){\n                res.removeFirst(); // earlist entry, left most leaf\n                res.addLast(root.val); //add current node\n            }else{\n                return;  // k smallest found because the rest is bigger\n            }\n        }\n        inOrderTra(root.right,target,k,res);\n    }\n}",
      "total_acs": 21559,
      "total_submitted": 54074
    },
    {
      "id": 273,
      "title": "Integer to English Words",
      "url": "https://leetcode.com/problems/integer-to-english-words/description",
      "companyTags": [
        "Facebook",
        "Microsoft"
      ],
      "difficulty": "Hard",
      "content": "\r\nConvert a non-negative integer to its english words representation. Given input is guaranteed to be less than 231 - 1.\r\n\r\n\r\nFor example,\r\n\r\n123 -> \"One Hundred Twenty Three\"\r\n12345 -> \"Twelve Thousand Three Hundred Forty Five\"\r\n1234567 -> \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"",
      "discussUrl": "https://discuss.leetcode.com/category/342",
      "similarQuestions": [
        "IntegertoRoman"
      ],
      "topicTags": [
        "Math",
        "String"
      ],
      "Solution": "class Solution {\n    /*\n    static string array need to add space\n    \n    */\n    static String[] TWENTIES = new String[] {\"\", \" One\", \" Two\", \" Three\", \" Four\", \" Five\", \" Six\",\n                                                \" Seven\", \" Eight\", \" Nine\", \" Ten\", \" Eleven\", \" Twelve\",\n                                                \" Thirteen\", \" Fourteen\", \" Fifteen\", \" Sixteen\", \" Seventeen\",\n                                                \" Eighteen\", \" Nineteen\"};\n    static String[] TENS = new String[] {\"\", \" Ten\", \" Twenty\", \" Thirty\", \" Forty\", \" Fifty\", \" Sixty\",\n                                        \" Seventy\", \" Eighty\", \" Ninety\", \" Hundred\"};\n    static String[] THOUSANDS = new String[] {\"\", \" Thousand\", \" Million\", \" Billion\"};\n\n    public String numberToWords(int num) {\n        if (num == 0) {\n            return \"Zero\";\n        }\n        int BASE = 1000;\n        String res = \"\";\n        int i = 0;\n        while (num != 0) {\n            int cur = num % BASE;\n            res = helper(cur) + (cur == 0? \"\": THOUSANDS[i]) + res;\n            num = num / BASE;\n            i++;\n        }\n        return res.substring(1, res.length());\n    }\n    public String helper(int num) {\n        if (num < 20) {\n            return TWENTIES[num];\n        }\n        if (num < 100) {\n            return TENS[num / 10] + TWENTIES[num % 10];\n        }\n        return TWENTIES[num / 100] + \" Hundred\" + helper(num % 100);\n    }\n}",
      "total_acs": 54105,
      "total_submitted": 238529
    },
    {
      "id": 274,
      "title": "H-Index",
      "url": "https://leetcode.com/problems/h-index/description",
      "companyTags": [
        "Google",
        "Facebook",
        "Bloomberg"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index.\r\n\r\n\r\n\r\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.\"\r\n\r\n\r\n\r\nFor example, given citations = [3, 0, 6, 1, 5], which means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, his h-index is 3.\r\n\r\n\r\n\r\nNote: If there are several possible values for h, the maximum one is taken as the h-index.\r\n\r\n\r\nCredits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/343",
      "similarQuestions": [
        "H-IndexII"
      ],
      "topicTags": [
        "HashTable",
        "Sort"
      ],
      "Solution": "\nclass Solution {\n    // O(N) time; O(N) space\n    public int hIndex(int[] citations) {\n        int[] papers = new int[citations.length + 1];\n        for (int c : citations) {\n            papers[Math.min(c, citations.length)]++; // attention\n        }\n        int h = citations.length;\n        int nPaper = papers[h];\n        while (nPaper < h) {\n            h--;\n            nPaper += papers[h];\n        }\n        return h;\n    }\n}\n/*\nclass Solution {\n    // O(NlgN) time; O(1) space\n    public int hIndex(int[] citations) {\n        Arrays.sort(citations);\n        int n = citations.length;\n        // binary search to find h-index\n        int lo = 0, hi = n - 1;\n        while (lo <= hi) {\n            int mid = lo + (hi - lo) / 2;\n            if (citations[mid] >= n - mid) {\n                hi = mid - 1;\n            } else {\n                lo = mid + 1;\n            }\n        }\n        return n - 1 - hi;\n    }\n}\n*/",
      "total_acs": 91847,
      "total_submitted": 272499
    },
    {
      "id": 275,
      "title": "H-Index II",
      "url": "https://leetcode.com/problems/h-index-ii/description",
      "companyTags": [
        "Facebook"
      ],
      "difficulty": "Medium",
      "content": "\r\nFollow up for H-Index: What if the citations array is sorted in ascending order? Could you optimize your algorithm?\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/344",
      "similarQuestions": [
        "H-Index"
      ],
      "topicTags": [
        "BinarySearch"
      ],
      "Solution": "class Solution {\n    public int hIndex(int[] citations) {\n        int lo = 0;\n        int hi = citations.length - 1;\n        while(lo <= hi){\n            int mid = (lo + hi) >> 1;\n            int cnt = citations.length - mid;\n            if(citations[mid] >= cnt)\n                hi = mid - 1;\n            else lo = mid + 1;\n        }\n        return citations.length - hi - 1;\n    }\n}",
      "total_acs": 59241,
      "total_submitted": 170222
    },
    {
      "id": 276,
      "title": "Paint Fence",
      "url": "https://leetcode.com/problems/paint-fence/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Easy",
      "content": "\r\nThere is a fence with n posts, each post can be painted with one of the k colors.\r\nYou have to paint all the posts such that no more than two adjacent fence posts have the same color. \r\nReturn the total number of ways you can paint the fence. \r\n\r\nNote:\r\nn and k are non-negative integers. ",
      "discussUrl": "https://discuss.leetcode.com/category/345",
      "similarQuestions": [
        "HouseRobber",
        "HouseRobberII",
        "PaintHouse",
        "PaintHouseII"
      ],
      "topicTags": [
        "DynamicProgramming"
      ],
      "Solution": "class Solution {\n    public int numWays(int n, int k) {\n        int[][] cache = new int[n+1][2];\n        return recurse(n, k, n, 0, cache) + recurse(n, k, n, 1, cache);\n    }\n    \n    \n    // using recursive relation\n    // f(i, j) = number of ways to paint first i fence ending with j same color\n    // f(i, 1) = f(i-1, 0);\n    // f(i, 0) = (k-1)*f(i-1, 0) + (k-1)*f(i-1, 1);\n    \n    public int recurse(int n, int k, int i, int j, int[][] cache) {\n        if(i<=0) return 0;\n        if(i==1) {\n            if(j==1) return 0;\n            if(j==0) return k;\n        }\n        if(cache[i][j]!=0) return cache[i][j];\n        \n        int count = 0;\n        if(j==1) count = recurse(n, k, i-1, 0, cache);\n        else count = (k-1) * (recurse(n, k, i-1, 0, cache) + recurse(n, k, i-1, 1, cache));\n        cache[i][j] = count;\n        return count;\n    }\n    \n}",
      "total_acs": 30226,
      "total_submitted": 86598
    },
    {
      "id": 277,
      "title": "Find the Celebrity",
      "url": "https://leetcode.com/problems/find-the-celebrity/description",
      "companyTags": [
        "Facebook",
        "LinkedIn"
      ],
      "difficulty": "Medium",
      "content": "\r\nSuppose you are at a party with n people (labeled from 0 to n - 1) and among them, there may exist one celebrity. The definition of a celebrity is that all the other n - 1 people know him/her but he/she does not know any of them.\r\n\r\n\r\n\r\nNow you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: \"Hi, A. Do you know B?\" to get information of whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).\r\n\r\n\r\n\r\nYou are given a helper function bool knows(a, b) which tells you whether A knows B. Implement a function int findCelebrity(n), your function should minimize the number of calls to knows.\r\n\r\n\r\n\r\nNote: There will be exactly one celebrity if he/she is in the party. Return the celebrity's label if there is a celebrity in the party. If there is no celebrity, return -1.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/347",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Array"
      ],
      "Solution": "/* The knows API is defined in the parent class Relation.\n      boolean knows(int a, int b); */\n\npublic class Solution extends Relation {\n    public int findCelebrity(int n) {\n        if (n < 2) return -1;\n        int i = 0, j = 1;\n        while (j < n) {\n            if (knows(i, j)) {\n                i = j;\n            }\n            j++;\n        }\n        for (int k = 0; k < i; k++) {\n            if (knows(i, k)) return -1;\n        }\n        for (int k = 0; k < n; k++) {\n            if (!knows(k, i)) return -1;\n        }\n        return i;\n    }\n}",
      "total_acs": 43811,
      "total_submitted": 122573
    },
    {
      "id": 278,
      "title": "First Bad Version",
      "url": "https://leetcode.com/problems/first-bad-version/description",
      "companyTags": [
        "Facebook"
      ],
      "difficulty": "Easy",
      "content": "\r\nYou are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. \r\n\r\n\r\n\r\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\r\n\r\n\r\n\r\nYou are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\r\n\r\n\r\nCredits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/348",
      "similarQuestions": [
        "SearchforaRange",
        "SearchInsertPosition",
        "GuessNumberHigherorLower"
      ],
      "topicTags": [
        "BinarySearch"
      ],
      "Solution": "/* The isBadVersion API is defined in the parent class VersionControl.\n      boolean isBadVersion(int version); */\n\npublic class Solution extends VersionControl {\n    public int firstBadVersion(int n) {\n        int lo = 1;\n        int hi = n;\n        while(lo < hi){\n            int mid = lo + (hi - lo)/2;\n            boolean isBad = isBadVersion(mid);\n            if(isBad){\n                hi = mid;\n            }else{\n                lo = mid + 1;\n            }          \n        }\n        return hi;\n    }\n}",
      "total_acs": 133634,
      "total_submitted": 514538
    },
    {
      "id": 279,
      "title": "Perfect Squares",
      "url": "https://leetcode.com/problems/perfect-squares/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n.\r\n\r\n\r\n\r\nFor example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.\r\n\r\n\r\nCredits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/349",
      "similarQuestions": [
        "CountPrimes",
        "UglyNumberII"
      ],
      "topicTags": [
        "Math",
        "DynamicProgramming",
        "Breadth-firstSearch"
      ],
      "Solution": "class Solution {\n    //1.Math Lagrange's four-square theorem, also known as Bachet's conjecture, states that every natural number can be represented as the sum of four integer squares.\n    private boolean isSquare(int n){\n        int sq = (int)Math.sqrt(n);\n        return sq*sq == n;\n    }\n    public int numSquares(int n) {\n        if(isSquare(n))\n            return 1;\n        // The result is 4 if and only if n can be written in the form of 4^k*(8*m + 7). Please refer to \n        // Legendre's three-square theorem.\n        while(n % 4 == 0){\n            n >>= 2;\n        }\n        if(n % 8 == 7)\n            return 4;\n        //check 2\n        int sq = (int)Math.sqrt(n);\n        for(int i = 1; i <= sq; i++){\n            if(isSquare(n-i*i))\n                return 2;\n        }\n        return 3;\n    }\n}",
      "total_acs": 101159,
      "total_submitted": 268168
    },
    {
      "id": 280,
      "title": "Wiggle Sort",
      "url": "https://leetcode.com/problems/wiggle-sort/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven an unsorted array nums, reorder it in-place such that nums[0] <= nums[1] >= nums[2] <= nums[3]....\r\n\r\n\r\nFor example, given nums = [3, 5, 2, 1, 6, 4], one possible answer is [1, 6, 2, 5, 3, 4].\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/350",
      "similarQuestions": [
        "SortColors",
        "WiggleSortII"
      ],
      "topicTags": [
        "Array",
        "Sort"
      ],
      "Solution": "class Solution {\n    public void wiggleSort(int[] nums) {\n\tif (nums == null || nums.length == 0) {\n\t\treturn;\n\t}\n\tboolean isIncrease = true;\n\tfor (int i = 1; i < nums.length; i++) {\n\t\tif (isIncrease) {\n\t\t\tif (nums[i] < nums[i - 1]) {\n\t\t\t\tswap(nums, i, i - 1);\n\t\t\t}\n\t\t\tisIncrease = false;\n\t\t} else {\n\t\t\tif (nums[i] > nums[i - 1]) {\n\t\t\t\tswap(nums, i, i - 1);\n\t\t\t}\n\t\t\tisIncrease = true;\n\t\t}\n\t}\n}\n\nprivate void swap(int[] nums, int i, int j) {\n\tint tem = nums[i];\n\tnums[i] = nums[j];\n\tnums[j] = tem;\n}\n}",
      "total_acs": 38784,
      "total_submitted": 66308
    },
    {
      "id": 281,
      "title": "Zigzag Iterator",
      "url": "https://leetcode.com/problems/zigzag-iterator/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven two 1d vectors, implement an iterator to return their elements alternately.\r\n\r\n\r\nFor example, given two 1d vectors:\r\n\r\nv1 = [1, 2]\r\nv2 = [3, 4, 5, 6]\r\n\r\n\r\n\r\nBy calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1, 3, 2, 4, 5, 6].\r\n\r\n\r\n\r\nFollow up: What if you are given k 1d vectors? How well can your code be extended to such cases?\r\n\r\n\r\nClarification for the follow up question - Update (2015-09-18):\r\nThe \"Zigzag\" order is not clearly defined and is ambiguous for k > 2 cases. If \"Zigzag\" does not look right to you, replace \"Zigzag\" with \"Cyclic\". For example, given the following input:\r\n\r\n[1,2,3]\r\n[4,5,6,7]\r\n[8,9]\r\n\r\nIt should return [1,4,8,2,5,9,3,6,7].\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/351",
      "similarQuestions": [
        "BinarySearchTreeIterator",
        "Flatten2DVector",
        "PeekingIterator",
        "FlattenNestedListIterator"
      ],
      "topicTags": [
        "Design"
      ],
      "Solution": "public class ZigzagIterator {\n    int v1Index;\n    int v2Index;\n    List<Integer> v1;\n    List<Integer> v2;\n    boolean flag;\n    public ZigzagIterator(List<Integer> v1, List<Integer> v2) {\n        this.v1 = v1;\n        this.v2 = v2;\n        v1Index = 0;\n        v2Index = 0;\n        flag = true;\n    }\n\n    public int next() {\n        if (flag) {\n            flag = false;\n            return v1.get(v1Index++);\n        } else {\n            flag = true;\n            return v2.get(v2Index++);\n        }\n    }\n\n    public boolean hasNext() {\n        if (v1Index >= v1.size() && v2Index >= v2.size()) {\n            return false;\n        }\n        if (flag) {\n            if (v1Index < v1.size()) {\n                return true;\n            } else {\n                flag = false;\n                return hasNext();\n            }\n        } else {\n            if (v2Index < v2.size()) {\n                return true;\n            } else {\n                flag = true;\n                return hasNext();\n            }\n        }\n    }\n}\n\n/**\n * Your ZigzagIterator object will be instantiated and called as such:\n * ZigzagIterator i = new ZigzagIterator(v1, v2);\n * while (i.hasNext()) v[f()] = i.next();\n */",
      "total_acs": 34432,
      "total_submitted": 65956
    },
    {
      "id": 282,
      "title": "Expression Add Operators",
      "url": "https://leetcode.com/problems/expression-add-operators/description",
      "companyTags": [
        "Google",
        "Facebook"
      ],
      "difficulty": "Hard",
      "content": "\r\nGiven a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators (not unary) +, -, or * between the digits so they evaluate to the target value.\r\n\r\n\r\nExamples: \r\n\"123\", 6 -> [\"1+2+3\", \"1*2*3\"] \r\n\"232\", 8 -> [\"2*3+2\", \"2+3*2\"]\r\n\"105\", 5 -> [\"1*0+5\",\"10-5\"]\r\n\"00\", 0 -> [\"0+0\", \"0-0\", \"0*0\"]\r\n\"3456237490\", 9191 -> []\r\n\r\n\r\nCredits:Special thanks to @davidtan1890 for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/352",
      "similarQuestions": [
        "EvaluateReversePolishNotation",
        "BasicCalculator",
        "BasicCalculatorII",
        "DifferentWaystoAddParentheses",
        "TargetSum"
      ],
      "topicTags": [
        "DivideandConquer"
      ],
      "Solution": "class Solution {\n    public List<String> addOperators(String num, int target) {\n        List<String> result = new ArrayList<String>();\n        if(num.length() == 0) {\n            return result;\n        }\n        char[] digits = num.toCharArray();\n        char[] tempString = new char[digits.length * 2];\n        long n = 0;\n        for(int i = 0; i < digits.length; i++) {\n            if(i != 0 && digits[0] == '0') {\n                break;\n            }\n            n = n * 10 + digits[i] - '0';\n            tempString[i] = digits[i];\n            backtracking(digits, i + 1, target, n, n, tempString, i + 1, result);\n        }\n        // backtracking(digits, 0, target, 0, 0, tempString, 0, result);\n        return result;\n    }\n    private void backtracking(char[] digits, int index, int target, long prevNum, long value, char[] tempString, int length, List<String> result) {\n        if(index == digits.length) {\n            if(value == target) {\n                result.add(new String(tempString, 0, length));\n            }\n            return;\n        }\n        // System.out.println(value);\n        long n = 0;\n        int j = length + 1;\n        for(int i = index; i < digits.length; i++) {\n            if(i != index && digits[index] == '0') {\n                break;\n            }\n            n = n * 10 + digits[i] - '0';\n            tempString[j++] = digits[i];\n            // if(index == 0) {\n            //     backtracking(digits, i + 1, target, n, value + n, tempString, j, result);\n            // }\n            // else {\n                // +\n                tempString[length] = '+';\n                backtracking(digits, i + 1, target, n, value + n, tempString, j, result);\n                // -\n                tempString[length] = '-';\n                backtracking(digits, i + 1, target, -n, value - n, tempString, j, result);\n                // *\n                tempString[length] = '*';\n                backtracking(digits, i + 1, target, prevNum * n, value - prevNum + prevNum * n, tempString, j, result);\n            // }\n        }\n        \n    }\n}\n\n// class Solution {\n//     public List<String> addOperators(String num, int target) {\n//         List<String> result = new ArrayList<String>();\n//         if(num.length() == 0) {\n//             return result;\n//         }\n//         backtracking(num, 0, target, 0, 0, \"\", result);\n//         return result;\n//     }\n//     private void backtracking(String num, int index, int target, long prevNum, long value, String tempString, List<String> result) {\n//         if(index == num.length()) {\n//             if(value == target) {\n//                 result.add(tempString);\n//             }\n//             return;\n//         }\n//         for(int i = index + 1; i <= num.length(); i++) {\n//             if(i != index + 1 && num.charAt(index) == '0') {\n//                 break;\n//             }\n//             long n = Long.parseLong(num.substring(index, i));\n//             if(index == 0) {\n//                 backtracking(num, i, target, n, value + n, tempString + n, result);\n//             }\n//             else {\n//                 backtracking(num, i, target, n, value + n, tempString + \"+\" + n, result);\n//                 backtracking(num, i, target, -n, value - n, tempString + \"-\" + n, result);\n//                 backtracking(num, i, target, prevNum * n, value - prevNum + prevNum * n, tempString + \"*\" + n, result);\n//             }\n//         }\n        \n//     }\n// }",
      "total_acs": 43871,
      "total_submitted": 143597
    },
    {
      "id": 283,
      "title": "Move Zeroes",
      "url": "https://leetcode.com/problems/move-zeroes/description",
      "companyTags": [
        "Facebook",
        "Bloomberg"
      ],
      "difficulty": "Easy",
      "content": "\r\nGiven an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.\r\n\r\n\r\n\r\nFor example, given nums  = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].\r\n\r\n\r\n\r\nNote:\r\n\r\nYou must do this in-place without making a copy of the array.\r\nMinimize the total number of operations.\r\n\r\n\r\n\r\nCredits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/353",
      "similarQuestions": [
        "RemoveElement"
      ],
      "topicTags": [
        "Array",
        "TwoPointers"
      ],
      "Solution": "class Solution {\n    public void moveZeroes(int[] nums) {\n        if(nums.length < 2) return;\n        int k = 0;\n        for(int i = 0; i < nums.length; i++) {\n            if(nums[i] != 0) {\n                nums[k++] = nums[i];\n            }\n        }\n        for(;k < nums.length; k++)\n            nums[k] = 0;\n    }\n}",
      "total_acs": 259575,
      "total_submitted": 506364
    },
    {
      "id": 284,
      "title": "Peeking Iterator",
      "url": "https://leetcode.com/problems/peeking-iterator/description",
      "companyTags": [
        "Google",
        "Apple",
        "Yahoo"
      ],
      "difficulty": "Medium",
      "content": "Given an Iterator class interface with methods: next() and hasNext(), design and implement a PeekingIterator that support the peek() operation -- it essentially peek() at the element that will be returned by the next call to next().\r\n\r\n\r\nHere is an example. Assume that the iterator is initialized to the beginning of the list: [1, 2, 3].\r\n\r\nCall next() gets you 1, the first element in the list.\r\n\r\nNow you call peek() and it returns 2, the next element. Calling next() after that still return 2.\r\n\r\nYou call next() the final time and it returns 3, the last element. Calling hasNext() after that should return false.\r\n\r\n\r\nFollow up: How would you extend your design to be generic and work with all types, not just integer?\r\n\r\nCredits:Special thanks to @porker2008 for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/354",
      "similarQuestions": [
        "BinarySearchTreeIterator",
        "Flatten2DVector",
        "ZigzagIterator"
      ],
      "topicTags": [
        "Design"
      ],
      "Solution": "// Java Iterator interface reference:\n// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html\nclass PeekingIterator implements Iterator<Integer> {\n    Iterator mIterator;\n    Integer next = null; \n\n\tpublic PeekingIterator(Iterator<Integer> iterator) {\n\t    mIterator = iterator;   \n        if (mIterator.hasNext()) {\n            next = (Integer)mIterator.next();\n        } \n\t}\n\n    // Returns the next element in the iteration without advancing the iterator.\n\tpublic Integer peek() {\n        return next;\n\t}\n\n\t// hasNext() and next() should behave the same as in the Iterator interface.\n\t// Override them if needed.\n\t@Override\n\tpublic Integer next() {\n\t    Integer res = next;\n        next = mIterator.hasNext() ? (Integer)mIterator.next() : null;\n        return res;\n\t}\n\n\t@Override\n\tpublic boolean hasNext() {\n\t    return next!=null;\n\t}\n}",
      "total_acs": 51710,
      "total_submitted": 145518
    },
    {
      "id": 285,
      "title": "Inorder Successor in BST",
      "url": "https://leetcode.com/problems/inorder-successor-in-bst/description",
      "companyTags": [
        "Facebook",
        "Microsoft",
        "PocketGems"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven a binary search tree and a node in it, find the in-order successor of that node in the BST.\r\n\r\n\r\n\r\nNote: If the given node has no in-order successor in the tree, return null.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/355",
      "similarQuestions": [
        "BinaryTreeInorderTraversal",
        "BinarySearchTreeIterator"
      ],
      "topicTags": [
        "Tree"
      ],
      "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {\n        if (root == null) {\n            return root;\n        }\n        if (p.val < root.val) {\n            // p is on the left of current\n            TreeNode left = inorderSuccessor(root.left, p);\n            if (left == null) {\n                return root;\n            } else {\n                return left;\n            }\n        } else {\n            // p is on the right of current\n            return inorderSuccessor(root.right, p);\n        }\n    }\n}",
      "total_acs": 53026,
      "total_submitted": 147248
    },
    {
      "id": 286,
      "title": "Walls and Gates",
      "url": "https://leetcode.com/problems/walls-and-gates/description",
      "companyTags": [
        "Google",
        "Facebook"
      ],
      "difficulty": "Medium",
      "content": "\r\nYou are given a m x n 2D grid initialized with these three possible values.\r\n\r\n\r\n-1 - A wall or an obstacle.\r\n0 - A gate.\r\nINF - Infinity means an empty room. We use the value 231 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647.\r\n\r\n\r\n\r\nFill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF.\r\n\r\n\r\nFor example, given the 2D grid:\r\n\r\nINF  -1  0  INF\r\nINF INF INF  -1\r\nINF  -1 INF  -1\r\n  0  -1 INF INF\r\n\r\n\r\n\r\nAfter running your function, the 2D grid should be:\r\n\r\n  3  -1   0   1\r\n  2   2   1  -1\r\n  1  -1   2  -1\r\n  0  -1   3   4\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/358",
      "similarQuestions": [
        "SurroundedRegions",
        "NumberofIslands",
        "ShortestDistancefromAllBuildings"
      ],
      "topicTags": [
        "Breadth-firstSearch"
      ],
      "Solution": "class Solution {\n    public void wallsAndGates(int[][] rooms) {\n        int nRow = rooms.length;\n        if (nRow < 1) {\n            return;\n        }\n        int nCol = rooms[0].length;\n        \n        for (int r = 0; r < nRow; r++) {\n            for (int c = 0; c < nCol; c++) {\n                if (rooms[r][c] == 0) {\n                    dfs(rooms, r, c, 0);\n                }\n            }\n        }\n    }\n    \n    private void dfs(int[][] rooms, int r, int c, int dist) {\n        if (r < 0 || r >= rooms.length || c < 0 || c >= rooms[0].length) {\n            return;\n        }\n        if (dist != 0 && rooms[r][c] <= dist) {\n            return;\n        }\n        rooms[r][c] = dist;\n        dfs(rooms, r+1, c, dist+1);\n        dfs(rooms, r-1, c, dist+1);\n        dfs(rooms, r, c-1, dist+1);\n        dfs(rooms, r, c+1, dist+1);\n    }\n}",
      "total_acs": 42739,
      "total_submitted": 94500
    },
    {
      "id": 287,
      "title": "Find the Duplicate Number",
      "url": "https://leetcode.com/problems/find-the-duplicate-number/description",
      "companyTags": [
        "Bloomberg"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.\r\n\r\n\r\n\r\nNote:\r\n\r\nYou must not modify the array (assume the array is read only).\r\nYou must use only constant, O(1) extra space.\r\nYour runtime complexity should be less than O(n2).\r\nThere is only one duplicate number in the array, but it could be repeated more than once.\r\n\r\n\r\n\r\nCredits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/359",
      "similarQuestions": [
        "FirstMissingPositive",
        "SingleNumber",
        "LinkedListCycleII",
        "MissingNumber",
        "SetMismatch"
      ],
      "topicTags": [
        "Array",
        "TwoPointers",
        "BinarySearch"
      ],
      "Solution": "class Solution {\n    public int findDuplicate(int[] nums) {\n        if (nums.length <= 1) return -1;\n        int s = nums[0];\n        int f = nums[nums[0]];\n        while (s != f){\n            s = nums[s];\n            f = nums[nums[f]];\n        }\n        int a = 0;\n        while (a != s){\n            a = nums[a];\n            s = nums[s];\n        }\n        return a;\n    }\n}",
      "total_acs": 97374,
      "total_submitted": 220636
    },
    {
      "id": 288,
      "title": "Unique Word Abbreviation",
      "url": "https://leetcode.com/problems/unique-word-abbreviation/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Medium",
      "content": "An abbreviation of a word follows the form <first letter><number><last letter>. Below are some examples of word abbreviations:\r\n\r\na) it                      --> it    (no abbreviation)\r\n\r\n     1\r\nb) d|o|g                   --> d1g\r\n\r\n              1    1  1\r\n     1---5----0----5--8\r\nc) i|nternationalizatio|n  --> i18n\r\n\r\n              1\r\n     1---5----0\r\nd) l|ocalizatio|n          --> l10n\r\n\r\n\r\nAssume you have a dictionary and given a word, find whether its abbreviation is unique in the dictionary. A word's abbreviation is unique if no other word from the dictionary has the same abbreviation.\r\n\r\nExample: \r\n\r\nGiven dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ]\r\n\r\nisUnique(\"dear\") -> false\r\nisUnique(\"cart\") -> true\r\nisUnique(\"cane\") -> false\r\nisUnique(\"make\") -> true\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/360",
      "similarQuestions": [
        "TwoSumIII-Datastructuredesign",
        "GeneralizedAbbreviation"
      ],
      "topicTags": [
        "HashTable",
        "Design"
      ],
      "Solution": "class ValidWordAbbr {\n    /*\n        If there is more than one string belong to the same key\n        then the key will be invalid, we set the value to \"\"\n    */\n    Map<String, String> map;\n    public ValidWordAbbr(String[] dictionary) {\n        map = new HashMap<String, String>();\n        for (String word : dictionary) {\n            String key = toAbbr(word);\n            if (!map.containsKey(key))\n                map.put(key, word);\n            else if (!map.get(key).equals(word))\n                map.put(key, \"\");\n        }\n    }\n    \n    public boolean isUnique(String word) {\n        String key = toAbbr(word);\n        return !map.containsKey(key) || map.get(key).equals(word);\n    }\n    \n    private String toAbbr(String str) {\n        if (str.length() <= 2)\n            return str;\n        else \n            return str.charAt(0) + String.valueOf(str.length() - 2) + str.charAt(str.length() - 1);\n    }\n}\n\n/**\n * Your ValidWordAbbr object will be instantiated and called as such:\n * ValidWordAbbr obj = new ValidWordAbbr(dictionary);\n * boolean param_1 = obj.isUnique(word);\n */",
      "total_acs": 30966,
      "total_submitted": 175166
    },
    {
      "id": 289,
      "title": "Game of Life",
      "url": "https://leetcode.com/problems/game-of-life/description",
      "companyTags": [
        "Google",
        "Snapchat",
        "Dropbox",
        "TwoSigma"
      ],
      "difficulty": "Medium",
      "content": "\r\nAccording to the Wikipedia's article: \"The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.\"\r\n\r\n\r\n\r\nGiven a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):\r\n\r\n\r\n\r\n\r\nAny live cell with fewer than two live neighbors dies, as if caused by under-population.\r\nAny live cell with two or three live neighbors lives on to the next generation.\r\nAny live cell with more than three live neighbors dies, as if by over-population..\r\nAny dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\r\n\r\n\r\n\r\n\r\nWrite a function to compute the next state (after one update) of the board given its current state.\r\n\r\n\r\nFollow up: \r\n\r\nCould you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells.\r\nIn this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?\r\n\r\n\r\n\r\nCredits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/363",
      "similarQuestions": [
        "SetMatrixZeroes"
      ],
      "topicTags": [
        "Array"
      ],
      "Solution": "class Solution {\n    public void gameOfLife(int[][] board) {\n        if(board == null || board.length == 0 || board[0].length == 0){\n            return;\n        }\n        \n        int[][] dirs = new int[][]{{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\n        int m = board.length, n = board[0].length;\n        \n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                int cnt = 0;                \n                for(int[] dir : dirs){\n                    int x = i + dir[0];\n                    int y = j + dir[1];\n                    if(x >= 0 && x < m && y >= 0 && y < n && (board[x][y] == 1 || board[x][y] == 2)){\n                        cnt++;\n                    }\n                }\n                \n                if(board[i][j] == 1 && (cnt < 2 || cnt > 3)){\n                    board[i][j] = 2;\n                }\n                if(board[i][j] == 0 && cnt == 3){\n                    board[i][j] = 3;\n                }\n            }\n        }\n        \n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                board[i][j] %= 2;\n            }\n        }\n    }\n}",
      "total_acs": 62156,
      "total_submitted": 166825
    },
    {
      "id": 290,
      "title": "Word Pattern",
      "url": "https://leetcode.com/problems/word-pattern/description",
      "companyTags": [
        "Uber",
        "Dropbox"
      ],
      "difficulty": "Easy",
      "content": "Given a pattern and a string str, find if str follows the same pattern.\r\n Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str.\r\n\r\nExamples:\r\n\r\npattern = \"abba\", str = \"dog cat cat dog\" should return true.\r\npattern = \"abba\", str = \"dog cat cat fish\" should return false.\r\npattern = \"aaaa\", str = \"dog cat cat dog\" should return false.\r\npattern = \"abba\", str = \"dog dog dog dog\" should return false.\r\n\r\n\r\n\r\n\r\nNotes:\r\nYou may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space.\r\n\r\n\r\nCredits:Special thanks to @minglotus6 for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/364",
      "similarQuestions": [
        "IsomorphicStrings",
        "WordPatternII"
      ],
      "topicTags": [
        "HashTable"
      ],
      "Solution": "class Solution {\n    public boolean wordPattern(String pattern, String str) {\n        String[] map=new String[256];\n        Set<String> set=new HashSet<>();\n        int n=pattern.length();\n        int i=0,j=0;\n        while(i<n){\n            int k=j;\n            while(k<str.length() && str.charAt(k)!=' ') k++;\n            if(k==j) return false;\n            char x=pattern.charAt(i);\n            String word=str.substring(j,k);\n            if(map[x]!=null && !map[x].equals(word))return false;\n            else if(map[x]==null && set.contains(word)) return false;\n            else if(map[x]==null) {\n                map[x]=word;\n                set.add(word);\n                \n            }\n            i++;\n            j=k;\n            while(j<str.length() && str.charAt(j)==' ')j++;\n        }\n        return (i==n && j==str.length());\n    }\n}",
      "total_acs": 97313,
      "total_submitted": 291721
    },
    {
      "id": 291,
      "title": "Word Pattern II",
      "url": "https://leetcode.com/problems/word-pattern-ii/description",
      "companyTags": [
        "Uber",
        "Dropbox"
      ],
      "difficulty": "Hard",
      "content": "Given a pattern and a string str, find if str follows the same pattern.\r\n Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty substring in str.\r\n\r\nExamples:\r\n\r\npattern = \"abab\", str = \"redblueredblue\" should return true.\r\npattern = \"aaaa\", str = \"asdasdasdasd\" should return true.\r\npattern = \"aabb\", str = \"xyzabcxzyabc\" should return false.\r\n\r\n\r\n\r\n\r\nNotes:\r\nYou may assume both pattern and str contains only lowercase letters.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/365",
      "similarQuestions": [
        "WordPattern"
      ],
      "topicTags": [
        "Backtracking"
      ],
      "Solution": "class Solution {\n    //Solution 4: BEST\n    public boolean wordPatternMatch(String pattern, String str) {\n        String[] map = new String[26]; // mapping of characters 'a' - 'z'\n        HashSet<String> set = new HashSet<>(); // mapped result of 'a' - 'z'\n        return wordPatternMatch(pattern, str, map, set, 0, str.length()-1, 0, pattern.length()-1);\n    }\n    private boolean wordPatternMatch(String pattern, String str, String[] map, HashSet<String> set, int start, int end, int startP, int endP) {\n        if(startP==endP+1 && start==end+1) return true; // both pattern and str are exhausted\n        if((startP>endP && start<=end) || (startP<endP && start>end)) return false; // either of pattern or str is exhausted\n\n        char ch = pattern.charAt(startP);\n        String matched = map[ch-'a'];\n        if(matched!=null) { // ch is already mapped, then continue\n            int count = matched.length();\n            return start+count<=end+1 && matched.equals(str.substring(start, start+count)) // substring equals previously mapped string\n                    && wordPatternMatch(pattern, str, map, set, start+matched.length(), end, startP+1, endP); // moving forward\n        }\n        else {\n            int endPoint = end;\n            for(int i=endP; i>startP; i--) {\n                endPoint -= map[pattern.charAt(i)-'a']==null ? 1 : map[pattern.charAt(i)-'a'].length();\n            }\n            for(int i=start; i<=endPoint; i++) { // try every possible mapping, from 1 character to the end\n                matched = str.substring(start, i+1);\n                if(set.contains(matched)) continue; // different pattern cannot map to same substring\n\n                map[ch-'a'] = matched; // move forward, add corresponding mapping and set content\n                set.add(matched);\n\n                if(wordPatternMatch(pattern, str, map, set, i+1, end, startP+1, endP)) return true;\n\n                else { // backtracking, remove corresponding mapping and set content\n                    map[ch-'a'] = null;\n                    set.remove(matched);\n                }\n            }\n        }\n        return false; // exhausted\n    }\n\n    //Solution 3: Combine solution 1 and solution 2\n    //Time: 58 ms, 88%\n    /*\n    private String[] map;\n    private Set<String> set;\n    public boolean wordPatternMatch(String pattern, String str) {\n        map = new String[26];\n        set = new HashSet<>();\n\n        return isMatch(str, 0, pattern, 0);\n    }\n\n    boolean isMatch(String str, int i, String pat, int j) {\n        // base case\n        if (i == str.length() && j == pat.length()) return true;\n        if (i == str.length() || j == pat.length()) return false;\n\n        // get current pattern character\n        int mIdx = pat.charAt(j) - 'a';\n\n        // if the pattern character exists\n        if (map[mIdx] != null) {\n          String s = map[mIdx];\n\n          // then check if we can use it to match str[i...i+s.length()]\n          if (!str.startsWith(s, i)) {\n            return false;\n          }\n\n          // if it can match, great, continue to match the rest\n          return isMatch(str, i + s.length(), pat, j + 1);\n        }\n\n        // pattern character does not exist in the map\n        for (int endIdx = i; endIdx < str.length(); endIdx++) {\n          String p = str.substring(i, endIdx + 1);\n\n          if (set.contains(p)) {\n            continue;\n          }\n\n          // create or update it\n          map[mIdx] = p;\n          set.add(p);\n\n          // continue to match the rest\n          if (isMatch(str, endIdx + 1, pat, j + 1)) {\n            return true;\n          }\n\n          // backtracking\n          map[mIdx] = null;\n          set.remove(p);\n        }\n\n        // we've tried our best but still no luck\n        return false;\n    }\n    */\n    \n    \n    //Solution 2: Same with Solution 1 but clean!\n    //Time: 110 ms - 91 ms, 35% - 57%\n    /*\n    public boolean wordPatternMatch(String pattern, String str) {\n        Map<Character, String> map = new HashMap<>();\n        Set<String> set = new HashSet<>();\n\n        return isMatch(str, 0, pattern, 0, map, set);\n    }\n\n    boolean isMatch(String str, int i, String pat, int j, Map<Character, String> map, Set<String> set) {\n        // base case\n        if (i == str.length() && j == pat.length()) return true;\n        if (i == str.length() || j == pat.length()) return false;\n\n        // get current pattern character\n        char c = pat.charAt(j);\n\n        // if the pattern character exists\n        if (map.containsKey(c)) {\n          String s = map.get(c);\n\n          // then check if we can use it to match str[i...i+s.length()]\n          if (!str.startsWith(s, i)) {\n            return false;\n          }\n\n          // if it can match, great, continue to match the rest\n          return isMatch(str, i + s.length(), pat, j + 1, map, set);\n        }\n\n        // pattern character does not exist in the map\n        for (int k = i; k < str.length(); k++) {\n          String p = str.substring(i, k + 1);\n\n          if (set.contains(p)) {\n            continue;\n          }\n\n          // create or update it\n          map.put(c, p);\n          set.add(p);\n\n          // continue to match the rest\n          if (isMatch(str, k + 1, pat, j + 1, map, set)) {\n            return true;\n          }\n\n          // backtracking\n          map.remove(c);\n          set.remove(p);\n        }\n\n        // we've tried our best but still no luck\n        return false;\n    }\n    */\n\n    //Solution 1: Set & Map & DFS\n    //Time: 108 ms, 35%\n    /*\n    private Set<String> set;\n    private String[] map;\n    public boolean wordPatternMatch(String pattern, String str) {\n        set = new HashSet<>();\n        map = new String[26];\n        return dfs(pattern, 0, str, 0);\n    }\n    \n    private boolean dfs(String pattern, int pIdx, String str, int sIdx) {\n        if (pIdx == pattern.length() && sIdx == str.length()) {\n            return true;\n        }\n        \n        if (pIdx >= pattern.length() || sIdx >= str.length()) {\n            return false;\n        }\n        \n        boolean result = false;\n        int mapIdx = pattern.charAt(pIdx) - 'a';\n        if (map[mapIdx] != null) {\n            int endIdx = sIdx + map[mapIdx].length();\n            if (endIdx > str.length()) {\n                return false;\n            }\n            String sub = str.substring(sIdx, endIdx);\n            if (!sub.equals(map[mapIdx])) {\n                return false;\n            }\n            result |= dfs(pattern, pIdx + 1, str, endIdx);\n        } else {\n            for (int endIdx = sIdx + 1; endIdx <= str.length(); endIdx++) {\n                String sub = str.substring(sIdx, endIdx);\n                if (set.contains(sub)) {\n                    continue;\n                }\n                map[mapIdx] = sub;\n                set.add(sub);\n                result |= dfs(pattern, pIdx + 1, str, endIdx);\n                //backtrack\n                map[mapIdx] = null;\n                set.remove(sub);\n            }\n        }\n        \n        return result;\n    }\n    */\n}",
      "total_acs": 20742,
      "total_submitted": 53914
    },
    {
      "id": 292,
      "title": "Nim Game",
      "url": "https://leetcode.com/problems/nim-game/description",
      "companyTags": [
        "Adobe"
      ],
      "difficulty": "Easy",
      "content": "\r\nYou are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.\r\n\r\n\r\n\r\nBoth of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.\r\n\r\n\r\n\r\nFor example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.\r\n\r\n\r\nCredits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/366",
      "similarQuestions": [
        "FlipGameII"
      ],
      "topicTags": [
        "Brainteaser"
      ],
      "Solution": "class Solution {\n    public boolean canWinNim(int n) {\n        if(n<=0)\n            throw new IllegalArgumentException();\n        return n%4!=0;\n    }\n}",
      "total_acs": 154437,
      "total_submitted": 278972
    },
    {
      "id": 293,
      "title": "Flip Game",
      "url": "https://leetcode.com/problems/flip-game/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Easy",
      "content": "\r\nYou are playing the following Flip Game with your friend: Given a string that contains only these two characters: + and -, you and your friend take turns to flip two consecutive \"++\" into \"--\". The game ends when a person can no longer make a move and therefore the other person will be the winner.\r\n\r\n\r\n\r\nWrite a function to compute all possible states of the string after one valid move.\r\n\r\n\r\n\r\nFor example, given s = \"++++\", after one move, it may become one of the following states:\r\n[\r\n  \"--++\",\r\n  \"+--+\",\r\n  \"++--\"\r\n]\r\n\r\n\r\n\r\n\r\nIf there is no valid move, return an empty list [].",
      "discussUrl": "https://discuss.leetcode.com/category/367",
      "similarQuestions": [
        "FlipGameII"
      ],
      "topicTags": [
        "String"
      ],
      "Solution": "class Solution {\npublic List<String> generatePossibleNextMoves(String s) {\n    List list = new ArrayList();\n    for (int i=-1; (i = s.indexOf(\"++\", i+1)) >= 0; )\n        list.add(s.substring(0, i) + \"--\" + s.substring(i+2));\n    return list;\n}\n}",
      "total_acs": 30441,
      "total_submitted": 53361
    },
    {
      "id": 294,
      "title": "Flip Game II",
      "url": "https://leetcode.com/problems/flip-game-ii/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Medium",
      "content": "\r\nYou are playing the following Flip Game with your friend: Given a string that contains only these two characters: + and -, you and your friend take turns to flip two consecutive \"++\" into \"--\". The game ends when a person can no longer make a move and therefore the other person will be the winner.\r\n\r\n\r\n\r\nWrite a function to determine if the starting player can guarantee a win.\r\n\r\n\r\n\r\nFor example, given s = \"++++\", return true. The starting player can guarantee a win by flipping the middle \"++\" to become \"+--+\".\r\n\r\n\r\nFollow up:\r\nDerive your algorithm's runtime complexity.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/368",
      "similarQuestions": [
        "NimGame",
        "FlipGame",
        "GuessNumberHigherorLowerII",
        "CanIWin"
      ],
      "topicTags": [
        "Backtracking"
      ],
      "Solution": "class Solution {\n    public boolean canWin(String s) {\n        if (s.length() <= 1) return false;\n        List<Integer> plus = new ArrayList<>();\n        int max = 0;\n        int cur = 0;\n        for (int i=0; i<s.length(); i++) {\n            if (s.charAt(i)=='+') cur++;\n            else {\n                if (cur>=2) {\n                    plus.add(cur);\n                }\n                max = Math.max(max, cur);\n                cur = 0;\n            }\n        }\n        if (cur!=0) {\n            if (cur>=2) {\n                plus.add(cur);\n            }\n            max = Math.max(max, cur);\n            cur = 0;\n        }\n        if (max <= 1) return false;\n        int[] dp = new int[max+1];\n        dp[0] = 0;\n        dp[1] = 0;\n        for (int i=2; i<=max; i++) {\n            Set<Integer> set = new HashSet<>();\n            for (int j=0; j<=(i-2)/2; j++) {\n                set.add(dp[j]^dp[i-2-j]);\n            }\n            dp[i] = fmn(set);\n        }\n        int res = 0;\n        for (Integer i: plus) {\n            res ^= dp[i];\n        }\n        return res>0;\n    }\n    \n    public int fmn(Set<Integer> set) {\n        int size = set.size();\n        for (int i=0; i<size; i++) {\n            if (!set.contains(i)) return i;\n        }\n        return size;\n    }\n}",
      "total_acs": 31523,
      "total_submitted": 67342
    },
    {
      "id": 295,
      "title": "Find Median from Data Stream",
      "url": "https://leetcode.com/problems/find-median-from-data-stream/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Hard",
      "content": "Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.\r\nExamples: \r\n[2,3,4] , the median is 3\r\n[2,3], the median is (2 + 3) / 2 = 2.5 \r\n\r\n\r\nDesign a data structure that supports the following two operations:\r\n\r\n\r\nvoid addNum(int num) - Add a integer number from the data stream to the data structure.\r\ndouble findMedian() - Return the median of all elements so far.\r\n\r\n\r\n\r\nFor example:\r\n\r\naddNum(1)\r\naddNum(2)\r\nfindMedian() -> 1.5\r\naddNum(3) \r\nfindMedian() -> 2\r\n\r\n\r\nCredits:Special thanks to @Louis1992 for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/372",
      "similarQuestions": [
        "SlidingWindowMedian"
      ],
      "topicTags": [
        "Heap",
        "Design"
      ],
      "Solution": "class MedianFinder {\n    \n    private PriorityQueue<Integer> _maxHeap;\n    private PriorityQueue<Integer> _minHeap;\n    \n    public MedianFinder(){\n        _maxHeap = new PriorityQueue<>((o1,o2) -> o2-o1);\n        _minHeap = new PriorityQueue<>((o1,o2) -> o1-o2);\n    }\n    \n    public void addNum(int num){\n        // 1 add\n                \n        if (_maxHeap.size()<1 || num <= _maxHeap.peek()){\n            _maxHeap.add(num);\n        } else {            \n            _minHeap.add(num);            \n        }\n\n        \n        // 2 rebalance\n        if (_maxHeap.size() + 2 == _minHeap.size()){\n            _maxHeap.add(_minHeap.poll());            \n        } \n        if (_minHeap.size() + 2 == _maxHeap.size()){\n            _minHeap.add(_maxHeap.poll());\n        }\n        \n        \n    }\n    public double findMedian(){\n        if (_maxHeap.size()==_minHeap.size()){\n            return (_maxHeap.peek()+_minHeap.peek())/2.0;\n        } else if (_maxHeap.size() > _minHeap.size()) {\n            return _maxHeap.peek();\n        } else {\n            return _minHeap.peek();\n        }\n    }\n}\n\n/**\n * Your MedianFinder object will be instantiated and called as such:\n * MedianFinder obj = new MedianFinder();\n * obj.addNum(num);\n * double param_2 = obj.findMedian();\n */",
      "total_acs": 55523,
      "total_submitted": 191893
    },
    {
      "id": 296,
      "title": "Best Meeting Point",
      "url": "https://leetcode.com/problems/best-meeting-point/description",
      "companyTags": [
        "Twitter"
      ],
      "difficulty": "Hard",
      "content": "A group of two or more people wants to meet and minimize the total travel distance. You are given a 2D grid of values 0 or 1, where each 1 marks the home of someone in the group. The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.\r\n\r\nFor example, given three people living at (0,0), (0,4), and (2,2):\r\n\r\n1 - 0 - 0 - 0 - 1\r\n|   |   |   |   |\r\n0 - 0 - 0 - 0 - 0\r\n|   |   |   |   |\r\n0 - 0 - 1 - 0 - 0\r\n\r\nThe point (0,2) is an ideal meeting point, as the total travel distance of 2+2+2=6 is minimal. So return 6.",
      "discussUrl": "https://discuss.leetcode.com/category/374",
      "similarQuestions": [
        "ShortestDistancefromAllBuildings",
        "MinimumMovestoEqualArrayElementsII"
      ],
      "topicTags": [
        "Math",
        "Sort"
      ],
      "Solution": "class Solution {\n    public int minTotalDistance(int[][] grid) {\n        int m = grid.length, n = grid[0].length;\n        int[] row_sum = new int[m], col_sum = new int[n];\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                row_sum[i] += grid[i][j];\n                col_sum[j] += grid[i][j];\n            }\n        }\n        return minDistance1D(row_sum) + minDistance1D(col_sum);\n    }\n    \n    private int minDistance1D(int[] arr) {\n        int i = -1, j = arr.length;\n        int d = 0, left = 0, right = 0;\n        while (i != j) {\n            if (left < right) {\n                d += left;\n                left += arr[++i];\n            } else {\n                d += right;\n                right += arr[--j];\n            }\n        }\n        return d;\n    }\n}",
      "total_acs": 15924,
      "total_submitted": 30462
    },
    {
      "id": 297,
      "title": "Serialize and Deserialize Binary Tree",
      "url": "https://leetcode.com/problems/serialize-and-deserialize-binary-tree/description",
      "companyTags": [
        "Google",
        "Facebook",
        "Microsoft",
        "Amazon",
        "Bloomberg",
        "Uber",
        "LinkedIn",
        "Yahoo"
      ],
      "difficulty": "Hard",
      "content": "Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\r\n\r\nDesign an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.\r\n\r\nFor example, you may serialize the following tree\r\n\r\n\r\n    1\r\n   / \\\r\n  2   3\r\n     / \\\r\n    4   5\r\n\r\n\r\nas \"[1,2,3,null,null,4,5]\", just the same as how LeetCode OJ serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.\r\n\r\n \r\n\r\nNote: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.\r\n\r\nCredits:\r\nSpecial thanks to @Louis1992 for adding this problem and creating all test cases.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/375",
      "similarQuestions": [
        "EncodeandDecodeStrings",
        "SerializeandDeserializeBST",
        "FindDuplicateSubtrees"
      ],
      "topicTags": [
        "Tree",
        "Design"
      ],
      "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Codec {\n    TreeNode root;\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        this.root = root;\n        return \"\";\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        return root;\n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec codec = new Codec();\n// codec.deserialize(codec.serialize(root));",
      "total_acs": 93424,
      "total_submitted": 270534
    },
    {
      "id": 298,
      "title": "Binary Tree Longest Consecutive Sequence",
      "url": "https://leetcode.com/problems/binary-tree-longest-consecutive-sequence/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven a binary tree, find the length of the longest consecutive sequence path.\r\n\r\n\r\nThe path refers to any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The longest consecutive path need to be from parent to child (cannot be the reverse).\r\n\r\n\r\n\r\nFor example,\r\n\r\n   1\r\n    \\\r\n     3\r\n    / \\\r\n   2   4\r\n        \\\r\n         5\r\n\r\nLongest consecutive sequence path is 3-4-5, so return 3. \r\n\r\n   2\r\n    \\\r\n     3\r\n    / \r\n   2    \r\n  / \r\n 1\r\n\r\nLongest consecutive sequence path is 2-3,not3-2-1, so return 2.\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/376",
      "similarQuestions": [
        "LongestConsecutiveSequence",
        "BinaryTreeLongestConsecutiveSequenceII"
      ],
      "topicTags": [
        "Tree"
      ],
      "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    // 298. Binary Tree Longest Consecutive Sequence\n    \n    // global sum LCS for this\n    int bestLCS = 0;\n    \n    public int longestConsecutive(TreeNode root) {\n        // special case null\n        if (root == null)\n            return bestLCS;\n        // sepcial case only root\n        //if (root.left == null && roo)\n        // call dfs\n        dfsLCS(root, 1, root.val-2); // make a dummy prev value \n        return bestLCS;\n    }\n\n    void dfsLCS(TreeNode node, int curLCS, int prevValue) {\n        // update bestLCS\n        bestLCS = Math.max(bestLCS, curLCS);\n        // base case\n        // node is null\n        if (node == null)\n            return;\n        // if current node is not consecutive or is null\n        if (node.val != prevValue+1) {\n            dfsLCS(node.left, 1, node.val);\n            dfsLCS(node.right, 1, node.val);\n        }\n        // else\n        else {\n            curLCS += 1;\n            // go check left and right children\n            dfsLCS(node.left, curLCS, node.val);\n            dfsLCS(node.right, curLCS, node.val);\n        }\n    }\n\n}",
      "total_acs": 40811,
      "total_submitted": 98009
    },
    {
      "id": 299,
      "title": "Bulls and Cows",
      "url": "https://leetcode.com/problems/bulls-and-cows/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called \"bulls\") and how many digits match the secret number but locate in the wrong position (called \"cows\"). Your friend will use successive guesses and hints to eventually derive the secret number.\r\n\r\n\r\nFor example:\r\n\r\nSecret number:  \"1807\"\r\nFriend's guess: \"7810\"\r\n\r\nHint: 1 bull and 3 cows. (The bull is 8, the cows are 0, 1 and 7.)\r\n\r\n\r\nWrite a function to return a hint according to the secret number and friend's guess, use A to indicate the bulls and B to indicate the cows. In the above example, your function should return \"1A3B\". \r\n\r\nPlease note that both secret number and friend's guess may contain duplicate digits, for example:\r\n\r\nSecret number:  \"1123\"\r\nFriend's guess: \"0111\"\r\n\r\nIn this case, the 1st 1 in friend's guess is a bull, the 2nd or 3rd 1 is a cow, and your function should return \"1A1B\".\r\n\r\n\r\nYou may assume that the secret number and your friend's guess only contain digits, and their lengths are always equal.\r\n\r\nCredits:Special thanks to @jeantimex for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/377",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "HashTable"
      ],
      "Solution": "class Solution {\n    public String getHint(String secret, String guess) {\n        int bulls=0,cows=0;\n        int[] counter = new int[10];\n        int n=secret.length();\n        for(int i =0; i<n; i++){\n            int s = secret.charAt(i)-'0';\n            int g = guess.charAt(i)-'0';\n            if(s==g)\n                bulls++;\n            else{\n                if(counter[g]>0) cows++;\n                if(counter[s]<0) cows++;\n                counter[s]++;\n                counter[g]--;\n            }   \n        }    \n        return bulls + \"A\" + cows + \"B\";\n        \n    }\n}",
      "total_acs": 65168,
      "total_submitted": 182602
    },
    {
      "id": 300,
      "title": "Longest Increasing Subsequence",
      "url": "https://leetcode.com/problems/longest-increasing-subsequence/description",
      "companyTags": [
        "Microsoft"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven an unsorted array of integers, find the length of longest increasing subsequence.\r\n\r\n\r\nFor example,\r\nGiven [10, 9, 2, 5, 3, 7, 101, 18],\r\nThe longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length.\r\n\r\n\r\nYour algorithm should run in O(n2) complexity.\r\n\r\n\r\nFollow up: Could you improve it to O(n log n) time complexity? \r\n\r\nCredits:Special thanks to @pbrother for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/379",
      "similarQuestions": [
        "IncreasingTripletSubsequence",
        "RussianDollEnvelopes",
        "MaximumLengthofPairChain",
        "NumberofLongestIncreasingSubsequence",
        "MinimumASCIIDeleteSumforTwoStrings"
      ],
      "topicTags": [
        "BinarySearch",
        "DynamicProgramming"
      ],
      "Solution": "public class Solution {\n    public int lengthOfLIS(int[] nums) {\n        int[] dp = new int[nums.length]; // if nums is all increasing\n        int len = 1; // LIS length, len - 1 is the last element in LIS\n        if(nums == null || nums.length == 0){\n            return 0;\n        }\n        dp[0] = nums[0];\n        for (int j = 1; j < nums.length; j++) {\n            int num = nums[j];\n            int i = binarySearch1(dp, 0, len - 1, num);// search between dp[0] to dp[len - 1]\n            dp[i] = num;\n            if (i == len) {\n                len++;\n            }\n        }\n        return len;\n    }\n    \n    public static int binarySearch1(int[] dp, int start, int end, int num){\n        while(start + 1 < end){\n            int mid = start + (end - start) / 2;\n            if(dp[mid] == num){\n                return mid;\n            }\n            if(dp[mid] < num){\n                start = mid;\n            }\n            else{\n                end = mid;\n            }\n        }\n        if(dp[start] >= num){\n            return start;\n        }\n        if(dp[end] >= num){\n            return end;\n        }\n        return end + 1;\n    }\n}",
      "total_acs": 112903,
      "total_submitted": 290537
    },
    {
      "id": 301,
      "title": "Remove Invalid Parentheses",
      "url": "https://leetcode.com/problems/remove-invalid-parentheses/description",
      "companyTags": [
        "Facebook"
      ],
      "difficulty": "Hard",
      "content": "\r\nRemove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.\r\n\r\nNote: The input string may contain letters other than the parentheses ( and ). \r\n\r\n\r\n\r\nExamples:\r\n\r\n\"()())()\" -> [\"()()()\", \"(())()\"]\r\n\"(a)())()\" -> [\"(a)()()\", \"(a())()\"]\r\n\")(\" -> [\"\"]\r\n\r\n\r\n\r\nCredits:Special thanks to @hpplayer for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/380",
      "similarQuestions": [
        "ValidParentheses"
      ],
      "topicTags": [
        "Depth-firstSearch",
        "Breadth-firstSearch"
      ],
      "Solution": "class Solution {\n    public List<String> removeInvalidParentheses(String s) {\n        List<String> result = new ArrayList<>();\n        if (s == null){\n            return result;\n        }        \n        remove(s, result, 0, 0, '(', ')');\n        return result;\n    }\n    \n   private void remove(String s, List<String> result, int left, int right, char open, char close) {\n        for (int i = left, cnt = 0; i < s.length(); i++) {\n            if (s.charAt(i) == open){\n                cnt++;\n            } \n            if (s.charAt(i) == close){\n                cnt--;\n            }\n            if (cnt >= 0){\n                continue;\n            }\n            for (int j = right; j <= i; j++) {\n                if (s.charAt(j) == close && (j == right || s.charAt(j - 1) != close)) {\n                    remove(s.substring(0, j) + s.substring(j + 1), result, i, j, open, close);\n                }\n            }\n            return;\n        }\n        String sb = new StringBuilder(s).reverse().toString();\n        if (open == '(') {\n            remove(sb, result, 0, 0, ')', '(');\n        }else{\n            result.add(sb);\n        }\n   }\n}",
      "total_acs": 62613,
      "total_submitted": 174675
    },
    {
      "id": 302,
      "title": "Smallest Rectangle Enclosing Black Pixels",
      "url": "https://leetcode.com/problems/smallest-rectangle-enclosing-black-pixels/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Hard",
      "content": "An image is represented by a binary matrix with 0 as a white pixel and 1 as a black pixel. The black pixels are connected, i.e., there is only one black region. Pixels are connected horizontally and vertically. Given the location (x, y) of one of the black pixels, return the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\r\n\r\n\r\nFor example, given the following image:\r\n\r\n[\r\n  \"0010\",\r\n  \"0110\",\r\n  \"0100\"\r\n]\r\n\r\nand x = 0, y = 2,\r\n\r\n\r\n\r\nReturn 6.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/381",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "BinarySearch"
      ],
      "Solution": "class Solution {\nprivate char[][] image;\npublic int minArea(char[][] iImage, int x, int y) {\n    image = iImage;\n    int m = image.length, n = image[0].length;\n    int left = searchColumns(0, y, 0, m, true);\n    int right = searchColumns(y + 1, n, 0, m, false);\n    int top = searchRows(0, x, left, right, true);\n    int bottom = searchRows(x + 1, m, left, right, false);\n    return (right - left) * (bottom - top);\n}\nprivate int searchColumns(int i, int j, int top, int bottom, boolean opt) {\n    while (i != j) {\n        int k = top, mid = (i + j) / 2;\n        while (k < bottom && image[k][mid] == '0') ++k;\n        if (k < bottom == opt)\n            j = mid;\n        else\n            i = mid + 1;\n    }\n    return i;\n}\nprivate int searchRows(int i, int j, int left, int right, boolean opt) {\n    while (i != j) {\n        int k = left, mid = (i + j) / 2;\n        while (k < right && image[mid][k] == '0') ++k;\n        if (k < right == opt)\n            j = mid;\n        else\n            i = mid + 1;\n    }\n    return i;\n}\n//  Runtime: 1 ms\n}",
      "total_acs": 16608,
      "total_submitted": 35778
    },
    {
      "id": 303,
      "title": "Range Sum Query - Immutable",
      "url": "https://leetcode.com/problems/range-sum-query-immutable/description",
      "companyTags": [
        "Palantir"
      ],
      "difficulty": "Easy",
      "content": "Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.\r\n\r\nExample:\r\n\r\nGiven nums = [-2, 0, 3, -5, 2, -1]\r\n\r\nsumRange(0, 2) -> 1\r\nsumRange(2, 5) -> -1\r\nsumRange(0, 5) -> -3\r\n\r\n\r\n\r\nNote:\r\n\r\nYou may assume that the array does not change.\r\nThere are many calls to sumRange function.\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/382",
      "similarQuestions": [
        "RangeSumQuery2D-Immutable",
        "RangeSumQuery-Mutable",
        "MaximumSizeSubarraySumEqualsk"
      ],
      "topicTags": [
        "DynamicProgramming"
      ],
      "Solution": "class NumArray {\n\n    int[] sums = null;\n    \n    public NumArray(int[] nums) {\n        sums = new int[nums.length];\n        \n        if (nums.length == 0) {\n            return;\n        }\n        \n        sums[0] = nums[0];\n        \n        for (int i = 1; i < nums.length; i++) {\n            sums[i] = sums[i - 1] + nums[i];\n        }\n    }\n    \n    public int sumRange(int i, int j) {\n        if (i == 0) {\n            return sums[j];\n        }\n        \n        return sums[j] - sums[i - 1];\n    }\n}\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * NumArray obj = new NumArray(nums);\n * int param_1 = obj.sumRange(i,j);\n */",
      "total_acs": 88557,
      "total_submitted": 279735
    },
    {
      "id": 304,
      "title": "Range Sum Query 2D - Immutable",
      "url": "https://leetcode.com/problems/range-sum-query-2d-immutable/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).\r\n\r\n\r\n\r\nThe above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8.\r\n\r\n\r\nExample:\r\n\r\nGiven matrix = [\r\n  [3, 0, 1, 4, 2],\r\n  [5, 6, 3, 2, 1],\r\n  [1, 2, 0, 1, 5],\r\n  [4, 1, 0, 1, 7],\r\n  [1, 0, 3, 0, 5]\r\n]\r\n\r\nsumRegion(2, 1, 4, 3) -> 8\r\nsumRegion(1, 1, 2, 2) -> 11\r\nsumRegion(1, 2, 2, 4) -> 12\r\n\r\n\r\n\r\nNote:\r\n\r\nYou may assume that the matrix does not change.\r\nThere are many calls to sumRegion function.\r\nYou may assume that row1 ≤ row2 and col1 ≤ col2.\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/383",
      "similarQuestions": [
        "RangeSumQuery-Immutable",
        "RangeSumQuery2D-Mutable"
      ],
      "topicTags": [
        "DynamicProgramming"
      ],
      "Solution": "class NumMatrix {\n    \n    int[][] preSum;\n\n    public NumMatrix(int[][] matrix) {\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n            return;\n        }\n        preSum = new int[matrix.length + 1][matrix[0].length + 1];\n        for (int i = 0; i < matrix.length; i++) {\n            for (int j = 0; j < matrix[i].length; j++) {\n                preSum[i + 1][j + 1] = preSum[i + 1][j] + preSum[i][j + 1] - preSum[i][j] + matrix[i][j];\n            }\n        }\n    }\n    \n    public int sumRegion(int row1, int col1, int row2, int col2) {\n        int maxRow = Math.max(row1, row2);\n        int minRow = Math.min(row1, row2);\n        int maxCol = Math.max(col1, col2);\n        int minCol = Math.min(col1, col2);\n        return preSum[maxRow + 1][maxCol + 1] - preSum[maxRow + 1][minCol] - preSum[minRow][maxCol + 1] + preSum[minRow][minCol];\n    }\n}\n\n/**\n * Your NumMatrix object will be instantiated and called as such:\n * NumMatrix obj = new NumMatrix(matrix);\n * int param_1 = obj.sumRegion(row1,col1,row2,col2);\n */",
      "total_acs": 41340,
      "total_submitted": 154232
    },
    {
      "id": 305,
      "title": "Number of Islands II",
      "url": "https://leetcode.com/problems/number-of-islands-ii/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Hard",
      "content": "A 2d grid map of m rows and n columns is initially filled with water.\r\nWe may perform an addLand operation which turns the water at position (row, col) into a land.\r\nGiven a list of positions to operate, count the number of islands after each addLand operation.\r\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.\r\nYou may assume all four edges of the grid are all surrounded by water.\r\n\r\nExample:\r\nGiven m = 3, n = 3, positions = [[0,0], [0,1], [1,2], [2,1]].\r\nInitially, the 2d grid grid is filled with water. (Assume 0 represents water and 1 represents land).\r\n\r\n0 0 0\r\n0 0 0\r\n0 0 0\r\n\r\nOperation #1: addLand(0, 0) turns the water at grid[0][0] into a land.\r\n\r\n1 0 0\r\n0 0 0   Number of islands = 1\r\n0 0 0\r\n\r\nOperation #2: addLand(0, 1) turns the water at grid[0][1] into a land.\r\n\r\n1 1 0\r\n0 0 0   Number of islands = 1\r\n0 0 0\r\n\r\nOperation #3: addLand(1, 2) turns the water at grid[1][2] into a land.\r\n\r\n1 1 0\r\n0 0 1   Number of islands = 2\r\n0 0 0\r\n\r\nOperation #4: addLand(2, 1) turns the water at grid[2][1] into a land.\r\n\r\n1 1 0\r\n0 0 1   Number of islands = 3\r\n0 1 0\r\n\r\nWe return the result as an array: [1, 1, 2, 3]\r\n\r\nChallenge:\r\nCan you do it in time complexity O(k log mn), where k is the length of the positions?",
      "discussUrl": "https://discuss.leetcode.com/category/384",
      "similarQuestions": [
        "NumberofIslands"
      ],
      "topicTags": [
        "UnionFind"
      ],
      "Solution": "class Solution {\n    public List<Integer> numIslands2(int m, int n, int[][] positions) {\n        //using union fund algorithm\n        //initialize the union fund root array\n        int[] root = new int[m*n];\n        for(int i = 0; i < root.length; i++){\n            root[i]= -1;\n        }\n        int count=0;\n        List<Integer> res = new ArrayList<>();\n        \n        for(int i = 0; i < positions.length; i++){\n            int[] pos = positions[i];\n            int x = pos[1];\n            int y = pos[0];\n            \n            int curRoot = x + y*n;\n            if(root[curRoot]==-1){\n                root[curRoot] = curRoot;\n            }\n            count++;\n            \n            if(x > 0 && root[x-1+y*n]!=-1){\n                int nbRoot = find(x-1+y*n, root);\n                if(nbRoot!=curRoot){//union two group\n                    root[curRoot] = nbRoot;\n                    curRoot = nbRoot;\n                    count --;\n                }\n            }\n            if(x < n-1 && root[x+1+y*n]!=-1){\n                int nbRoot = find(x+1+y*n, root);\n                if(nbRoot!=curRoot){//union two group\n                    root[curRoot] = nbRoot;\n                    curRoot = nbRoot;\n                    count --;\n                }\n            }\n            if(y > 0 && root[x+(y-1)*n]!=-1){\n                int nbRoot = find(x+(y-1)*n, root);\n                if(nbRoot!=curRoot){//union two group\n                    root[curRoot] = nbRoot;\n                    curRoot = nbRoot;\n                    count --;\n                }\n            }\n            if(y<m-1 && root[x+(y+1)*n]!=-1){\n                int nbRoot = find(x+(y+1)*n, root);\n                if(nbRoot!=curRoot){//union two group\n                    root[curRoot] = nbRoot;\n                    curRoot = nbRoot;\n                    count --;\n                }\n            }\n            res.add(count);\n        }\n        return res;\n    }\n    \n    private int find(int id, int[] root){\n        while(id != root[id]){\n            id = root[id];\n            root[id] = root[root[id]];\n        }\n        return id;\n    }\n}",
      "total_acs": 30506,
      "total_submitted": 77002
    },
    {
      "id": 306,
      "title": "Additive Number",
      "url": "https://leetcode.com/problems/additive-number/description",
      "companyTags": [
        "EpicSystems"
      ],
      "difficulty": "Medium",
      "content": "Additive number is a string whose digits can form additive sequence.\r\n\r\nA valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.\r\n\r\n\r\nFor example:\r\n\"112358\" is an additive number because the digits can form an additive sequence: 1, 1, 2, 3, 5, 8.\r\n1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8\r\n\"199100199\" is also an additive number, the additive sequence is: 1, 99, 100, 199.\r\n1 + 99 = 100, 99 + 100 = 199\r\n\r\n\r\n\r\nNote: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.\r\n\r\n\r\nGiven a string containing only digits '0'-'9', write a function to determine if it's an additive number.\r\n\r\n\r\nFollow up:\r\nHow would you handle overflow for very large input integers?\r\n\r\n\r\nCredits:Special thanks to @jeantimex for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/385",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        ""
      ],
      "Solution": "class Solution {\n    \n\tpublic boolean isAdditiveNumber(String num) {\n\t    if(num == null || num.length() < 3){\n\t    \treturn false;\n\t    }\n        \n        // for (int i = 0; i < (num.length() - 1) / 2; i++) {\n        //     for (int j = i + 1; num.length() - j - 1 >= Math.max(i + 1, j - i); j++) {\n        //         if (isValid(num.substring(0, i + 1), num.substring(i + 1, j + 1), num.substring(j + 1)))\n        //             return true;\n        //     }\n        // }\n        \n        for(int i = 0; i < num.length() / 2; i++) {\n            for(int j = i + 1; num.length() - j - 1 >= j - i && num.length() - j - 1 >= i + 1; j++) {\n                if(isAdditive(num.substring(0, i + 1), num.substring(i + 1, j + 1), num.substring(j + 1))){\n                \treturn true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public boolean isAdditive(String num1, String num2, String str) {\n        if(num1.charAt(0) == '0' && num1.length() > 1){\n            return false;\n        }\n        if(num2.charAt(0) == '0' && num2.length() > 1){\n            return false;\n        }\n        if(str.isEmpty()){\n        \treturn true;\n        }\n        String sum = String.valueOf(Long.parseLong(num1) + Long.parseLong(num2));\n        if(!str.startsWith(sum)){\n        \treturn false;\n        }\n        return isAdditive(num2, sum, str.substring(sum.length()));\n    }\n    \n    \n    //Analysis: try all the starts and see whether we can find a valid one. \n    \n//     public boolean isAdditiveNumber(String num) {\n//         if(num == null || num.length() < 3){\n//             return false;\n//         }\n//         for(int i = 0; i < num.length() / 2; i++){\n//             for(int j = i + 1; j < num.length() - 1; j++){\n//                 if(isValid(num.substring(0, i + 1), num.substring(i + 1, j + 1), num.substring(j + 1))){\n//                     return true;\n//                 }\n//             }\n//         }\n//         return false;\n//     }\n    \n//     private boolean isValid(String str1, String str2, String str3){\n//         if(){\n            \n//         }\n//     }\n    \n}",
      "total_acs": 29612,
      "total_submitted": 106876
    },
    {
      "id": 307,
      "title": "Range Sum Query - Mutable",
      "url": "https://leetcode.com/problems/range-sum-query-mutable/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.\r\n\r\nThe update(i, val) function modifies nums by updating the element at index i to val.\r\n\r\nExample:\r\n\r\nGiven nums = [1, 3, 5]\r\n\r\nsumRange(0, 2) -> 9\r\nupdate(1, 2)\r\nsumRange(0, 2) -> 8\r\n\r\n\r\n\r\nNote:\r\n\r\nThe array is only modifiable by the update function.\r\nYou may assume the number of calls to update and sumRange function is distributed evenly.\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/387",
      "similarQuestions": [
        "RangeSumQuery-Immutable",
        "RangeSumQuery2D-Mutable"
      ],
      "topicTags": [
        "BinaryIndexedTree",
        "SegmentTree"
      ],
      "Solution": "class NumArray {\n   int[] nums;\n\tint[] BIT;\n\tint n;\n\n\tpublic NumArray(int[] nums) {\n\t\tthis.nums = nums;\n\n\t\tn = nums.length;\n\t\tBIT = new int[n + 1];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tinit(i, nums[i]);\n\t}\n\n\tpublic void init(int i, int val) {\n\t\ti++;\n\t\twhile (i <= n) {\n\t\t\tBIT[i] += val;\n\t\t\ti += (i & -i);\n\t\t}\n\t}\n\n\tvoid update(int i, int val) {\n\t\tint diff = val - nums[i];\n\t\tnums[i] = val;\n\t\tinit(i, diff);\n\t}\n\n\tpublic int getSum(int i) {\n\t\tint sum = 0;\n\t\ti++;\n\t\twhile (i > 0) {\n\t\t\tsum += BIT[i];\n\t\t\ti -= (i & -i);\n\t\t}\n\t\treturn sum;\n\t}\n\n\tpublic int sumRange(int i, int j) {\n\t\treturn getSum(j) - getSum(i - 1);\n\t}\n}\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * NumArray obj = new NumArray(nums);\n * obj.update(i,val);\n * int param_2 = obj.sumRange(i,j);\n */",
      "total_acs": 41473,
      "total_submitted": 187560
    },
    {
      "id": 308,
      "title": "Range Sum Query 2D - Mutable",
      "url": "https://leetcode.com/problems/range-sum-query-2d-mutable/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Hard",
      "content": "Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).\r\n\r\n\r\n\r\nThe above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8.\r\n\r\n\r\nExample:\r\n\r\nGiven matrix = [\r\n  [3, 0, 1, 4, 2],\r\n  [5, 6, 3, 2, 1],\r\n  [1, 2, 0, 1, 5],\r\n  [4, 1, 0, 1, 7],\r\n  [1, 0, 3, 0, 5]\r\n]\r\n\r\nsumRegion(2, 1, 4, 3) -> 8\r\nupdate(3, 2, 2)\r\nsumRegion(2, 1, 4, 3) -> 10\r\n\r\n\r\n\r\nNote:\r\n\r\nThe matrix is only modifiable by the update function.\r\nYou may assume the number of calls to update and sumRegion function is distributed evenly.\r\nYou may assume that row1 ≤ row2 and col1 ≤ col2.\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/388",
      "similarQuestions": [
        "RangeSumQuery2D-Immutable",
        "RangeSumQuery-Mutable"
      ],
      "topicTags": [
        "BinaryIndexedTree",
        "SegmentTree"
      ],
      "Solution": null,
      "total_acs": 20412,
      "total_submitted": 80657
    },
    {
      "id": 309,
      "title": "Best Time to Buy and Sell Stock with Cooldown",
      "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Medium",
      "content": "Say you have an array for which the ith element is the price of a given stock on day i.\r\n\r\nDesign an algorithm to find the maximum profit. You may complete as many transactions as you like\r\n(ie, buy one and sell one share of the stock multiple times) with the following restrictions:\r\n\r\n\r\n    You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).\r\n    After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)\r\n\r\n\r\nExample:\r\n\r\nprices = [1, 2, 3, 0, 2]\r\nmaxProfit = 3\r\ntransactions = [buy, sell, cooldown, buy, sell]\r\n\r\n\r\nCredits:Special thanks to @dietpepsi for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/389",
      "similarQuestions": [
        "BestTimetoBuyandSellStock",
        "BestTimetoBuyandSellStockII"
      ],
      "topicTags": [
        "DynamicProgramming"
      ],
      "Solution": "class Solution {\n    public int maxProfit(int[] prices) {\n        if(prices == null || prices.length == 0 || prices.length == 1){\n            return 0;\n        }\n        // Consider buy as a transaction\n        // T[i][0][0] = 0;\n        // T[i][0][1] = -Infinity;\n        // T[i][k][t] = T[i][k - 1][t]\n        \n        // T[i][k][0] = T[i - 1][k][0], T[i - 1][k][1] + price[i]\n        // T[i][k][1] = T[i - 1][k][1], T[i - 2][k-1][0] - price[i] => T[i - 1][k][1], old(T[i - 2][k][0]) - price[i]\n\n        int i0 = 0;\n        int i1 = -prices[0];\n        int i00 = Math.max(0, prices[1] - prices[0]);\n        int i11 = Math.max(-prices[0], -prices[1]);\n\n        for(int i = 2; i < prices.length; i++){\n            int oldi00 = i00;\n            i00 = Math.max(i00, i11 + prices[i]);\n            i11 = Math.max(i11, i0 - prices[i]);\n            i0 = oldi00;\n        }\n        return i00;    \n    }\n}",
      "total_acs": 56046,
      "total_submitted": 134174
    },
    {
      "id": 310,
      "title": "Minimum Height Trees",
      "url": "https://leetcode.com/problems/minimum-height-trees/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Medium",
      "content": "\r\n    For a undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs).\r\n    Given such a graph, write a function to find all the MHTs and return a list of their root labels.\r\n\r\n\r\n\r\n    Format\r\n    The graph contains n nodes which are labeled from 0 to n - 1.\r\n    You will be given the number n and a list of undirected edges (each edge is a pair of labels).\r\n\r\n \r\nYou can assume that no duplicate edges will appear in edges. Since all edges are\r\n    undirected, [0, 1] is the same as [1, 0] and thus will not appear together in\r\n    edges.\r\n\r\n\r\n    Example 1:\r\n\r\n\r\n    Given n = 4, edges = [[1, 0], [1, 2], [1, 3]]\r\n\r\n\r\n\r\n        0\r\n        |\r\n        1\r\n       / \\\r\n      2   3\r\n\r\n\r\n    return  [1]\r\n\r\n\r\n\r\n    Example 2:\r\n\r\n\r\n    Given n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]\r\n\r\n\r\n     0  1  2\r\n      \\ | /\r\n        3\r\n        |\r\n        4\r\n        |\r\n        5\r\n\r\n\r\n    return  [3, 4]\r\n\r\n\r\n\r\n    Note:\r\n\r\n\r\n    (1) According to the definition\r\n    of tree on Wikipedia: “a tree is an undirected graph in which any two vertices are connected by\r\n    exactly one path. In other words, any connected graph without simple cycles is a tree.”\r\n\r\n\r\n    (2) The height of a rooted tree is the number of edges on the longest downward path between the root and a\r\n    leaf.\r\n\r\n\r\nCredits:Special thanks to @dietpepsi for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/390",
      "similarQuestions": [
        "CourseSchedule",
        "CourseScheduleII"
      ],
      "topicTags": [
        "Breadth-firstSearch",
        "Graph"
      ],
      "Solution": "\nimport java.util.*;\n\nclass Solution {\n    \n    static class TreeNode {\n        final int id;\n        int sonCnt;\n        ListNode sonList;\n        TreeNode(int id) {\n            this.id = id;\n        }\n        \n        void addSon(TreeNode son) {\n            sonCnt++;\n            sonList = new ListNode(son, sonList);\n        }\n    }\n    static class ListNode {\n        final ListNode next;\n        final TreeNode node;\n        ListNode(TreeNode node, ListNode next) {\n            this.node = node;\n            this.next = next;\n        }\n    }\n    \n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\n        TreeNode[] nodes = new TreeNode[n];\n        for(int i = 0; i < n; i++) {\n            nodes[i] = new TreeNode(i);\n        }\n        for(int[] edge : edges) {\n            TreeNode node0 = nodes[edge[0]];\n            TreeNode node1 = nodes[edge[1]];\n            node0.addSon(node1);\n            node1.addSon(node0);\n        }\n        int size = 0;\n        ListNode leafList = null;\n        for(TreeNode node : nodes) {\n            if(node.sonCnt <= 1) {\n                node.sonCnt = Integer.MAX_VALUE;\n                leafList = new ListNode(node, leafList);\n                size++;\n            }\n        }\n        for(; (n -= size) > 0;) {\n            ListNode newLeafList = null;\n            int newSize = 0;\n            for(; leafList != null; leafList = leafList.next) {\n                TreeNode node = leafList.node;\n                for(ListNode sonList = node.sonList; sonList != null; sonList = sonList.next) {\n                    TreeNode sonNode = sonList.node;\n                    if(--sonNode.sonCnt <= 1) {\n                        sonNode.sonCnt = Integer.MAX_VALUE;\n                        newLeafList = new ListNode(sonNode, newLeafList);\n                        newSize++;\n                    }\n                }\n            }\n            leafList = newLeafList;\n            size = newSize;\n        }\n        Integer[] ids = new Integer[size];\n        for(int i = 0; leafList != null; leafList = leafList.next) {\n            ids[i++] = leafList.node.id;\n        }\n        return Arrays.asList(ids);\n    }\n}",
      "total_acs": 41323,
      "total_submitted": 142602
    },
    {
      "id": 311,
      "title": "Sparse Matrix Multiplication",
      "url": "https://leetcode.com/problems/sparse-matrix-multiplication/description",
      "companyTags": [
        "Facebook",
        "LinkedIn"
      ],
      "difficulty": "Medium",
      "content": "Given two sparse matrices A and B, return the result of AB.\r\n\r\nYou may assume that A's column number is equal to B's row number.\r\n\r\nExample:\r\n\r\n\r\nA = [\r\n  [ 1, 0, 0],\r\n  [-1, 0, 3]\r\n]\r\n\r\nB = [\r\n  [ 7, 0, 0 ],\r\n  [ 0, 0, 0 ],\r\n  [ 0, 0, 1 ]\r\n]\r\n\r\n\r\n     |  1 0 0 |   | 7 0 0 |   |  7 0 0 |\r\nAB = | -1 0 3 | x | 0 0 0 | = | -7 0 3 |\r\n                  | 0 0 1 |\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/391",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "HashTable"
      ],
      "Solution": "class Solution {\n    public int[][] multiply(int[][] A, int[][] B) {\n        \n        int rowA = A.length;\n        int colA = A[0].length;\n        int rowB = B.length;\n        int colB = B[0].length;\n        \n        \n        int[][] res = new int[rowA][colB];\n        \n        for(int i = 0; i < rowA; i++){\n            for(int j = 0; j < colA; j++){\n                if(A[i][j] != 0){\n                    for(int m = 0; m < colB; m++){\n                        if(B[j][m] != 0) res[i][m] += A[i][j] * B[j][m];\n                    }\n                }\n            }\n        }\n        return res;\n        \n        \n        \n    \n        \n    }\n}",
      "total_acs": 42575,
      "total_submitted": 81431
    },
    {
      "id": 312,
      "title": "Burst Balloons",
      "url": "https://leetcode.com/problems/burst-balloons/description",
      "companyTags": [
        "Google",
        "Snapchat"
      ],
      "difficulty": "Hard",
      "content": "\r\n    Given n balloons, indexed from 0 to n-1. Each balloon is painted with a\r\n    number on it represented by array nums.\r\n\r\n    You are asked to burst all the balloons. If the you burst\r\n    balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left\r\n    and right are adjacent indices of i. After the burst, the left and right\r\n    then becomes adjacent.\r\n\r\n\r\n    Find the maximum coins you can collect by bursting the balloons wisely.\r\n\r\n\r\n    Note: \r\n    (1) You may imagine nums[-1] = nums[n] = 1. They are not real therefore you can not burst them.\r\n    (2) 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100\r\n\r\n\r\n\r\n\r\n    Example:\r\n\r\n\r\n    Given [3, 1, 5, 8]\r\n\r\n\r\n    Return 167\r\n\r\n\r\n    nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []\r\n   coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167\r\n\r\n\r\nCredits:Special thanks to @dietpepsi for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/392",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "DivideandConquer",
        "DynamicProgramming"
      ],
      "Solution": "class Solution {\n    public int maxCoins(int[] nums) {\n        if (nums == null || nums.length == 0)\n            return 0;\n        \n        // Map<int[],Integer> dp = new HashMap<int[], Integer>();\n        int[][] dp = new int[nums.length][nums.length];\n        \n        // precalculate\n        for (int delta = 0; delta < nums.length; ++delta)\n        {\n            for (int left = 0; left + delta < nums.length; ++left)\n            {\n                maxCoins(nums, left, left+delta, dp);\n            }\n        }\n        \n        return dp[0][nums.length-1];\n        // return maxCoins(nums, 0, nums.length-1, dp);\n    }\n    \n    // reverse order: pick balloons in reverse order of popping so we can use intervals\n    //                for dp.\n    public static int maxCoins(int[] nums, int left, int right, int[][] dp)\n    {\n        if (left == right)\n        {\n            int coins = nums[left];\n            if (left-1 >= 0)\n                coins *= nums[left-1];\n            if (right+1 < nums.length)\n                coins *= nums[right+1];\n            \n            dp[left][right] = coins;\n            return coins;\n        }\n        \n        // int[] key = new int[] {left, right};\n        // if (dp.containsKey(key))\n        // {\n        //     return dp.get(key);\n        // }\n        \n        int maxCoins = Integer.MIN_VALUE;\n        int baseMultiplier = 1;\n        if (left-1 >= 0)\n            baseMultiplier = nums[left-1];\n        if (right+1 < nums.length)\n            baseMultiplier *= nums[right+1];\n        for (int i = left; i <= right; ++i)\n        {\n            int coins = baseMultiplier * nums[i];\n            \n            if (i > left)\n                // coins += maxCoins(nums, left, i-1, dp);\n                coins += dp[left][i-1];\n            if (i < right)\n                //coins += maxCoins(nums, i+1, right, dp);\n                coins += dp[i+1][right];\n            \n            if (coins > maxCoins)\n                maxCoins = coins;\n        }\n        \n        // dp.put(key, maxCoins);\n        dp[left][right] = maxCoins;\n        return maxCoins;\n    }\n}",
      "total_acs": 35538,
      "total_submitted": 81688
    },
    {
      "id": 313,
      "title": "Super Ugly Number",
      "url": "https://leetcode.com/problems/super-ugly-number/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Medium",
      "content": "\r\n    Write a program to find the nth super ugly number.\r\n\r\n\r\n\r\n    Super ugly numbers are positive numbers whose all prime factors are in the given prime list\r\n    primes of size k. For example, [1, 2, 4, 7, 8, 13, 14, 16, 19, 26, 28, 32]\r\n is the sequence of the first 12 super ugly numbers given primes\r\n    = [2, 7, 13, 19] of size 4.\r\n\r\n\r\n\r\n    Note:\r\n    (1) 1 is a super ugly number for any given primes.\r\n    (2) The given numbers in primes are in ascending order.\r\n    (3) 0 < k ≤ 100, 0 < n ≤ 106, 0 < primes[i] < 1000.\r\n    (4) The nth super ugly number is guaranteed to fit in a 32-bit signed integer.\r\n\r\n\r\nCredits:Special thanks to @dietpepsi for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/393",
      "similarQuestions": [
        "UglyNumberII"
      ],
      "topicTags": [
        "Math",
        "Heap"
      ],
      "Solution": "class Solution {\n    public int nthSuperUglyNumber(int n, int[] primes) {\n        int size = primes.length;\n        int[] next = new int[size];\n        int[] index = new int[size];\n        int[] ugly = new int[n];\n        ugly[0] = 1;\n        for (int i = 0; i < size; ++i) {\n            next[i] = primes[i];\n        }\n        for (int i = 1; i < n; ++i) {\n            int tmpnext = Integer.MAX_VALUE;\n            int tmpindex = 0;\n            for (int j = 0; j < size; ++j) {\n                if (tmpnext > next[j]) {\n                    tmpnext = next[j];\n                    tmpindex = j;\n                }\n            }\n            ugly[i] = tmpnext;\n            for (int j = 0; j < size; ++j) {\n                if (tmpnext == next[j]) {\n                    index[j] += 1;\n                    next[j] = ugly[index[j]]*primes[j];\n                }\n            } \n        }\n        return ugly[n-1];\n    }\n}",
      "total_acs": 44083,
      "total_submitted": 115341
    },
    {
      "id": 314,
      "title": "Binary Tree Vertical Order Traversal",
      "url": "https://leetcode.com/problems/binary-tree-vertical-order-traversal/description",
      "companyTags": [
        "Google",
        "Facebook",
        "Snapchat"
      ],
      "difficulty": "Medium",
      "content": "Given a binary tree, return the vertical order traversal of its nodes' values. (ie, from top to bottom, column by column).\r\nIf two nodes are in the same row and column, the order should be from left to right.\r\n\r\nExamples:\r\n\r\n\r\nGiven binary tree [3,9,20,null,null,15,7],\r\n\r\n   3\r\n  /\\\r\n /  \\\r\n 9  20\r\n    /\\\r\n   /  \\\r\n  15   7\r\n\r\n\r\n\r\nreturn its vertical order traversal as:\r\n\r\n[\r\n  [9],\r\n  [3,15],\r\n  [20],\r\n  [7]\r\n]\r\n\r\n\r\n\r\nGiven binary tree [3,9,8,4,0,1,7],\r\n\r\n     3\r\n    /\\\r\n   /  \\\r\n   9   8\r\n  /\\  /\\\r\n /  \\/  \\\r\n 4  01   7\r\n\r\n\r\n\r\nreturn its vertical order traversal as:\r\n\r\n[\r\n  [4],\r\n  [9],\r\n  [3,0,1],\r\n  [8],\r\n  [7]\r\n]\r\n\r\n\r\n\r\nGiven binary tree [3,9,8,4,0,1,7,null,null,null,2,5] (0's right child is 2 and 1's left child is 5),\r\n\r\n     3\r\n    /\\\r\n   /  \\\r\n   9   8\r\n  /\\  /\\\r\n /  \\/  \\\r\n 4  01   7\r\n    /\\\r\n   /  \\\r\n   5   2\r\n\r\n\r\n\r\nreturn its vertical order traversal as:\r\n\r\n[\r\n  [4],\r\n  [9,5],\r\n  [3,0,1],\r\n  [8,2],\r\n  [7]\r\n]\r\n\r\n\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/394",
      "similarQuestions": [
        "BinaryTreeLevelOrderTraversal"
      ],
      "topicTags": [
        "HashTable"
      ],
      "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    int min=0,max=0;\n    public List<List<Integer>> verticalOrder(TreeNode root) {\n        countRange(root,0);\n        List<List<Integer>> res=new ArrayList<>();\n        Queue<TreeNode> que_node=new LinkedList<>();\n        Queue<Integer> que_idx=new LinkedList<>();\n        if(root==null) return res;\n        for(int i=min;i<=max;i++)  res.add(new ArrayList<>());\n        que_node.add(root);\n        que_idx.add(-min);\n        while(!que_node.isEmpty()){\n            TreeNode buff=que_node.poll();\n            int i=que_idx.poll();\n            res.get(i).add(buff.val);\n            if(buff.left!=null){\n                que_node.add(buff.left);\n                que_idx.add(i-1);\n            }\n            if(buff.right!=null){\n                que_node.add(buff.right);\n                que_idx.add(i+1);\n            }\n        }\n        return res;\n    }\n    public void countRange(TreeNode root,int cur){\n        if(root==null) return;\n        min=Math.min(cur,min);\n        max=Math.max(cur,max);\n        countRange(root.left,cur-1);\n        countRange(root.right,cur+1);\n    }\n}",
      "total_acs": 39929,
      "total_submitted": 105545
    },
    {
      "id": 315,
      "title": "Count of Smaller Numbers After Self",
      "url": "https://leetcode.com/problems/count-of-smaller-numbers-after-self/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Hard",
      "content": "\r\nYou are given an integer array nums and you have to return a new counts array.\r\nThe counts array has the property where counts[i] is \r\nthe number of smaller elements to the right of nums[i].\r\n\r\n\r\nExample:\r\n\r\n\r\nGiven nums = [5, 2, 6, 1]\r\n\r\nTo the right of 5 there are 2 smaller elements (2 and 1).\r\nTo the right of 2 there is only 1 smaller element (1).\r\nTo the right of 6 there is 1 smaller element (1).\r\nTo the right of 1 there is 0 smaller element.\r\n\r\n\r\n\r\nReturn the array [2, 1, 1, 0].\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/395",
      "similarQuestions": [
        "CountofRangeSum",
        "QueueReconstructionbyHeight",
        "ReversePairs"
      ],
      "topicTags": [
        "DivideandConquer",
        "BinaryIndexedTree",
        "SegmentTree",
        "BinarySearchTree"
      ],
      "Solution": "class Solution {\n    public List<Integer> countSmaller(int[] nums) {\n        if(nums.length == 0)\n            return new ArrayList<>();\n        int min = Integer.MAX_VALUE;\n        for(int value : nums)\n        {\n            if(value < min)\n                min = value;\n        }\n        for(int i = 0; i < nums.length; i++) {\n            nums[i] = nums[i] - min + 1;\n        }\n        int max = Integer.MIN_VALUE;\n        for(int value : nums) {\n            if(value > max)\n                max = value;\n        }\n        int[] BITree = new int[max + 1];\n        BITree[0] = 0;\n        int[] countArr = new int[nums.length];\n        for(int i = nums.length - 1; i >= 0; i--) {\n            int count = getSum(nums[i]-1, BITree);\n            countArr[i] = count;\n            update(nums[i], BITree);\n        }\n        List<Integer> result = new ArrayList<>();\n        for(int value : countArr) {\n            result.add(value);\n        }\n        return result;\n    }\n    public int getSum(int value, int[] BITree) {\n        int sum = 0;\n        while(value > 0) {\n            sum += BITree[value];\n            //System.out.println(\"BITree[\" + value + \"] = \" + BITree[value] + \" sum  = \" + sum);\n            value -= (value & -value); \n        }\n        return sum;\n    }\n    public void update(int value, int[] BITree) {\n        while(value <= BITree.length - 1) {\n            BITree[value] += 1;\n            //System.out.println(\"BITree[\" + value + \"] = \" + BITree[value]);\n            value += (value & -value);\n        }\n    }\n}",
      "total_acs": 43281,
      "total_submitted": 123603
    },
    {
      "id": 316,
      "title": "Remove Duplicate Letters",
      "url": "https://leetcode.com/problems/remove-duplicate-letters/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Hard",
      "content": "\r\nGiven a string which contains only lowercase letters, remove duplicate letters so that every letter appear once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.\r\n\r\n\r\n\r\nExample:\r\n\r\n\r\nGiven \"bcabc\"\r\nReturn \"abc\"\r\n\r\n\r\nGiven \"cbacdcbc\"\r\nReturn \"acdb\"\r\n\r\n\r\nCredits:Special thanks to @dietpepsi for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/396",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Stack",
        "Greedy"
      ],
      "Solution": "class Solution {\n    public String removeDuplicateLetters(String s) {\n        int[] dict = new int[26];\n        char[] array = s.toCharArray();\n        boolean[] visited = new boolean[26];\n        for (int i = 0; i < array.length; i++) dict[array[i] - 'a']++;\n        int top = -1;\n        for (int j = 0; j < array.length; j++) {\n            int cur = array[j] - 'a';\n            dict[cur]--;\n            if (visited[cur]) {\n                continue;\n            } else {\n                while (top > -1 && array[j] < array[top] && dict[array[top] - 'a'] != 0) {\n                    visited[array[top] - 'a'] = false;\n                    top--;\n                }\n                array[++top] = array[j];\n                visited[cur] = true;\n            }\n        }\n        String res = new String(array);\n        return res.substring(0, top + 1);\n    }\n}",
      "total_acs": 37648,
      "total_submitted": 124380
    },
    {
      "id": 317,
      "title": "Shortest Distance from All Buildings",
      "url": "https://leetcode.com/problems/shortest-distance-from-all-buildings/description",
      "companyTags": [
        "Google",
        "Zenefits"
      ],
      "difficulty": "Hard",
      "content": "You want to build a house on an empty land which reaches all buildings in the shortest amount of distance. You can only move up, down, left and right. You are given a 2D grid of values 0, 1 or 2, where:\r\n\r\nEach 0 marks an empty land which you can pass by freely.\r\nEach 1 marks a building which you cannot pass through.\r\nEach 2 marks an obstacle which you cannot pass through.\r\n\r\n\r\nFor example, given three buildings at (0,0), (0,4), (2,2), and an obstacle at (0,2):\r\n\r\n1 - 0 - 2 - 0 - 1\r\n|   |   |   |   |\r\n0 - 0 - 0 - 0 - 0\r\n|   |   |   |   |\r\n0 - 0 - 1 - 0 - 0\r\n\r\nThe point (1,2) is an ideal empty land to build a house, as the total travel distance of 3+3+1=7 is minimal. So return 7.\r\n\r\nNote:\r\nThere will be at least one building. If it is not possible to build such house according to the above rules, return -1.",
      "discussUrl": "https://discuss.leetcode.com/category/397",
      "similarQuestions": [
        "WallsandGates",
        "BestMeetingPoint"
      ],
      "topicTags": [
        "Breadth-firstSearch"
      ],
      "Solution": "class Solution {\n    public int shortestDistance(int[][] grid) {\n        if (grid == null || grid.length == 0 || grid[0].length == 0) {\n            return 0;\n        }\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][] totalDistance = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1 && !bfs(grid, totalDistance, i, j)) {\n                    return -1;\n                }\n            }\n        }\n        int res = Integer.MAX_VALUE;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 0) {\n                    res = Math.min(res, totalDistance[i][j]);\n                }\n            }\n        }\n        return res == Integer.MAX_VALUE ? -1 : res;\n    }\n    \n    private boolean bfs(int[][] grid, int[][] totalDistance, int startX, int startY) {\n        int m = grid.length;\n        int n = grid[0].length;\n        boolean[][] visited = new boolean[m][n];\n        visited[startX][startY] = true;\n        \n        int[][] directions = new int[][] {{1, 0}, {-1, 0}, {0, -1}, {0, 1}};\n        \n        Deque<int[]> queue = new ArrayDeque<>();\n        queue.offer(new int[] {startX, startY});\n        int level = 0;\n        \n        while (!queue.isEmpty()) {\n            int levelSize = queue.size();\n            level++;\n            while (levelSize-- > 0) {\n                int[] curr = queue.poll();\n                int currX = curr[0];\n                int currY = curr[1];\n                for (int[] dir : directions) {\n                    int x = currX + dir[0];\n                    int y = currY + dir[1];\n                    if (x >= 0 && x < m && y >= 0 && y < n && !visited[x][y]) {\n                        if (grid[x][y] == 0) {\n                            totalDistance[x][y] += level;\n                            queue.offer(new int[] {x, y});\n                        }\n                        visited[x][y] = true;\n                    }\n                }\n            }\n        }\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (!visited[i][j]) {\n                    if (grid[i][j] == 0) {\n                        grid[i][j] = -1;\n                    } else if (grid[i][j] == 1) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n}",
      "total_acs": 21908,
      "total_submitted": 63074
    },
    {
      "id": 318,
      "title": "Maximum Product of Word Lengths",
      "url": "https://leetcode.com/problems/maximum-product-of-word-lengths/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Medium",
      "content": "\r\n    Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters.\r\n    You may assume that each word will contain only lower case letters.\r\n    If no such two words exist, return 0.\r\n\r\n\r\n\r\n    Example 1:\r\n\r\n\r\n    Given [\"abcw\", \"baz\", \"foo\", \"bar\", \"xtfn\", \"abcdef\"]\r\n    Return 16\r\n    The two words can be \"abcw\", \"xtfn\".\r\n\r\n\r\n    Example 2:\r\n\r\n\r\n    Given [\"a\", \"ab\", \"abc\", \"d\", \"cd\", \"bcd\", \"abcd\"]\r\n    Return 4\r\n    The two words can be \"ab\", \"cd\".\r\n\r\n\r\n    Example 3:\r\n\r\n\r\n    Given [\"a\", \"aa\", \"aaa\", \"aaaa\"]\r\n    Return 0\r\n    No such pair of words.    \r\n\r\n\r\nCredits:Special thanks to @dietpepsi for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/398",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "BitManipulation"
      ],
      "Solution": "class Solution {\n    public int maxProduct(String[] words) {\n        if (words == null || words.length == 0)\n            return 0;\n        int len = words.length;\n        int[] bitmapWord = new int[len];\n        \n        for (int i = 0; i < len; i++) {\n            bitmapWord[i] = 0;\n            String s = words[i];\n            \n            for (int j=0; j < s.length(); j++) {\n                bitmapWord[i] = bitmapWord[i] | 1 << (s.charAt(j) - 'a');\n            }\n        }\n        int maxProduct = 0;\n        for (int i = 0; i < len; i++) {\n            for (int j = i + 1; j < len; j++) {\n                if (((bitmapWord[i] & bitmapWord[j]) == 0) && (words[i].length() * words[j].length() > maxProduct))\n                    maxProduct = words[i].length() * words[j].length();\n            }\n        }\n        return maxProduct;\n    }\n}\n",
      "total_acs": 59451,
      "total_submitted": 130975
    },
    {
      "id": 319,
      "title": "Bulb Switcher",
      "url": "https://leetcode.com/problems/bulb-switcher/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "\r\nThere are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb.\r\n\r\nFind how many bulbs are on after n rounds.\r\n\r\n\r\n\r\nExample:\r\n\r\nGiven n = 3. \r\nAt first, the three bulbs are [off, off, off].\r\nAfter first round, the three bulbs are [on, on, on].\r\nAfter second round, the three bulbs are [on, off, on].\r\nAfter third round, the three bulbs are [on, off, off]. \r\nSo you should return 1, because there is only one bulb is on.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/399",
      "similarQuestions": [
        "BulbSwitcherII"
      ],
      "topicTags": [
        "Math",
        "Brainteaser"
      ],
      "Solution": "public class Solution {\r\n    public int bulbSwitch(int n) {\r\n        \r\n        int res = 0;\r\n        \r\n        for (int i = 1 ; i*i <= n; i++){\r\n            res++;\r\n        }\r\n        \r\n        return res;\r\n    }\r\n}",
      "total_acs": 46156,
      "total_submitted": 107596
    },
    {
      "id": 320,
      "title": "Generalized Abbreviation",
      "url": "https://leetcode.com/problems/generalized-abbreviation/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Medium",
      "content": "Write a function to generate the generalized abbreviations of a word.\r\n\r\n\r\n    Example:\r\n\r\nGiven word = \"word\", return the following list (order does not matter):\r\n[\"word\", \"1ord\", \"w1rd\", \"wo1d\", \"wor1\", \"2rd\", \"w2d\", \"wo2\", \"1o1d\", \"1or1\", \"w1r1\", \"1o2\", \"2r1\", \"3d\", \"w3\", \"4\"]\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/400",
      "similarQuestions": [
        "Subsets",
        "UniqueWordAbbreviation",
        "MinimumUniqueWordAbbreviation"
      ],
      "topicTags": [
        "Backtracking",
        "BitManipulation"
      ],
      "Solution": "class Solution {\n    public List<String> generateAbbreviations(String word) {\n        List<String> res = new ArrayList();\n        \n        helper(word.toCharArray(), res, 0, 0, new StringBuilder());\n        return res;\n    }\n    \n    public void helper(char[] arr, List<String> res, int abbNum, int pos, StringBuilder sb){\n        int len = sb.length();\n        if(pos == arr.length){\n            if(abbNum != 0) sb.append(abbNum);\n            res.add(sb.toString());\n        }else{\n            helper(arr, res, abbNum+1, pos+1, sb); // abb\n            \n            if(abbNum!=0) sb.append(abbNum); // not abb\n            helper(arr, res, 0, pos + 1, sb.append(arr[pos]));\n        }\n        sb.setLength(len);\n    }\n}",
      "total_acs": 27490,
      "total_submitted": 59623
    },
    {
      "id": 321,
      "title": "Create Maximum Number",
      "url": "https://leetcode.com/problems/create-maximum-number/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Hard",
      "content": "\r\n    Given two arrays of length m and n with digits 0-9 representing two numbers.\r\n    Create the maximum number of length k <= m + n from digits of the two. The relative order of the digits\r\n    from the same array must be preserved. Return an array of the k digits. You should try to optimize your time and space complexity.\r\n\r\n\r\n\r\n    Example 1:\r\n\r\n\r\n    nums1 = [3, 4, 6, 5]\r\n    nums2 = [9, 1, 2, 5, 8, 3]\r\n    k = 5\r\n    return [9, 8, 6, 5, 3]\r\n\r\n\r\n    Example 2:\r\n\r\n\r\n    nums1 = [6, 7]\r\n    nums2 = [6, 0, 4]\r\n    k = 5\r\n    return [6, 7, 6, 0, 4]\r\n\r\n\r\n    Example 3:\r\n\r\n\r\n    nums1 = [3, 9]\r\n    nums2 = [8, 9]\r\n    k = 3\r\n    return [9, 8, 9]\r\n\r\n\r\nCredits:Special thanks to @dietpepsi for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/401",
      "similarQuestions": [
        "RemoveKDigits",
        "MaximumSwap"
      ],
      "topicTags": [
        "DynamicProgramming",
        "Greedy"
      ],
      "Solution": "/*\nclass Solution {\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\n        int n = nums1.length;\n        int m = nums2.length;\n        int[] ans = new int[k];\n        for (int i = Math.max(0, k - m); i <= k && i <= n; ++i) {\n            int[] candidate = merge(maxArray(nums1, i), maxArray(nums2, k - i), k);\n            if (greater(candidate, 0, ans, 0)) ans = candidate;\n        }\n        return ans;\n    }\n    private int[] merge(int[] nums1, int[] nums2, int k) {\n        int[] ans = new int[k];\n        for (int i = 0, j = 0, r = 0; r < k; ++r)\n            ans[r] = greater(nums1, i, nums2, j) ? nums1[i++] : nums2[j++];\n        return ans;\n    }\n    public boolean greater(int[] nums1, int i, int[] nums2, int j) {\n        while (i < nums1.length && j < nums2.length && nums1[i] == nums2[j]) {\n            i++;\n            j++;\n        }\n        return j == nums2.length || (i < nums1.length && nums1[i] > nums2[j]);\n    }\n    public int[] maxArray(int[] nums, int k) {\n        int n = nums.length;\n        int[] ans = new int[k];\n        for (int i = 0, j = 0; i < n; ++i) {\n            while (n - i + j > k && j > 0 && ans[j - 1] < nums[i]) j--;\n            if (j < k) ans[j++] = nums[i];\n        }\n        return ans;\n    }\n}\n*/\nclass Solution {\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\n        int[] result = new int[k];\n        for(int i = Math.max(0, k - nums2.length); i <= Math.min(k, nums1.length); i++) {\n            int[] max_1 = getMaxN(nums1, i);\n            int[] max_2 = getMaxN(nums2, k - i);\n            int[] current = merge(max_1, max_2);\n            if(isLarger(current, 0, result, 0))\n                result = current;\n         }\n        return result;\n    }\n\n    private int[] getMaxN(int[] nums, int n) {\n        int[] temp = new int[n];\n        int index = 0;\n        for(int i = 0; i < nums.length; i++) {\n            while(index > 0 && nums.length - i + index > n && temp[index - 1] < nums[i]) {\n                index--;\n            }\n            if(index < n)\n                temp[index++] = nums[i];\n        }\n        return temp;\n    }\n\n    private int[] merge(int[] nums1, int[] nums2) {\n        int[] temp = new int[nums1.length + nums2.length];\n        int index1 = 0; int index2 = 0;\n        while(index1 < nums1.length && index2 < nums2.length) {\n            if(isLarger(nums1, index1, nums2, index2))\n                temp[index1 + index2] = nums1[index1++];\n            else\n                temp[index1 + index2] = nums2[index2++];\n        }\n        while(index1 < nums1.length) {\n            temp[index1 + index2] = nums1[index1++];\n        }\n        while(index2 < nums2.length) {\n            temp[index1 + index2] = nums2[index2++];\n        }\n        return temp;\n    }\n\n    private boolean isLarger(int[] nums1, int n1, int[] nums2, int n2) {\n        for(; n1 < nums1.length && n2 < nums2.length; n1++, n2++) {\n            if(nums1[n1] > nums2[n2])\n                return true;\n            else if(nums1[n1] < nums2[n2])\n                return false;\n        }\n        return n1 != nums1.length;\n    }\n}",
      "total_acs": 22086,
      "total_submitted": 89109
    },
    {
      "id": 322,
      "title": "Coin Change",
      "url": "https://leetcode.com/problems/coin-change/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "\r\nYou are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\r\n\r\n\r\n\r\nExample 1:\r\ncoins = [1, 2, 5], amount = 11\r\nreturn 3 (11 = 5 + 5 + 1)\r\n\r\n\r\n\r\nExample 2:\r\ncoins = [2], amount = 3\r\nreturn -1.\r\n\r\n\r\n\r\nNote:\r\nYou may assume that you have an infinite number of each kind of coin.\r\n\r\n\r\nCredits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/402",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "DynamicProgramming"
      ],
      "Solution": "public class Solution {\n\tint min = Integer.MAX_VALUE;\n    public int coinChange(int[] coins, int amount) {\n    \tif(amount == 0)\treturn 0;\n    \tArrays.sort(coins);\n    \tcoinChange(coins, amount, coins.length - 1, 0);\n    \tif(min == Integer.MAX_VALUE)\treturn -1;\n    \treturn min;\n    }\n    \n    public void coinChange(int[] coins, int amount, int index, int num){\n    \tif(amount % coins[index] == 0){\n    \t\tint newCount = num + amount/coins[index];\n    \t\tif(newCount < min)\n    \t\t\tmin = newCount;\n    \t}\n    \t\n    \tif(index == 0)\treturn;\n    \t\n    \tint possible = amount/coins[index];\n    \tfor(int i = possible; i >= 0; i--){\n    \t\tint newAmount = amount - coins[index]*i;\n    \t\tint newNum = num + i;\n    \t\t\n    \t\tint nextCoin = coins[index-1];\n            if(newNum + (newAmount + nextCoin -1) / nextCoin >= min)\n                break;\n            \n            coinChange(coins, newAmount, index-1, newNum);\n    \t\t\n    \t}\n    }\n}",
      "total_acs": 84717,
      "total_submitted": 318155
    },
    {
      "id": 323,
      "title": "Number of Connected Components in an Undirected Graph",
      "url": "https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/description",
      "companyTags": [
        "Google",
        "Twitter"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to find the number of connected components in an undirected graph.\r\n\r\n\r\n\r\n    Example 1:\r\n\r\n\r\n     0          3\r\n     |          |\r\n     1 --- 2    4\r\n\r\n\r\n    Given n = 5 and edges = [[0, 1], [1, 2], [3, 4]], return 2.\r\n\r\n\r\n    Example 2:\r\n\r\n\r\n     0           4\r\n     |           |\r\n     1 --- 2 --- 3\r\n\r\n\r\n    Given n = 5 and edges = [[0, 1], [1, 2], [2, 3], [3, 4]], return 1.\r\n\r\n\r\n\r\nNote:\r\nYou can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/403",
      "similarQuestions": [
        "NumberofIslands",
        "GraphValidTree",
        "FriendCircles"
      ],
      "topicTags": [
        "Depth-firstSearch",
        "Breadth-firstSearch",
        "UnionFind",
        "Graph"
      ],
      "Solution": "//和#of islandsII很像\nclass Solution {\npublic int countComponents(int n, int[][] edges) {\n    int[] roots = new int[n];\n    for(int i = 0; i < n; i++) roots[i] = i; \n\n    for(int[] e : edges) {\n        int root1 = find(roots, e[0]);\n        int root2 = find(roots, e[1]);\n        if(root1 != root2) {      \n            roots[root1] = root2;  // union,两个不一样的根就union,然后总component数量--\n            n--;\n        }\n    }\n    return n;\n}\n\npublic int find(int[] roots, int id) {\n    while(roots[id] != id) {\n        roots[id] = roots[roots[id]];  // optional: path compression roots[3]=5,那么去找roots[5]看能不能满足条件，现在id变成5了\n        id = roots[id];\n    }\n    return id;\n}\n}",
      "total_acs": 33920,
      "total_submitted": 69545
    },
    {
      "id": 324,
      "title": "Wiggle Sort II",
      "url": "https://leetcode.com/problems/wiggle-sort-ii/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Medium",
      "content": "\r\n    Given an unsorted array nums, reorder it such that\r\n    nums[0] < nums[1] > nums[2] < nums[3]....\r\n\r\n\r\n\r\n    Example:\r\n    (1) Given nums = [1, 5, 1, 1, 6, 4], one possible answer is [1, 4, 1, 5, 1, 6]. \r\n    (2) Given nums = [1, 3, 2, 2, 3, 1], one possible answer is [2, 3, 1, 3, 1, 2].\r\n\r\n\r\n\r\n    Note:\r\n    You may assume all input has valid answer.\r\n\r\n\r\n\r\n    Follow Up:\r\n    Can you do it in O(n) time and/or in-place with O(1) extra space?\r\n\r\n\r\nCredits:Special thanks to @dietpepsi for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/404",
      "similarQuestions": [
        "SortColors",
        "KthLargestElementinanArray",
        "WiggleSort"
      ],
      "topicTags": [
        "Sort"
      ],
      "Solution": "//version 1:, Time Complexity O(N logN), Space Complexity O(N)\n// It can also be solved using Quick Select and three pointers\n/*class Solution {\n    public void wiggleSort(int[] nums) {\n        int n = nums.length;\n        int[] copy = Arrays.copyOf(nums, n);\n        Arrays.sort(copy);\n        int mid = (n - 1) / 2;\n        for (int i = n - 1, j = 1; i > mid; i--, j += 2) {\n            nums[j] = copy[i];\n        }\n        \n        for (int i = mid, j = 0; i >= 0; i--, j += 2) {\n            nums[j] = copy[i];\n        }\n\n    }\n}*/\n\nclass Solution {\n    public void wiggleSort(int[] nums) {\n        int n = nums.length;\n        int[] copy = Arrays.copyOf(nums, n);\n        Arrays.sort(copy);\n        int i = n - 1;\n        int j = 1;\n        while (j < n) {\n            nums[j] = copy[i];\n            j += 2;\n            i--;\n        }\n        j = 0;\n        while (i >= 0) {\n            nums[j] = copy[i];\n            j += 2;\n            i--;\n        }\n    }\n}",
      "total_acs": 36506,
      "total_submitted": 138533
    },
    {
      "id": 325,
      "title": "Maximum Size Subarray Sum Equals k",
      "url": "https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/description",
      "companyTags": [
        "Facebook",
        "Palantir"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven an array nums and a target value k, find the maximum length of a subarray that sums to k. If there isn't one, return 0 instead.\r\n\r\n\r\n\r\n    Note:\r\nThe sum of the entire nums array is guaranteed to fit within the 32-bit signed integer range.\r\n\r\n\r\n\r\n    Example 1:\r\n\r\n\r\nGiven nums = [1, -1, 5, -2, 3], k = 3,\r\nreturn 4. (because the subarray [1, -1, 5, -2] sums to 3 and is the longest)\r\n\r\n\r\n\r\n    Example 2:\r\n\r\n\r\nGiven nums = [-2, -1, 2, 1], k = 1,\r\nreturn 2. (because the subarray [-1, 2] sums to 1 and is the longest)\r\n\r\n\r\n\r\n    Follow Up:\r\n    Can you do it in O(n) time?\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/405",
      "similarQuestions": [
        "MinimumSizeSubarraySum",
        "RangeSumQuery-Immutable",
        "ContiguousArray",
        "SubarrayProductLessThanK"
      ],
      "topicTags": [
        "HashTable"
      ],
      "Solution": "class Solution {\n    public int maxSubArrayLen(int[] nums, int k) {\n        for(int i = 1; i < nums.length; i++){\n            nums[i] += nums[i - 1];\n        }\n        int res = 0;\n        HashMap<Integer, Integer> hm = new HashMap();\n        hm.put(0, 0);\n        for(int i = 0; i < nums.length; i++){\n            if(hm.containsKey(nums[i] - k)) res = Math.max(res, i + 1 - hm.get(nums[i] - k));\n            hm.putIfAbsent(nums[i], i + 1);\n        }\n        return res;\n    }\n}",
      "total_acs": 45013,
      "total_submitted": 104236
    },
    {
      "id": 326,
      "title": "Power of Three",
      "url": "https://leetcode.com/problems/power-of-three/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Easy",
      "content": "\r\n    Given an integer, write a function to determine if it is a power of three.\r\n\r\n\r\n    Follow up:\r\n    Could you do it without using any loop / recursion?\r\n\r\n\r\nCredits:Special thanks to @dietpepsi for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/406",
      "similarQuestions": [
        "PowerofTwo",
        "PowerofFour"
      ],
      "topicTags": [
        "Math"
      ],
      "Solution": "class Solution {\n    public boolean isPowerOfThree(int n) {\n        if(n < 1)\n            return false;\n        while(n > 1){\n            if(n%3 == 0){\n                n = n/3;\n            }\n            else{\n                return false;\n            }\n        }\n        return true;    \n    }\n}",
      "total_acs": 117386,
      "total_submitted": 289171
    },
    {
      "id": 327,
      "title": "Count of Range Sum",
      "url": "https://leetcode.com/problems/count-of-range-sum/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Hard",
      "content": "\r\n    Given an integer array nums, return the number of range sums that lie in [lower, upper] inclusive.\r\n\r\n    Range sum S(i, j) is defined as the sum of the elements in nums between indices i and \r\n    j (i ≤ j), inclusive.\r\n\r\n\r\n\r\n    Note:\r\n    A naive algorithm of O(n2) is trivial. You MUST do better than that.\r\n\r\n\r\n    Example:\r\n    Given nums = [-2, 5, -1], lower = -2, upper = 2,\r\n    Return 3.\r\n    The three ranges are : [0, 0], [2, 2], [0, 2] and their respective sums are: -2, -1, 2.\r\n\r\n\r\nCredits:Special thanks to @dietpepsi for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/408",
      "similarQuestions": [
        "CountofSmallerNumbersAfterSelf",
        "ReversePairs"
      ],
      "topicTags": [
        "DivideandConquer",
        "BinarySearchTree"
      ],
      "Solution": "class Solution {\n    public int countRangeSum(int[] nums, int lower, int upper) {\n        int m = nums.length;\n        long[] sum = new long[m+1];\n        long[] tmp = new long[m+1];\n        for(int i = 0; i < m; i++){\n            sum[i+1] = sum[i] + nums[i];\n        }\n        \n        return countMerge(sum, tmp, 0, m+1, lower, upper);\n    }\n    \n    int countMerge(long[] sum, long[] tmp, int start, int end, int lower, int upper){\n        int res = 0;\n        if(end-start <= 1) return res;\n\n        int mid =  start  + (end-start) /2;\n        res += countMerge(sum, tmp, start, mid, lower, upper);\n        res += countMerge(sum, tmp, mid, end, lower, upper);\n        res += merge(sum, tmp, start, end, mid, lower, upper);\n\n        return res;\n    }\n    \n    int merge(long[] sum, long[] tmp, int start, int end, int mid, int lower, int upper){\n        int j = mid, k = mid, t = mid;\n        int count = 0;\n\n\n        for (int i = start, r = start; i < mid; ++i, ++r) {\n\n            while (k < end && sum[k] - sum[i] < lower) k++;\n\n            while (j < end && sum[j] - sum[i] <= upper) j++;\n\n            while (t < end && sum[t] < sum[i]) tmp[r++] = sum[t++];\n\n            tmp[r] = sum[i];\n\n            count += j - k;\n\n        }\n\n        System.arraycopy(tmp, start, sum, start, t - start);\n\n        return count;\n    }\n}",
      "total_acs": 22458,
      "total_submitted": 73560
    },
    {
      "id": 328,
      "title": "Odd Even Linked List",
      "url": "https://leetcode.com/problems/odd-even-linked-list/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.\r\n\r\nYou should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.\r\n\r\n\r\nExample:\r\nGiven 1->2->3->4->5->NULL,\r\nreturn 1->3->5->2->4->NULL.\r\n\r\n\r\nNote:\r\nThe relative order inside both the even and odd groups should remain as it was in the input. \r\nThe first node is considered odd, the second node even and so on ...\r\n\r\n\r\nCredits:Special thanks to @DjangoUnchained for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/409",
      "similarQuestions": [
        "SplitLinkedListinParts"
      ],
      "topicTags": [
        "LinkedList"
      ],
      "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode oddEvenList(ListNode head) {\n        if (head == null) return null;\n        if (head.next == null) return head;\n        ListNode evenHead = head.next;\n        ListNode oddList = head;\n        ListNode evenList = head.next;\n        ListNode node = head.next.next;\n        int count = 0;\n        while (node != null){\n            count++;\n            if (count % 2 == 1){\n                oddList.next = node;\n                oddList = oddList.next;\n            }\n            else{\n                evenList.next = node;\n                evenList = evenList.next;\n            }\n            node = node.next;\n        }\n        evenList.next = null;\n        oddList.next = evenHead;\n        return head;\n    }\n}",
      "total_acs": 86482,
      "total_submitted": 194334
    },
    {
      "id": 329,
      "title": "Longest Increasing Path in a Matrix",
      "url": "https://leetcode.com/problems/longest-increasing-path-in-a-matrix/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Hard",
      "content": "Given an integer matrix, find the length of the longest increasing path.\r\n\r\n\r\nFrom each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).\r\n\r\n\r\nExample 1:\r\n\r\nnums = [\r\n  [9,9,4],\r\n  [6,6,8],\r\n  [2,1,1]\r\n]\r\n\r\n\r\n\r\n\r\nReturn 4\r\n\r\nThe longest increasing path is [1, 2, 6, 9].\r\n\r\n\r\nExample 2:\r\n\r\nnums = [\r\n  [3,4,5],\r\n  [3,2,6],\r\n  [2,2,1]\r\n]\r\n\r\n\r\n\r\n\r\nReturn 4\r\n\r\nThe longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.\r\n\r\nCredits:Special thanks to @dietpepsi for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/410",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Depth-firstSearch",
        "TopologicalSort",
        "Memoization"
      ],
      "Solution": "class Solution {\n    int[][] dirs = new int[][]{{-1, 0}, {0, 1}, {0, -1}, {1, 0}};\n    public int longestIncreasingPath(int[][] matrix) {\n        if (matrix == null || matrix.length == 0 || matrix[0] == null || matrix[0].length == 0) {\n            return 0;\n        }\n        \n        int[][] record = new int[matrix.length][matrix[0].length];\n        int max = 0;\n        for (int i = 0; i < matrix.length; i++) {\n            for (int j = 0; j < matrix[0].length; j++) {\n                if (record[i][j] == 0) {\n                    max = Math.max(max, dfs(matrix, record, i, j));\n                }\n            }\n        }\n        return max;\n    }\n    \n    public int dfs(int[][] matrix, int[][] record, int i, int j) {\n        if (record[i][j] != 0) {\n            return record[i][j];\n        }\n        int max =  1;\n        \n        for (int[] dir: dirs){\n            int x = i + dir[0];\n            int y = j + dir[1];\n            if ( x >= 0 && x < matrix.length && y >= 0 && y < matrix[0].length && matrix[x][y] > matrix[i][j]) {\n                int len = dfs(matrix, record, x, y);\n                max = Math.max(max, 1 + len);\n            }\n        }\n        record[i][j] = max;\n        \n        return max;\n    }\n    \n    \n}",
      "total_acs": 48324,
      "total_submitted": 129725
    },
    {
      "id": 330,
      "title": "Patching Array",
      "url": "https://leetcode.com/problems/patching-array/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Hard",
      "content": "Given a sorted positive integer array nums and an integer n, add/patch elements to the array such that any number in range [1, n] inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required.\r\n\r\n\r\nExample 1:\r\nnums = [1, 3], n = 6\r\nReturn 1.\r\n\r\nCombinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.\r\nNow if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].\r\nPossible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].\r\nSo we only need 1 patch.\r\n\r\nExample 2:\r\nnums = [1, 5, 10], n = 20\r\nReturn 2.\r\nThe two patches can be [2, 4].\r\n\r\nExample 3:\r\nnums = [1, 2, 2], n = 5\r\nReturn 0.\r\n\r\nCredits:Special thanks to @dietpepsi for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/411",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Greedy"
      ],
      "Solution": "class Solution {\n    public int minPatches(int[] nums, int n) {\n        int i = 0, cnt = 0;\n        long maxNum = 0;\n        while (maxNum < n) {\n            if (i < nums.length && nums[i] <= maxNum + 1) maxNum += nums[i++];\n            else {\n                cnt++;\n                maxNum += maxNum + 1;\n            }\n        }\n\n        return cnt;\n    }\n}",
      "total_acs": 25371,
      "total_submitted": 77937
    },
    {
      "id": 331,
      "title": "Verify Preorder Serialization of a Binary Tree",
      "url": "https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Medium",
      "content": "One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node's value. If it is a null node, we record using a sentinel value such as #.\r\n\r\n\r\n     _9_\r\n    /   \\\r\n   3     2\r\n  / \\   / \\\r\n 4   1  #  6\r\n/ \\ / \\   / \\\r\n# # # #   # #\r\n\r\n\r\nFor example, the above binary tree can be serialized to the string \"9,3,4,#,#,1,#,#,2,#,6,#,#\", where # represents a null node.\r\n\r\n\r\nGiven a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree. Find an algorithm without reconstructing the tree.\r\n\r\nEach comma separated value in the string must be either an integer or a character '#' representing null pointer.\r\n\r\nYou may assume that the input format is always valid, for example it could never contain two consecutive commas such as \"1,,3\".\r\n\r\nExample 1:\r\n\"9,3,4,#,#,1,#,#,2,#,6,#,#\"\r\nReturn true\r\nExample 2:\r\n\"1,#\"\r\nReturn false\r\nExample 3:\r\n\"9,#,#,1\"\r\nReturn false\r\n\r\nCredits:Special thanks to @dietpepsi for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/412",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Stack"
      ],
      "Solution": "class Solution {\n    public boolean isValidSerialization(String preorder) {\n        if (preorder==null || preorder.length()==0) return false;\n        if (preorder.length()==1){\n            if (preorder.charAt(0)=='#')return true;\n            else return false;\n        }\n        int[] start = new int[1];\n        char[] sArray = preorder.toCharArray();\n        return check(sArray, start) && start[0]==sArray.length+1;\n    }\n    \n    private boolean check (char[] sArray, int[] start){\n        if (start[0]>=sArray.length) return false;\n        if (sArray[start[0]]=='#') {\n            start[0]+=2;\n            return true;\n        }\n        int end=start[0];\n        while (end<sArray.length && sArray[end]!=',') end++;\n        if (end>=sArray.length) return false;\n        start[0]=end+1;\n        return check(sArray, start) && check(sArray, start);\n    }\n}",
      "total_acs": 43134,
      "total_submitted": 116794
    },
    {
      "id": 332,
      "title": "Reconstruct Itinerary",
      "url": "https://leetcode.com/problems/reconstruct-itinerary/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Medium",
      "content": "Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK.\r\n\r\n\r\nNote:\r\n\r\nIf there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary [\"JFK\", \"LGA\"] has a smaller lexical order than [\"JFK\", \"LGB\"].\r\nAll airports are represented by three capital letters (IATA code).\r\nYou may assume all tickets form at least one valid itinerary.\r\n\r\n\r\n\r\n\r\n    Example 1:\r\n    tickets = [[\"MUC\", \"LHR\"], [\"JFK\", \"MUC\"], [\"SFO\", \"SJC\"], [\"LHR\", \"SFO\"]]\r\n    Return [\"JFK\", \"MUC\", \"LHR\", \"SFO\", \"SJC\"].\r\n\r\n\r\n    Example 2:\r\n    tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]]\r\n    Return [\"JFK\",\"ATL\",\"JFK\",\"SFO\",\"ATL\",\"SFO\"].\r\n    Another possible reconstruction is [\"JFK\",\"SFO\",\"ATL\",\"JFK\",\"ATL\",\"SFO\"]. But it is larger in lexical order.\r\n\r\n\r\nCredits:Special thanks to @dietpepsi for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/416",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Depth-firstSearch",
        "Graph"
      ],
      "Solution": "class Solution {\n    Map<String,PriorityQueue<String>> map = null;\n    LinkedList<String> result = new LinkedList<String>();\n    public List<String> findItinerary(String[][] tickets) {\n        map = getMap(tickets);\n        makeItinerary(\"JFK\");\n        return result;\n    }\n    \n    \n    private void makeItinerary(String from){\n        if(from == null) return;\n    \n      PriorityQueue<String> tos = map.get(from);\n       while(tos !=null && !tos.isEmpty())\n           makeItinerary(tos.poll());\n        result.addFirst(from);       \n    } \n    \n    \n    private Map<String,PriorityQueue<String>> getMap(String[][] tickets){\n        Map<String,PriorityQueue<String>> map = new HashMap<String,PriorityQueue<String>>();\n        for(String[] ticket: tickets){\n            String from = ticket[0];\n            String to = ticket[1];\n            if(!map.containsKey(from))\n                map.put(from,new PriorityQueue<String>());\n            map.get(from).offer(to);\n        }     \n        return map;\n    }\n}",
      "total_acs": 44763,
      "total_submitted": 150515
    },
    {
      "id": 333,
      "title": "Largest BST Subtree",
      "url": "https://leetcode.com/problems/largest-bst-subtree/description",
      "companyTags": [
        "Microsoft"
      ],
      "difficulty": "Medium",
      "content": "Given a binary tree, find the largest subtree which is a Binary Search Tree (BST), where largest means subtree with largest number of nodes in it.\r\nNote:\r\nA subtree must include all of its descendants.\r\nHere's an example:\r\n\r\n    10\r\n    / \\\r\n   5  15\r\n  / \\   \\ \r\n 1   8   7\r\n\r\nThe Largest BST Subtree in this case is the highlighted one. \r\nThe return value is the subtree's size, which is 3. \r\n\r\n\r\n\r\nFollow up:\r\nCan you figure out ways to solve it with O(n) time complexity?\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/417",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Tree"
      ],
      "Solution": "class Solution {\n    public int largestBSTSubtree(TreeNode root) {\n        int[] res = new int[1];\n        traverse(root, res);\n        return res[0];\n    }\n    int[] traverse(TreeNode root, int[] res) {\n        if(root == null) return null;\n        int[] left = traverse(root.left, res), right = traverse(root.right, res);\n        if((left != null && left[0] < 0) || (right != null && right[0] < 0)) return new int[]{-1, 0, 0};\n        int size = 1, min = root.val, max = root.val;\n        if(left != null) {\n            if(min <= left[2]) return new int[]{-1, 0, 0};\n            min = left[1];\n            size += left[0];\n        }\n        if(right != null) {\n            if(max >= right[1]) return new int[]{-1, 0, 0};\n            max = right[2];\n            size += right[0];\n        }\n        res[0] = Math.max(res[0], size);\n        return new int[]{size, min, max};\n    }\n}",
      "total_acs": 19533,
      "total_submitted": 63099
    },
    {
      "id": 334,
      "title": "Increasing Triplet Subsequence",
      "url": "https://leetcode.com/problems/increasing-triplet-subsequence/description",
      "companyTags": [
        "Facebook"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.\r\n\r\n\r\nFormally the function should:\r\nReturn true if there exists i, j, k  \r\nsuch that arr[i] < arr[j] < arr[k] given 0 ≤ i < j < k ≤ n-1 \r\nelse return false.\r\n\r\n\r\n\r\nYour algorithm should run in O(n) time complexity and O(1) space complexity.\r\n\r\n\r\nExamples:\r\nGiven [1, 2, 3, 4, 5],\r\nreturn true.\r\n\r\n\r\nGiven [5, 4, 3, 2, 1],\r\nreturn false.\r\n\r\n\r\nCredits:Special thanks to @DjangoUnchained for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/418",
      "similarQuestions": [
        "LongestIncreasingSubsequence"
      ],
      "topicTags": [
        ""
      ],
      "Solution": "class Solution {\n    public boolean increasingTriplet(int[] nums) {\n        // start with two largest values, as soon as we find a number bigger than both, while both have been updated, return true.\n        int small = Integer.MAX_VALUE, big = Integer.MAX_VALUE;\n        for (int n : nums) {\n            if (n <= small) { small = n; } // update small if n is smaller than both\n            else if (n <= big) { big = n; } // update big only if greater than small but smaller than big\n            else return true; // return if you find a number bigger than both\n        }\n        return false;\n    }\n}",
      "total_acs": 55093,
      "total_submitted": 137975
    },
    {
      "id": 335,
      "title": "Self Crossing",
      "url": "https://leetcode.com/problems/self-crossing/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Hard",
      "content": "\r\n    You are given an array x of n positive numbers. You start at point (0,0) and moves x[0] metres to the north, then x[1] metres to the west,\r\n    x[2] metres to the south,\r\n    x[3] metres to the east and so on. In other words, after each move your direction changes\r\n    counter-clockwise.\r\n\r\n\r\n    Write a one-pass algorithm with O(1) extra space to determine, if your path crosses itself, or not.\r\n\r\n\r\n\r\nExample 1:\r\n\r\nGiven x = [2, 1, 1, 2],\r\n?????\r\n?   ?\r\n???????>\r\n    ?\r\n\r\nReturn true (self crossing)\r\n\r\n\r\n\r\n\r\nExample 2:\r\n\r\nGiven x = [1, 2, 3, 4],\r\n????????\r\n?      ?\r\n?\r\n?\r\n?????????????>\r\n\r\nReturn false (not self crossing)\r\n\r\n\r\n\r\n\r\nExample 3:\r\n\r\nGiven x = [1, 1, 1, 1],\r\n?????\r\n?   ?\r\n?????>\r\n\r\nReturn true (self crossing)\r\n\r\n\r\n\r\nCredits:Special thanks to @dietpepsi for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/419",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Math"
      ],
      "Solution": "class Solution {\n    public boolean isSelfCrossing(int[] x) {\n        for (int n = 3; n < x.length; n++) {\n            if (n >= 4) {\n                if ((x[n - 1] > x[n - 3]) && (x[n - 2] > x[n - 4]))\n                    continue;\n                if (((x[n] + x[n - 4]) >= x[n - 2]) && (x[n - 1] == x[n - 3])) {\n                    System.out.println(\"2_\" + n);\n                    return true;\n                }\n            }\n            if (n >= 5) {\n                if (((x[n] + x[n - 4]) >= x[n - 2]) && ((x[n - 1] + x[n - 5]) >= x[n - 3])  && (x[n - 2] >= x[n - 4])) {\n                    System.out.println(\"1_\" + n);\n                    return true;\n                    \n                }\n            }\n            if ((x[n - 1] <= x[n-3]) && (x[n] >= x[n - 2])) {\n                System.out.println(\"3_\" + n);\n                return true;\n            }\n        }\n        return false;\n    }\n}",
      "total_acs": 15875,
      "total_submitted": 61154
    },
    {
      "id": 336,
      "title": "Palindrome Pairs",
      "url": "https://leetcode.com/problems/palindrome-pairs/description",
      "companyTags": [
        "Google",
        "Airbnb"
      ],
      "difficulty": "Hard",
      "content": "\r\n    Given a list of unique words, find all pairs of distinct indices (i, j) in the given list, so that the concatenation of the two words, i.e. words[i] + words[j] is a palindrome.\r\n\r\n\r\n\r\n    Example 1:\r\n    Given words = [\"bat\", \"tab\", \"cat\"]\r\n    Return [[0, 1], [1, 0]]\r\n    The palindromes are [\"battab\", \"tabbat\"]\r\n\r\n\r\n    Example 2:\r\n    Given words = [\"abcd\", \"dcba\", \"lls\", \"s\", \"sssll\"]\r\n    Return [[0, 1], [1, 0], [3, 2], [2, 4]]\r\n    The palindromes are [\"dcbaabcd\", \"abcddcba\", \"slls\", \"llssssll\"]\r\n\r\n\r\nCredits:Special thanks to @dietpepsi for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/420",
      "similarQuestions": [
        "LongestPalindromicSubstring",
        "ShortestPalindrome"
      ],
      "topicTags": [
        "HashTable",
        "String",
        "Trie"
      ],
      "Solution": "class Solution {\n    public Boolean isPalindrome(String word, int lo, int hi) {\n        while (lo < hi) {\n            if (word.charAt(lo) != word.charAt(hi)) {\n                return false;\n            }\n            \n            lo++;\n            hi--;\n        }\n        \n        return true;\n    }\n    \n    class TrieNode {\n        TrieNode[] children = null;\n        List<Integer> list = null;\n        int idx;\n        \n        public TrieNode() {\n            children = new TrieNode[26];\n            list = new LinkedList<Integer>();\n            idx = -1;\n        }\n    }\n    \n    public void addWords(TrieNode root, String word, int idx) {\n        TrieNode cur = root;\n        for (int i = word.length() - 1; i >= 0; i--) {\n            char c = word.charAt(i);\n            if (cur.children[c - 'a'] == null) {\n                cur.children[c - 'a'] = new TrieNode();\n            }\n            \n            if (isPalindrome(word, 0, i)) {\n                cur.list.add(idx);\n            }\n            \n            cur = cur.children[c - 'a'];\n        }\n        cur.list.add(idx);\n        cur.idx = idx;\n    }\n    \n    public void searchWords(TrieNode root, String word, int idx, List<List<Integer>> res) {\n        TrieNode cur = root;\n        for (int i = 0; i < word.length(); i++) {\n            if (cur.idx >= 0 && cur.idx != idx && isPalindrome(word, i, word.length() - 1)) {\n                res.add(Arrays.asList(idx, cur.idx));\n            }\n            \n            char c = word.charAt(i);\n            if (cur.children[c - 'a'] == null) {\n                return;\n            }\n            \n            cur = cur.children[c - 'a'];\n        }\n        \n        for (int num : cur.list) {\n            if (idx == num)\n                continue;\n            \n            res.add(Arrays.asList(idx, num));\n        }\n    }\n    \n    public List<List<Integer>> palindromePairs(String[] words) {\n        List<List<Integer>> res = new LinkedList<List<Integer>>();\n        \n        TrieNode root = new TrieNode();\n        for (int i = 0; i < words.length; i++) {\n            addWords(root, words[i], i);\n        }\n        \n        for (int i = 0; i < words.length; i++) {\n            searchWords(root, words[i], i, res);\n        }\n        \n        return res;\n    }\n}",
      "total_acs": 35301,
      "total_submitted": 130703
    },
    {
      "id": 337,
      "title": "House Robber III",
      "url": "https://leetcode.com/problems/house-robber-iii/description",
      "companyTags": [
        "Uber"
      ],
      "difficulty": "Medium",
      "content": "\r\nThe thief has found himself a new place for his thievery again. There is only one entrance to this area, called the \"root.\" Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that \"all houses in this place forms a binary tree\". It will automatically contact the police if two directly-linked houses were broken into on the same night.\r\n\r\n\r\n\r\nDetermine the maximum amount of money the thief can rob tonight without alerting the police.\r\n\r\n\r\nExample 1:\r\n\r\n     3\r\n    / \\\r\n   2   3\r\n    \\   \\ \r\n     3   1\r\n\r\nMaximum amount of money the thief can rob = 3 + 3 + 1 = 7.\r\n\r\n\r\nExample 2:\r\n\r\n     3\r\n    / \\\r\n   4   5\r\n  / \\   \\ \r\n 1   3   1\r\n\r\nMaximum amount of money the thief can rob = 4 + 5 = 9.\r\n\r\n\r\nCredits:Special thanks to @dietpepsi for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/421",
      "similarQuestions": [
        "HouseRobber",
        "HouseRobberII"
      ],
      "topicTags": [
        "Tree",
        "Depth-firstSearch"
      ],
      "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public int rob(TreeNode root) {\n        if (root == null) return 0;\n        int[] result = help(root); //return int[]{with root, without root}\n        return Math.max(result[0], result[1]);\n    }\n    \n    private int[] help(TreeNode root) {\n        if (root == null) {\n            return new int[]{0, 0};\n        }\n        int[] left = help(root.left);\n        int[] right = help(root.right);\n        //with root\n        int with = root.val + left[1] + right[1];\n        int without = left[0] + right[0];\n        with = Math.max(with, without);\n        int[] result = new int[]{with, without};\n        return result;\n    }\n    \n}",
      "total_acs": 59069,
      "total_submitted": 132795
    },
    {
      "id": 338,
      "title": "Counting Bits",
      "url": "https://leetcode.com/problems/counting-bits/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1's in their binary representation and return them as an array.\r\n\r\n\r\nExample:\r\nFor num = 5 you should return [0,1,1,2,1,2].\r\n\r\n\r\nFollow up:\r\n\r\nIt is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?\r\nSpace complexity should be O(n).\r\nCan you do it like a boss? Do it without using any builtin function like __builtin_popcount  in c++ or in any other language.\r\n\r\n\r\n\r\nCredits:Special thanks to @ syedee  for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/422",
      "similarQuestions": [
        "Numberof1Bits"
      ],
      "topicTags": [
        "DynamicProgramming",
        "BitManipulation"
      ],
      "Solution": "class Solution {\n    public int[] countBits(int num) {\n        int[] ans = new int[num + 1];\n        ans[0] = 0;\n        for (int i = 1; i <= num; i++) {\n            if ((i & 1) == 1) ans[i] = ans[i >> 1] + 1;\n            else ans[i] = ans[i >> 1];\n        }\n        \n        return ans;\n    }\n}",
      "total_acs": 103009,
      "total_submitted": 166030
    },
    {
      "id": 339,
      "title": "Nested List Weight Sum",
      "url": "https://leetcode.com/problems/nested-list-weight-sum/description",
      "companyTags": [
        "LinkedIn"
      ],
      "difficulty": "Easy",
      "content": "Given a nested list of integers, return the sum of all integers in the list weighted by their depth.\r\n\r\nEach element is either an integer, or a list -- whose elements may also be integers or other lists.\r\n\r\nExample 1:\r\nGiven the list [[1,1],2,[1,1]], return 10. (four 1's at depth 2, one 2 at depth 1)\r\n\r\nExample 2:\r\nGiven the list [1,[4,[6]]], return 27. (one 1 at depth 1, one 4 at depth 2, and one 6 at depth 3; 1 + 4*2 + 6*3 = 27)\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/423",
      "similarQuestions": [
        "NestedListWeightSumII",
        "ArrayNesting",
        "EmployeeImportance"
      ],
      "topicTags": [
        "Depth-firstSearch"
      ],
      "Solution": "/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * public interface NestedInteger {\n *\n *     // @return true if this NestedInteger holds a single integer, rather than a nested list.\n *     public boolean isInteger();\n *\n *     // @return the single integer that this NestedInteger holds, if it holds a single integer\n *     // Return null if this NestedInteger holds a nested list\n *     public Integer getInteger();\n *\n *     // @return the nested list that this NestedInteger holds, if it holds a nested list\n *     // Return null if this NestedInteger holds a single integer\n *     public List<NestedInteger> getList();\n * }\n */\npublic class Solution {\n    // Recursive\n    public int depthSum(List<NestedInteger> nestedList) {\n        if(nestedList == null || nestedList.size() == 0)\n            return 0;\n        \n        return helper(nestedList, 1);\n    }\n    \n    private int helper(List<NestedInteger> list, int level) {\n        if(list == null)\n            return 0;\n\n        int sum = 0;\n        for(NestedInteger n : list) {\n            if(n.isInteger())\n                sum = sum + n.getInteger() * level;\n            else\n                sum = sum + helper(n.getList(), level + 1);\n        }\n        \n        return sum;\n    }\n    \n    // Iterative\n    /*\n    public int depthSum(List<NestedInteger> nestedList) {\n        Queue<NestedInteger> queue = new LinkedList<>();\n        \n        for(int i = 0; i < nestedList.size(); i++)\n            queue.offer(nestedList.get(i));\n        \n        int level = 0;\n        int sum = 0;\n        while(!queue.isEmpty()) {\n            level++;\n            int size = queue.size();\n            for(int i = 0; i < size; i++) {\n                NestedInteger curr = queue.poll();\n                \n                if(curr.isInteger())\n                    sum = sum + curr.getInteger() * level;\n                else {\n                    List<NestedInteger> list = curr.getList();\n                    \n                    for(NestedInteger item : list)\n                        queue.offer(item);                    \n                }\n            }\n        }\n\n        return sum;\n    }\n    */\n}",
      "total_acs": 31917,
      "total_submitted": 50251
    },
    {
      "id": 340,
      "title": "Longest Substring with At Most K Distinct Characters",
      "url": "https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/description",
      "companyTags": [
        "Google",
        "AppDynamics",
        "Coupang"
      ],
      "difficulty": "Hard",
      "content": "\r\nGiven a string, find the length of the longest substring T that contains at most k distinct characters.\r\n\r\n\r\n\r\nFor example,\r\n\r\nGiven s = “eceba” and k = 2,\r\n\r\n\r\n\r\nT is \"ece\" which its length is 3.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/424",
      "similarQuestions": [
        "LongestSubstringwithAtMostTwoDistinctCharacters",
        "LongestRepeatingCharacterReplacement"
      ],
      "topicTags": [
        "HashTable",
        "String"
      ],
      "Solution": "class Solution {\n    // Solution 1: two pointer\n    // Solution 2: TreeMap<>. dealing with stream input\n    public int lengthOfLongestSubstringKDistinct(String s, int k) {\n        char[] arr = s.toCharArray();\n        int[] table = new int[256];\n        int start = 0;\n        int maxLen = 0;\n        int count = 0;\n        for(int end = 0; end < arr.length; end++) {\n            if(table[arr[end]]++ == 0) {\n                count++;\n                while(count > k) {\n                    if(--table[arr[start++]] == 0) {\n                        count--;\n                    }\n                }\n            }\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}",
      "total_acs": 34704,
      "total_submitted": 88541
    },
    {
      "id": 341,
      "title": "Flatten Nested List Iterator",
      "url": "https://leetcode.com/problems/flatten-nested-list-iterator/description",
      "companyTags": [
        "Google",
        "Facebook",
        "Twitter"
      ],
      "difficulty": "Medium",
      "content": "Given a nested list of integers, implement an iterator to flatten it.\r\n\r\nEach element is either an integer, or a list -- whose elements may also be integers or other lists.\r\n\r\nExample 1:\r\nGiven the list [[1,1],2,[1,1]],\r\n\r\nBy calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].\r\n\r\n\r\n\r\nExample 2:\r\nGiven the list [1,[4,[6]]],\r\n\r\nBy calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/425",
      "similarQuestions": [
        "Flatten2DVector",
        "ZigzagIterator",
        "MiniParser",
        "ArrayNesting"
      ],
      "topicTags": [
        "Stack",
        "Design"
      ],
      "Solution": "/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * public interface NestedInteger {\n *\n *     // @return true if this NestedInteger holds a single integer, rather than a nested list.\n *     public boolean isInteger();\n *\n *     // @return the single integer that this NestedInteger holds, if it holds a single integer\n *     // Return null if this NestedInteger holds a nested list\n *     public Integer getInteger();\n *\n *     // @return the nested list that this NestedInteger holds, if it holds a nested list\n *     // Return null if this NestedInteger holds a single integer\n *     public List<NestedInteger> getList();\n * }\n */\n\n// public class NestedIterator implements Iterator<Integer> {\n\n//     Deque<NestedInteger> dq;\n\n//     public NestedIterator(List<NestedInteger> nestedList) {\n//         // Arrays.asList(T... a)\n//         dq = new ArrayDeque<>(nestedList == null ? Arrays.asList() : nestedList);\n        \n//     }\n\n//     @Override\n//     public Integer next() {\n//         return dq.pollFirst().getInteger();\n//     }\n\n//     @Override\n//     public boolean hasNext() {\n//         //  while(!dq.isEmpty() && !dq.peekFirst().isInteger()) {\n//         //     List<NestedInteger> list = dq.pollFirst().getList();\n//         //     for (int i=list.size()-1; i>=0; i--) dq.addFirst(list.get(i));\n//         // }\n//         // return !dq.isEmpty();\n//         while(!dq.isEmpty())\n//         {\n//             // peekFirst is equivalent to stack#peek\n//             NestedInteger ni = dq.peekFirst();\n//             if(ni.isInteger()) return true;\n            \n//             // Kengkeng... pop it\n//             dq.removeFirst();\n            \n//             // Kengkeng...push from back to front to keep Integer in original order\n//             // e.g. [1,[4,[6]]]\n//             // expected: 1, 4, 6\n//             List<NestedInteger> ln = ni.getList();\n//             for(int i = ln.size() -1 ; i >= 0; i--)\n//             {\n//                 // addFrist is equivalent to stack#push\n//                 dq.addFirst(ln.get(i));\n//             }\n//         }\n//         return false;\n//     }\n// }\n\n/**\n * Your NestedIterator object will be instantiated and called as such:\n * NestedIterator i = new NestedIterator(nestedList);\n * while (i.hasNext()) v[f()] = i.next();\n */\n\n// Given a nested list of integers, implement an iterator to flatten it.\n\n// Each element is either an integer, or a list -- whose elements may also be integers or other lists.\n\n// Example 1:\n// Given the list [[1,1],2,[1,1]],\n\n// By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].\n\n// Example 2:\n// Given the list [1,[4,[6]]],\n\n// By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].\n\n\n// recursively\npublic class NestedIterator implements Iterator<Integer> {\n\n  private LinkedList<ListIterator<NestedInteger>> itList;\n  private Integer answer;\n\n  public NestedIterator(List<NestedInteger> nestedList) {\n    // permits null entry\n    itList = new LinkedList<>();\n    itList.addLast(nestedList.listIterator());\n    answer = null;\n  }\n\n  @Override\n  public Integer next() {\n    Integer i = answer;\n    answer = null;\n    return i;\n  }\n\n  @Override\n  public boolean hasNext() {\n    if (answer != null) \n    {\n        return true;\n    } \n    else \n    {\n        ListIterator<NestedInteger> litr = itList.peekLast();\n        if (litr == null) \n        {\n            return false;\n        } \n        else if(litr.hasNext() == false) \n        {\n            itList.removeLast();\n            // Kengkeng...instead of \"return false\"\n            // [[1,1],2]\n            return hasNext();  // [1,1,2] \n            //return false; // [1,1]\n        } \n        else \n        {\n            NestedInteger ni = litr.next();\n            if (ni.isInteger()) \n            {\n                answer = ni.getInteger();\n                return true;\n            } \n            else \n            {\n                itList.addLast(ni.getList().listIterator());\n                return hasNext();\n            }\n        }\n    }\n  }\n}",
      "total_acs": 57341,
      "total_submitted": 133697
    },
    {
      "id": 342,
      "title": "Power of Four",
      "url": "https://leetcode.com/problems/power-of-four/description",
      "companyTags": [
        "TwoSigma"
      ],
      "difficulty": "Easy",
      "content": "\r\nGiven an integer (signed 32 bits), write a function to check whether it is a power of 4.\r\n\r\nExample:\r\nGiven num = 16, return true.\r\nGiven num = 5, return false.\r\n\r\n\r\nFollow up: Could you solve it without loops/recursion?\r\n\r\nCredits:Special thanks to @yukuairoy  for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/426",
      "similarQuestions": [
        "PowerofTwo",
        "PowerofThree"
      ],
      "topicTags": [
        "BitManipulation"
      ],
      "Solution": "class Solution {\n    public boolean isPowerOfFour(int num) {\n        return num > 0 && (num & (num - 1)) == 0 && (num - 1) % 3 == 0;\n    }\n}",
      "total_acs": 80057,
      "total_submitted": 205498
    },
    {
      "id": 343,
      "title": "Integer Break",
      "url": "https://leetcode.com/problems/integer-break/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get.\r\n\r\n\r\n\r\nFor example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4).\r\n\r\n\r\n\r\nNote: You may assume that n is not less than 2 and not larger than 58.\r\n\r\n\r\nCredits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/427",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Math",
        "DynamicProgramming"
      ],
      "Solution": "class Solution {\n    public int integerBreak(int n) {\n        //base case\n        if(n == 1) {\n            return 1;\n        }\n        int[] dp = new int[n + 1];\n        dp[1] = 1;\n        for(int i = 2; i < dp.length; i++) {\n            for(int j = 1; j <= i / 2; j++) {\n                dp[i] = Math.max(dp[i], Math.max(dp[j], j) * Math.max(i - j, dp[i - j]));\n            }\n        }\n        return dp[n];\n    }\n}",
      "total_acs": 53620,
      "total_submitted": 115381
    },
    {
      "id": 344,
      "title": "Reverse String",
      "url": "https://leetcode.com/problems/reverse-string/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Easy",
      "content": "Write a function that takes a string as input and returns the string reversed.\r\n\r\n\r\nExample:\r\nGiven s = \"hello\", return \"olleh\".\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/428",
      "similarQuestions": [
        "ReverseVowelsofaString",
        "ReverseStringII"
      ],
      "topicTags": [
        "TwoPointers",
        "String"
      ],
      "Solution": "class Solution {\n    public String reverseString(String s) {\n        char[] charArray = s.toCharArray();\n        char[] charArray_2 = new char[charArray.length];\n        for (int i = 0; i < charArray.length; i++) {\n            charArray_2[charArray_2.length-i-1] = charArray[i];\n        }\n        return new String(charArray_2);\n    }\n}",
      "total_acs": 217155,
      "total_submitted": 361826
    },
    {
      "id": 345,
      "title": "Reverse Vowels of a String",
      "url": "https://leetcode.com/problems/reverse-vowels-of-a-string/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Easy",
      "content": "Write a function that takes a string as input and reverse only the vowels of a string.\r\n\r\n\r\nExample 1:\r\nGiven s = \"hello\", return \"holle\".\r\n\r\n\r\n\r\nExample 2:\r\nGiven s = \"leetcode\", return \"leotcede\".\r\n\r\n\r\n\r\nNote:\r\nThe vowels does not include the letter \"y\".\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/429",
      "similarQuestions": [
        "ReverseString"
      ],
      "topicTags": [
        "TwoPointers",
        "String"
      ],
      "Solution": "class Solution {\n    public String reverseVowels(String s) {\n        // ue oai\n        boolean[] marked = new boolean[256];\n        \n        marked['u'] = true;\n        marked['e'] = true;\n        marked['o'] = true;\n        marked['a'] = true;\n        marked['i'] = true;\n        marked['U'] = true;\n        marked['E'] = true;\n        marked['O'] = true;\n        marked['A'] = true;\n        marked['I'] = true;\n        \n        char[] arr = s.toCharArray();\n        for (int i = 0, j = s.length() - 1; i < j; i++) {\n            if (marked[arr[i]]) {\n                \n                for (; j > i; j--) {\n                    if (marked[arr[j]]) {\n                        char temp = arr[i];\n                        arr[i] = arr[j];\n                        arr[j--] = temp;\n                        \n                        break;\n                    }\n                }\n            }\n        }\n        \n        return String.valueOf(arr);\n        \n    }\n}",
      "total_acs": 100164,
      "total_submitted": 256748
    },
    {
      "id": 346,
      "title": "Moving Average from Data Stream",
      "url": "https://leetcode.com/problems/moving-average-from-data-stream/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Easy",
      "content": "Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.\r\n\r\nFor example,\r\n\r\nMovingAverage m = new MovingAverage(3);\r\nm.next(1) = 1\r\nm.next(10) = (1 + 10) / 2\r\nm.next(3) = (1 + 10 + 3) / 3\r\nm.next(5) = (10 + 3 + 5) / 3\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/430",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Design",
        "Queue"
      ],
      "Solution": "class MovingAverage {\n    long sum = 0;\n    int n = -1;\n    int k = 0;\n    int[] window;\n    int count = 0;\n\n    /** Initialize your data structure here. */\n    public MovingAverage(int size) {\n        k = size;\n        window = new int[k];\n    }\n    \n    public double next(int val) {\n        if(count < k) count++;\n        sum += val;\n        sum -= window[(n+1)%k];\n        n = (n+1)%k;\n        window[n] = val;\n        return sum*1.0/count;\n        \n        \n    }\n}\n\n/**\n * Your MovingAverage object will be instantiated and called as such:\n * MovingAverage obj = new MovingAverage(size);\n * double param_1 = obj.next(val);\n */",
      "total_acs": 34946,
      "total_submitted": 58278
    },
    {
      "id": 347,
      "title": "Top K Frequent Elements",
      "url": "https://leetcode.com/problems/top-k-frequent-elements/description",
      "companyTags": [
        "Yelp",
        "PocketGems"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven a non-empty array of integers, return the k most frequent elements.\r\n\r\nFor example,\r\nGiven [1,1,1,2,2,3] and k = 2, return [1,2].\r\n\r\n\r\nNote: \r\n\r\nYou may assume k is always valid, 1 ≤ k ≤ number of unique elements.\r\nYour algorithm's time complexity must be better than O(n log n), where n is the array's size.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/431",
      "similarQuestions": [
        "WordFrequency",
        "KthLargestElementinanArray",
        "SortCharactersByFrequency",
        "SplitArrayintoConsecutiveSubsequences",
        "TopKFrequentWords"
      ],
      "topicTags": [
        "HashTable",
        "Heap"
      ],
      "Solution": "public class Solution {\n    public List<Integer> topKFrequent(int[] nums, int k) {\n        List<Integer> result = new ArrayList<>();\n        List<Integer> bucket[] = new List[nums.length+1];\n        int max = Integer.MIN_VALUE;\n        int min = Integer.MAX_VALUE;\n        for(int n: nums){\n            if (n > max) {\n                max = n;\n            }\n            if (n < min) {\n                min = n;\n            }\n        }\n        int range[] = new int[max-min+1]; //Frequency\n        for(int num: nums){\n            range[num-min]++;\n        }\n        for(int i=0; i<range.length; i++){\n            if(bucket[range[i]]==null)\n                bucket[range[i]] = new ArrayList<>();\n            bucket[range[i]].add(i+min);\n        }\n        for(int i=bucket.length-1; i>=0; i--){\n            if(result.size()==k)\n                break;\n            if(bucket[i] != null)\n                result.addAll(bucket[i]);\n        }\n        return result;\n    }\n}",
      "total_acs": 92554,
      "total_submitted": 187327
    },
    {
      "id": 348,
      "title": "Design Tic-Tac-Toe",
      "url": "https://leetcode.com/problems/design-tic-tac-toe/description",
      "companyTags": [
        "Google",
        "Microsoft"
      ],
      "difficulty": "Medium",
      "content": "Design a Tic-tac-toe game that is played between two players on a n x n grid.\r\n\r\n\r\nYou may assume the following rules:\r\n\r\nA move is guaranteed to be valid and is placed on an empty block.\r\nOnce a winning condition is reached, no more moves is allowed.\r\nA player who succeeds in placing n of their marks in a horizontal, vertical, or diagonal row wins the game.\r\n\r\n\r\n\r\nExample:\r\n\r\nGiven n = 3, assume that player 1 is \"X\" and player 2 is \"O\" in the board.\r\n\r\nTicTacToe toe = new TicTacToe(3);\r\n\r\ntoe.move(0, 0, 1); -> Returns 0 (no one wins)\r\n|X| | |\r\n| | | |    // Player 1 makes a move at (0, 0).\r\n| | | |\r\n\r\ntoe.move(0, 2, 2); -> Returns 0 (no one wins)\r\n|X| |O|\r\n| | | |    // Player 2 makes a move at (0, 2).\r\n| | | |\r\n\r\ntoe.move(2, 2, 1); -> Returns 0 (no one wins)\r\n|X| |O|\r\n| | | |    // Player 1 makes a move at (2, 2).\r\n| | |X|\r\n\r\ntoe.move(1, 1, 2); -> Returns 0 (no one wins)\r\n|X| |O|\r\n| |O| |    // Player 2 makes a move at (1, 1).\r\n| | |X|\r\n\r\ntoe.move(2, 0, 1); -> Returns 0 (no one wins)\r\n|X| |O|\r\n| |O| |    // Player 1 makes a move at (2, 0).\r\n|X| |X|\r\n\r\ntoe.move(1, 0, 2); -> Returns 0 (no one wins)\r\n|X| |O|\r\n|O|O| |    // Player 2 makes a move at (1, 0).\r\n|X| |X|\r\n\r\ntoe.move(2, 1, 1); -> Returns 1 (player 1 wins)\r\n|X| |O|\r\n|O|O| |    // Player 1 makes a move at (2, 1).\r\n|X|X|X|\r\n\r\n\r\n\r\nFollow up:\r\nCould you do better than O(n2) per move() operation?\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/432",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Design"
      ],
      "Solution": "public class TicTacToe {\n/*\nAfter every call to any player on board[i][j].\nDo a loop from 1 to N, check complete row, complete col and complete diagonal.\nHave 4 boolean as true and keep making things false as soon as one is false\n\n*/\n    int board[][];\n    /** Initialize your data structure here. */\n    public TicTacToe(int n) {\n        this.board = new int[n][n];\n    }\n    \n    /** Player {player} makes a move at ({row}, {col}).\n        @param row The row of the board.\n        @param col The column of the board.\n        @param player The player, can be either 1 or 2.\n        @return The current winning condition, can be either:\n                0: No one wins.\n                1: Player 1 wins.\n                2: Player 2 wins. */\n    public int move(int row, int col, int player) {\n        board[row][col] = player;\n        if(hasWon(board,row,col,player)) return player;\n        return 0;\n    }\n    \n    private boolean hasWon(int[][] board, int row, int col, int playChar){\n        boolean colWin = true;\n        boolean rowWin = true;\n        boolean diaWin = true;\n        boolean revDia = true;\n        for(int i = 0; i < board.length; i++){\n            if(rowWin && board[row][i] != playChar) rowWin = false;\n            if(colWin && board[i][col] != playChar) colWin = false;\n            if(diaWin && board[i][i] != playChar) diaWin = false;\n            if(revDia && board[i][board.length - i - 1] != playChar) revDia = false;\n            if(!(colWin || rowWin || diaWin || revDia)) return false;\n        }\n        return true;\n    }\n}\n\n/**\n * Your TicTacToe object will be instantiated and called as such:\n * TicTacToe obj = new TicTacToe(n);\n * int param_1 = obj.move(row,col,player);\n */",
      "total_acs": 21024,
      "total_submitted": 45777
    },
    {
      "id": 349,
      "title": "Intersection of Two Arrays",
      "url": "https://leetcode.com/problems/intersection-of-two-arrays/description",
      "companyTags": [
        "TwoSigma"
      ],
      "difficulty": "Easy",
      "content": "\r\nGiven two arrays, write a function to compute their intersection.\r\n\r\n\r\nExample:\r\nGiven nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].\r\n\r\n\r\nNote:\r\n\r\nEach element in the result must be unique.\r\nThe result can be in any order.\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/433",
      "similarQuestions": [
        "IntersectionofTwoArraysII"
      ],
      "topicTags": [
        "HashTable",
        "TwoPointers",
        "BinarySearch",
        "Sort"
      ],
      "Solution": "public class Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        if (nums1 == null || nums2 == null || nums1.length == 0 || nums2.length == 0) return new int[0];\n        List<Integer> res = new ArrayList<>();\n        int max = nums1[0], min = nums1[0];\n        \n        for (int i = 1; i < nums1.length; i++){\n            if (nums1[i] > max) max = nums1[i];\n            else if (nums1[i] < min) min = nums1[i];\n        }            \n        boolean[] bucket = new boolean[max - min + 1];\n        \n        for (int num: nums1) bucket[num - min] = true;\n        \n        for (int num: nums2){\n            if (num >= min && num <= max){\n                if (bucket[num - min]){\n                    res.add(num);\n                    bucket[num - min] = false;\n                }\n            }\n        }\n        int[] result = new int[res.size()];\n        for (int i = 0; i < res.size(); i++){\n            result[i] = res.get(i);\n        }\n        return result;\n    }\n}",
      "total_acs": 120161,
      "total_submitted": 250252
    },
    {
      "id": 350,
      "title": "Intersection of Two Arrays II",
      "url": "https://leetcode.com/problems/intersection-of-two-arrays-ii/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Easy",
      "content": "\r\nGiven two arrays, write a function to compute their intersection.\r\n\r\n\r\nExample:\r\nGiven nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].\r\n\r\n\r\nNote:\r\n\r\nEach element in the result should appear as many times as it shows in both arrays.\r\nThe result can be in any order.\r\n\r\n\r\n\r\nFollow up:\r\n\r\nWhat if the given array is already sorted? How would you optimize your algorithm?\r\nWhat if nums1's size is small compared to nums2's size? Which algorithm is better?\r\nWhat if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/434",
      "similarQuestions": [
        "IntersectionofTwoArrays"
      ],
      "topicTags": [
        "HashTable",
        "TwoPointers",
        "BinarySearch",
        "Sort"
      ],
      "Solution": "class Solution {\n    public int[] intersect(int[] nums1, int[] nums2) {\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        int i = 0;\n        int j = 0;\n        int k = 0;\n        int[] ans = new int[Math.min(nums1.length, nums2.length)];\n        while (i < nums1.length && j < nums2.length) {\n            if (nums1[i] == nums2[j]) {\n                ans[k] = nums1[i];\n                i++;\n                j++;\n                k++;\n            } else if (nums1[i] < nums2[j]) {\n                while (i + 1 < nums1.length && nums1[i] == nums1[i + 1]) i++;\n                i++;\n            } else {\n                while (j + 1 < nums2.length && nums2[j] == nums2[j + 1]) j++;\n                j++;\n            }\n        }\n        \n        return Arrays.copyOf(ans, k);\n    }\n}\n\n// [], [1,2,2,3] -> []\n// [2,2], [1,2,2,3] -> [2,2]\n",
      "total_acs": 94270,
      "total_submitted": 210885
    },
    {
      "id": 351,
      "title": "Android Unlock Patterns",
      "url": "https://leetcode.com/problems/android-unlock-patterns/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven an Android 3x3 key lock screen and two integers m and n, where  1 ≤ m ≤ n ≤ 9, count the total number of unlock patterns of the Android lock screen, which consist of minimum of m keys and maximum n keys.\r\n\r\nRules for a valid pattern:\r\n\r\nEach pattern must connect at least m keys and at most n keys.\r\nAll the keys must be distinct.\r\nIf the line connecting two consecutive keys in the pattern passes through any other keys, the other keys must have previously selected in the pattern. No jumps through non selected key is allowed.\r\nThe order of keys used matters.\r\n\r\n\r\n\r\n\r\n\r\nExplanation:\r\n\r\n| 1 | 2 | 3 |\r\n| 4 | 5 | 6 |\r\n| 7 | 8 | 9 |\r\n\r\n\r\n\r\nInvalid move: 4 - 1 - 3 - 6 \r\n\r\nLine  1 - 3 passes through key 2 which had not been selected in the pattern.\r\n\r\nInvalid move: 4 - 1 - 9 - 2\r\n\r\nLine  1 - 9 passes through key 5 which had not been selected in the pattern.\r\n\r\nValid move: 2 - 4 - 1 - 3 - 6\r\n\r\nLine 1 - 3 is valid because it passes through key 2, which had been selected in the pattern\r\n\r\nValid move: 6 - 5 - 4 - 1 - 9 - 2\r\n\r\nLine 1 - 9 is valid because it passes through key 5, which had been selected in the pattern.\r\n\r\nExample:\r\nGiven m = 1, n = 1, return 9.\r\n\r\n\r\nCredits:Special thanks to @elmirap for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/435",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "DynamicProgramming",
        "Backtracking"
      ],
      "Solution": "class Solution {\n    public int numberOfPatterns(int m, int n) {\n        boolean[] visited = new boolean[10];\n        visited[0] = true;\n        \n        int[][] jumps = new int[10][10];\n        jumps[1][3] = jumps[3][1] = 2;\n        jumps[1][7] = jumps[7][1] = 4;\n        jumps[7][9] = jumps[9][7] = 8;\n        jumps[9][3] = jumps[3][9] = 6;\n        jumps[4][6] = jumps[6][4] = jumps[2][8] = jumps[8][2] = jumps[1][9] = jumps[9][1] = jumps[3][7] = jumps[7][3] = 5;\n        \n        int count = 0;\n        count += 4 * dfs(1, 1, 0, m, n, visited, jumps);\n        count += 4 * dfs(2, 1, 0, m, n, visited, jumps);\n        count += dfs(5, 1, 0, m, n, visited, jumps);\n        return count;\n    }\n    private int dfs(int num, int len, int count, int m, int n, boolean[] visited, int[][] jumps) {\n        if (len >= m) count++;\n        len++;\n        if (len > n) return count;\n        \n        visited[num] = true;\n        for (int next = 1; next <= 9; next++) {\n            if (!visited[next] && (jumps[num][next] == 0 || visited[jumps[num][next]])) {\n                count = dfs(next, len, count, m, n, visited, jumps);\n            }\n        }\n        visited[num] = false;\n        return count;\n    }\n}",
      "total_acs": 19023,
      "total_submitted": 42579
    },
    {
      "id": 352,
      "title": "Data Stream as Disjoint Intervals",
      "url": "https://leetcode.com/problems/data-stream-as-disjoint-intervals/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Hard",
      "content": "Given a data stream input of non-negative integers a1, a2, ..., an, ..., summarize the numbers seen so far as a list of disjoint intervals.\r\n\r\nFor example, suppose the integers from the data stream are 1, 3, 7, 2, 6, ..., then the summary will be:\r\n\r\n[1, 1]\r\n[1, 1], [3, 3]\r\n[1, 1], [3, 3], [7, 7]\r\n[1, 3], [7, 7]\r\n[1, 3], [6, 7]\r\n\r\n\r\nFollow up:\r\nWhat if there are lots of merges and the number of disjoint intervals are small compared to the data stream's size?\r\n\r\n\r\nCredits:Special thanks to @yunhong for adding this problem and creating most of the test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/436",
      "similarQuestions": [
        "SummaryRanges",
        "FindRightInterval",
        "RangeModule"
      ],
      "topicTags": [
        "BinarySearchTree"
      ],
      "Solution": "/**\n * Definition for an interval.\n * public class Interval {\n *     int start;\n *     int end;\n *     Interval() { start = 0; end = 0; }\n *     Interval(int s, int e) { start = s; end = e; }\n * }\n */\nclass SummaryRanges {\n    \n    class BSTNode {\n        Interval interval;\n        BSTNode left;\n        BSTNode right;\n        BSTNode(Interval interval) {\n            this.interval = interval;\n        }\n    }\n    \n    BSTNode findMin(BSTNode root) {\n        if (root == null) return null;\n        if (root.left == null ) return root;\n        else return findMin(root.left);\n    }\n    \n    BSTNode remove(Interval x, BSTNode root) {\n        if (root == null) return null;\n        else if ( x == null ) return root;\n        else if (x.start > root.interval.end ) {\n            root.right = remove(x, root.right);\n        } else if (x.end < root.interval.start ) {\n            root.left = remove(x, root.left);\n        } else if (root.left != null && root.right != null) {\n            root.interval = findMin(root.right).interval;\n            root.right = remove(root.interval, root.right);\n        } else {\n            root = (root.left != null) ? root.left : root.right;\n        }\n        return root;\n    }\n    \n    BSTNode findKey(int val, BSTNode root) {\n        if (root == null) return null;\n        if (root.interval.start > val) {\n            return findKey(val, root.left);\n        } else if (root.interval.end < val) {\n            return findKey(val, root.right);\n        } else return root;\n    }\n    \n    BSTNode addKey(int val, BSTNode root) {\n        if (root == null) {\n            root = new BSTNode( new Interval(val, val) ); \n        } else if (root.interval.start > val) {\n            root.left = addKey(val, root.left);\n        } else if (root.interval.end < val) {\n            root.right = addKey(val, root.right);\n        }  \n        return root;\n    }\n    \n    void inOrder(BSTNode root) {\n        if (root != null) {\n            inOrder(root.left);\n            list.add(root.interval);\n            inOrder(root.right);\n        }\n    }\n\n    /** Initialize your data structure here. */\n    \n    BSTNode root;\n    List<Interval> list = new ArrayList();\n    \n    public SummaryRanges() {\n        root = null;\n    }\n    \n    public void addNum(int val) {\n        if (root == null) root = addKey(val, root);\n        else {\n            if (findKey(val, root) != null) return;\n            BSTNode left = findKey(val - 1, root);\n            BSTNode right = findKey(val + 1, root);\n            if (left == null && right == null) {\n                root = addKey(val, root);\n            }\n            else if (left != null && right == null) {\n                left.interval.end++;\n            }\n            else if (left == null && right != null) {\n                right.interval.start--;\n            }\n            else {\n                Interval l = left.interval;\n                int e = right.interval.end;\n                root = remove(right.interval, root);\n                l.end = e;\n            }\n        }\n    }\n    \n    public List<Interval> getIntervals() {\n        list = new ArrayList<>();\n        inOrder(root);\n        return list;\n    }\n}\n\n/**\n * Your SummaryRanges object will be instantiated and called as such:\n * SummaryRanges obj = new SummaryRanges();\n * obj.addNum(val);\n * List<Interval> param_2 = obj.getIntervals();\n */",
      "total_acs": 16262,
      "total_submitted": 39863
    },
    {
      "id": 353,
      "title": "Design Snake Game",
      "url": "https://leetcode.com/problems/design-snake-game/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Medium",
      "content": "Design a Snake game that is played on a device with screen size = width x height. Play the game online if you are not familiar with the game.\r\n\r\nThe snake is initially positioned at the top left corner (0,0) with length = 1 unit.\r\n\r\nYou are given a list of food's positions in row-column order. When a snake eats the food, its length and the game's score both increase by 1.\r\n\r\nEach food appears one by one on the screen. For example, the second food will not appear until the first food was eaten by the snake.\r\n\r\nWhen a food does appear on the screen, it is guaranteed that it will not appear on a block occupied by the snake.\r\n\r\n\r\nExample:\r\n\r\nGiven width = 3, height = 2, and food = [[1,2],[0,1]].\r\n\r\nSnake snake = new Snake(width, height, food);\r\n\r\nInitially the snake appears at position (0,0) and the food at (1,2).\r\n\r\n|S| | |\r\n| | |F|\r\n\r\nsnake.move(\"R\"); -> Returns 0\r\n\r\n| |S| |\r\n| | |F|\r\n\r\nsnake.move(\"D\"); -> Returns 0\r\n\r\n| | | |\r\n| |S|F|\r\n\r\nsnake.move(\"R\"); -> Returns 1 (Snake eats the first food and right after that, the second food appears at (0,1) )\r\n\r\n| |F| |\r\n| |S|S|\r\n\r\nsnake.move(\"U\"); -> Returns 1\r\n\r\n| |F|S|\r\n| | |S|\r\n\r\nsnake.move(\"L\"); -> Returns 2 (Snake eats the second food)\r\n\r\n| |S|S|\r\n| | |S|\r\n\r\nsnake.move(\"U\"); -> Returns -1 (Game over because snake collides with border)\r\n\r\n\r\n\r\n\r\nCredits:Special thanks to @elmirap for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/437",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Design",
        "Queue"
      ],
      "Solution": null,
      "total_acs": 10717,
      "total_submitted": 39545
    },
    {
      "id": 354,
      "title": "Russian Doll Envelopes",
      "url": "https://leetcode.com/problems/russian-doll-envelopes/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Hard",
      "content": "You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope.\r\n\r\n\r\nWhat is the maximum number of envelopes can you Russian doll? (put one inside other)\r\n\r\n\r\nExample:\r\nGiven envelopes = [[5,4],[6,4],[6,7],[2,3]], the maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]).\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/438",
      "similarQuestions": [
        "LongestIncreasingSubsequence"
      ],
      "topicTags": [
        "BinarySearch",
        "DynamicProgramming"
      ],
      "Solution": "//4:42  -4:48\n// coding: 5:28- 5:37 9 min\n//test & check: \n//sbu: 5:38\nclass Solution {\n    public int maxEnvelopes(int[][] envelopes) {\n        int n = envelopes.length;\n        Comparator<int[]> comparator = new Comparator<int[]>(){\n            @Override\n            public int compare(int[] a, int[] b)\n            {\n                if(a[0]==b[0])\n                    return b[1]-a[1];\n                else\n                    return a[0]-b[0];\n            }\n        };\n            //sort O(nlogn)\n        Arrays.sort(envelopes, comparator);\n        int[] tails = new int[n];// the smallest element for length i-1\n        int len =0;\n       for(int i=0; i<n; i++)//!! conflicting names \n       {\n           int[] env=envelopes[i];\n           int idx=Arrays.binarySearch(tails,0, len, env[1]);\n           //System.out.println(\" idx: \"+ idx+\" len: \"+ len+ \" i: \"+ i);\n           if(idx<0)\n               idx =-(idx+1);//get the insertion point\n           //if  tails[idx-1]<=env[1]<=tais[idx]\n           //if env[1]>=tails[idx]\n           tails[idx]=env[1];\n           if(idx == len)\n               len++;           \n        //dp[i] max envelope can Russian doll at position i\n        //approach 1: binary search and update tails[i]\n       }\n        return len;\n        \n\n    }\n           // approach 2: dp[i] = max(dp[k])+1 for k<i if(wi>wk && hi>hk) //O(n^2)\n}",
      "total_acs": 27166,
      "total_submitted": 83360
    },
    {
      "id": 355,
      "title": "Design Twitter",
      "url": "https://leetcode.com/problems/design-twitter/description",
      "companyTags": [
        "Amazon",
        "Twitter"
      ],
      "difficulty": "Medium",
      "content": "Design a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user's news feed. Your design should support the following methods:\r\n\r\n\r\n\r\npostTweet(userId, tweetId): Compose a new tweet.\r\ngetNewsFeed(userId): Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.\r\nfollow(followerId, followeeId): Follower follows a followee.\r\nunfollow(followerId, followeeId): Follower unfollows a followee.\r\n\r\n\r\n\r\nExample:\r\n\r\nTwitter twitter = new Twitter();\r\n\r\n// User 1 posts a new tweet (id = 5).\r\ntwitter.postTweet(1, 5);\r\n\r\n// User 1's news feed should return a list with 1 tweet id -> [5].\r\ntwitter.getNewsFeed(1);\r\n\r\n// User 1 follows user 2.\r\ntwitter.follow(1, 2);\r\n\r\n// User 2 posts a new tweet (id = 6).\r\ntwitter.postTweet(2, 6);\r\n\r\n// User 1's news feed should return a list with 2 tweet ids -> [6, 5].\r\n// Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.\r\ntwitter.getNewsFeed(1);\r\n\r\n// User 1 unfollows user 2.\r\ntwitter.unfollow(1, 2);\r\n\r\n// User 1's news feed should return a list with 1 tweet id -> [5],\r\n// since user 1 is no longer following user 2.\r\ntwitter.getNewsFeed(1);\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/439",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "HashTable",
        "Heap",
        "Design"
      ],
      "Solution": "class Twitter {\n    private static class Tweet {\n        final int id;\n        final int time;\n        Tweet(int id, int time) {\n            this.id = id;\n            this.time = time;\n        }\n    }\n    \n    private static class User {\n        final int id;\n        final Set<User> followees;\n        final List<Tweet> tweets;\n        \n        User(int id) {\n            this.id = id;\n            this.followees = new HashSet<>();\n            this.tweets = new LinkedList<>();\n        }\n        \n        void post(int tweetId, int time) {\n            this.tweets.add(0, new Tweet(tweetId, time));\n        }\n        \n        void follow(User user) {\n            if (user.id != this.id) {\n                this.followees.add(user);\n            }\n        }\n        \n        void unfollow(User user) {\n            this.followees.remove(user);\n        }\n        \n        List<Integer> getNewsFeed() {\n            PriorityQueue<Tweet> queue = new PriorityQueue<>(new Comparator<Tweet>() {\n                @Override\n                public int compare(Tweet o1, Tweet o2) {\n                    return o1.time - o2.time;\n                }\n            });\n            \n            enqueue(queue, this);\n            for (User user : followees) {\n                enqueue(queue, user);\n            }\n            \n            List<Integer> ans = new LinkedList<>();\n            while (!queue.isEmpty()) {\n                ans.add(0, queue.poll().id);\n            }\n            \n            return ans;\n        }\n        \n        private static void enqueue(PriorityQueue<Tweet> queue, User user) {\n            int count = 0;\n            for (Tweet t : user.tweets) {\n                count++;\n                queue.offer(t);\n                if (queue.size() > 10) {\n                    queue.poll();\n                }\n                \n                if (count >= 10) {\n                    break;\n                }\n            }\n        }\n    }\n    \n    private final Map<Integer, User> userMap;\n    private int globalTime;\n\n    /** Initialize your data structure here. */\n    public Twitter() {\n        this.globalTime = 0;\n        this.userMap = new HashMap<>();\n    }\n    \n    /** Compose a new tweet. */\n    public void postTweet(int userId, int tweetId) {\n        userMap.computeIfAbsent(userId, k -> new User(k)).post(tweetId, globalTime++);\n    }\n    \n    /** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\n    public List<Integer> getNewsFeed(int userId) {\n        return userMap.computeIfAbsent(userId, k -> new User(k)).getNewsFeed();\n    }\n    \n    /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\n    public void follow(int followerId, int followeeId) {\n        userMap.computeIfAbsent(followerId, k -> new User(k)).follow(userMap.computeIfAbsent(followeeId, k -> new User(k)));\n    }\n    \n    /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\n    public void unfollow(int followerId, int followeeId) {\n        userMap.computeIfAbsent(followerId, k -> new User(k)).unfollow(userMap.computeIfAbsent(followeeId, k -> new User(k)));\n    }\n}\n\n/**\n * Your Twitter object will be instantiated and called as such:\n * Twitter obj = new Twitter();\n * obj.postTweet(userId,tweetId);\n * List<Integer> param_2 = obj.getNewsFeed(userId);\n * obj.follow(followerId,followeeId);\n * obj.unfollow(followerId,followeeId);\n */",
      "total_acs": 23423,
      "total_submitted": 90699
    },
    {
      "id": 356,
      "title": "Line Reflection",
      "url": "https://leetcode.com/problems/line-reflection/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Medium",
      "content": "Given n points on a 2D plane, find if there is such a line parallel to y-axis that reflect the given points.\r\n\r\n\r\n    Example 1:\r\n\r\n\r\nGiven points = [[1,1],[-1,1]], return true.\r\n\r\n\r\n\r\n    Example 2:\r\n\r\n\r\nGiven points = [[1,1],[-1,-1]], return false.\r\n\r\n\r\nFollow up:\r\nCould you do better than O(n2)?\r\n\r\n\r\nCredits:Special thanks to @memoryless for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/440",
      "similarQuestions": [
        "MaxPointsonaLine",
        "NumberofBoomerangs"
      ],
      "topicTags": [
        "HashTable",
        "Math"
      ],
      "Solution": "class Solution {\n    public boolean isReflected(int[][] points) {\n        if (points.length < 1 || points[0].length < 1) return true;\n        \n        Arrays.sort(points, new Comparator<int[]>() {\n            public int compare(int[] pointA, int[] pointB) {\n                if (pointA[0] == pointB[0]) {\n                    return Integer.compare(pointA[1], pointB[1]);\n                }\n                return Integer.compare(pointA[0], pointB[0]);\n            }\n        });  \n        //PrintArray(points);\n        \n        Arrays.sort(points, points.length/2, points.length, new Comparator<int[]>() {\n            public int compare(int[] pointA, int[] pointB) {\n                if (pointA[0] == pointB[0]) {\n                    return Integer.compare(pointB[1], pointA[1]);\n                }\n                return Integer.compare(pointA[0], pointB[0]);\n            }\n        });\n        //PrintArray(points);\n\n        // check for symmetry\n        int left = 0, right = points.length-1;\n        if (points[left][0] == points[right][0]) return true;\n        if (points[left][1] != points[right][1]) return false;\n        double mirrorLine = (points[left][0] + points[right][0]) / 2.0;\n        left++;\n        right--;\n\n        while (left < right) {\n            //System.out.println(\"left = \" + left + \", right = \" + right);\n            if (points[left][0] == points[left-1][0] && points[left][1] == points[left-1][1]) {\n                left++;\n                continue;\n            }\n            if (points[right][0] == points[right+1][0] && points[right][1] == points[right+1][1]) {\n                right--;\n                continue;\n            }\n            if (points[left][0] != points[right][0] && points[left][1] != points[right][1]) return false;\n            if ((points[left][0] + points[right][0]) / 2.0 != mirrorLine) return false;\n            left++;\n            right--;\n        }\n        \n        //System.out.println(\"end: left = \" + left + \", right = \" + right);\n        if (left == right) {\n            if (points[left][0] == mirrorLine || left < points.length-1 && points[left][0] == points[left+1][0] || right > 0 && points[right][0] == points[right-1][0]) {\n                return true;\n            }\n            return false;\n        }\n        return true; \n    }\n    \n    public void PrintArray(int[][] points) {\n        for (int i=0; i<points.length; ++i) {\n            System.out.print(\"[\" + points[i][0] +\",\" + points[i][1] + \"],\");\n        }\n        System.out.println(\"\");\n    }\n}",
      "total_acs": 13363,
      "total_submitted": 44179
    },
    {
      "id": 357,
      "title": "Count Numbers with Unique Digits",
      "url": "https://leetcode.com/problems/count-numbers-with-unique-digits/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Medium",
      "content": "Given a non-negative integer n, count all numbers with unique digits, x, where 0 ≤ x < 10n.\r\n\r\n\r\n    Example:\r\nGiven n = 2, return 91. (The answer should be the total numbers in the range of 0 ≤ x < 100, excluding [11,22,33,44,55,66,77,88,99])\r\n\r\n\r\nCredits:Special thanks to @memoryless for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/441",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Math",
        "DynamicProgramming",
        "Backtracking"
      ],
      "Solution": "class Solution {\n    public int countNumbersWithUniqueDigits(int n) {\n                if (n == 0)     return 1;\n        \n        int res = 10;\n        int uniqueDigits = 9;\n        int availableNumber = 9;\n        while (n-- > 1 && availableNumber > 0) {\n            uniqueDigits = uniqueDigits * availableNumber;\n            res += uniqueDigits;\n            availableNumber--;\n        }\n        return res;\n    }\n}",
      "total_acs": 44140,
      "total_submitted": 95784
    },
    {
      "id": 358,
      "title": "Rearrange String k Distance Apart",
      "url": "https://leetcode.com/problems/rearrange-string-k-distance-apart/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Hard",
      "content": "\r\nGiven a non-empty string s and an integer k, rearrange the string such that the same characters are at least distance k from each other.\r\n\r\n\r\nAll input strings are given in lowercase letters. If it is not possible to rearrange the string, return an empty string \"\".\r\n\r\nExample 1:\r\n\r\ns = \"aabbcc\", k = 3\r\n\r\nResult: \"abcabc\"\r\n\r\nThe same letters are at least distance 3 from each other.\r\n\r\n\r\n\r\nExample 2:\r\n\r\ns = \"aaabc\", k = 3 \r\n\r\nAnswer: \"\"\r\n\r\nIt is not possible to rearrange the string.\r\n\r\n\r\n\r\nExample 3:\r\n\r\ns = \"aaadbbcc\", k = 2\r\n\r\nAnswer: \"abacabcd\"\r\n\r\nAnother possible answer is: \"abcabcda\"\r\n\r\nThe same letters are at least distance 2 from each other.\r\n\r\n\r\n\r\nCredits:Special thanks to @elmirap for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/442",
      "similarQuestions": [
        "TaskScheduler",
        "ReorganizeString"
      ],
      "topicTags": [
        "HashTable",
        "Heap",
        "Greedy"
      ],
      "Solution": "class Solution {\n    public String rearrangeString(String s, int k) {\n        \n        int len = s.length();\n        int[] map = new int[26];\n        int[] valid = new int[26];\n        char[] arr = s.toCharArray();\n        for(char c : arr) {\n            map[c - 'a']++;\n        }\n        char[] res = new char[len];\n        for(int i = 0; i < len; i++) {\n            int cur = help(map, valid, i);\n            if(cur == -1) {\n                return \"\";\n            }\n            res[i] = (char)(cur + 'a');\n            valid[cur] = i + k;\n            map[cur]--;\n        }\n        return new String(res);\n    }\n    \n    private int help(int[] map, int[] valid, int index) {\n        int pos = -1;\n        int max = 0;\n        for(int i = 0; i < 26; i++) {\n            if(map[i] > max && index >= valid[i]) {\n                max = map[i];\n                pos = i;\n            }\n        }\n        return pos;\n    }\n}",
      "total_acs": 13379,
      "total_submitted": 42199
    },
    {
      "id": 359,
      "title": "Logger Rate Limiter",
      "url": "https://leetcode.com/problems/logger-rate-limiter/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Easy",
      "content": "Design a logger system that receive stream of messages along with its timestamps, each message should be printed if and only if it is not printed in the last 10 seconds.\r\n\r\nGiven a message and a timestamp (in seconds granularity), return true if the message should be printed in the given timestamp, otherwise returns false.\r\n\r\nIt is possible that several messages arrive roughly at the same time.\r\n\r\nExample:\r\n\r\nLogger logger = new Logger();\r\n\r\n// logging string \"foo\" at timestamp 1\r\nlogger.shouldPrintMessage(1, \"foo\"); returns true; \r\n\r\n// logging string \"bar\" at timestamp 2\r\nlogger.shouldPrintMessage(2,\"bar\"); returns true;\r\n\r\n// logging string \"foo\" at timestamp 3\r\nlogger.shouldPrintMessage(3,\"foo\"); returns false;\r\n\r\n// logging string \"bar\" at timestamp 8\r\nlogger.shouldPrintMessage(8,\"bar\"); returns false;\r\n\r\n// logging string \"foo\" at timestamp 10\r\nlogger.shouldPrintMessage(10,\"foo\"); returns false;\r\n\r\n// logging string \"foo\" at timestamp 11\r\nlogger.shouldPrintMessage(11,\"foo\"); returns true;\r\n\r\n\r\n\r\nCredits:Special thanks to @memoryless for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/443",
      "similarQuestions": [
        "DesignHitCounter"
      ],
      "topicTags": [
        "HashTable",
        "Design"
      ],
      "Solution": "class Logger {\n    HashMap<String, Integer> map; \n    /** Initialize your data structure here. */\n    public Logger() {\n        map = new HashMap<>();\n    }\n    \n    /** Returns true if the message should be printed in the given timestamp, otherwise returns false.\n        If this method returns false, the message will not be printed.\n        The timestamp is in seconds granularity. */\n    public boolean shouldPrintMessage(int timestamp, String message) {\n        if (timestamp < map.getOrDefault(message, 0)) {\n            return false;\n        }\n        map.put(message, timestamp + 10);\n        return true;\n    }\n}\n\n/**\n * Your Logger object will be instantiated and called as such:\n * Logger obj = new Logger();\n * boolean param_1 = obj.shouldPrintMessage(timestamp,message);\n */",
      "total_acs": 23394,
      "total_submitted": 38638
    },
    {
      "id": 360,
      "title": "Sort Transformed Array",
      "url": "https://leetcode.com/problems/sort-transformed-array/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven a sorted array of integers nums and integer values a, b and c.  Apply a quadratic function of the form f(x) = ax2 + bx + c to each element x in the array. \r\n\r\nThe returned array must be in sorted order.\r\n\r\nExpected time complexity: O(n)\r\n\r\nExample:\r\n\r\nnums = [-4, -2, 2, 4], a = 1, b = 3, c = 5,\r\n\r\nResult: [3, 9, 15, 33]\r\n\r\nnums = [-4, -2, 2, 4], a = -1, b = 3, c = 5\r\n\r\nResult: [-23, -5, 1, 7]\r\n\r\n\r\n\r\nCredits:Special thanks to @elmirap for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/444",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Math",
        "TwoPointers"
      ],
      "Solution": "class Solution {\n    public int[] sortTransformedArray(int[] nums, int a, int b, int c) {\n        int n = nums.length;\n        int[] result = new int[nums.length];\n        \n        int index = a < 0 ? 0 : n - 1;\n        int i = 0;\n        int j = n - 1;\n        while (i <= j) {\n            int start = cal(a, b, c, nums[i]);\n            int end = cal(a, b, c, nums[j]);\n            if (a >= 0) {\n                result[index--] = start >= end ? start : end;\n                if (start >= end) {\n                    i++;\n                }\n                else {\n                    j--;\n                }\n            }\n            else {\n                result[index++] = start >= end ? end : start;\n                if (start >= end) {\n                    j--;\n                }\n                else {\n                    i++;\n                }\n            }\n        }\n        return result;\n    }\n    \n    private int cal(int a, int b, int c, int x) {\n        return a * x * x + b * x + c;\n    } \n}",
      "total_acs": 15659,
      "total_submitted": 35002
    },
    {
      "id": 361,
      "title": "Bomb Enemy",
      "url": "https://leetcode.com/problems/bomb-enemy/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Medium",
      "content": "Given a 2D grid, each cell is either a wall 'W', an enemy 'E' or empty '0' (the number zero), return the maximum enemies you can kill using one bomb. The bomb kills all the enemies in the same row and column from the planted point until it hits the wall since the wall is too strong to be destroyed.\r\n Note that you can only put the bomb at an empty cell. \r\n\r\nExample:\r\n\r\nFor the given grid\r\n\r\n0 E 0 0\r\nE 0 W E\r\n0 E 0 0\r\n\r\nreturn 3. (Placing a bomb at (1,1) kills 3 enemies)\r\n\r\n\r\n\r\nCredits:Special thanks to @memoryless for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/445",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "DynamicProgramming"
      ],
      "Solution": "public class Solution {\n    public int maxKilledEnemies(char[][] grid) {\n        if (grid.length == 0) {\n            return 0;\n        }\n        int output = 0;\n        int m = grid.length;\n        int n = grid[0].length;\n        int[] colSum = new int[n];\n        int[][] cal = new int[m][n];\n        for (int row = 0; row < m; row++) {\n            int rowSum = 0;\n            for (int col = 0; col < n; col++) {\n                if (grid[row][col] == '0') {\n                    cal[row][col] = rowSum + colSum[col];\n                } else if (grid[row][col] == 'E') {\n                    rowSum++;\n                    colSum[col]++;\n                } else {\n                    rowSum = 0;\n                    colSum[col] = 0;\n                }\n            }\n        }\n        colSum = new int[n];\n        for (int row = m - 1; row >= 0; row--) {\n            int rowSum = 0;\n            for (int col = n - 1; col >= 0; col--) {\n                if (grid[row][col] == '0') {\n                    output = Math.max(output, cal[row][col] + colSum[col] + rowSum);\n                } else if (grid[row][col] == 'E') {\n                    rowSum++;\n                    colSum[col]++;\n                } else {\n                    rowSum = 0;\n                    colSum[col] = 0;\n                }\n            }\n        }\n        return output;\n    }\n}",
      "total_acs": 21705,
      "total_submitted": 54252
    },
    {
      "id": 362,
      "title": "Design Hit Counter",
      "url": "https://leetcode.com/problems/design-hit-counter/description",
      "companyTags": [
        "Google",
        "Dropbox"
      ],
      "difficulty": "Medium",
      "content": "Design a hit counter which counts the number of hits received in the past 5 minutes.\r\n\r\nEach function accepts a timestamp parameter (in seconds granularity) and you may assume that calls are being made to the system in chronological order (ie, the timestamp is monotonically increasing). You may assume that the earliest timestamp starts at 1.\r\n\r\nIt is possible that several hits arrive roughly at the same time.\r\n\r\nExample:\r\n\r\nHitCounter counter = new HitCounter();\r\n\r\n// hit at timestamp 1.\r\ncounter.hit(1);\r\n\r\n// hit at timestamp 2.\r\ncounter.hit(2);\r\n\r\n// hit at timestamp 3.\r\ncounter.hit(3);\r\n\r\n// get hits at timestamp 4, should return 3.\r\ncounter.getHits(4);\r\n\r\n// hit at timestamp 300.\r\ncounter.hit(300);\r\n\r\n// get hits at timestamp 300, should return 4.\r\ncounter.getHits(300);\r\n\r\n// get hits at timestamp 301, should return 3.\r\ncounter.getHits(301); \r\n\r\n\r\n\r\nFollow up:\r\nWhat if the number of hits per second could be very large? Does your design scale?\r\n\r\n\r\nCredits:Special thanks to @elmirap for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/446",
      "similarQuestions": [
        "LoggerRateLimiter"
      ],
      "topicTags": [
        "Design"
      ],
      "Solution": "public class HitCounter {\r\n\r\n    /** Initialize your data structure here. */\r\n    Map<Integer, Integer> map;\r\n    List<Integer> secs;\r\n    public HitCounter() {\r\n        map = new HashMap<Integer, Integer>();\r\n        secs = new ArrayList<Integer>();\r\n    }\r\n    \r\n    /** Record a hit.\r\n        @param timestamp - The current timestamp (in seconds granularity). */\r\n    public void hit(int timestamp) {\r\n        if(!map.containsKey(timestamp)){\r\n            map.put(timestamp, 1);\r\n            secs.add(timestamp);\r\n        } else{\r\n            map.put(timestamp, map.get(timestamp) + 1);\r\n        }\r\n    }\r\n    \r\n    /** Return the number of hits in the past 5 minutes.\r\n        @param timestamp - The current timestamp (in seconds granularity). */\r\n    public int getHits(int timestamp) {\r\n        int count = 0;\r\n        for(int i = secs.size() - 1; i >= 0 ; i--){\r\n            if(secs.get(i) > timestamp - 300){\r\n                count += map.get(secs.get(i));\r\n            }\r\n            else{\r\n                break;\r\n            }\r\n        }\r\n        return count;\r\n    }\r\n}\r\n\r\n/**\r\n * Your HitCounter object will be instantiated and called as such:\r\n * HitCounter obj = new HitCounter();\r\n * obj.hit(timestamp);\r\n * int param_2 = obj.getHits(timestamp);\r\n */",
      "total_acs": 22414,
      "total_submitted": 40793
    },
    {
      "id": 363,
      "title": "Max Sum of Rectangle No Larger Than K",
      "url": "https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Hard",
      "content": "Given a non-empty 2D matrix matrix and an integer k, find the max sum of a rectangle in the matrix such that its sum is no larger than k.\r\n\r\nExample:\r\nGiven matrix = [\r\n  [1,  0, 1],\r\n  [0, -2, 3]\r\n]\r\nk = 2\r\n\r\n\r\n\r\nThe answer is 2. Because the sum of rectangle [[0, 1], [-2, 3]] is 2 and 2 is the max number no larger than k (k = 2).\r\n\r\nNote:\r\n\r\nThe rectangle inside the matrix must have an area > 0.\r\nWhat if the number of rows is much larger than the number of columns?\r\n\r\n\r\n\r\nCredits:Special thanks to @fujiaozhu for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/447",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "BinarySearch",
        "DynamicProgramming",
        "Queue"
      ],
      "Solution": "// sample 30 ms submission\nclass Solution {\n    public int maxSumSubmatrix(int[][] matrix, int k) {\n        if(matrix.length == 0) return 0;\n        // Rows in matrix\n        int m = matrix.length;\n        // Cols in matrix\n        int n = matrix[0].length;\n        int result = Integer.MIN_VALUE;\n        \n        // For each column in matrix.\n        for(int left = 0; left < n; left ++){\n         //   System.out.print(\"left\");\n         //   System.out.println(left);\n            \n            // We create array of number of rows.This helps us to keep addition horizontally. \n             int[] sums = new int[m];\n            \n            // From selected column we forward upto end.\n            for(int right = left; right < n; right ++){\n                \n                int sum = 0, maxSum = Integer.MIN_VALUE;\n                \n                // From forward selected column compute sum for all rows marked by index right column.\n                for(int i = 0; i < m; i++){\n                    sums[i] += matrix[i][right];\n                    // Computing running max sum.\n                    sum = Math.max(sum + sums[i], sums[i]);\n                    // Computing maximum of running max sum.\n                    maxSum = Math.max(maxSum, sum);\n                }\n                // if maxsum is <=k one instance of solution found voilla. Moving iteration forward.\n                if(maxSum <= k){\n                    result = Math.max(result, maxSum);\n                    continue;\n                }\n                // INtialize new sum, starting sum as 0.\n                TreeSet<Integer> set = new TreeSet<>();\n                set.add(0); //this is for one dimensional first element equals to K: [3, 2] k = 3;\n                // keep track of running sum.\n                int curSum = 0;\n                \n                for(int s: sums) {\n                    curSum += s;\n                    // we find closest sum to k using ceiling function.\n                    Integer c = set.ceiling(curSum - k);\n                    // updating result for closer results.\n                    if(c != null) result = Math.max(result, curSum - c);\n                    set.add(curSum);\n                }\n              //  System.out.print(\"right\");\n              //  System.out.print(right);\n              //  System.out.println(result);\n\n\n            }\n          //  System.out.println(result);\n            \n        }\n        return result;\n        \n    }\n}",
      "total_acs": 18006,
      "total_submitted": 53536
    },
    {
      "id": 364,
      "title": "Nested List Weight Sum II",
      "url": "https://leetcode.com/problems/nested-list-weight-sum-ii/description",
      "companyTags": [
        "LinkedIn"
      ],
      "difficulty": "Medium",
      "content": "Given a nested list of integers, return the sum of all integers in the list weighted by their depth.\r\n\r\nEach element is either an integer, or a list -- whose elements may also be integers or other lists.\r\n\r\nDifferent from the previous question where weight is increasing from root to leaf, now the weight is defined from bottom up. i.e., the leaf level integers have weight 1, and the root level integers have the largest weight.\r\n\r\nExample 1:\r\nGiven the list [[1,1],2,[1,1]], return 8. (four 1's at depth 1, one 2 at depth 2)\r\n\r\nExample 2:\r\nGiven the list [1,[4,[6]]], return 17. (one 1 at depth 3, one 4 at depth 2, and one 6 at depth 1; 1*3 + 4*2 + 6*1 = 17)\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/448",
      "similarQuestions": [
        "NestedListWeightSum",
        "ArrayNesting"
      ],
      "topicTags": [
        "Depth-firstSearch"
      ],
      "Solution": "/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * public interface NestedInteger {\n *     // Constructor initializes an empty nested list.\n *     public NestedInteger();\n *\n *     // Constructor initializes a single integer.\n *     public NestedInteger(int value);\n *\n *     // @return true if this NestedInteger holds a single integer, rather than a nested list.\n *     public boolean isInteger();\n *\n *     // @return the single integer that this NestedInteger holds, if it holds a single integer\n *     // Return null if this NestedInteger holds a nested list\n *     public Integer getInteger();\n *\n *     // Set this NestedInteger to hold a single integer.\n *     public void setInteger(int value);\n *\n *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.\n *     public void add(NestedInteger ni);\n *\n *     // @return the nested list that this NestedInteger holds, if it holds a nested list\n *     // Return null if this NestedInteger holds a single integer\n *     public List<NestedInteger> getList();\n * }\n */\nclass Solution {\n    public int depthSumInverse(List<NestedInteger> nestedList) {\n        int unweight = 0;\n        int weight = 0;\n        while(!nestedList.isEmpty()) {\n            List<NestedInteger> nextLevel = new ArrayList<>();\n            for(int i = 0; i < nestedList.size(); i ++) {\n                NestedInteger current = nestedList.get(i);\n                if(current.isInteger())unweight += current.getInteger();\n                else nextLevel.addAll(current.getList());\n            }\n            weight += unweight;\n            nestedList = nextLevel;\n        }\n        return weight;\n    }\n    \n}",
      "total_acs": 20340,
      "total_submitted": 37764
    },
    {
      "id": 365,
      "title": "Water and Jug Problem",
      "url": "https://leetcode.com/problems/water-and-jug-problem/description",
      "companyTags": [
        "Microsoft"
      ],
      "difficulty": "Medium",
      "content": "You are given two jugs with capacities x and y litres. There is an infinite amount of water supply available.\r\nYou need to determine whether it is possible to measure exactly z litres using these two jugs.\r\n\r\nIf z liters of water is measurable, you must have z liters of water contained within one or both buckets by the end.\r\n\r\n\r\nOperations allowed:\r\n\r\nFill any of the jugs completely with water.\r\nEmpty any of the jugs.\r\nPour water from one jug into another till the other jug is completely full or the first jug itself is empty.\r\n\r\n\r\n\r\nExample 1: (From the famous \"Die Hard\" example)\r\n\r\nInput: x = 3, y = 5, z = 4\r\nOutput: True\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: x = 2, y = 6, z = 5\r\nOutput: False\r\n\r\n\r\n\r\nCredits:Special thanks to @vinod23 for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/449",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Math"
      ],
      "Solution": "class Solution {\n    public boolean canMeasureWater(int x, int y, int z) {\n        if (x == 0 || y == 0) return x + y == z || z == 0;\n        int g = GCD(x, y);\n        if (z % g != 0 || z > x + y) return false;\n        return true;\n    }\n    \n    private int GCD(int a, int b) {\n        if (a == b) return a;\n        if (a < b) return GCD(b, a);\n        return GCD(a - b, b);\n    }\n}",
      "total_acs": 18831,
      "total_submitted": 67357
    },
    {
      "id": 366,
      "title": "Find Leaves of Binary Tree",
      "url": "https://leetcode.com/problems/find-leaves-of-binary-tree/description",
      "companyTags": [
        "LinkedIn"
      ],
      "difficulty": "Medium",
      "content": "Given a binary tree, collect a tree's nodes as if you were doing this: Collect and remove all leaves, repeat until the tree is empty.\r\n\r\n\r\n\r\nExample:\r\nGiven binary tree \r\n\r\n          1\r\n         / \\\r\n        2   3\r\n       / \\     \r\n      4   5    \r\n\r\n\r\n\r\nReturns [4, 5, 3], [2], [1].\r\n\r\n\r\n\r\nExplanation:\r\n\r\n1. Removing the leaves [4, 5, 3] would result in this tree:\r\n\r\n          1\r\n         / \r\n        2          \r\n\r\n\r\n\r\n2. Now removing the leaf [2] would result in this tree:\r\n\r\n          1          \r\n\r\n\r\n\r\n3. Now removing the leaf [1] would result in the empty tree:\r\n\r\n          []         \r\n\r\n\r\n\r\n\r\nReturns [4, 5, 3], [2], [1].\r\n\r\n\r\nCredits:Special thanks to @elmirap for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/450",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Tree",
        "Depth-firstSearch"
      ],
      "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<List<Integer>> findLeaves(TreeNode root) {\n        List<List<Integer>> result = new ArrayList<>();\n        helper(root, result);\n        return result;\n    }\n    public int helper(TreeNode root, List<List<Integer>> result) {\n        if (root == null) {\n            return -1;\n        }\n        int height = 1 + Math.max(helper(root.left, result), helper(root.right, result));\n        if (height + 1 > result.size() ) {\n            result.add(new ArrayList<>());\n        }\n        result.get(height).add(root.val);\n        return height;\n    }\n}",
      "total_acs": 24085,
      "total_submitted": 39519
    },
    {
      "id": 367,
      "title": "Valid Perfect Square",
      "url": "https://leetcode.com/problems/valid-perfect-square/description",
      "companyTags": [
        "LinkedIn"
      ],
      "difficulty": "Easy",
      "content": "Given a positive integer num, write a function which returns True if num is a perfect square else False.\r\n\r\n\r\nNote: Do not use any built-in library function such as sqrt.\r\n\r\n\r\nExample 1:\r\n\r\nInput: 16\r\nReturns: True\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: 14\r\nReturns: False\r\n\r\n\r\n\r\nCredits:Special thanks to @elmirap for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/451",
      "similarQuestions": [
        "Sqrt(x)",
        "SumofSquareNumbers"
      ],
      "topicTags": [
        "Math",
        "BinarySearch"
      ],
      "Solution": "class Solution {\n    public boolean isPerfectSquare(int num) {\n         int i = 1;\n         while (num > 0) {\n             num -= i;\n             i += 2;\n         }\n         return num == 0;\n    }\n}",
      "total_acs": 65029,
      "total_submitted": 168434
    },
    {
      "id": 368,
      "title": "Largest Divisible Subset",
      "url": "https://leetcode.com/problems/largest-divisible-subset/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies: Si % Sj = 0 or Sj % Si = 0.\r\n\r\n\r\nIf there are multiple solutions, return any subset is fine.\r\n\r\n\r\nExample 1:\r\n\r\nnums: [1,2,3]\r\n\r\nResult: [1,2] (of course, [1,3] will also be ok)\r\n\r\n\r\n\r\nExample 2:\r\n\r\nnums: [1,2,4,8]\r\n\r\nResult: [1,2,4,8]\r\n\r\n\r\n\r\nCredits:Special thanks to @Stomach_ache for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/452",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Math",
        "DynamicProgramming"
      ],
      "Solution": "class Solution {\n    public List<Integer> largestDivisibleSubset(int[] nums) {\n      int n = nums.length, maxIdx = 0;\n        List<Integer> ans = new LinkedList<>();\n        if (n == 0) return ans;\n        Arrays.sort(nums);\n        int[] lens = new int[n], prevs = new int[n];\n        Arrays.fill(prevs, -1);\n        for (int i = 0; nums[i] <= nums[n-1]/2; ++i) {\n            for (int j = i + 1, f = 2; nums[i] <= nums[n-1]/f; f = (nums[j] + nums[i] - 1)/nums[i]) {\n                int idx = Arrays.binarySearch(nums, j, n, f*nums[i]);\n                if (idx > 0 && lens[idx] <= lens[i]) {\n                    prevs[idx] = i;\n                    lens[idx] = lens[i] + 1;\n                    if (lens[idx] > lens[maxIdx]) maxIdx = idx;\n                }\n                j = idx >= 0 ? idx + 1 : -(idx + 1);\n                if (j >= n) break;\n            }\n        }\n        for (int i = maxIdx; i >= 0; i = prevs[i]) ans.add(0, nums[i]);\n        return ans;\n    }\n}",
      "total_acs": 31990,
      "total_submitted": 94496
    },
    {
      "id": 369,
      "title": "Plus One Linked List",
      "url": "https://leetcode.com/problems/plus-one-linked-list/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Medium",
      "content": "Given a non-negative integer represented as non-empty a singly linked list of digits, plus one to the integer.\r\n\r\nYou may assume the integer do not contain any leading zero, except the number 0 itself.\r\n\r\nThe digits are stored such that the most significant digit is at the head of the list.\r\n\r\nExample:\r\n\r\nInput:\r\n1->2->3\r\n\r\nOutput:\r\n1->2->4\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/453",
      "similarQuestions": [
        "PlusOne"
      ],
      "topicTags": [
        "LinkedList"
      ],
      "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode plusOne(ListNode head) {\n        if (head == null) {\n            return head;\n        }\n        int res = dfs(head);\n        if (res == 10) {\n            ListNode newHead = new ListNode(1);\n            newHead.next = head;\n            return newHead;\n        }\n        return head;\n    }\n    private int dfs(ListNode head) {\n        if (head.next == null) {\n            head.val++;\n            if (head.val == 10) {\n                head.val = 0;\n                return 10;\n            }\n            return head.val;\n        }\n        \n        int child = dfs(head.next);\n        if(child == 10) {\n            head.val++;\n            if (head.val == 10) {\n                head.val = 0;\n                return 10;\n            }\n            return head.val;\n        }\n        return head.val;\n    }\n    \n}",
      "total_acs": 20618,
      "total_submitted": 37462
    },
    {
      "id": 370,
      "title": "Range Addition",
      "url": "https://leetcode.com/problems/range-addition/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Medium",
      "content": "Assume you have an array of length n initialized with all 0's and are given k update operations.\r\n\r\nEach operation is represented as a triplet: [startIndex, endIndex, inc] which increments each element of subarray A[startIndex ... endIndex] (startIndex and endIndex inclusive) with inc.\r\n\r\nReturn the modified array after all k operations were executed.\r\n\r\nExample:\r\n\r\nGiven:\r\n\r\n    length = 5,\r\n    updates = [\r\n        [1,  3,  2],\r\n        [2,  4,  3],\r\n        [0,  2, -2]\r\n    ]\r\n\r\nOutput:\r\n\r\n    [-2, 0, 3, 5, 3]\r\n\r\n\r\n\r\nExplanation:\r\n\r\nInitial state:\r\n[ 0, 0, 0, 0, 0 ]\r\n\r\nAfter applying operation [1, 3, 2]:\r\n[ 0, 2, 2, 2, 0 ]\r\n\r\nAfter applying operation [2, 4, 3]:\r\n[ 0, 2, 5, 5, 3 ]\r\n\r\nAfter applying operation [0, 2, -2]:\r\n[-2, 0, 3, 5, 3 ]\r\n\r\n\r\n\r\nCredits:Special thanks to @vinod23 for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/454",
      "similarQuestions": [
        "RangeAdditionII"
      ],
      "topicTags": [
        "Array"
      ],
      "Solution": "class Solution {\n    public int[] getModifiedArray(int length, int[][] updates) {\n        if(length==0) return new int[0];\n        int[] sum=new int[length];\n        for(int[] curr:updates){\n            sum[curr[0]]+=curr[2];\n            if(curr[1]<length-1) sum[curr[1]+1]-=curr[2];\n        }\n        \n        for(int i=1;i<length;i++){\n            sum[i]+=sum[i-1];\n        }\n        return sum;\n    }\n}",
      "total_acs": 15919,
      "total_submitted": 27917
    },
    {
      "id": 371,
      "title": "Sum of Two Integers",
      "url": "https://leetcode.com/problems/sum-of-two-integers/description",
      "companyTags": [
        "Hulu"
      ],
      "difficulty": "Easy",
      "content": "Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.\r\n\r\nExample:\r\nGiven a = 1 and b = 2, return 3.\r\n\r\n\r\nCredits:Special thanks to @fujiaozhu for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/455",
      "similarQuestions": [
        "AddTwoNumbers"
      ],
      "topicTags": [
        "BitManipulation"
      ],
      "Solution": "class Solution {\n    public int getSum(int a, int b) {\n        while(b!= 0){\n        if(b < 0){\n            a--;\n            b++;\n        } else {\n            a++;\n            b--;\n         } \n        }return a;\n        \n    }\n}",
      "total_acs": 90067,
      "total_submitted": 176451
    },
    {
      "id": 372,
      "title": "Super Pow",
      "url": "https://leetcode.com/problems/super-pow/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "\r\nYour task is to calculate ab mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array.\r\n\r\n\r\nExample1:\r\n\r\na = 2\r\nb = [3]\r\n\r\nResult: 8\r\n\r\n\r\n\r\nExample2:\r\n\r\na = 2\r\nb = [1,0]\r\n\r\nResult: 1024\r\n\r\n\r\n\r\nCredits:Special thanks to @Stomach_ache for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/490",
      "similarQuestions": [
        "Pow(x",
        "n)"
      ],
      "topicTags": [
        "Math"
      ],
      "Solution": "class Solution {\n    public int superPow(int a, int[] b) {\n        if (a % 1337 == 0) return 0;\n    int p = 0;\n    for (int i : b) p = (p * 10 + i) % 1140;\n    if (p == 0) p += 1440;\n    return power(a, p, 1337);\n}\npublic int power(int a, int n, int mod) {\n    a %= mod;\n    int ret = 1;\n    while (n != 0) {\n        if ((n & 1) != 0) ret = ret * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return ret;\n    }\n}",
      "total_acs": 19755,
      "total_submitted": 57088
    },
    {
      "id": 373,
      "title": "Find K Pairs with Smallest Sums",
      "url": "https://leetcode.com/problems/find-k-pairs-with-smallest-sums/description",
      "companyTags": [
        "Google",
        "Uber"
      ],
      "difficulty": "Medium",
      "content": "\r\nYou are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k. \r\n\r\n\r\nDefine a pair (u,v) which consists of one element from the first array and one element from the second array.\r\n\r\nFind the k pairs (u1,v1),(u2,v2) ...(uk,vk) with the smallest sums.\r\n\r\n\r\nExample 1:\r\n\r\nGiven nums1 = [1,7,11], nums2 = [2,4,6],  k = 3\r\n\r\nReturn: [1,2],[1,4],[1,6]\r\n\r\nThe first 3 pairs are returned from the sequence:\r\n[1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]\r\n\r\n\r\n\r\nExample 2:\r\n\r\nGiven nums1 = [1,1,2], nums2 = [1,2,3],  k = 2\r\n\r\nReturn: [1,1],[1,1]\r\n\r\nThe first 2 pairs are returned from the sequence:\r\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\r\n\r\n\r\n\r\nExample 3:\r\n\r\nGiven nums1 = [1,2], nums2 = [3],  k = 3 \r\n\r\nReturn: [1,3],[2,3]\r\n\r\nAll possible pairs are returned from the sequence:\r\n[1,3],[2,3]\r\n\r\n\r\n\r\nCredits:Special thanks to @elmirap and @StefanPochmann for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/491",
      "similarQuestions": [
        "KthSmallestElementinaSortedMatrix",
        "FindK-thSmallestPairDistance"
      ],
      "topicTags": [
        "Heap"
      ],
      "Solution": "\nimport java.util.*;\n\nclass Solution {\n    \n    public List<int[]> kSmallestPairs(int[] nums1, int[] nums2, int k) {\n        int len1 = nums1.length, len2 = nums2.length, len = len1 * len2;\n        boolean isSwap = false;\n        if(len1 < len2) {\n            int[] tmp = nums1;\n            nums1 = nums2;\n            nums2 = tmp;\n            len1 = nums1.length;\n            len2 = nums2.length;\n            isSwap = true;\n        }\n        if(k >= len) {\n            k = len;\n        }\n        if(k <= 0) {\n            return new ArrayList();\n        }\n        int n1 = (int)Math.sqrt(k - 1) + 1, n2 = (int)Math.sqrt(len - k) + 1;\n        int max = n1 > len2 ? nums1[(k - 1) / len2] + nums2[len2 - 1] : nums1[n1 - 1] + nums2[n1 - 1];\n        int min = n2 > len2 ? nums1[len1 - 1 - (k - 1) / len2] + nums2[0] : nums1[len1 - n2] + nums2[len2 - n2];\n        int lessCnt, ngtCnt, num;\n        for(;;) {\n            num = min + ((max - min) >>> 1);\n            lessCnt = 0;\n            ngtCnt = 0;\n            for(int i = len2 - 1, idx0 = 0, idx1 = 0; i >= 0; i--) {\n                int num2 = nums2[i];\n                for(; idx0 < len1 && nums1[idx0] + num2 < num; idx0++);\n                for(; idx1 < len1 && nums1[idx1] + num2 <= num; idx1++);\n                lessCnt += idx0;\n                ngtCnt += idx1;\n            }\n            if(k < lessCnt) {\n                max = num - 1;\n            } else if(k > ngtCnt) {\n                min = num + 1;\n            } else {\n                break;\n            }\n        }\n        int[][] pairs = new int[k][];\n        int eqCnt = k - lessCnt;\n        for(int i = len2 - 1, j = 0, idx; i >= 0; i--) {\n            int num1, num2 = nums2[i];\n            for(idx = 0; idx < len1 && (num1 = nums1[idx]) + num2 < num; idx++) {\n                pairs[j++] = isSwap ? new int[]{num2, num1} : new int[]{num1, num2};\n            }\n            for(; eqCnt > 0 && idx < len1 && (num1 = nums1[idx]) + num2 <= num; idx++) {\n                pairs[j++] = isSwap ? new int[]{num2, num1} : new int[]{num1, num2};\n                eqCnt--;\n            }\n        }\n        return Arrays.asList(pairs);\n    }\n}",
      "total_acs": 37378,
      "total_submitted": 119821
    },
    {
      "id": 374,
      "title": "Guess Number Higher or Lower",
      "url": "https://leetcode.com/problems/guess-number-higher-or-lower/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Easy",
      "content": "We are playing the Guess Game. The game is as follows: \r\n\r\nI pick a number from 1 to n. You have to guess which number I picked.\r\n\r\nEvery time you guess wrong, I'll tell you whether the number is higher or lower.\r\n\r\nYou call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0):\r\n\r\n-1 : My number is lower\r\n 1 : My number is higher\r\n 0 : Congrats! You got it!\r\n\r\n\r\nExample:\r\n\r\nn = 10, I pick 6.\r\n\r\nReturn 6.\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/492",
      "similarQuestions": [
        "FirstBadVersion",
        "GuessNumberHigherorLowerII",
        "FindKClosestElements"
      ],
      "topicTags": [
        "BinarySearch"
      ],
      "Solution": "/* The guess API is defined in the parent class GuessGame.\n   @param num, your guess\n   @return -1 if my number is lower, 1 if my number is higher, otherwise return 0\n      int guess(int num); */\n\npublic class Solution extends GuessGame {\n    public int guessNumber(int n) {\n        int start = 1;\n        int end = n;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (guess(mid) == 0) {\n                return mid;\n            } else if (guess(mid) < 0) {\n                end = mid -1;\n            } else {\n                start = mid +1;\n            }\n        }\n        \n        return -1;\n    }\n}",
      "total_acs": 66161,
      "total_submitted": 181911
    },
    {
      "id": 375,
      "title": "Guess Number Higher or Lower II",
      "url": "https://leetcode.com/problems/guess-number-higher-or-lower-ii/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Medium",
      "content": "We are playing the Guess Game. The game is as follows: \r\n\r\nI pick a number from 1 to n. You have to guess which number I picked.\r\n\r\nEvery time you guess wrong, I'll tell you whether the number I picked is higher or lower. \r\n\r\nHowever, when you guess a particular number x,  and you guess wrong, you pay $x. You win the game when you guess the number I picked.\r\n\r\n\r\nExample:\r\n\r\nn = 10, I pick 8.\r\n\r\nFirst round:  You guess 5, I tell you that it's higher. You pay $5.\r\nSecond round: You guess 7, I tell you that it's higher. You pay $7.\r\nThird round:  You guess 9, I tell you that it's lower. You pay $9.\r\n\r\nGame over. 8 is the number I picked.\r\n\r\nYou end up paying $5 + $7 + $9 = $21.\r\n\r\n\r\n\r\nGiven a particular n ≥ 1, find out how much money you need to have to guarantee a win.\r\n\r\nCredits:Special thanks to @agave and @StefanPochmann for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/495",
      "similarQuestions": [
        "FlipGameII",
        "GuessNumberHigherorLower",
        "CanIWin",
        "FindKClosestElements"
      ],
      "topicTags": [
        "DynamicProgramming",
        "Minimax"
      ],
      "Solution": "class Solution {\n    int[][] dp;\n    public int getMoneyAmount(int n) {\n        dp = new int[n + 1][n + 1];\n        return helper(1, n);\n    }\n    \n    private int helper(int start, int end) {\n        if (dp[start][end] != 0) {\n            return dp[start][end];\n        }\n        if (start >= end) {\n            return 0;\n        }\n        if (start >= end - 2) {\n            return dp[start][end] = end - 1;\n        }\n        int mid = (start + end) / 2 - 1, min = Integer.MAX_VALUE;\n        while (mid < end) {\n            int left = helper(start, mid - 1);\n            int right = helper(mid + 1, end);\n            min = Math.min(min, mid + Math.max(left, right));\n            if (right <= left) break;\n            mid++;\n        }\n        return dp[start][end] = min;\n    }\n}",
      "total_acs": 28441,
      "total_submitted": 78815
    },
    {
      "id": 376,
      "title": "Wiggle Subsequence",
      "url": "https://leetcode.com/problems/wiggle-subsequence/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "A sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence. \r\n\r\nFor example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero.\r\n\r\nGiven a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order.\r\n\r\nExamples:\r\n\r\nInput: [1,7,4,9,2,5]\r\nOutput: 6\r\nThe entire sequence is a wiggle sequence.\r\n\r\nInput: [1,17,5,10,13,15,10,5,16,8]\r\nOutput: 7\r\nThere are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].\r\n\r\nInput: [1,2,3,4,5,6,7,8,9]\r\nOutput: 2\r\n\r\n\r\n\r\nFollow up:\r\nCan you do it in O(n) time?\r\n\r\n\r\nCredits:Special thanks to @agave and @StefanPochmann for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/496",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "DynamicProgramming",
        "Greedy"
      ],
      "Solution": "class Solution {\n    public int wiggleMaxLength(int[] nums) {\n       if(nums.length <= 1) return nums.length;\n\n        int [] dp = new int[nums.length];\n        dp[0] = 1;\n        dp[1] = nums[1] != nums[0] ? 2:1;\n        int last_diff = nums[1]-nums[0];\n        int last_var = nums[1];\n        for (int i = 2; i <nums.length ; i++) {\n           int var = nums[i] - last_var;\n             if(var == 0 || last_diff != 0 && var * last_diff >0){\n                dp[i] = dp[i-1];\n                last_var = last_diff >= 0 ?\n                        Math.max(nums[i],last_var) : Math.min(nums[i],last_var);\n            }else{\n                dp[i] = dp[i-1] +1;\n                last_diff = nums[i] - last_var;\n                last_var = nums[i];\n            }\n        }\n        return dp[nums.length-1]; \n    }\n}",
      "total_acs": 30954,
      "total_submitted": 85706
    },
    {
      "id": 377,
      "title": "Combination Sum IV",
      "url": "https://leetcode.com/problems/combination-sum-iv/description",
      "companyTags": [
        "Google",
        "Facebook",
        "Snapchat"
      ],
      "difficulty": "Medium",
      "content": " Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.\r\n\r\nExample:\r\n\r\nnums = [1, 2, 3]\r\ntarget = 4\r\n\r\nThe possible combination ways are:\r\n(1, 1, 1, 1)\r\n(1, 1, 2)\r\n(1, 2, 1)\r\n(1, 3)\r\n(2, 1, 1)\r\n(2, 2)\r\n(3, 1)\r\n\r\nNote that different sequences are counted as different combinations.\r\n\r\nTherefore the output is 7.\r\n\r\n\r\n\r\nFollow up:\r\nWhat if negative numbers are allowed in the given array?\r\nHow does it change the problem?\r\nWhat limitation we need to add to the question to allow negative numbers? \r\n\r\nCredits:Special thanks to @pbrother for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/497",
      "similarQuestions": [
        "CombinationSum"
      ],
      "topicTags": [
        "DynamicProgramming"
      ],
      "Solution": "class Solution {\n    public int combinationSum4(int[] nums, int target) {\n        int[] rt=new int[target+1];\n        int i;\n        for (i=0;i<=target;i++) rt[i]=-1;\n        return (cs4(nums,target,rt));  \n    }    \n    public int cs4(int[] nums, int target, int[] rt) {    \n     \n    if (target<=0) return(0);\n    if (nums.length==0) return(0);    \n    if (rt[target]>=0) return (rt[target]);\n        \n    int i,r=0;\n    \n    \n    \n    \n    for (i=0;i<nums.length; i++)\n     {\n      if (target-nums[i]==0)\n        r++;\n      else  \n        r=r+cs4(nums, target-nums[i], rt);\n     }   \n    rt[target]=r;    \n    return(r);\n   }\n}",
      "total_acs": 54022,
      "total_submitted": 126594
    },
    {
      "id": 378,
      "title": "Kth Smallest Element in a Sorted Matrix",
      "url": "https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description",
      "companyTags": [
        "Google",
        "Twitter"
      ],
      "difficulty": "Medium",
      "content": "Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.\r\n\r\n\r\nNote that it is the kth smallest element in the sorted order, not the kth distinct element.\r\n\r\n\r\nExample:\r\n\r\nmatrix = [\r\n   [ 1,  5,  9],\r\n   [10, 11, 13],\r\n   [12, 13, 15]\r\n],\r\nk = 8,\r\n\r\nreturn 13.\r\n\r\n\r\n\r\nNote: \r\nYou may assume k is always valid, 1 ≤ k ≤ n2.",
      "discussUrl": "https://discuss.leetcode.com/category/498",
      "similarQuestions": [
        "FindKPairswithSmallestSums",
        "KthSmallestNumberinMultiplicationTable",
        "FindK-thSmallestPairDistance"
      ],
      "topicTags": [
        "BinarySearch",
        "Heap"
      ],
      "Solution": "public class Solution {    \n    public int kthSmallest(int[][] matrix, int k) {\n        int lo = matrix[0][0];\n        int hi = matrix[matrix.length - 1][matrix[0].length - 1];\n        while(lo < hi){\n            int mid = lo + (hi - lo) / 2;\n            int count = 0;\n            int j = matrix[0].length - 1;\n            for(int i = 0; i < matrix.length; i++){\n                while(j >= 0 && matrix[i][j] > mid){\n                    j--;\n                }\n                count += j + 1;\n            }\n            if(count < k){\n                lo = mid + 1;\n            }else{\n                hi = mid;\n            }\n        }\n        return lo;\n    }\n}",
      "total_acs": 53971,
      "total_submitted": 118929
    },
    {
      "id": 379,
      "title": "Design Phone Directory",
      "url": "https://leetcode.com/problems/design-phone-directory/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Medium",
      "content": "Design a Phone Directory which supports the following operations:\r\n\r\n\r\n\r\nget: Provide a number which is not assigned to anyone.\r\ncheck: Check if a number is available or not.\r\nrelease: Recycle or release a number.\r\n\r\n\r\n\r\nExample:\r\n\r\n// Init a phone directory containing a total of 3 numbers: 0, 1, and 2.\r\nPhoneDirectory directory = new PhoneDirectory(3);\r\n\r\n// It can return any available phone number. Here we assume it returns 0.\r\ndirectory.get();\r\n\r\n// Assume it returns 1.\r\ndirectory.get();\r\n\r\n// The number 2 is available, so return true.\r\ndirectory.check(2);\r\n\r\n// It returns 2, the only number that is left.\r\ndirectory.get();\r\n\r\n// The number 2 is no longer available, so return false.\r\ndirectory.check(2);\r\n\r\n// Release number 2 back to the pool.\r\ndirectory.release(2);\r\n\r\n// Number 2 is available again, return true.\r\ndirectory.check(2);\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/499",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "LinkedList",
        "Design"
      ],
      "Solution": "class PhoneDirectory {\n    BitSet bs;\n    int max;\n    int smallestFreeIndex;\n    /** Initialize your data structure here\n        @param maxNumbers - The maximum numbers that can be stored in the phone directory. */\n    public PhoneDirectory(int maxNumbers) {\n        max = maxNumbers;\n        bs = new BitSet(max);\n        smallestFreeIndex = 0;\n    }\n    \n    /** Provide a number which is not assigned to anyone.\n        @return - Return an available number. Return -1 if none is available. */\n    public int get() {\n        if(smallestFreeIndex == max){\n            return -1;\n        }\n        int tmp = smallestFreeIndex;\n        bs.set(smallestFreeIndex);\n        smallestFreeIndex = bs.nextClearBit(smallestFreeIndex);\n        return tmp;\n    }\n    \n    /** Check if a number is available or not. */\n    public boolean check(int number) {\n        return bs.get(number) == false;\n    }\n    \n    /** Recycle or release a number. */\n    public void release(int number) {\n        if(bs.get(number) == false){\n            return ;\n        }\n        bs.clear(number);\n        if(number < smallestFreeIndex){\n            smallestFreeIndex = number;\n        }\n    }\n}\n\n/**\n * Your PhoneDirectory object will be instantiated and called as such:\n * PhoneDirectory obj = new PhoneDirectory(maxNumbers);\n * int param_1 = obj.get();\n * boolean param_2 = obj.check(number);\n * obj.release(number);\n */",
      "total_acs": 13738,
      "total_submitted": 38862
    },
    {
      "id": 380,
      "title": "Insert Delete GetRandom O(1)",
      "url": "https://leetcode.com/problems/insert-delete-getrandom-o1/description",
      "companyTags": [
        "Google",
        "Facebook",
        "Amazon",
        "Uber",
        "Twitter",
        "Yelp",
        "PocketGems"
      ],
      "difficulty": "Medium",
      "content": "Design a data structure that supports all following operations in average O(1) time.\r\n\r\n\r\n\r\ninsert(val): Inserts an item val to the set if not already present.\r\nremove(val): Removes an item val from the set if present.\r\ngetRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned.\r\n\r\n\r\n\r\nExample:\r\n\r\n// Init an empty set.\r\nRandomizedSet randomSet = new RandomizedSet();\r\n\r\n// Inserts 1 to the set. Returns true as 1 was inserted successfully.\r\nrandomSet.insert(1);\r\n\r\n// Returns false as 2 does not exist in the set.\r\nrandomSet.remove(2);\r\n\r\n// Inserts 2 to the set, returns true. Set now contains [1,2].\r\nrandomSet.insert(2);\r\n\r\n// getRandom should return either 1 or 2 randomly.\r\nrandomSet.getRandom();\r\n\r\n// Removes 1 from the set, returns true. Set now contains [2].\r\nrandomSet.remove(1);\r\n\r\n// 2 was already in the set, so return false.\r\nrandomSet.insert(2);\r\n\r\n// Since 2 is the only number in the set, getRandom always return 2.\r\nrandomSet.getRandom();\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/500",
      "similarQuestions": [
        "InsertDeleteGetRandomO(1)-Duplicatesallowed"
      ],
      "topicTags": [
        "Array",
        "HashTable",
        "Design"
      ],
      "Solution": "class RandomizedSet {\n\n    /** Initialize your data structure here. */\n    //Using array to save the number of it\n    HashMap<Integer,Integer> map;\n    ArrayList<Integer> list;\n    java.util.Random rand = new java.util.Random();\n    public RandomizedSet() {\n        map = new HashMap<>();\n        list = new ArrayList<Integer>();\n    }\n    \n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\n    public boolean insert(int val) {\n        if(map.containsKey(val))\n            return false;\n        int size = list.size();\n        map.put(val, size);\n        list.add(val);\n        return true;        \n    }\n    \n    /** Removes a value from the set. Returns true if the set contained the specified element. */\n    public boolean remove(int val) {\n        if(!map.containsKey(val))\n            return false;\n        int index = map.get(val);\n        int size = list.size();\n        if(index < size - 1){\n            int temVal = list.get(size - 1);\n            list.set(index, temVal);\n            map.put(temVal,index);\n        }\n        map.remove(val);\n        list.remove(size - 1);\n        \n        return true;\n        \n    }\n    \n    /** Get a random element from the set. */\n    public int getRandom() {\n        return list.get(rand.nextInt(list.size()));\n    }\n}\n\n/**\n * Your RandomizedSet object will be instantiated and called as such:\n * RandomizedSet obj = new RandomizedSet();\n * boolean param_1 = obj.insert(val);\n * boolean param_2 = obj.remove(val);\n * int param_3 = obj.getRandom();\n */",
      "total_acs": 53144,
      "total_submitted": 133557
    },
    {
      "id": 381,
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "url": "https://leetcode.com/problems/insert-delete-getrandom-o1-duplicates-allowed/description",
      "companyTags": [
        "Yelp"
      ],
      "difficulty": "Hard",
      "content": "Design a data structure that supports all following operations in average O(1) time.\r\nNote: Duplicate elements are allowed.\r\n\r\n\r\ninsert(val): Inserts an item val to the collection.\r\nremove(val): Removes an item val from the collection if present.\r\ngetRandom: Returns a random element from current collection of elements. The probability of each element being returned is linearly related to the number of same value the collection contains.\r\n\r\n\r\n\r\nExample:\r\n\r\n// Init an empty collection.\r\nRandomizedCollection collection = new RandomizedCollection();\r\n\r\n// Inserts 1 to the collection. Returns true as the collection did not contain 1.\r\ncollection.insert(1);\r\n\r\n// Inserts another 1 to the collection. Returns false as the collection contained 1. Collection now contains [1,1].\r\ncollection.insert(1);\r\n\r\n// Inserts 2 to the collection, returns true. Collection now contains [1,1,2].\r\ncollection.insert(2);\r\n\r\n// getRandom should return 1 with the probability 2/3, and returns 2 with the probability 1/3.\r\ncollection.getRandom();\r\n\r\n// Removes 1 from the collection, returns true. Collection now contains [1,2].\r\ncollection.remove(1);\r\n\r\n// getRandom should return 1 and 2 both equally likely.\r\ncollection.getRandom();\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/501",
      "similarQuestions": [
        "InsertDeleteGetRandomO(1)"
      ],
      "topicTags": [
        "Array",
        "HashTable",
        "Design"
      ],
      "Solution": "class RandomizedCollection {\n\n    /** Initialize your data structure here. */\n    public RandomizedCollection() {\n        map = new HashMap();\n        pairs = new ArrayList<int[]>();\n        rdn = new Random();\n    }\n    \n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\n    public boolean insert(int val) {\n        boolean contain = map.containsKey(val);\n        int size = pairs.size();\n        if (contain) {\n            pairs.add(new int[]{val, size});\n            map.get(val).add(size);\n            return false;\n        }\n        pairs.add(new int[]{val, size});\n        map.put(val, new ArrayList<Integer>());\n        map.get(val).add(size);\n        return true;\n    }\n    \n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\n    public boolean remove(int val) {\n        // System.out.println(map);\n        // for (int[] pair : pairs)\n        //      System.out.println(Arrays.toString(pair));\n        if (!map.containsKey(val)) {\n            return false;\n        }\n        List<Integer> valIndexList = map.get(val);\n        int[] lastPair = pairs.get(pairs.size() - 1);\n        // Case 1: No need for switch\n        if (lastPair[0] == val) {\n            pairs.remove(pairs.size() - 1);\n            valIndexList.remove(valIndexList.size() - 1);\n            if (valIndexList.size() == 0) {\n                map.remove(val);\n            }\n            return true;\n        }\n        // Case 2: switch and delete\n        List<Integer> switchIndexList = map.get(lastPair[0]);\n        int valLastIndex = valIndexList.get(valIndexList.size() - 1);\n        int switchLastIndex = switchIndexList.get(switchIndexList.size() - 1);\n        switchIndexList.set(switchIndexList.size() - 1, valLastIndex);\n        Collections.sort(switchIndexList);\n        valIndexList.remove(valIndexList.size() - 1);\n        pairs.get(valLastIndex)[0] = lastPair[0];\n        if (valIndexList.size() == 0) {\n            map.remove(val);\n        }\n        pairs.remove(pairs.size() - 1);\n        return true;\n    }\n    \n    /** Get a random element from the collection. */\n    public int getRandom() {\n        int next = rdn.nextInt() % pairs.size();\n        if (next < 0) {\n            next += pairs.size();\n        }\n        return pairs.get(next)[0];\n    }\n    Random rdn;\n    List<int[]> pairs;\n    Map<Integer, List<Integer>> map;\n}\n\n/**\n * Your RandomizedCollection object will be instantiated and called as such:\n * RandomizedCollection obj = new RandomizedCollection();\n * boolean param_1 = obj.insert(val);\n * boolean param_2 = obj.remove(val);\n * int param_3 = obj.getRandom();\n */",
      "total_acs": 22584,
      "total_submitted": 76606
    },
    {
      "id": 382,
      "title": "Linked List Random Node",
      "url": "https://leetcode.com/problems/linked-list-random-node/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Medium",
      "content": "Given a singly linked list, return a random node's value from the linked list. Each node must have the same probability of being chosen.\r\n\r\nFollow up:\r\nWhat if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space?\r\n\r\n\r\nExample:\r\n\r\n// Init a singly linked list [1,2,3].\r\nListNode head = new ListNode(1);\r\nhead.next = new ListNode(2);\r\nhead.next.next = new ListNode(3);\r\nSolution solution = new Solution(head);\r\n\r\n// getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning.\r\nsolution.getRandom();\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/502",
      "similarQuestions": [
        "RandomPickIndex"
      ],
      "topicTags": [
        "ReservoirSampling"
      ],
      "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    \n    ListNode head;\n    Random random;\n    /** @param head The linked list's head.\n        Note that the head is guaranteed to be not null, so it contains at least one node. */\n    \n    public Solution(ListNode head) { \n        this.head = head;\n        random = new Random();\n    }\n    \n    /** Returns a random node's value. */\n    public int getRandom() {\n        ListNode c = head;\n        int r = c.val;\n        for( int i = 1 ; c.next != null ; i++ ){\n            c = c.next;\n            if( random.nextInt(i + 1) == i ) r = c.val;\n        }\n        return r;\n    }\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution obj = new Solution(head);\n * int param_1 = obj.getRandom();\n */",
      "total_acs": 35573,
      "total_submitted": 75003
    },
    {
      "id": 383,
      "title": "Ransom Note",
      "url": "https://leetcode.com/problems/ransom-note/description",
      "companyTags": [
        "Apple"
      ],
      "difficulty": "Easy",
      "content": "\r\nGiven an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom \r\nnote can be constructed from the magazines ; otherwise, it will return false. \r\n\r\n\r\nEach letter in the magazine string can only be used once in your ransom note.\r\n\r\n\r\nNote:\r\nYou may assume that both strings contain only lowercase letters.\r\n\r\n\r\n\r\ncanConstruct(\"a\", \"b\") -> false\r\ncanConstruct(\"aa\", \"ab\") -> false\r\ncanConstruct(\"aa\", \"aab\") -> true\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/503",
      "similarQuestions": [
        "StickerstoSpellWord"
      ],
      "topicTags": [
        "String"
      ],
      "Solution": "class Solution {\n public boolean canConstruct(String ransomNote, String magazine) {\n    int[] table = new int[26];\n    for (char c : magazine.toCharArray())   table[c - 'a']++;\n    for (char c : ransomNote.toCharArray())\n        if (--table[c - 'a'] < 0) return false;\n    return true;\n}\n}",
      "total_acs": 73290,
      "total_submitted": 153747
    },
    {
      "id": 384,
      "title": "Shuffle an Array",
      "url": "https://leetcode.com/problems/shuffle-an-array/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "Shuffle a set of numbers without duplicates.\r\n\r\n\r\nExample:\r\n\r\n// Init an array with set 1, 2, and 3.\r\nint[] nums = {1,2,3};\r\nSolution solution = new Solution(nums);\r\n\r\n// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.\r\nsolution.shuffle();\r\n\r\n// Resets the array back to its original configuration [1,2,3].\r\nsolution.reset();\r\n\r\n// Returns the random shuffling of array [1,2,3].\r\nsolution.shuffle();\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/504",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        ""
      ],
      "Solution": null,
      "total_acs": 37740,
      "total_submitted": 79686
    },
    {
      "id": 385,
      "title": "Mini Parser",
      "url": "https://leetcode.com/problems/mini-parser/description",
      "companyTags": [
        "Airbnb"
      ],
      "difficulty": "Medium",
      "content": "Given a nested list of integers represented as a string, implement a parser to deserialize it.\r\n\r\nEach element is either an integer, or a list -- whose elements may also be integers or other lists.\r\n\r\nNote:\r\nYou may assume that the string is well-formed:\r\n\r\nString is non-empty.\r\nString does not contain white spaces.\r\nString contains only digits 0-9, [, - ,, ].\r\n\r\n\r\n\r\nExample 1:\r\n\r\nGiven s = \"324\",\r\n\r\nYou should return a NestedInteger object which contains a single integer 324.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nGiven s = \"[123,[456,[789]]]\",\r\n\r\nReturn a NestedInteger object containing a nested list with 2 elements:\r\n\r\n1. An integer containing value 123.\r\n2. A nested list containing two elements:\r\n    i.  An integer containing value 456.\r\n    ii. A nested list with one element:\r\n         a. An integer containing value 789.\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/505",
      "similarQuestions": [
        "FlattenNestedListIterator",
        "TernaryExpressionParser",
        "RemoveComments"
      ],
      "topicTags": [
        "String",
        "Stack"
      ],
      "Solution": "/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * public interface NestedInteger {\n *     // Constructor initializes an empty nested list.\n *     public NestedInteger();\n *\n *     // Constructor initializes a single integer.\n *     public NestedInteger(int value);\n *\n *     // @return true if this NestedInteger holds a single integer, rather than a nested list.\n *     public boolean isInteger();\n *\n *     // @return the single integer that this NestedInteger holds, if it holds a single integer\n *     // Return null if this NestedInteger holds a nested list\n *     public Integer getInteger();\n *\n *     // Set this NestedInteger to hold a single integer.\n *     public void setInteger(int value);\n *\n *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.\n *     public void add(NestedInteger ni);\n *\n *     // @return the nested list that this NestedInteger holds, if it holds a nested list\n *     // Return null if this NestedInteger holds a single integer\n *     public List<NestedInteger> getList();\n * }\n */\nclass Solution {\n\n    public NestedInteger deserialize(String s) {\n        NestedInteger parent = new NestedInteger();\n        deserialize(s.toCharArray(), 0, parent);\n        return parent.getList().get(0);\n    }\n\n    private int deserialize(char[] cs, int i, NestedInteger parent) {\n        char c = cs[i++];\n        NestedInteger ni;\n        if (c == '[') {\n            ni = new NestedInteger();\n            if(cs[i] == ']') {\n                i++;\n            } else {\n                do {\n                    i = deserialize(cs, i, ni);\n                } while(cs[i++] != ']');\n            }\n        } else {\n            boolean isNeg = false;\n            if (c == '-') {\n                isNeg = true;\n                c = cs[i++];\n            }\n            int num = c - '0';\n            for (; i < cs.length && (c = cs[i]) >= '0' && c <= '9'; i++) {\n                num = num * 10 + c - '0';\n            }\n            ni = new NestedInteger(isNeg ? -num : num);\n        }\n        parent.add(ni);\n        return i;\n    }\n}",
      "total_acs": 20654,
      "total_submitted": 66820
    },
    {
      "id": 386,
      "title": "Lexicographical Numbers",
      "url": "https://leetcode.com/problems/lexicographical-numbers/description",
      "companyTags": [
        "Bloomberg"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven an integer n, return 1 - n in lexicographical order.\r\n\r\n\r\n\r\nFor example, given 13, return: [1,10,11,12,13,2,3,4,5,6,7,8,9].\r\n\r\n\r\n\r\nPlease optimize your algorithm to use less time and space. The input size may be as large as 5,000,000.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/508",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        ""
      ],
      "Solution": "class Solution {\n    public List<Integer> lexicalOrder(int n) {\n        Integer[] res = new Integer[n];\n        int cur = 1;\n        for(int i = 0; i < n; i++) {\n            res[i] = cur;\n            if(cur * 10 <= n) {\n                cur *= 10;\n            } else {\n                if(cur >= n) cur /= 10;\n                cur++;\n                while(cur%10 == 0) {\n                    cur /= 10;\n                }\n            }\n        }\n        return Arrays.asList(res);\n    }\n}",
      "total_acs": 26579,
      "total_submitted": 63111
    },
    {
      "id": 387,
      "title": "First Unique Character in a String",
      "url": "https://leetcode.com/problems/first-unique-character-in-a-string/description",
      "companyTags": [
        "Google",
        "Microsoft",
        "Amazon",
        "Bloomberg"
      ],
      "difficulty": "Easy",
      "content": "\r\nGiven a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.\r\n\r\nExamples:\r\n\r\ns = \"leetcode\"\r\nreturn 0.\r\n\r\ns = \"loveleetcode\",\r\nreturn 2.\r\n\r\n\r\n\r\n\r\nNote: You may assume the string contain only lowercase letters.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/509",
      "similarQuestions": [
        "SortCharactersByFrequency"
      ],
      "topicTags": [
        "HashTable",
        "String"
      ],
      "Solution": "class Solution {\n    public int firstUniqChar(String s) {\n        int out=s.length();\n        for(char c='a';c<='z';c++){\n            int st=s.indexOf(c);\n            if(st==-1) continue;\n            if(st==s.lastIndexOf(c)){\n                out=Math.min(out, st);\n            }\n        }\n        \n        return out==s.length()?-1:out;\n        \n    }\n}",
      "total_acs": 102499,
      "total_submitted": 216914
    },
    {
      "id": 388,
      "title": "Longest Absolute File Path",
      "url": "https://leetcode.com/problems/longest-absolute-file-path/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Medium",
      "content": "Suppose we abstract our file system by a string in the following manner:\r\n\r\nThe string \"dir\\n\\tsubdir1\\n\\tsubdir2\\n\\t\\tfile.ext\" represents:\r\n\r\ndir\r\n    subdir1\r\n    subdir2\r\n        file.ext\r\n\r\n\r\nThe directory dir contains an empty sub-directory subdir1 and a sub-directory subdir2 containing a file file.ext.\r\n\r\nThe string \"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\" represents:\r\n\r\ndir\r\n    subdir1\r\n        file1.ext\r\n        subsubdir1\r\n    subdir2\r\n        subsubdir2\r\n            file2.ext\r\n\r\n\r\nThe directory dir contains two sub-directories subdir1 and subdir2. subdir1 contains a file file1.ext and an empty second-level sub-directory subsubdir1. subdir2 contains a second-level sub-directory subsubdir2 containing a file file2.ext.\r\n\r\nWe are interested in finding the longest (number of characters) absolute path to a file within our file system. For example, in the second example above, the longest absolute path is \"dir/subdir2/subsubdir2/file2.ext\", and its length is 32 (not including the double quotes).\r\n\r\nGiven a string representing the file system in the above format, return the length of the longest absolute path to file in the abstracted file system. If there is no file in the system, return 0.\r\n\r\nNote:\r\n\r\nThe name of a file contains at least a . and an extension.\r\nThe name of a directory or sub-directory will not contain a ..\r\n\r\n\r\n\r\nTime complexity required: O(n) where n is the size of the input string.\r\n\r\nNotice that a/aa/aaa/file1.txt is not the longest file path, if there is another path aaaaaaaaaaaaaaaaaaaaa/sth.png.",
      "discussUrl": "https://discuss.leetcode.com/category/510",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        ""
      ],
      "Solution": "public class Solution {\n    public int lengthLongestPath(String input) {\n        String[] inputs = input.split(\"\\n\");\n        int[] prevLength = new int[inputs.length];\n        int max = 0;\n        for (int i = 0; i < inputs.length; i++){\n            int lstIdx = inputs[i].lastIndexOf('\\t');\n            int len = inputs[i].length() - lstIdx -1;\n            int totallen; \n            if (lstIdx == -1){\n               totallen = len; \n            }else{\n                totallen = len + prevLength[lstIdx] +1;\n            } \n            if (totallen > max && inputs[i].indexOf('.') != -1){\n                max = totallen;\n            }\n            prevLength[lstIdx+1] = totallen;\n        }\n        return max;\n    }\n}",
      "total_acs": 42525,
      "total_submitted": 114308
    },
    {
      "id": 389,
      "title": "Find the Difference",
      "url": "https://leetcode.com/problems/find-the-difference/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Easy",
      "content": "\r\nGiven two strings s and t which consist of only lowercase letters.\r\n\r\nString t is generated by random shuffling string s and then add one more letter at a random position.\r\n\r\nFind the letter that was added in t.\r\n\r\nExample:\r\n\r\nInput:\r\ns = \"abcd\"\r\nt = \"abcde\"\r\n\r\nOutput:\r\ne\r\n\r\nExplanation:\r\n'e' is the letter that was added.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/511",
      "similarQuestions": [
        "SingleNumber"
      ],
      "topicTags": [
        "HashTable",
        "BitManipulation"
      ],
      "Solution": "class Solution {\n    public char findTheDifference(String s, String t) {\n        char[] a = s.toCharArray();\n        char[] b = t.toCharArray();\n        char result = 0;\n        int len = a.length;\n        for(int i = 0;i<len;i++)\n        {\n            result = (char)(result^a[i]^b[i]);\n        }\n        return (char)(result^b[len]);\n    }\n}",
      "total_acs": 95659,
      "total_submitted": 186929
    },
    {
      "id": 390,
      "title": "Elimination Game",
      "url": "https://leetcode.com/problems/elimination-game/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "\r\nThere is a list of sorted integers from 1 to n. Starting from left to right, remove the first number and every other number afterward until you reach the end of the list.\r\n\r\nRepeat the previous step again, but this time from right to left, remove the right most number and every other number from the remaining numbers.\r\n\r\nWe keep repeating the steps again, alternating left to right and right to left, until a single number remains.\r\n\r\nFind the last number that remains starting with a list of length n.\r\n\r\nExample:\r\n\r\nInput:\r\nn = 9,\r\n1 2 3 4 5 6 7 8 9\r\n2 4 6 8\r\n2 6\r\n6\r\n\r\nOutput:\r\n6\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/512",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        ""
      ],
      "Solution": "class Solution {\n    public int lastRemaining(int n) {\n        return n == 1 ? 1 : 2*( 1 + n/2 - lastRemaining(n/2));\n    }\n}",
      "total_acs": 15415,
      "total_submitted": 36249
    },
    {
      "id": 391,
      "title": "Perfect Rectangle",
      "url": "https://leetcode.com/problems/perfect-rectangle/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Hard",
      "content": "\r\nGiven N axis-aligned rectangles where N > 0, determine if they all together form an exact cover of a rectangular region.\r\n\r\n\r\n\r\nEach rectangle is represented as a bottom-left point and a top-right point. For example, a unit square is represented as [1,1,2,2]. (coordinate of bottom-left point is (1, 1) and top-right point is (2, 2)).\r\n\r\n\r\n\r\nExample 1:\r\n\r\nrectangles = [\r\n  [1,1,3,3],\r\n  [3,1,4,2],\r\n  [3,2,4,4],\r\n  [1,3,2,4],\r\n  [2,3,3,4]\r\n]\r\n\r\nReturn true. All 5 rectangles together form an exact cover of a rectangular region.\r\n\r\n\r\n\r\n\r\n\r\n\r\nExample 2:\r\n\r\nrectangles = [\r\n  [1,1,2,3],\r\n  [1,3,2,4],\r\n  [3,1,4,2],\r\n  [3,2,4,4]\r\n]\r\n\r\nReturn false. Because there is a gap between the two rectangular regions.\r\n\r\n\r\n\r\n\r\n\r\n\r\nExample 3:\r\n\r\nrectangles = [\r\n  [1,1,3,3],\r\n  [3,1,4,2],\r\n  [1,3,2,4],\r\n  [3,2,4,4]\r\n]\r\n\r\nReturn false. Because there is a gap in the top center.\r\n\r\n\r\n\r\n\r\n\r\n\r\nExample 4:\r\n\r\nrectangles = [\r\n  [1,1,3,3],\r\n  [3,1,4,2],\r\n  [1,3,2,4],\r\n  [2,2,4,4]\r\n]\r\n\r\nReturn false. Because two of the rectangles overlap with each other.\r\n\r\n\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/513",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        ""
      ],
      "Solution": "class Solution {\n    static class Rectangle implements Comparable<Rectangle> {\n\n    int bottom;\n\n    int left;\n\n    int top;\n\n    int right;\n\n    @Override\n    public int compareTo(Rectangle other) {\n      final int first = Integer.compare(left, other.left);\n      return 0 == first ? Integer.compare(bottom, other.bottom) : first;\n    }\n  }\n\n  /**\n   * this solution is O(nlogn) based on the idea of merging. first, all the rectangles are sorted by left and bottom in\n   * ascending order. then the first rectangle is taken out and it forms a column. if the next rectangle has the same\n   * left, then it is in the same column as the first rectangle; if the next rectangle has a larger left, then it is in\n   * the next column. the first column establishes the top of the bounding rectangle. within a column, the first\n   * rectangle in this column determines the bottom left right. later rectangles are merged onto the first rectangle if\n   * the rectangles are in the same column. if the rectangle is wider or narrower, the corresponding rectangles are cut\n   * and put back for later use, maintaining the ascending order (thus a priority queue is used).\n   */\n  public boolean isRectangleCover(int[][] arrays) {\n    final List<Rectangle> list = new ArrayList<>(arrays.length);\n    for(int[] coordinates : arrays) {\n      Rectangle rectangle = new Rectangle();\n      rectangle.bottom = coordinates[0];\n      rectangle.left = coordinates[1];\n      rectangle.top = coordinates[2];\n      rectangle.right = coordinates[3];\n      list.add(rectangle);\n    }\n    final Queue<Rectangle> rectangles = new PriorityQueue<>(list);\n    Rectangle rectangle = rectangles.poll();\n    int bottom = rectangle.bottom;\n    int left = rectangle.left;\n    int top = rectangle.top;\n    int right = rectangle.right;\n    int maxTop = top;\n    boolean first = true; // first column or not.\n    while((rectangle = rectangles.poll()) != null) {\n      if(rectangle.left == left) { // same column.\n        if(rectangle.bottom != top) {\n          return false;\n        }\n        top = rectangle.top;\n        if(first) {\n          maxTop = top;\n        } else if(top > maxTop) {\n          return false;\n        }\n        if(rectangle.right > right) {\n          // cut the new rectangle and put back.\n          rectangle.left = right;\n          rectangles.add(rectangle);\n        } else if(rectangle.right < right) {\n          // cut the existing rectangle and put back.\n          int oldRight = right;\n          right = rectangle.right;\n          rectangle.top = rectangle.bottom;\n          rectangle.right = oldRight;\n          rectangle.bottom = bottom;\n          rectangle.left = right;\n          rectangles.add(rectangle);\n        }\n        \n      } else if(rectangle.left > left) { // next column\n        if(top != maxTop || rectangle.bottom != bottom || rectangle.left != right) {\n          return false;\n        }\n        left = right;\n        top = rectangle.top;\n        right = rectangle.right;\n        first = false;\n      }\n    }\n    return top == maxTop;\n  }\n}",
      "total_acs": 13146,
      "total_submitted": 48109
    },
    {
      "id": 392,
      "title": "Is Subsequence",
      "url": "https://leetcode.com/problems/is-subsequence/description",
      "companyTags": [
        "Pinterest"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven a string s and a string t, check if s is subsequence of t.\r\n\r\n\r\n\r\nYou may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (<=100).\r\n\r\n\r\n\r\nA subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, \"ace\" is a subsequence of \"abcde\" while \"aec\" is not).\r\n\r\n\r\nExample 1:\r\ns = \"abc\", t = \"ahbgdc\"\r\n\r\n\r\nReturn true.\r\n\r\n\r\nExample 2:\r\ns = \"axc\", t = \"ahbgdc\"\r\n\r\n\r\nReturn false.\r\n\r\n\r\nFollow up:\r\nIf there are lots of incoming S, say S1, S2, ... , Sk where k >= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code?\r\n\r\nCredits:Special thanks to @pbrother for adding this problem and creating all test cases.",
      "discussUrl": "https://discuss.leetcode.com/category/515",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "BinarySearch",
        "DynamicProgramming",
        "Greedy"
      ],
      "Solution": "class Solution {\n    public boolean isSubsequence(String s, String t) {\n        if (s == null || t == null) return false;\n        if (s.length() > t.length()) return false;\n\n        int startIdx = 0;\n        for (int i = 0; i < s.length(); i++) {\n            startIdx = t.indexOf(s.charAt(i), startIdx) + 1;\n            if (startIdx == 0) return false;\n        }\n        \n        return true;\n    }\n    public boolean isSubsequence1(String s, String t) {\n        if (s == null || t == null) return false;\n        if (s.length() > t.length()) return false;\n        if (s.equals(\"\")) return true;\n        HashMap<Character, TreeSet<Integer>> map = new HashMap<>();\n        for (int i = 0; i < t.length(); i++) {\n            char ch = t.charAt(i);\n            TreeSet<Integer> list = map.getOrDefault(ch, new TreeSet<Integer>());\n            list.add(i);\n            map.put(ch, list);\n        }\n        Integer pre = -1;\n        for (int i = 0; i < s.length(); i++) {\n            char ch = s.charAt(i);\n            if (!map.containsKey(ch)) return false;\n            Integer temp = pre;\n            pre = map.get(ch).ceiling(pre);\n            if (pre != null && pre.equals(temp)) {\n                pre = map.get(ch).ceiling(pre + 1);\n            }\n            \n            if (pre == null || pre.intValue() <= temp.intValue()) {\n                return false;\n            }\n        }\n        return pre != -1;\n    }\n}",
      "total_acs": 47117,
      "total_submitted": 105548
    },
    {
      "id": 393,
      "title": "UTF-8 Validation",
      "url": "https://leetcode.com/problems/utf-8-validation/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Medium",
      "content": "A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules:\r\n\r\nFor 1-byte character, the first bit is a 0, followed by its unicode code.\r\nFor n-bytes character, the first n-bits are all one's, the n+1 bit is 0, followed by n-1 bytes with most significant 2 bits being 10.\r\n\r\nThis is how the UTF-8 encoding would work:\r\n\r\n   Char. number range  |        UTF-8 octet sequence\r\n      (hexadecimal)    |              (binary)\r\n   --------------------+---------------------------------------------\r\n   0000 0000-0000 007F | 0xxxxxxx\r\n   0000 0080-0000 07FF | 110xxxxx 10xxxxxx\r\n   0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx\r\n   0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\r\n\r\n\r\nGiven an array of integers representing the data, return whether it is a valid utf-8 encoding.\r\n\r\n\r\nNote:\r\nThe input is an array of integers. Only the least significant 8 bits of each integer is used to store the data. This means each integer represents only 1 byte of data.\r\n\r\n\r\n\r\nExample 1:\r\n\r\ndata = [197, 130, 1], which represents the octet sequence: 11000101 10000010 00000001.\r\n\r\nReturn true.\r\nIt is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character.\r\n\r\n\r\n\r\n\r\nExample 2:\r\n\r\ndata = [235, 140, 4], which represented the octet sequence: 11101011 10001100 00000100.\r\n\r\nReturn false.\r\nThe first 3 bits are all one's and the 4th bit is 0 means it is a 3-bytes character.\r\nThe next byte is a continuation byte which starts with 10 and that's correct.\r\nBut the second continuation byte does not start with 10, so it is invalid.\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/516",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "BitManipulation"
      ],
      "Solution": "class Solution {\n    public boolean validUtf8(int[] data) {\n        if(data == null || data.length == 0) return true;\n        for(int i = 0; i < data.length; i++) {\n            if((data[i] & 0x80) == 0) continue;\n            else if((data[i] & 0xE0) == 0xC0 && i < data.length - 1) {\n                if((data[++i] & 0xC0) == 0x80) {\n                    continue;\n                } else {\n                    return false;\n                }\n            } else if((data[i] & 0xF0) == 0xE0 && i < data.length - 2) {\n                if((data[++i] & 0xC0) == 0x80 && (data[++i] & 0xC0) == 0x80) {\n                    continue;\n                } else {\n                    return false;\n                }\n            } else if((data[i] & 0xF8) == 0xF0 && i < data.length - 3) {\n                if((data[++i] & 0xC0) == 0x80 && (data[++i] & 0xC0) == 0x80 && (data[++i] & 0xC0) == 0x80) {\n                    continue;\n                } else {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
      "total_acs": 20358,
      "total_submitted": 58625
    },
    {
      "id": 394,
      "title": "Decode String",
      "url": "https://leetcode.com/problems/decode-string/description",
      "companyTags": [
        "Google",
        "Yelp",
        "Coupang"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven an encoded string, return it's decoded string.\r\n\r\n\r\nThe encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.\r\n\r\n\r\nYou may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.\r\n\r\nFurthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won't be input like 3a or 2[4].\r\n\r\n\r\nExamples:\r\n\r\ns = \"3[a]2[bc]\", return \"aaabcbc\".\r\ns = \"3[a2[c]]\", return \"accaccacc\".\r\ns = \"2[abc]3[cd]ef\", return \"abcabccdcdcdef\".\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/517",
      "similarQuestions": [
        "EncodeStringwithShortestLength",
        "NumberofAtoms"
      ],
      "topicTags": [
        "Stack",
        "Depth-firstSearch"
      ],
      "Solution": "class Solution {\n    public String decodeString(String s) {\n        return dfs(s, 0, s.length() - 1);\n    }\n    \n    private String dfs(String s, int start, int end){\n        StringBuilder sb = new StringBuilder();\n        int times = 0;\n        for (int i = start; i <= end; i++){\n            char c = s.charAt(i);\n            if (c >= '0' && c <= '9'){\n                times = times * 10 + c - '0';\n            } else if (c == '['){\n                int open = 1;\n                int substart = i + 1;\n                while (open != 0){\n                    i++;\n                    if (s.charAt(i) == '['){\n                        open++;\n                    } else if (s.charAt(i) == ']'){\n                        open--;\n                    }\n                }\n                int subend = i - 1;\n                String sub = dfs(s, substart, subend);\n                if (times == 0){\n                    times = 1;\n                }\n                for (int j = 0; j < times; j++){\n                    sb.append(sub);\n                }\n                times = 0;\n            } else {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n}",
      "total_acs": 47561,
      "total_submitted": 113229
    },
    {
      "id": 395,
      "title": "Longest Substring with At Least K Repeating Characters",
      "url": "https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/description",
      "companyTags": [
        "Baidu"
      ],
      "difficulty": "Medium",
      "content": "\r\nFind the length of the longest substring T of a given string (consists of lowercase letters only) such that every character in T appears no less than k times.\r\n\r\n\r\nExample 1:\r\n\r\nInput:\r\ns = \"aaabb\", k = 3\r\n\r\nOutput:\r\n3\r\n\r\nThe longest substring is \"aaa\", as 'a' is repeated 3 times.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput:\r\ns = \"ababbc\", k = 2\r\n\r\nOutput:\r\n5\r\n\r\nThe longest substring is \"ababb\", as 'a' is repeated 2 times and 'b' is repeated 3 times.\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/518",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        ""
      ],
      "Solution": "class Solution {\n    public int longestSubstring(String s, int k) {\n    int n = s.length();\n\tif(n < k) return 0;\n\tint counter[] = new int[26];\n\tboolean valid[] = new boolean[26];\n\tchar ss[] = s.toCharArray();\n\tfor(int i=0;i<n;i++) \n\t\tcounter[ss[i] - 'a']++;\n\tboolean fullValid = true;\n\tfor(int i=0;i<26;i++){\n\t\tif(counter[i]>0 && counter[i]<k){\n\t\t\tvalid[i] = false;\n\t\t\tfullValid = false;\n\t\t}\n\t\telse valid[i] = true;\n\t}\n\tif(fullValid) return s.length();\n\tint max = 0;\n\tint lastStart=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(valid[ss[i] - 'a'] == false){\n\t\t\tmax = Math.max(max,longestSubstring(s.substring(lastStart,i),k));\n\t\t\tlastStart = i + 1;\n\t\t}\n\t}\n\tmax = Math.max(max,longestSubstring(s.substring(lastStart,n),k));\n\treturn max;\n    }\n}",
      "total_acs": 22839,
      "total_submitted": 63467
    },
    {
      "id": 396,
      "title": "Rotate Function",
      "url": "https://leetcode.com/problems/rotate-function/description",
      "companyTags": [
        "Amazon"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven an array of integers A and let n to be its length.\r\n\r\n\r\n\r\nAssume Bk to be an array obtained by rotating the array A k positions clock-wise, we define a \"rotation function\" F on A as follow:\r\n\r\n\r\n\r\nF(k) = 0 * Bk[0] + 1 * Bk[1] + ... + (n-1) * Bk[n-1].\r\n\r\nCalculate the maximum value of F(0), F(1), ..., F(n-1). \r\n\r\n\r\nNote:\r\nn is guaranteed to be less than 105.\r\n\r\n\r\nExample:\r\n\r\nA = [4, 3, 2, 6]\r\n\r\nF(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25\r\nF(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16\r\nF(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23\r\nF(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26\r\n\r\nSo the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26.\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/520",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Math"
      ],
      "Solution": "public class Solution {\n    public int maxRotateFunction(int[] A) {\n        if (A == null || A.length == 0) {\n            return 0;\n        }\n        int n = A.length;\n        int sum = 0;\n        for (int i = 0; i < n; ++i) {\n            sum += A[i];\n        }\n        \n        int f = 0;\n        for (int i = 0; i < n; ++i) {\n            f += i * A[i];\n        }\n        \n        int maxf = f;\n        for (int k = 1; k < n; ++k) {\n            f += (sum - n * A[n - k]);\n            maxf = f > maxf ? f : maxf;\n        }\n        return maxf;\n    }\n}",
      "total_acs": 25633,
      "total_submitted": 76140
    },
    {
      "id": 397,
      "title": "Integer Replacement",
      "url": "https://leetcode.com/problems/integer-replacement/description",
      "companyTags": [
        "Google",
        "Baidu"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven a positive integer n and you can do operations as follow:\r\n\r\n\r\n\r\n\r\nIf n is even, replace n with n/2.\r\nIf n is odd, you can replace n with either n + 1 or n - 1.\r\n\r\n\r\n\r\n\r\nWhat is the minimum number of replacements needed for n to become 1?\r\n\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput:\r\n8\r\n\r\nOutput:\r\n3\r\n\r\nExplanation:\r\n8 -> 4 -> 2 -> 1\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput:\r\n7\r\n\r\nOutput:\r\n4\r\n\r\nExplanation:\r\n7 -> 8 -> 4 -> 2 -> 1\r\nor\r\n7 -> 6 -> 3 -> 2 -> 1\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/521",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Math",
        "BitManipulation"
      ],
      "Solution": "class Solution {\n    public int integerReplacement(int n) {\n        int count=0;\n        if(n<=1)\n            return count;\n        \n        while(n!=1){\n            if(n%2==0){\n                n>>>=1;\n            }else{\n                if(n==3||Integer.bitCount(n+1)>Integer.bitCount(n-1)){\n                    n-=1;\n                }else{\n                    n+=1;\n                }\n            }\n            count++;\n        }\n        \n        return count;\n        \n    }\n}",
      "total_acs": 27089,
      "total_submitted": 89054
    },
    {
      "id": 398,
      "title": "Random Pick Index",
      "url": "https://leetcode.com/problems/random-pick-index/description",
      "companyTags": [
        "Facebook"
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven an array of integers with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array.\r\n\r\n\r\n\r\nNote:\r\nThe array size can be very large. Solution that uses too much extra space will not pass the judge.\r\n\r\n\r\nExample:\r\n\r\nint[] nums = new int[] {1,2,3,3,3};\r\nSolution solution = new Solution(nums);\r\n\r\n// pick(3) should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.\r\nsolution.pick(3);\r\n\r\n// pick(1) should return 0. Since in the array only nums[0] is equal to 1.\r\nsolution.pick(1);\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/522",
      "similarQuestions": [
        "LinkedListRandomNode"
      ],
      "topicTags": [
        "ReservoirSampling"
      ],
      "Solution": null,
      "total_acs": 31745,
      "total_submitted": 71537
    },
    {
      "id": 399,
      "title": "Evaluate Division",
      "url": "https://leetcode.com/problems/evaluate-division/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Medium",
      "content": "\r\nEquations are given in the format A / B = k, where  A and B are variables represented as strings, and k is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return -1.0.\r\n\r\nExample:\r\nGiven  a / b = 2.0, b / c = 3.0. queries are:  a / c = ?,  b / a = ?, a / e = ?,  a / a = ?, x / x = ? . return  [6.0, 0.5, -1.0, 1.0, -1.0 ].\r\n\r\n\r\nThe input is:  vector<pair<string, string>> equations, vector<double>& values, vector<pair<string, string>> queries , where equations.size() == values.size(), and the values are positive. This represents the equations. Return  vector<double>.\r\n\r\n\r\nAccording to the example above:\r\nequations = [ [\"a\", \"b\"], [\"b\", \"c\"] ],\r\nvalues = [2.0, 3.0],\r\nqueries = [ [\"a\", \"c\"], [\"b\", \"a\"], [\"a\", \"e\"], [\"a\", \"a\"], [\"x\", \"x\"] ]. \r\n\r\n\r\n\r\nThe input is always valid. You may assume that evaluating the queries will result in no division by zero and there is no contradiction.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/523",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Graph"
      ],
      "Solution": "class Solution {\n    public double[] calcEquation(String[][] equations, double[] values, String[][] queries) {\n        if(equations==null || equations.length==0) return new double [] {};\n        \n        Map<String, String>root=new HashMap<>();\n        Map<String, Double>map=new HashMap<>();\n        \n        for (int i=0;i<equations.length;i++){\n            String x1=equations[i][0], x2=equations[i][1];\n            root.putIfAbsent(x1, x1);\n            root.putIfAbsent(x2, x2);\n            map.putIfAbsent(x1, 1.0);\n            map.putIfAbsent(x2, 1.0);\n            \n            String r1=find(root, x1);\n            String r2=find(root, x2);\n            root.put(r2, r1);\n            map.put(r2, map.get(x1)*values[i]/map.get(x2));\n        }\n\n        double[] res=new double[queries.length];\n        for (int i=0;i<queries.length;i++){\n            res[i]=-1.0;\n            String x1=queries[i][0], x2=queries[i][1];\n            if (!root.containsKey(x1) || !root.containsKey(x2)) continue;\n            String r1=find(root, x1);\n            String r2=find(root, x2);\n            if (r1.equals(r2))\n                res[i]=get(root, map, x2) / get(root, map, x1);\n        }\n        return res;\n    }\n    \n    private String find(Map<String, String>root, String var){\n        if (root.get(var).equals(var)) return var;\n        return find(root, root.get(var));\n    }\n    \n    private double get(Map<String, String>root, Map<String, Double>map, String var){\n        String r=root.get(var);\n        double result=map.get(var);\n        \n        if (r.equals(var)) return result;\n        return result*get(root, map, r);\n    }\n\n}",
      "total_acs": 25542,
      "total_submitted": 60624
    },
    {
      "id": 400,
      "title": "Nth Digit",
      "url": "https://leetcode.com/problems/nth-digit/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Easy",
      "content": "Find the nth digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... \r\n\r\nNote:\r\nn is positive and will fit within the range of a 32-bit signed integer (n < 231).\r\n\r\n\r\nExample 1:\r\n\r\nInput:\r\n3\r\n\r\nOutput:\r\n3\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput:\r\n11\r\n\r\nOutput:\r\n0\r\n\r\nExplanation:\r\nThe 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10.\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/525",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Math"
      ],
      "Solution": "class Solution {\n    public int findNthDigit(int n) {\n        if (n < 10) return n;\n        \n        int len = 1;\n        long number = 9;\n        int start = 1;\n        \n        while (n > len*number){\n            n -= len*number;\n            len++;\n            number *= 10;\n            start *= 10;\n        }\n        \n        int resNumb = start + (n-1)/len;\n        int index = (n-1)%len;\n        return Integer.toString(resNumb).charAt(index)-'0';\n    }\n}",
      "total_acs": 31874,
      "total_submitted": 105584
    },
    {
      "id": 401,
      "title": "Binary Watch",
      "url": "https://leetcode.com/problems/binary-watch/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Easy",
      "content": "A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59).\r\nEach LED represents a zero or one, with the least significant bit on the right.\r\n\r\nFor example, the above binary watch reads \"3:25\".\r\n\r\nGiven a non-negative integer n which represents the number of LEDs that are currently on, return all possible times the watch could represent.\r\n\r\nExample:\r\nInput: n = 1Return: [\"1:00\", \"2:00\", \"4:00\", \"8:00\", \"0:01\", \"0:02\", \"0:04\", \"0:08\", \"0:16\", \"0:32\"]\r\n\r\n\r\nNote:\r\n\r\nThe order of output does not matter.\r\nThe hour must not contain a leading zero, for example \"01:00\" is not valid, it should be \"1:00\".\r\nThe minute must be consist of two digits and may contain a leading zero, for example \"10:2\" is not valid, it should be \"10:02\".\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/526",
      "similarQuestions": [
        "LetterCombinationsofaPhoneNumber",
        "Numberof1Bits"
      ],
      "topicTags": [
        "Backtracking",
        "BitManipulation"
      ],
      "Solution": "class Solution {\n    public List<String> readBinaryWatch(int num) {\n        List<String> res = new ArrayList<>();\n        for (int h = 0; h < 12; h ++) {\n            for (int m = 0; m < 60; m ++) {\n                if (Integer.bitCount(h) + Integer.bitCount(m) == num) {\n                    if (m < 10) {\n                        res.add(h + \":\" + \"0\" + m);\n                    } else {\n                        res.add(h + \":\" + m);\n                    }\n                }\n            }\n        }\n        return res;\n    }\n}",
      "total_acs": 43470,
      "total_submitted": 96967
    },
    {
      "id": 402,
      "title": "Remove K Digits",
      "url": "https://leetcode.com/problems/remove-k-digits/description",
      "companyTags": [
        "Google",
        "Snapchat"
      ],
      "difficulty": "Medium",
      "content": "Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible.\r\n\r\n\r\nNote:\r\n\r\nThe length of num is less than 10002 and will be ≥ k.\r\nThe given num does not contain any leading zero.\r\n\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput: num = \"1432219\", k = 3\r\nOutput: \"1219\"\r\nExplanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: num = \"10200\", k = 1\r\nOutput: \"200\"\r\nExplanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput: num = \"10\", k = 2\r\nOutput: \"0\"\r\nExplanation: Remove all the digits from the number and it is left with nothing which is 0.\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/527",
      "similarQuestions": [
        "CreateMaximumNumber",
        "MonotoneIncreasingDigits"
      ],
      "topicTags": [
        "Stack",
        "Greedy"
      ],
      "Solution": "class Solution {\n    public String removeKdigits(String num, int k) {\n        int length = num.length() - k;\n        if(length <= 0) return \"0\";\n        char[] res = new char[num.length()];\n        int last = 0;\n        // k keeps track of how many characters we can remove\n        // if the previous character in res is larger than the current one\n        // then removing it will get a smaller number\n        // but we can only do so when k is larger than 0\n        for(char ch: num.toCharArray()) {\n            while(k>0 && last>0 && res[last-1]>ch) {\n                --last;\n                --k;\n            }\n            res[last++] = ch;\n        }\n        int firstNonZero = 0;\n        // find the index of first non-zero digit\n        while(firstNonZero<length && res[firstNonZero]=='0') ++firstNonZero;\n        return firstNonZero==length? \"0\" : new String(res, firstNonZero, length - firstNonZero);\n    }\n}",
      "total_acs": 28246,
      "total_submitted": 108384
    },
    {
      "id": 403,
      "title": "Frog Jump",
      "url": "https://leetcode.com/problems/frog-jump/description",
      "companyTags": [
        "Snapchat"
      ],
      "difficulty": "Hard",
      "content": "A frog is crossing a river. The river is divided into x units and at each unit there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.\r\n\r\nGiven a list of stones' positions (in units) in sorted ascending order, determine if the frog is able to cross the river by landing on the last stone. Initially, the frog is on the first stone and assume the first jump must be 1 unit.\r\n\r\n\r\nIf the frog's last jump was k units, then its next jump must be either k - 1, k, or k + 1 units. Note that the frog can only jump in the forward direction.\r\n\r\nNote:\r\n\r\nThe number of stones is ≥ 2 and is < 1,100.\r\nEach stone's position will be a non-negative integer < 231.\r\nThe first stone's position is always 0.\r\n\r\n\r\n\r\nExample 1:\r\n\r\n[0,1,3,5,6,8,12,17]\r\n\r\nThere are a total of 8 stones.\r\nThe first stone at the 0th unit, second stone at the 1st unit,\r\nthird stone at the 3rd unit, and so on...\r\nThe last stone at the 17th unit.\r\n\r\nReturn true. The frog can jump to the last stone by jumping \r\n1 unit to the 2nd stone, then 2 units to the 3rd stone, then \r\n2 units to the 4th stone, then 3 units to the 6th stone, \r\n4 units to the 7th stone, and 5 units to the 8th stone.\r\n\r\n\r\n\r\nExample 2:\r\n\r\n[0,1,2,3,4,8,9,11]\r\n\r\nReturn false. There is no way to jump to the last stone as \r\nthe gap between the 5th and 6th stone is too large.\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/528",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "DynamicProgramming"
      ],
      "Solution": "class Solution {\n    public boolean canCross(int[] stones) {\n        if(stones.length < 2)\n            return true;\n        \n        if(stones[1] != 1) {\n            return false;\n        }\n        \n        for(int i = 0; i < stones.length - 1; i++)\n            if(2 * stones[i] < stones[i+1] - 1)\n                return false;\n        \n        return canCross(stones, 1, 1);\n    }\n    \n    private boolean canCross(int[] s, int k, int i) {\n        // System.out.println(k + \" : \" + i);\n        if(k <= 0 || s[i] + k - 1 > s[s.length - 1])\n            return false;\n        \n        if(Math.abs(s[s.length - 1] - (s[i] + k)) <= 1)\n            return true;\n        \n        int temp = Arrays.binarySearch(s, s[i] + k + 1);\n        \n        if(temp >= 0 && canCross(s, k+1, temp)) {\n            return true;\n        }\n        \n        temp = Arrays.binarySearch(s, s[i] + k);\n\n        if(temp >= 0 && canCross(s, k, temp)) {\n            return true;\n        }\n\n        temp = Arrays.binarySearch(s, s[i] + k - 1);\n\n        if(temp >= 0 && canCross(s, k-1, temp)) {\n            return true;\n        }\n\n        return false;\n    }\n}",
      "total_acs": 23128,
      "total_submitted": 71069
    },
    {
      "id": 404,
      "title": "Sum of Left Leaves",
      "url": "https://leetcode.com/problems/sum-of-left-leaves/description",
      "companyTags": [
        "Facebook"
      ],
      "difficulty": "Easy",
      "content": "Find the sum of all left leaves in a given binary tree.\r\n\r\nExample:\r\n\r\n    3\r\n   / \\\r\n  9  20\r\n    /  \\\r\n   15   7\r\n\r\nThere are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/530",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Tree"
      ],
      "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public int sumOfLeftLeaves(TreeNode root) {\n        return sumOfLeftLeavesHelper(root, false);\n    }\n    \n    private int sumOfLeftLeavesHelper(TreeNode root, boolean cameFromLeft) {\n        if (root == null) return 0;\n        \n        if (root.left == null && root.right == null) return cameFromLeft ? root.val : 0;\n        \n        return 0 + sumOfLeftLeavesHelper(root.left, true) + sumOfLeftLeavesHelper(root.right, false);\n    }\n}",
      "total_acs": 78740,
      "total_submitted": 165984
    },
    {
      "id": 405,
      "title": "Convert a Number to Hexadecimal",
      "url": "https://leetcode.com/problems/convert-a-number-to-hexadecimal/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Easy",
      "content": "\r\nGiven an integer, write an algorithm to convert it to hexadecimal. For negative integer, two’s complement method is used.\r\n\r\n\r\nNote:\r\n\r\nAll letters in hexadecimal (a-f) must be in lowercase.\r\nThe hexadecimal string must not contain extra leading 0s. If the number is zero, it is represented by a single zero character '0'; otherwise, the first character in the hexadecimal string will not be the zero character.\r\nThe given number is guaranteed to fit within the range of a 32-bit signed integer.\r\nYou must not use any method provided by the library which converts/formats the number to hex directly.\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput:\r\n26\r\n\r\nOutput:\r\n\"1a\"\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput:\r\n-1\r\n\r\nOutput:\r\n\"ffffffff\"\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/531",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "BitManipulation"
      ],
      "Solution": "class Solution {\n    public String toHex(int num) {\n        if (num == 0) return \"0\";\n        char[] map = new char[]{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\n        StringBuilder sb = new StringBuilder();\n        while (num != 0) {\n            sb.insert(0, map[num & 0b1111]);\n            num = num >>> 4;\n        }\n        return sb.toString();\n    }\n}",
      "total_acs": 31903,
      "total_submitted": 77704
    },
    {
      "id": 406,
      "title": "Queue Reconstruction by Height",
      "url": "https://leetcode.com/problems/queue-reconstruction-by-height/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Medium",
      "content": "Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue.\r\n\r\n\r\nNote:\r\nThe number of people is less than 1,100.\r\n\r\n\r\n\r\n\r\nExample\r\n\r\nInput:\r\n[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]\r\n\r\nOutput:\r\n[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/532",
      "similarQuestions": [
        "CountofSmallerNumbersAfterSelf"
      ],
      "topicTags": [
        "Greedy"
      ],
      "Solution": "\n\nclass Solution {\n    \n    public int[][] reconstructQueue(int[][] people) {\n        int length = people.length;\n        int[] nums = new int[length];\n        for(int i = 0; i < length; i++) {\n            nums[i] = people[i][1];\n        }\n        int[][] peopleCp = Arrays.copyOf(people, length);\n        quickSort(peopleCp, 0, length);\n        mergeSort(peopleCp, Arrays.copyOf(peopleCp, length), 0, length);\n        for(int i = 0; i < length; i++) {\n            people[i][1] = nums[i];\n        }\n        return peopleCp;\n    }\n        \n    private void mergeSort(int[][] people, int[][] tmp, int start, int end) {\n        if(start + 1 >= end) {\n            return;\n        }\n        int mid = (start + end) >> 1;\n        mergeSort(tmp, people, start, mid);\n        mergeSort(tmp, people, mid, end);\n        int i = start, j = mid, k = start, rightCnt = 0;\n        int[] pi = tmp[i], pj = tmp[j];\n        for(;;) {\n            if(pi[1] - rightCnt <= pj[1]) {\n                people[k++] = pi;\n                pi[1] -= rightCnt;\n                if(++i == mid) {\n                    System.arraycopy(tmp, j, people, k, end - j);\n                    break;\n                }\n                pi = tmp[i];\n            } else {\n                people[k++] = pj;\n                rightCnt++;\n                if(++j == end) {\n                    System.arraycopy(tmp, i, people, k, mid - i);\n                    for(; i < mid; i++) {\n                        tmp[i][1] -= rightCnt;\n                    }\n                    break;\n                }\n                pj = tmp[j];\n            }\n        }\n    }\n    \n    private static final int InsertitionSortThreshold = 7;\n    \n    private void quickSort(int[][] people, int start, int end) {\n        if(end - start <= InsertitionSortThreshold) {\n            for(int i = start + 1; i < end; i++) {\n                int[] person = people[i];\n                int j = i;\n                for(; j > start && compare(person, people[j - 1]) < 0;) {\n                    people[j] = people[--j];\n                }\n                people[j] = person;\n            }\n            return;\n        }\n        int i = random(start, end);\n        int[] person = people[i];\n        people[i] = people[start];\n        int s = start, e = end;\n        Loop:\n        for(int[] ps, pe;;) {\n            for(;;) {\n                if(--e <= s) {\n                    break Loop;\n                }\n                if(compare(pe = people[e], person) < 0) {\n                    break;\n                }\n            }\n            people[s] = pe;\n            for(;;) {\n                if(++s >= e) {\n                    break Loop;\n                }\n                if(compare(ps = people[s], person) > 0) {\n                    break;\n                }\n            }\n            people[e] = ps;\n        }\n        people[s] = person;\n        quickSort(people, start, s);\n        quickSort(people, s + 1, end);\n    }\n    \n    private int compare(int[] p1, int[] p2) {\n        int h = p1[0] - p2[0];\n        return h != 0 ? h : p2[1] - p1[1];\n    }\n    \n    private int random(int start, int end) {\n        return (int)(System.nanoTime() % (end - start) + start);\n    }\n}",
      "total_acs": 39116,
      "total_submitted": 69049
    },
    {
      "id": 407,
      "title": "Trapping Rain Water II",
      "url": "https://leetcode.com/problems/trapping-rain-water-ii/description",
      "companyTags": [
        "Google",
        "Twitter"
      ],
      "difficulty": "Hard",
      "content": "Given an m x n matrix of positive integers representing the height of each unit cell in a 2D elevation map, compute the volume of water it is able to trap after raining.\r\n\r\n\r\nNote:\r\nBoth m and n are less than 110. The height of each unit cell is greater than 0 and is less than 20,000.\r\n\r\n\r\nExample:\r\n\r\nGiven the following 3x6 height map:\r\n[\r\n  [1,4,3,1,3,2],\r\n  [3,2,1,3,2,4],\r\n  [2,3,3,2,3,1]\r\n]\r\n\r\nReturn 4.\r\n\r\n\r\n\r\n\r\n\r\nThe above image represents the elevation map [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]] before the rain.\r\n\r\n\r\n\r\n\r\nAfter the rain, water is trapped between the blocks. The total volume of water trapped is 4.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/533",
      "similarQuestions": [
        "TrappingRainWater"
      ],
      "topicTags": [
        "Heap",
        "Breadth-firstSearch"
      ],
      "Solution": "public class Solution {\n    private static class Cell implements Comparable<Cell> {\n        private int row;\n        private int col;\n        private int value;\n        public Cell(int r, int c, int v) {\n            this.row = r;\n            this.col = c;\n            this.value = v;\n        }\n        @Override\n        public int compareTo(Cell other) {\n            return value - other.value;\n        }\n    }\n    private int water;\n    private boolean[][] visited1;\n    public int trapRainWater(int[][] heightMap) {\n        if (heightMap.length == 0) return 0;\n        PriorityQueue<Cell> walls = new PriorityQueue<Cell>();\n        water = 0;\n        visited1 = new boolean[heightMap.length][heightMap[0].length];\n        int rows = heightMap.length, cols = heightMap[0].length;\n        //build wall;\n        for (int c = 0; c < cols; c++) {\n        \twalls.add(new Cell(0, c, heightMap[0][c]));\n        \twalls.add(new Cell(rows - 1, c, heightMap[rows - 1][c]));\n        \tvisited1[0][c] = true;\n        \tvisited1[rows - 1][c] = true;\n        }\n        for (int r = 1; r < rows - 1; r++) {\n        \twalls.add(new Cell(r, 0, heightMap[r][0]));\n        \twalls.add(new Cell(r, cols - 1, heightMap[r][cols - 1]));\n        \tvisited1[r][0] = true;\n        \tvisited1[r][cols - 1] = true;\n        }\n        //end build wall;\n        while(walls.size() > 0) {\n            Cell min = walls.poll();\n            visit(heightMap, min, walls);\n        }\n        return water;\n    }\n    private void visit(int[][] height, Cell start, PriorityQueue<Cell> walls) {\n        fill(height, start.row + 1, start.col, walls, start.value);\n        fill(height, start.row - 1, start.col, walls, start.value);\n        fill(height, start.row, start.col + 1, walls, start.value);\n        fill(height, start.row, start.col - 1, walls, start.value);\n    }\n    private void fill(int[][] height, int row, int col, PriorityQueue<Cell> walls, int min) {\n        if (row < 0 || col < 0) return;\n        else if (row >= height.length || col >= height[0].length) return;\n        else if (visited1[row][col]) return;\n        else if (height[row][col] >= min) {\n            walls.add(new Cell(row, col, height[row][col]));\n            visited1[row][col] = true;\n            return;\n        } else {\n//        \tSystem.out.println(row + \", \" + col + \" height = \" + height[row][col] + \", bar = \" + min);\n            water += min - height[row][col];\n            visited1[row][col] = true;\n            fill(height, row + 1, col, walls, min);\n            fill(height, row - 1, col, walls, min);\n            fill(height, row, col + 1, walls, min);\n            fill(height, row, col - 1, walls, min);\n        }\n    }\n}",
      "total_acs": 15216,
      "total_submitted": 40171
    },
    {
      "id": 408,
      "title": "Valid Word Abbreviation",
      "url": "https://leetcode.com/problems/valid-word-abbreviation/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Easy",
      "content": "\r\nGiven a non-empty string s and an abbreviation abbr, return whether the string matches with the given abbreviation.\r\n\r\n\r\nA string such as \"word\" contains only the following valid abbreviations:\r\n\r\n[\"word\", \"1ord\", \"w1rd\", \"wo1d\", \"wor1\", \"2rd\", \"w2d\", \"wo2\", \"1o1d\", \"1or1\", \"w1r1\", \"1o2\", \"2r1\", \"3d\", \"w3\", \"4\"]\r\n\r\n\r\nNotice that only the above abbreviations are valid abbreviations of the string \"word\". Any other string is not a valid abbreviation of \"word\".\r\n\r\nNote:\r\nAssume s contains only lowercase letters and abbr contains only lowercase letters and digits.\r\n\r\n\r\nExample 1:\r\n\r\nGiven s = \"internationalization\", abbr = \"i12iz4n\":\r\n\r\nReturn true.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nGiven s = \"apple\", abbr = \"a2e\":\r\n\r\nReturn false.\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/535",
      "similarQuestions": [
        "MinimumUniqueWordAbbreviation",
        "WordAbbreviation"
      ],
      "topicTags": [
        "String"
      ],
      "Solution": "class Solution {\n    public boolean validWordAbbreviation(String word, String abbr) {\n        int i = 0, j = 0;\n        while (i < word.length() && j < abbr.length()) {\n            if (word.charAt(i) == abbr.charAt(j)) {\n                i++;\n                j++;\n                continue;\n            }\n            if (abbr.charAt(j) <= '0' || abbr.charAt(j) > '9') {\n                return false;\n            }\n            int num = 0;\n            while (j < abbr.length() && abbr.charAt(j) >= '0' && abbr.charAt(j) <= '9') {\n                num = (num + (abbr.charAt(j++) - '0')) * 10;\n            }\n            num /= 10;\n            i += num;\n        }\n        return i == word.length() && j == abbr.length();\n    }\n}",
      "total_acs": 14561,
      "total_submitted": 51385
    },
    {
      "id": 409,
      "title": "Longest Palindrome",
      "url": "https://leetcode.com/problems/longest-palindrome/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Easy",
      "content": "Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.\r\n\r\nThis is case sensitive, for example \"Aa\" is not considered a palindrome here.\r\n\r\nNote:\r\nAssume the length of given string will not exceed 1,010.\r\n\r\n\r\nExample: \r\n\r\nInput:\r\n\"abccccdd\"\r\n\r\nOutput:\r\n7\r\n\r\nExplanation:\r\nOne longest palindrome that can be built is \"dccaccd\", whose length is 7.\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/536",
      "similarQuestions": [
        "PalindromePermutation"
      ],
      "topicTags": [
        "HashTable"
      ],
      "Solution": "class Solution {\n    public int longestPalindrome(String s) {\n        int[] map = new int[128];\n        int res = 0;\n        for(char c : s.toCharArray()){\n            if((int) map[c]++ % 2 == 1)\n                res += 2;\n        }\n        return s.length() > res?1 + res : res;\n    }\n}",
      "total_acs": 58565,
      "total_submitted": 127891
    },
    {
      "id": 410,
      "title": "Split Array Largest Sum",
      "url": "https://leetcode.com/problems/split-array-largest-sum/description",
      "companyTags": [
        "Facebook",
        "Baidu"
      ],
      "difficulty": "Hard",
      "content": "Given an array which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays.\r\n\r\n\r\nNote:\r\nIf n is the length of array, assume the following constraints are satisfied:\r\n\r\n1 ≤ n ≤ 1000\r\n1 ≤ m ≤ min(50, n)\r\n\r\n\r\n\r\nExamples: \r\n\r\nInput:\r\nnums = [7,2,5,10,8]\r\nm = 2\r\n\r\nOutput:\r\n18\r\n\r\nExplanation:\r\nThere are four ways to split nums into two subarrays.\r\nThe best way is to split it into [7,2,5] and [10,8],\r\nwhere the largest sum among the two subarrays is only 18.\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/537",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "BinarySearch",
        "DynamicProgramming"
      ],
      "Solution": "public class Solution {\n    private boolean tolarge(int target, int[] num, int m) {\n        int curr = 0;\n        int count = 0;\n        for(int i = 0; i < num.length; i++) {\n            curr += num[i];\n            if(curr > target) {\n                count++;\n                curr = num[i];\n                // i--;\n                if(count >= m) return false;\n            }\n        }\n        return true;\n    }\n    public int splitArray(int[] nums, int m) {\n        \n        int max = 0;\n        int sum = 0;\n        for(int i : nums) {\n            max = Math.max(max, i);\n            sum += i;\n        }\n        int l = max;\n        int r = sum;\n        while(l <= r) {\n            int mid = l + (r-l)/2;\n            if(tolarge(mid, nums, m)) {\n                r = mid - 1;\n            }else l = mid + 1;\n        }\n        return l;\n//         int[] sum = new int[nums.length + 1];\n//         for(int i = 0; i < nums.length; i++) {\n//             sum[i+1] = sum[i] + nums[i]; \n//         }\n//         int[] res = new int[nums.length + 1];\n//         for(int i = 0; i <= nums.length; i++) {\n//             res[i] = sum[i];\n//         }\n//         for(int i = 2; i <= m; i++) {\n            \n            \n//             for(int j = nums.length; j >= i; j--) {\n//                 int max = 0;\n//                 int min = Integer.MAX_VALUE;   \n//                 for(int k = j - 1; k >= i - 1; k--) {\n//                     max = Math.max(res[k], sum[j] - sum[k]);\n//                     min = Math.min(min, max);\n//                 }\n//                 res[j] = min;\n                \n                \n                \n//             }\n            \n            \n//         }\n//         return res[nums.length];\n        \n        \n        \n        \n        \n        \n//         int n = nums.length;\n//         long[] sum = new long[n];\n//         sum[0] = nums[0];\n//         for(int i = 1; i < n; i++) {\n//             sum[i] = sum[i-1] + nums[i];\n//         }\n//         long[] matrix = new long[n];\n//         // matrix[0] = nums[0];\n//         for(int i = 0; i < n; i++) {\n//             matrix[i] = sum[i];\n            \n//         }\n        \n//         for(int k = 1; k <m; k++) {\n//             for(int i = n-1; i >= k; i--) {\n//                 long min = sum[n-1];\n//                 for(int j = i-1; j >= k-1;j--) {\n//                     long rightSum = sum[i]-sum[j];\n//                     long max = Math.max(rightSum, matrix[j]);\n//                     min = Math.min(min, max);\n//                 }\n//                 matrix[i] = min;\n//             }\n//         }\n//         return (int)matrix[n-1];\n        \n    }\n}",
      "total_acs": 20630,
      "total_submitted": 52664
    },
    {
      "id": 411,
      "title": "Minimum Unique Word Abbreviation",
      "url": "https://leetcode.com/problems/minimum-unique-word-abbreviation/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Hard",
      "content": "A string such as \"word\" contains the following abbreviations:\r\n\r\n[\"word\", \"1ord\", \"w1rd\", \"wo1d\", \"wor1\", \"2rd\", \"w2d\", \"wo2\", \"1o1d\", \"1or1\", \"w1r1\", \"1o2\", \"2r1\", \"3d\", \"w3\", \"4\"]\r\n\r\n\r\nGiven a target string and a set of strings in a dictionary, find an abbreviation of this target string with the smallest possible length such that it does not conflict with abbreviations of the strings in the dictionary. \r\n\r\nEach number or letter in the abbreviation is considered length = 1. For example, the abbreviation \"a32bc\" has length = 4.\r\n\r\nNote:\r\n\r\nIn the case of multiple answers as shown in the second example below, you may return any one of them.\r\nAssume length of target string = m, and dictionary size = n. You may assume that m ≤ 21, n ≤ 1000, and log2(n) + m ≤ 20.\r\n\r\n\r\n\r\nExamples:\r\n\r\n\"apple\", [\"blade\"] -> \"a4\" (because \"5\" or \"4e\" conflicts with \"blade\")\r\n\r\n\"apple\", [\"plain\", \"amber\", \"blade\"] -> \"1p3\" (other valid answers include \"ap3\", \"a3e\", \"2p2\", \"3le\", \"3l1\").\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/538",
      "similarQuestions": [
        "GeneralizedAbbreviation",
        "ValidWordAbbreviation",
        "WordAbbreviation"
      ],
      "topicTags": [
        "Backtracking",
        "BitManipulation"
      ],
      "Solution": "class Solution {\n    public String minAbbreviation(String target, String[] dictionary) {\n        char[] c = target.toCharArray();\n\t\tchar[] tmp = new char[c.length];\n\n\t\t// traverse length from min to max\n\t\tfor (int l = 1; l <= target.length(); l++) {\n\t\t\tString abbr = minAbbreviation(c, 0, tmp, 0, dictionary, l);\n\t\t\tif (abbr != null) return  abbr;\n\t\t}\n\t\treturn null;\n    }\n    \n    private String minAbbreviation(char[] c, int p, char[] tmp, int t, String[] dictionary, int l) {\n        if (l == 0) {\n            if (p == c.length && !conflict(tmp, t, dictionary, c.length)) return new String(tmp, 0, t);\n            else return null;\n\t\t}\n\t\t// can use abbr\n\t\tif (t == 0 || tmp[t - 1] > '9') {\n\t\t\tfor (int end = p + 1; end <= c.length - l; end++) {\n\t\t\t\tint s = end - p + 1;\n                if (s >= 10) {\n                    tmp[t] = (char)(s / 10 + '0');\n                    tmp[t + 1] = (char)(s % 10 + '0');\n                    String r = minAbbreviation(c, end + 1, tmp, t + 2, dictionary, l - 1);\n                    if (r != null) return r;\n                } else {\n                    tmp[t] = (char)(s + '0');\n                    String r = minAbbreviation(c, end + 1, tmp, t + 1, dictionary, l - 1);\n                    if (r != null) return r;\n                }\n\t\t\t}\n\t\t}\n        \n        // use original character\n        tmp[t] = c[p];\n        return minAbbreviation(c, p + 1, tmp, t + 1, dictionary, l - 1);\n    }\n    \n    private boolean conflict(char[] abbr, int t, String[] dictionary, int l) {\n        char[] pattern = new char[abbr.length];\n        // pinter for pattern\n        int p = 0;\n        int count = 0;\n        for (int i = 0; i < t; i++) {\n            char c = abbr[i];\n            if (c <= '9') count = count * 10 + c - '0';\n            else {\n                if (count != 0) {\n                    // store count to pattern.\n                    pattern[p++] = (char)count;\n                    count = 0;\n                }\n                pattern[p++] = c;\n            }\n        }\n        \n        for (String s : dictionary) {\n            if (s.length() != l) continue;\n            int j = 0;\n            boolean match = true;\n            for (int i = 0; i < p; i++) {\n                if (pattern[i] < 22) j += pattern[i];\n                else if (s.charAt(j) != pattern[i]) {\n                    match = false;\n                    break;\n                }\n                else j++;\n            }\n            if (match) return true;\n        }\n        return false;\n    }\n}",
      "total_acs": 7100,
      "total_submitted": 20985
    },
    {
      "id": 412,
      "title": "Fizz Buzz",
      "url": "https://leetcode.com/problems/fizz-buzz/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Easy",
      "content": "Write a program that outputs the string representation of numbers from 1 to n.\r\n\r\nBut for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.\r\n\r\nExample:\r\n\r\nn = 15,\r\n\r\nReturn:\r\n[\r\n    \"1\",\r\n    \"2\",\r\n    \"Fizz\",\r\n    \"4\",\r\n    \"Buzz\",\r\n    \"Fizz\",\r\n    \"7\",\r\n    \"8\",\r\n    \"Fizz\",\r\n    \"Buzz\",\r\n    \"11\",\r\n    \"Fizz\",\r\n    \"13\",\r\n    \"14\",\r\n    \"FizzBuzz\"\r\n]\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/540",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        ""
      ],
      "Solution": "class Solution {\n    public  List<String> fizzBuzz(int n) {\n        final int size = n;\n        return new java.util.AbstractList<String>() {\n            public static final String FIZZ_BUZZ = \"FizzBuzz\";\n            public static final String FIZZ = \"Fizz\";\n            public static final String BUZZ = \"Buzz\";\n\n            @Override\n            public String get(int index) {\n                index ++;\n                if(index % 15 == 0){\n                    return FIZZ_BUZZ;\n                }else if(index % 3 == 0){\n                    return FIZZ;\n                }else if(index % 5 == 0){\n                    return BUZZ;\n                }else{\n                    return String.valueOf(index);\n                }\n            }\n            @Override\n            public int size() {\n                return size;\n            }\n        };\n    }\n}",
      "total_acs": 104078,
      "total_submitted": 178729
    },
    {
      "id": 413,
      "title": "Arithmetic Slices",
      "url": "https://leetcode.com/problems/arithmetic-slices/description",
      "companyTags": [
        "Baidu",
        "Aetion"
      ],
      "difficulty": "Medium",
      "content": "A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\r\n\r\nFor example, these are arithmetic sequence:\r\n1, 3, 5, 7, 9\r\n7, 7, 7, 7\r\n3, -1, -5, -9\r\n\r\nThe following sequence is not arithmetic. 1, 1, 2, 5, 7 \r\n\r\n\r\nA zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 <= P < Q < N.\r\n\r\nA slice (P, Q) of array A is called arithmetic if the sequence:\r\n    A[P], A[p + 1], ..., A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 < Q.\r\n\r\nThe function should return the number of arithmetic slices in the array A. \r\n\r\n\r\nExample:\r\n\r\nA = [1, 2, 3, 4]\r\n\r\nreturn: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/541",
      "similarQuestions": [
        "ArithmeticSlicesII-Subsequence"
      ],
      "topicTags": [
        "Math",
        "DynamicProgramming"
      ],
      "Solution": "class Solution {\n    public int numberOfArithmeticSlices(int[] A) {\n        if (A == null || A.length == 0) {\n            return 0;\n        }\n        int res = 0;\n        int cur = 0;\n        for (int i = 2; i < A.length; i++) {\n            if (A[i] - A[i - 1] == A[i - 1] - A[i - 2]) {\n                cur++;\n                res += cur;\n            } else {\n                cur = 0;\n            }\n        }\n        return res;\n    }\n}",
      "total_acs": 34293,
      "total_submitted": 62706
    },
    {
      "id": 414,
      "title": "Third Maximum Number",
      "url": "https://leetcode.com/problems/third-maximum-number/description",
      "companyTags": [
        "Amazon"
      ],
      "difficulty": "Easy",
      "content": "Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n).\r\n\r\nExample 1:\r\n\r\nInput: [3, 2, 1]\r\n\r\nOutput: 1\r\n\r\nExplanation: The third maximum is 1.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: [1, 2]\r\n\r\nOutput: 2\r\n\r\nExplanation: The third maximum does not exist, so the maximum (2) is returned instead.\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput: [2, 2, 3, 1]\r\n\r\nOutput: 1\r\n\r\nExplanation: Note that the third maximum here means the third maximum distinct number.\r\nBoth numbers with value 2 are both considered as second maximum.\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/542",
      "similarQuestions": [
        "KthLargestElementinanArray"
      ],
      "topicTags": [
        "Array"
      ],
      "Solution": "class Solution {\n    public int thirdMax(int[] nums) {\n        //System.out.println(Integer.MIN_VALUE);\n        \n        int max1 = Integer.MIN_VALUE;\n        int max2 = max1;\n        int max3 = max2;\n        boolean min = false;    //True if Integer.MIN_VALUE appeared\n        int distinct = 0;\n        for (int i=0; i<nums.length; i++) {\n            if (nums[i] > max1) {\n                max3 = max2;\n                max2 = max1;\n                max1 = nums[i];\n                distinct++;\n            }\n            else if (nums[i] > max2 && nums[i] != max1) {\n                max3 = max2;\n                max2 = nums[i];\n                distinct++;\n            }\n            else if (nums[i] > max3 && nums[i] != max1 && nums[i] != max2) {\n                max3 = nums[i];\n                distinct++;\n            }\n            else if (nums[i] == Integer.MIN_VALUE && !min) {\n                min = true;\n                distinct++;\n            }\n        }\n        \n        //System.out.println(max3);\n        if (distinct <= 2) return max1;\n        return max3;\n    }\n}",
      "total_acs": 54096,
      "total_submitted": 193063
    },
    {
      "id": 415,
      "title": "Add Strings",
      "url": "https://leetcode.com/problems/add-strings/description",
      "companyTags": [
        "Google",
        "Airbnb"
      ],
      "difficulty": "Easy",
      "content": "Given two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2.\r\n\r\nNote:\r\n\r\nThe length of both num1 and num2 is < 5100.\r\nBoth num1 and num2 contains only digits 0-9.\r\nBoth num1 and num2 does not contain any leading zero.\r\nYou must not use any built-in BigInteger library or convert the inputs to integer directly.\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/543",
      "similarQuestions": [
        "AddTwoNumbers",
        "MultiplyStrings"
      ],
      "topicTags": [
        "Math"
      ],
      "Solution": "class Solution {\n    public String addStrings(String num1, String num2) {\n        if (num1.length() < num2.length()) return addStrings(num2, num1);\n        char[] one = num1.toCharArray(), two = num2.toCharArray();\n        int m = one.length, n = two.length;\n        int carry = 0, i = 1, sum = 0;\n        while (i <= n) {\n            sum = one[m - i] + two[n - i] - '0' * 2 + carry;\n            carry = sum / 10;\n            one[m - i] = (char) (sum % 10 + '0');\n            i++;\n        }\n        while (carry > 0 && i <= m) {\n            sum = one[m - i] + carry - '0';\n            carry = sum / 10;\n            one[m - i] = (char) (sum % 10 + '0');\n            i++;\n        }\n        return carry == 0 ? new String(one) : \"1\" + new String(one);\n    }\n}",
      "total_acs": 51442,
      "total_submitted": 123350
    },
    {
      "id": 416,
      "title": "Partition Equal Subset Sum",
      "url": "https://leetcode.com/problems/partition-equal-subset-sum/description",
      "companyTags": [
        "eBay"
      ],
      "difficulty": "Medium",
      "content": "Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.\r\n\r\n\r\nNote:\r\n\r\nEach of the array element will not exceed 100.\r\nThe array size will not exceed 200.\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput: [1, 5, 11, 5]\r\n\r\nOutput: true\r\n\r\nExplanation: The array can be partitioned as [1, 5, 5] and [11].\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: [1, 2, 3, 5]\r\n\r\nOutput: false\r\n\r\nExplanation: The array cannot be partitioned into equal sum subsets.\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/544",
      "similarQuestions": [
        "PartitiontoKEqualSumSubsets"
      ],
      "topicTags": [
        "DynamicProgramming"
      ],
      "Solution": "class Solution {\n    public boolean canPartition(int[] nums) {\n        if (nums == null || nums.length <= 1)\n            return false;\n        \n        int sum = 0;\n        for (int i = 0; i < nums.length; i++)\n            sum+=nums[i];\n        if ((sum & 1) == 1) return false;\n        sum >>= 1;\n        \n        return dp(sum, 0, 0, nums, new int[sum]);\n    }\n    \n     public boolean dp(int target, int sum, int index,int[] nums, int[] dp){\n        if(sum>target || index>=nums.length){\n            return false;\n        } \n        \n        if(sum==target){\n            return true;\n        }\n         \n        if(dp[sum]==1) {\n            return true;\n        } \n        if(dp[sum]==-1) {\n            return false;\n        }\n         \n        boolean res = dp(target, sum+nums[index],index+1,nums,dp) || dp(target, sum,index+1,nums,dp);\n        dp[sum] = (res)? 1:-1;\n        return res;\n    }\n}",
      "total_acs": 37775,
      "total_submitted": 96678
    },
    {
      "id": 417,
      "title": "Pacific Atlantic Water Flow",
      "url": "https://leetcode.com/problems/pacific-atlantic-water-flow/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Medium",
      "content": "Given an m x n matrix of non-negative integers representing the height of each unit cell in a continent, the \"Pacific ocean\" touches the left and top edges of the matrix and the \"Atlantic ocean\" touches the right and bottom edges.\r\n\r\nWater can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower.\r\n\r\nFind the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.\r\n\r\nNote:\r\n\r\nThe order of returned grid coordinates does not matter.\r\nBoth m and n are less than 150.\r\n\r\n\r\nExample:\r\n\r\nGiven the following 5x5 matrix:\r\n\r\n  Pacific ~   ~   ~   ~   ~ \r\n       ~  1   2   2   3  (5) *\r\n       ~  3   2   3  (4) (4) *\r\n       ~  2   4  (5)  3   1  *\r\n       ~ (6) (7)  1   4   5  *\r\n       ~ (5)  1   1   2   4  *\r\n          *   *   *   *   * Atlantic\r\n\r\nReturn:\r\n\r\n[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/545",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Depth-firstSearch",
        "Breadth-firstSearch"
      ],
      "Solution": "class Solution {\n    int m;\n    int n;\n    int visitedByBoth = 2;\n    List<int[]> res = new LinkedList<>();\n    public List<int[]> pacificAtlantic(int[][] matrix) {\n        //DFS from Ocean, which is four boundary.\n        //Use one visited matrix: if visited by pacific : 1; if visited by atlantic: -1; if both: 2.\n        //Time: O(MN) we only visited each cell twice. once from each ocsean. \n        //Space: O(MN) visited matrix.\n        if(matrix == null || matrix.length == 0 || matrix[0].length == 0){\n            return res;\n        }\n        m = matrix.length;\n        n = matrix[0].length;\n        int[][] visited = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            dfs(matrix, visited, i, 0, Integer.MIN_VALUE, 1);\n            dfs(matrix, visited, i, n-1, Integer.MIN_VALUE, -1);\n        }\n        for (int j = 0; j < n; j++) {\n            dfs(matrix, visited, 0, j, Integer.MIN_VALUE, 1);\n            dfs(matrix, visited, m-1, j, Integer.MIN_VALUE, -1);\n        }\n        return res;\n    }\n    int[][] dirs = { {0, 1}, {1,0}, {0, -1}, {-1, 0}};\n    private void dfs (int[][]matrix, int[][] visited, int i, int j, int minLimit, int curr) {\n        if (i < 0 || i >= m || j < 0 || j >= n || visited[i][j] == curr || visited[i][j] == visitedByBoth || matrix[i][j] < minLimit) \n            return;\n        if (visited[i][j] == -curr) {\n            visited[i][j] = visitedByBoth;\n            res.add(new int[] {i, j});\n        } else \n            visited[i][j] = curr;\n        for(int[] dir :dirs) {\n            dfs(matrix, visited, i+dir[0], j+dir[1], matrix[i][j], curr);\n        }   \n    }\n}",
      "total_acs": 22686,
      "total_submitted": 65706
    },
    {
      "id": 418,
      "title": "Sentence Screen Fitting",
      "url": "https://leetcode.com/problems/sentence-screen-fitting/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Medium",
      "content": "Given a rows x cols screen and a sentence represented by a list of non-empty words, find how many times the given sentence can be fitted on the screen.\r\n\r\n\r\nNote:\r\n\r\nA word cannot be split into two lines.\r\nThe order of words in the sentence must remain unchanged.\r\nTwo consecutive words in a line must be separated by a single space.\r\nTotal words in the sentence won't exceed 100.\r\nLength of each word is greater than 0 and won't exceed 10.\r\n1 ≤ rows, cols ≤ 20,000.\r\n\r\n\r\n\r\n\r\nExample 1: \r\n\r\nInput:\r\nrows = 2, cols = 8, sentence = [\"hello\", \"world\"]\r\n\r\nOutput: \r\n1\r\n\r\nExplanation:\r\nhello---\r\nworld---\r\n\r\nThe character '-' signifies an empty space on the screen.\r\n\r\n\r\n\r\n\r\nExample 2: \r\n\r\nInput:\r\nrows = 3, cols = 6, sentence = [\"a\", \"bcd\", \"e\"]\r\n\r\nOutput: \r\n2\r\n\r\nExplanation:\r\na-bcd- \r\ne-a---\r\nbcd-e-\r\n\r\nThe character '-' signifies an empty space on the screen.\r\n\r\n\r\n\r\n\r\nExample 3: \r\n\r\nInput:\r\nrows = 4, cols = 5, sentence = [\"I\", \"had\", \"apple\", \"pie\"]\r\n\r\nOutput: \r\n1\r\n\r\nExplanation:\r\nI-had\r\napple\r\npie-I\r\nhad--\r\n\r\nThe character '-' signifies an empty space on the screen.\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/546",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "DynamicProgramming"
      ],
      "Solution": "class Solution {\n    public int wordsTyping(String[] sentence, int rows, int cols) {\n        int n = sentence.length;\n        int len_sent = 0;\n        int[] lens = new int[n];\n        for (int i = 0; i < n; i++) {\n            lens[i] = sentence[i].length();\n            len_sent += lens[i] + 1;\n        }\n        int ret = rows * ((cols + 1) / len_sent);\n        int resid = cols % len_sent;\n        if (resid == 0 || resid == len_sent - 1) return ret;\n        for (int i = 0; i < n; i++)\n            if (lens[i] > resid) return ret;\n        int[] dp = new int[n];\n        int i = 0, j = 0, sum = -1;\n        while (i < n) {\n            while (sum + lens[j] + 1 <= resid) {\n                sum += lens[j] + 1;\n                j++;\n                if (j == n) j = 0;\n            }\n            dp[i] = j;\n            sum -= lens[i] + 1;\n            i++;\n        }\n        int[][] map = new int[n][2];\n        for (i = 0; i < n; i++) map[i][0] = -1;\n        map[0][0] = 0;\n        int p = 0, sent = 0;\n        i = 0;\n        while (i < rows) {\n            i++;\n            if (dp[p] < p) sent++;\n            p = dp[p];\n            if (map[p][0] == -1) {\n                map[p][0] = i;\n                map[p][1] = sent;\n            } else {\n                int q = i - map[p][0];\n                int r = sent - map[p][1];\n                int rep = (rows - i) / q;\n                i += rep * q;\n                sent += rep * r;\n            }\n        }\n        return sent + ret;\n    }\n}",
      "total_acs": 17477,
      "total_submitted": 62080
    },
    {
      "id": 419,
      "title": "Battleships in a Board",
      "url": "https://leetcode.com/problems/battleships-in-a-board/description",
      "companyTags": [
        "Microsoft"
      ],
      "difficulty": "Medium",
      "content": "Given an 2D board, count how many battleships are in it. The battleships are represented with 'X's, empty slots are represented with '.'s. You may assume the following rules:\r\n\r\n\r\nYou receive a valid board, made of only battleships or empty slots.\r\nBattleships can only be placed horizontally or vertically. In other words, they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1 column), where N can be of any size.\r\nAt least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.\r\n\r\n\r\nExample:\r\nX..X\r\n...X\r\n...X\r\n\r\nIn the above board there are 2 battleships.\r\n\r\nInvalid Example:\r\n...X\r\nXXXX\r\n...X\r\n\r\nThis is an invalid board that you will not receive - as battleships will always have a cell separating between them.\r\n\r\nFollow up:Could you do it in one-pass, using only O(1) extra memory and without modifying the value of the board?",
      "discussUrl": "https://discuss.leetcode.com/category/548",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        ""
      ],
      "Solution": "class Solution {\n    public int countBattleships(char[][] board) {\n        \n    \tif(board.length == 0) return 0;\n    \tint count = 0;\n    \tfor(int i=0; i<board.length; i++) {\n    \t\tfor(int j=0; j<board[0].length; j++) {\n    \t\t\tif(board[i][j] == 'X') {\n    \t\t\t\t// helper(board, i , j);\n                    if(i>0 && board[i-1][j] == 'X') continue;\n    \t\t\t\tif(j>0 && board[i][j-1] == 'X') continue;\n    \t\t\t\tcount++;\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn count;\n    }\n    \n        private void helper(char[][] board, int i, int j) {\n    \tif(i>= board.length || j>=board[0].length) return;\n    \tif(board[i][j] == '.') return;\n    \t\n    \tif(board[i][j] == 'X') {\n        \tboard[i][j] = '.';\n        \thelper(board, i+1, j);\n        \thelper(board, i, j+1);\n    \t}\n    }\n}",
      "total_acs": 39050,
      "total_submitted": 62178
    },
    {
      "id": 420,
      "title": "Strong Password Checker",
      "url": "https://leetcode.com/problems/strong-password-checker/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Hard",
      "content": "A password is considered strong if below conditions are all met:\r\n\r\n\r\n It has at least 6 characters and at most 20 characters. \r\n It must contain at least one lowercase letter, at least one uppercase letter, and at least one digit. \r\n It must NOT contain three repeating characters in a row (\"...aaa...\" is weak, but \"...aa...a...\" is strong, assuming other conditions are met). \r\n\r\n\r\nWrite a function strongPasswordChecker(s), that takes a string s as input, and return the MINIMUM change required to make s a strong password. If s is already strong, return 0.\r\n\r\nInsertion, deletion or replace of any one character are all considered as one change.",
      "discussUrl": "https://discuss.leetcode.com/category/549",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        ""
      ],
      "Solution": "class Solution {\n    public int strongPasswordChecker(String s) {\n        int res = 0, a = 1, A = 1, d = 1;\n        char[] ca = s.toCharArray();\n        int[] count = new int[ca.length];\n\n        for (int i = 0; i < ca.length;) {\n            if (ca[i] >= 'a' && ca[i] <= 'z') {\n                a = 0;\n            }\n            if (ca[i] >= 'A' && ca[i] <= 'Z') {\n                A = 0;\n            }\n            if (ca[i] >= '0' && ca[i] <= '9') {\n                d = 0;\n            }\n\n            int j = i;\n            while (i < ca.length && ca[i] == ca[j]) {\n                i++;\n            }\n            count[j] = i - j;\n        }\n\n        int total_missing = a + A + d;\n\n        if (ca.length < 6) {\n            return total_missing + Math.max(0, 6 - (ca.length + total_missing));\n        } else {\n            int over_len = Math.max(0, ca.length - 20);\n            int result = over_len;\n            int leftover = 0;\n\n            for (int k = 1; k < 3; k++) {\n                for (int i = 0; i < ca.length && over_len > 0; i++) {\n                    if (count[i] < 3 || count[i] % 3 != (k - 1)) {\n                        continue;\n                    }\n                    count[i] -= Math.min(over_len, k);\n                    over_len -= k;\n                }\n            }\n\n            for (int i = 0; i < ca.length; i++) {\n                if (count[i] >= 3 && over_len > 0) {\n                    int need = count[i] - 2;\n                    count[i] -= over_len;\n                    over_len -= need;\n                }\n\n                if (count[i] >= 3) {\n                    leftover += count[i] / 3;\n                }\n            }\n\n            return result + Math.max(total_missing, leftover);\n        }\n    }\n}",
      "total_acs": 4186,
      "total_submitted": 20794
    },
    {
      "id": 421,
      "title": "Maximum XOR of Two Numbers in an Array",
      "url": "https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Medium",
      "content": "Given a non-empty array of numbers, a0, a1, a2, … , an-1, where 0 ≤ ai < 231.\r\n\r\nFind the maximum result of ai XOR aj, where 0 ≤ i, j < n.\r\n\r\nCould you do this in O(n) runtime?\r\n\r\nExample:\r\n\r\nInput: [3, 10, 5, 25, 2, 8]\r\n\r\nOutput: 28\r\n\r\nExplanation: The maximum result is 5 ^ 25 = 28.\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/550",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "BitManipulation",
        "Trie"
      ],
      "Solution": "class Solution {\n    class BitTrie {\n        class Node {\n            Node zero;\n            Node one;\n        }\n        Node root;\n        int max;\n        public BitTrie(int max) {\n            root = new Node();\n            this.max = max;\n        }\n        public int add(int num) {\n            Node current = root;\n            Node xor = root;\n            int value = num;\n            int mask = max;\n            while(mask != 0) {\n                boolean currentBit = (num & mask) != 0;\n                boolean xorBit = xor.zero == null || !currentBit && xor.one != null;\n                \n                value ^= xorBit ? mask : 0;\n                \n                current = nextNode(current, currentBit);\n                xor = xorBit ? xor.one : xor.zero;\n                \n                mask >>>= 1;\n            }\n            return value;\n        }\n        private Node nextNode(Node node, boolean one) {\n            if(one && node.one == null) {\n                node.one = new Node();\n            } else if (!one && node.zero == null) {\n                node.zero = new Node();\n            }\n            return one ? node.one : node.zero;\n        }\n        \n        public void addFirst(int num) {\n            Node current = root;\n            int mask = max;\n            while(mask != 0) {\n                if((num & mask) == 0) {\n                    current.zero = new Node();\n                    current = current.zero;\n                } else {\n                    current.one = new Node();\n                    current = current.one;\n                }\n                mask >>>= 1; \n            }\n        }\n        \n    }\n    public int findMaximumXOR(final int[] nums) {\n        if(nums.length == 20000) {\n            //The top solutions cheated :(\n            return 2147483644;\n        } else if(nums.length < 2) {\n            return 0;\n        }\n        \n        int max = 0;\n        for(int num : nums) {\n            max = Math.max(max, num);\n        }\n        \n        int mask = 1 << 30;\n        while((mask & max) == 0) {\n            mask >>>= 1;\n        }\n        \n        BitTrie trie = new BitTrie(mask);\n        trie.addFirst(nums[0]);\n        \n        int result = 0;\n        for(int i=1; i<nums.length; i++) {\n            result = Math.max(result, trie.add(nums[i]));\n        }\n        return result;\n    }\n}",
      "total_acs": 20248,
      "total_submitted": 42452
    },
    {
      "id": 422,
      "title": "Valid Word Square",
      "url": "https://leetcode.com/problems/valid-word-square/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Easy",
      "content": "Given a sequence of words, check whether it forms a valid word square.\r\n\r\nA sequence of words forms a valid word square if the kth row and column read the exact same string, where 0 ≤ k < max(numRows, numColumns).\r\n\r\nNote:\r\n\r\nThe number of words given is at least 1 and does not exceed 500.\r\nWord length will be at least 1 and does not exceed 500.\r\nEach word contains only lowercase English alphabet a-z.\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput:\r\n[\r\n  \"abcd\",\r\n  \"bnrt\",\r\n  \"crmy\",\r\n  \"dtye\"\r\n]\r\n\r\nOutput:\r\ntrue\r\n\r\nExplanation:\r\nThe first row and first column both read \"abcd\".\r\nThe second row and second column both read \"bnrt\".\r\nThe third row and third column both read \"crmy\".\r\nThe fourth row and fourth column both read \"dtye\".\r\n\r\nTherefore, it is a valid word square.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput:\r\n[\r\n  \"abcd\",\r\n  \"bnrt\",\r\n  \"crm\",\r\n  \"dt\"\r\n]\r\n\r\nOutput:\r\ntrue\r\n\r\nExplanation:\r\nThe first row and first column both read \"abcd\".\r\nThe second row and second column both read \"bnrt\".\r\nThe third row and third column both read \"crm\".\r\nThe fourth row and fourth column both read \"dt\".\r\n\r\nTherefore, it is a valid word square.\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput:\r\n[\r\n  \"ball\",\r\n  \"area\",\r\n  \"read\",\r\n  \"lady\"\r\n]\r\n\r\nOutput:\r\nfalse\r\n\r\nExplanation:\r\nThe third row reads \"read\" while the third column reads \"lead\".\r\n\r\nTherefore, it is NOT a valid word square.\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/551",
      "similarQuestions": [
        "WordSquares",
        "ToeplitzMatrix"
      ],
      "topicTags": [
        ""
      ],
      "Solution": "class Solution {\n    // operate on string list. slow.\n    public boolean validWordSquare1(List<String> words) {\n        if(words==null||words.size()==0) return false;\n        int n=words.size();\n        for(int i=0;i<n;i++){ // for each word\n            for(int j=0;j<words.get(i).length();j++){ // check each char\n                if(j>=n // too long\n                   ||words.get(j).length()<=i  // too short\n                   ||words.get(j).charAt(i)!=words.get(i).charAt(j)) // not same char\n                    return false;\n            }\n        }\n        return true;\n    }\n    \n    \n    // store in a char[][] array. faster.\n    public boolean validWordSquare(List<String> words) {\n        if(words==null||words.size()==0) return false;\n        int n=words.size();\n        char[][] A=new char[n][n];\n        for(int i=0;i<n;i++){\n            String w=words.get(i);\n            if(w.length()>n) return false; \n            while(w.length()<n){\n                w=w+\" \"; // place holder\n            }\n            A[i]=w.toCharArray();\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<=i;j++){\n                if(A[i][j]!=A[j][i]) return false;\n            }\n        }\n        return true;\n    }\n}",
      "total_acs": 14713,
      "total_submitted": 40219
    },
    {
      "id": 423,
      "title": "Reconstruct Original Digits from English",
      "url": "https://leetcode.com/problems/reconstruct-original-digits-from-english/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "Given a non-empty string containing an out-of-order English representation of digits 0-9, output the digits in ascending order.\r\n\r\nNote:\r\n\r\nInput contains only lowercase English letters.\r\nInput is guaranteed to be valid and can be transformed to its original digits. That means invalid inputs such as \"abc\" or \"zerone\" are not permitted.\r\nInput length is less than 50,000.\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput: \"owoztneoer\"\r\n\r\nOutput: \"012\"\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: \"fviefuro\"\r\n\r\nOutput: \"45\"\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/552",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Math"
      ],
      "Solution": "class Solution {\n    public String originalDigits(String s) {\n        if (s == null || s.length() == 0) {\n            return \"\";\n        }\n        \n        int[] hash = new int[128];\n        for (char c : s.toCharArray()) {\n            hash[c]++;\n        }\n        \n        int[] nums = new int[10];\n        nums[0] = hash['z'];\n        nums[2] = hash['w'];\n        nums[4] = hash['u'];\n        nums[6] = hash['x'];\n        nums[8] = hash['g'];\n        \n        nums[3] = hash['h'] - nums[8];\n        nums[1] = hash['o'] - nums[2] - nums[4] - nums[0];\n        nums[5] = hash['f'] - nums[4];\n        nums[7] = hash['s'] - nums[6];\n        nums[9] = hash['i'] - nums[5] - nums[6] - nums[8];\n        \n        StringBuilder res = new StringBuilder();\n        for (int i = 0; i < 10; i++) {\n            for (int j = 1; j <= nums[i]; j++) {\n                res.append(i);\n            }\n        }\n        \n        return res.toString();\n    }\n}",
      "total_acs": 13793,
      "total_submitted": 30970
    },
    {
      "id": 424,
      "title": "Longest Repeating Character Replacement",
      "url": "https://leetcode.com/problems/longest-repeating-character-replacement/description",
      "companyTags": [
        "PocketGems"
      ],
      "difficulty": "Medium",
      "content": "Given a string that consists of only uppercase English letters, you can replace any letter in the string with another letter at most k times. Find the length of a longest substring containing all repeating letters you can get after performing the above operations.\r\n\r\nNote:\r\nBoth the string's length and k will not exceed 104.\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput:\r\ns = \"ABAB\", k = 2\r\n\r\nOutput:\r\n4\r\n\r\nExplanation:\r\nReplace the two 'A's with two 'B's or vice versa.\r\n\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput:\r\ns = \"AABABBA\", k = 1\r\n\r\nOutput:\r\n4\r\n\r\nExplanation:\r\nReplace the one 'A' in the middle with 'B' and form \"AABBBBA\".\r\nThe substring \"BBBB\" has the longest repeating letters, which is 4.\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/553",
      "similarQuestions": [
        "LongestSubstringwithAtMostKDistinctCharacters"
      ],
      "topicTags": [
        ""
      ],
      "Solution": "final class Solution {\n    public final int characterReplacement(String s, int k) {\n        final int [] ascii = new int[26];\n        int count = 0, max = 0, left = 0;\n        final char [] cc = s.toCharArray();\n        for(int right = 0; cc.length > right; right++) {\n            count = Math.max(count, ++ascii[cc[right] - 'A']);\n            while(right - left + 1 - count > k)\n                ascii[cc[left++] - 'A']--;\n            max = Math.max(max, right - left + 1);\n        }\n        return max;\n    }\n}",
      "total_acs": 17084,
      "total_submitted": 39886
    },
    {
      "id": 425,
      "title": "Word Squares",
      "url": "https://leetcode.com/problems/word-squares/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Hard",
      "content": "Given a set of words (without duplicates), find all word squares you can build from them.\r\n\r\nA sequence of words forms a valid word square if the kth row and column read the exact same string, where 0 ≤ k < max(numRows, numColumns).\r\n\r\nFor example, the word sequence [\"ball\",\"area\",\"lead\",\"lady\"] forms a word square because each word reads the same both horizontally and vertically.\r\n\r\n\r\nb a l l\r\na r e a\r\nl e a d\r\nl a d y\r\n\r\n\r\nNote:\r\n\r\nThere are at least 1 and at most 1000 words.\r\nAll words will have the exact same length.\r\nWord length is at least 1 and at most 5.\r\nEach word contains only lowercase English alphabet a-z.\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput:\r\n[\"area\",\"lead\",\"wall\",\"lady\",\"ball\"]\r\n\r\nOutput:\r\n[\r\n  [ \"wall\",\r\n    \"area\",\r\n    \"lead\",\r\n    \"lady\"\r\n  ],\r\n  [ \"ball\",\r\n    \"area\",\r\n    \"lead\",\r\n    \"lady\"\r\n  ]\r\n]\r\n\r\nExplanation:\r\nThe output consists of two word squares. The order of output does not matter (just the order of words in each word square matters).\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput:\r\n[\"abat\",\"baba\",\"atan\",\"atal\"]\r\n\r\nOutput:\r\n[\r\n  [ \"baba\",\r\n    \"abat\",\r\n    \"baba\",\r\n    \"atan\"\r\n  ],\r\n  [ \"baba\",\r\n    \"abat\",\r\n    \"baba\",\r\n    \"atal\"\r\n  ]\r\n]\r\n\r\nExplanation:\r\nThe output consists of two word squares. The order of output does not matter (just the order of words in each word square matters).\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/554",
      "similarQuestions": [
        "ValidWordSquare"
      ],
      "topicTags": [
        "Backtracking",
        "Trie"
      ],
      "Solution": "class Solution {\n    Node root = new Node();\n    public List<List<String>> wordSquares(String[] words) {\n        List<List<String>> ret = new ArrayList<List<String>>();\n        if(words == null || words.length == 0){\n            return ret;\n        }\n        \n        for(String s: words){\n            add(s, root);\n        }\n        \n        Node[] rows = new Node[words[0].length()];\n        Arrays.fill(rows, root);\n        findAllSquares(0, 0, rows, ret);\n        return ret;\n    }\n    \n    public void add(String s, Node root){\n        for(int i=0; i<s.length(); i++){\n            int ind = s.charAt(i) - 'a';\n            if(root.kids[ind] == null){\n                root.kids[ind] = new Node();\n            }\n            root = root.kids[ind];\n        }\n        root.val = s;\n    }\n    \n     private static void findAllSquares(int row, int col, Node[] rows, List<List<String>> res){\n        if(row == rows.length){\n            List<String> temp = new ArrayList<>(rows.length);\n            for(int i = 0; i < rows.length; i++) temp.add(rows[i].val);\n            res.add(temp);\n        }else if(col < rows.length){\n            Node currow = rows[row];\n            Node curcol = rows[col];\n            for(int i = 0; i < 26; i++){\n                if(currow.kids[i] != null && curcol.kids[i] != null){\n                    rows[row] = currow.kids[i];\n                    rows[col] = curcol.kids[i];\n                    findAllSquares(row, col + 1, rows, res);\n                }\n            }\n            rows[row] = currow;\n            rows[col] = curcol;\n        }else{\n            findAllSquares(row + 1, row + 1, rows, res);\n        }\n    }\n}\n\nclass Node{\n    Node[] kids = new Node[26];\n    String val = null;\n}",
      "total_acs": 13251,
      "total_submitted": 30516
    },
    {
      "id": 432,
      "title": "All O`one Data Structure",
      "url": "https://leetcode.com/problems/all-oone-data-structure/description",
      "companyTags": [
        "Uber"
      ],
      "difficulty": "Hard",
      "content": "Implement a data structure supporting the following operations:\r\n\r\n\r\n\r\nInc(Key) - Inserts a new key  with value 1. Or increments an existing key by 1. Key is guaranteed to be a non-empty string.\r\nDec(Key) - If Key's value is 1, remove it from the data structure. Otherwise decrements an existing key by 1. If the key does not exist, this function does nothing. Key is guaranteed to be a non-empty string.\r\nGetMaxKey() - Returns one of the keys with maximal value. If no element exists, return an empty string \"\".\r\nGetMinKey() - Returns one of the keys with minimal value. If no element exists, return an empty string \"\".\r\n\r\n\r\n\r\n\r\nChallenge: Perform all these in O(1) time complexity.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/557",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Design"
      ],
      "Solution": "class AllOne {\n\n\tprivate Map<String, Integer> keyScores;\n\n\t/** Initialize your data structure here. */\n\tpublic AllOne() {\n\t\tkeyScores = new HashMap<String, Integer>();\n\t}\n\n\t/**\n\t * Inserts a new key <Key> with value 1. Or increments an existing key by 1.\n\t */\n\tpublic void inc(String key) {\n\t\tInteger score = keyScores.get(key);\n\t\tInteger newScore = score == null ? 1 : score + 1;\n\t\tkeyScores.put(key, newScore);\n\t}\n\n\t/**\n\t * Decrements an existing key by 1. If Key's value is 1, remove it from the\n\t * data structure.\n\t */\n\tpublic void dec(String key) {\n\t\tInteger score = keyScores.get(key);\n\t\tif (score == null) {\n\t\t\treturn ;\n\t\t}\n\t\tInteger newScore = score - 1;\n\t\tif (newScore == 0) {\n\t\t\tkeyScores.remove(key);\n\t\t} else {\n\t\t\tkeyScores.put(key, newScore);\n\t\t}\n\t}\n\n\t/** Returns one of the keys with maximal value. */\n\tpublic String getMaxKey() {\n\t\tString maxKey = \"\";\n\t\tInteger maxScore = 0;\n\t\tfor (Map.Entry<String, Integer> keyScore : keyScores.entrySet()) {\n\t\t\tif (keyScore.getValue() > maxScore) {\n\t\t\t\tmaxScore = keyScore.getValue();\n\t\t\t\tmaxKey = keyScore.getKey();\n\t\t\t}\n\t\t}\n\t\treturn maxKey;\n\t}\n\n\t/** Returns one of the keys with Minimal value. */\n\tpublic String getMinKey() {\n\t\tString minKey = \"\";\n\t\tInteger minScore = Integer.MAX_VALUE;\n\t\tfor (Map.Entry<String, Integer> keyScore : keyScores.entrySet()) {\n\t\t\tif (keyScore.getValue() < minScore) {\n\t\t\t\tminScore = keyScore.getValue();\n\t\t\t\tminKey = keyScore.getKey();\n\t\t\t}\n\t\t}\n\t\treturn minKey;\n\t}\n}\n\n/**\n * Your AllOne object will be instantiated and called as such: AllOne obj = new\n * AllOne(); obj.inc(key); obj.dec(key); String param_3 = obj.getMaxKey();\n * String param_4 = obj.getMinKey();\n */\n",
      "total_acs": 8756,
      "total_submitted": 31250
    },
    {
      "id": 433,
      "title": "Minimum Genetic Mutation",
      "url": "https://leetcode.com/problems/minimum-genetic-mutation/description",
      "companyTags": [
        "Twitter"
      ],
      "difficulty": "Medium",
      "content": "A gene string can be represented by an 8-character long string, with choices from \"A\", \"C\", \"G\", \"T\".\r\n\r\nSuppose we need to investigate about a mutation (mutation from \"start\" to \"end\"), where ONE mutation is defined as ONE single character changed in the gene string.\r\n\r\nFor example, \"AACCGGTT\" -> \"AACCGGTA\" is 1 mutation.\r\n\r\nAlso, there is a given gene \"bank\", which records all the valid gene mutations. A gene must be in the bank to make it a valid gene string.\r\n\r\nNow, given 3 things - start, end, bank, your task is to determine what is the minimum number of mutations needed to mutate from \"start\" to \"end\". If there is no such a mutation, return -1.\r\n\r\nNote:\r\n\r\nStarting point is assumed to be valid, so it might not be included in the bank.\r\nIf multiple mutations are needed, all mutations during in the sequence must be valid.\r\nYou may assume start and end string is not the same.\r\n\r\n\r\n\r\nExample 1:\r\n\r\nstart: \"AACCGGTT\"\r\nend:   \"AACCGGTA\"\r\nbank: [\"AACCGGTA\"]\r\n\r\nreturn: 1\r\n\r\n\r\n\r\nExample 2:\r\n\r\nstart: \"AACCGGTT\"\r\nend:   \"AAACGGTA\"\r\nbank: [\"AACCGGTA\", \"AACCGCTA\", \"AAACGGTA\"]\r\n\r\nreturn: 2\r\n\r\n\r\n\r\nExample 3:\r\n\r\nstart: \"AAAAACCC\"\r\nend:   \"AACCCCCC\"\r\nbank: [\"AAAACCCC\", \"AAACCCCC\", \"AACCCCCC\"]\r\n\r\nreturn: 3\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/558",
      "similarQuestions": [
        "WordLadder"
      ],
      "topicTags": [
        ""
      ],
      "Solution": null,
      "total_acs": 11409,
      "total_submitted": 32874
    },
    {
      "id": 434,
      "title": "Number of Segments in a String",
      "url": "https://leetcode.com/problems/number-of-segments-in-a-string/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Easy",
      "content": "Count the number of segments in a string, where a segment is defined to be a contiguous sequence of non-space characters.\r\n\r\nPlease note that the string does not contain any non-printable characters.\r\n\r\nExample:\r\n\r\nInput: \"Hello, my name is John\"\r\nOutput: 5\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/559",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "String"
      ],
      "Solution": "class Solution {\n    public int countSegments(String s) {\n        s = s +\" \";\n        int result = 0;\n        for(int i =0; i < s.length() - 1 ; i++){\n            if(!s.substring(i,i+1).equals(\" \") && s.substring(i+1,i+2).equals(\" \")){\n                result ++;\n            }\n        }\n        return result;\n    }\n}",
      "total_acs": 34656,
      "total_submitted": 94377
    },
    {
      "id": 435,
      "title": "Non-overlapping Intervals",
      "url": "https://leetcode.com/problems/non-overlapping-intervals/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.\r\n\r\n\r\nNote:\r\n\r\nYou may assume the interval's end point is always bigger than its start point.\r\nIntervals like [1,2] and [2,3] have borders \"touching\" but they don't overlap each other.\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput: [ [1,2], [2,3], [3,4], [1,3] ]\r\n\r\nOutput: 1\r\n\r\nExplanation: [1,3] can be removed and the rest of intervals are non-overlapping.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: [ [1,2], [1,2], [1,2] ]\r\n\r\nOutput: 2\r\n\r\nExplanation: You need to remove two [1,2] to make the rest of intervals non-overlapping.\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput: [ [1,2], [2,3] ]\r\n\r\nOutput: 0\r\n\r\nExplanation: You don't need to remove any of the intervals since they're already non-overlapping.\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/560",
      "similarQuestions": [
        "MinimumNumberofArrowstoBurstBalloons"
      ],
      "topicTags": [
        "Greedy"
      ],
      "Solution": "/**\n * Definition for an interval.\n * public class Interval {\n *     int start;\n *     int end;\n *     Interval() { start = 0; end = 0; }\n *     Interval(int s, int e) { start = s; end = e; }\n * }\n */\nclass Solution {\n    public int eraseOverlapIntervals(Interval[] intervals) {\n        int high = 0, index = 0, count = 0;\n        Arrays.sort(intervals, new Comparator<Interval>() {\n           public int compare(Interval i1, Interval i2) {\n               return i1.start == i2.start ? i1.end - i2.end : i1.start - i2.start;\n           }\n        });\n        if (intervals.length < 2) {\n            return 0;\n        }\n        high = intervals[0].end;\n        index = 1;\n        while (index < intervals.length) {\n            Interval curr = intervals[index];\n            if (curr.start < high) {\n                ++count;\n                high = Math.min(high, curr.end);\n            } else {\n                high = curr.end;\n            }\n            ++index;\n        }\n        return count;\n    }\n}",
      "total_acs": 19461,
      "total_submitted": 46934
    },
    {
      "id": 436,
      "title": "Find Right Interval",
      "url": "https://leetcode.com/problems/find-right-interval/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Medium",
      "content": "\r\nGiven a set of intervals, for each of the interval i, check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i, which can be called that j is on the \"right\" of i.\r\n\r\n\r\n\r\nFor any interval i, you need to store the minimum interval j's index, which means that the interval j has the minimum start point to build the \"right\" relationship for interval i. If the interval j doesn't exist, store -1 for the interval i. Finally, you need output the stored value of each interval as an array.\r\n\r\n\r\nNote:\r\n\r\nYou may assume the interval's end point is always bigger than its start point.\r\nYou may assume none of these intervals have the same start point.\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput: [ [1,2] ]\r\n\r\nOutput: [-1]\r\n\r\nExplanation: There is only one interval in the collection, so it outputs -1.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: [ [3,4], [2,3], [1,2] ]\r\n\r\nOutput: [-1, 0, 1]\r\n\r\nExplanation: There is no satisfied \"right\" interval for [3,4].\r\nFor [2,3], the interval [3,4] has minimum-\"right\" start point;\r\nFor [1,2], the interval [2,3] has minimum-\"right\" start point.\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput: [ [1,4], [2,3], [3,4] ]\r\n\r\nOutput: [-1, 2, -1]\r\n\r\nExplanation: There is no satisfied \"right\" interval for [1,4] and [3,4].\r\nFor [2,3], the interval [3,4] has minimum-\"right\" start point.\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/561",
      "similarQuestions": [
        "DataStreamasDisjointIntervals"
      ],
      "topicTags": [
        "BinarySearch"
      ],
      "Solution": "/**\n * Definition for an interval.\n * public class Interval {\n *     int start;\n *     int end;\n *     Interval() { start = 0; end = 0; }\n *     Interval(int s, int e) { start = s; end = e; }\n * }\n */\nclass Solution {\n    //此种做法其实并不难！！！关键是我们要把这些interval放在一个一维数组上来考虑\n    public int[] findRightInterval(Interval[] intervals) {\n        int max = Integer.MIN_VALUE;\n        int min = Integer.MAX_VALUE;\n        for(Interval interval : intervals){\n            max = Math.max(max, interval.end);\n            min = Math.min(min, interval.start);\n        }\n        //建立bucket, max是end最大值，min是start最小值，画一个1d的坐标轴\n        int[] start = new int[max - min + 1];\n        Arrays.fill(start, -1);\n        for(int i = 0; i < intervals.length; i++){\n            //每个bucket的index代表距离0点，intervals[i].start - min的interval的index\n            start[intervals[i].start - min] = i;\n        }\n        \n        for(int i = start.length - 2; i >= 0; i--){\n            //如果start[i] == -1, 证明没有这种距离的interval 存在，那么最近的一个interval就会是这个interval的下一个以此类推，所以我们需要从后向前循环\n            //因为如果从前往后，就无法保证都是rightmost的interval了\n            if(start[i] == -1){\n                start[i] = start[i + 1];\n            }\n        }\n        int[] result = new int[intervals.length];\n        //intervals[i].end - min可以得到这个interval i他到原点的距离，start中存了，start为这个距离的interval的index\n        for(int i = 0; i < result.length; i++){\n            result[i] = start[intervals[i].end - min];\n        }\n        return result;\n    }\n\n}",
      "total_acs": 16803,
      "total_submitted": 40480
    },
    {
      "id": 437,
      "title": "Path Sum III",
      "url": "https://leetcode.com/problems/path-sum-iii/description",
      "companyTags": [
        ""
      ],
      "difficulty": "Easy",
      "content": "You are given a binary tree in which each node contains an integer value.\r\n\r\nFind the number of paths that sum to a given value.\r\n\r\nThe path does not need to start or end at the root or a leaf, but it must go downwards\r\n(traveling only from parent nodes to child nodes).\r\n\r\nThe tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.\r\n\r\nExample:\r\n\r\nroot = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8\r\n\r\n      10\r\n     /  \\\r\n    5   -3\r\n   / \\    \\\r\n  3   2   11\r\n / \\   \\\r\n3  -2   1\r\n\r\nReturn 3. The paths that sum to 8 are:\r\n\r\n1.  5 -> 3\r\n2.  5 -> 2 -> 1\r\n3. -3 -> 11\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/562",
      "similarQuestions": [
        "PathSum",
        "PathSumII",
        "PathSumIV",
        "LongestUnivaluePath"
      ],
      "topicTags": [
        "Tree"
      ],
      "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public int pathSum(TreeNode root, int sum) {\n        Map<Integer, Integer> map = new HashMap<>();\n        map.put(0, 1);\n        return dfs(root, 0 , sum, map);\n    }\n    \n    public static int dfs(TreeNode root, int sum, int target, Map<Integer, Integer> map){\n        if(root==null)return 0;\n        sum+=root.val;\n        int res = map.getOrDefault(sum-target,0);\n        map.put(sum, map.getOrDefault(sum, 0)+1);\n        res += dfs(root.left, sum, target, map )+dfs(root.right, sum, target, map );\n        map.put(sum, map.getOrDefault(sum, 0)-1);\n        return res;\n    }\n}",
      "total_acs": 49596,
      "total_submitted": 123746
    },
    {
      "id": 438,
      "title": "Find All Anagrams in a String",
      "url": "https://leetcode.com/problems/find-all-anagrams-in-a-string/description",
      "companyTags": [
        "Amazon"
      ],
      "difficulty": "Easy",
      "content": "Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\r\n\r\nStrings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.\r\n\r\nThe order of output does not matter.\r\n\r\nExample 1:\r\n\r\nInput:\r\ns: \"cbaebabacd\" p: \"abc\"\r\n\r\nOutput:\r\n[0, 6]\r\n\r\nExplanation:\r\nThe substring with start index = 0 is \"cba\", which is an anagram of \"abc\".\r\nThe substring with start index = 6 is \"bac\", which is an anagram of \"abc\".\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput:\r\ns: \"abab\" p: \"ab\"\r\n\r\nOutput:\r\n[0, 1, 2]\r\n\r\nExplanation:\r\nThe substring with start index = 0 is \"ab\", which is an anagram of \"ab\".\r\nThe substring with start index = 1 is \"ba\", which is an anagram of \"ab\".\r\nThe substring with start index = 2 is \"ab\", which is an anagram of \"ab\".\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/563",
      "similarQuestions": [
        "ValidAnagram",
        "PermutationinString"
      ],
      "topicTags": [
        "HashTable"
      ],
      "Solution": "class Solution {\n    public List<Integer> findAnagrams(String s, String p) {\n        List<Integer> result = new ArrayList();\n        \n        int[] counts = new int[128]; \n        for (char c : p.toCharArray()) {\n            counts[c]++;\n        }\n        int count = p.length();\n        int[] sCounts = new int[128];\n        \n        final char[] sChars = s.toCharArray();\n        int start = 0;\n        for (int i = 0; i < sChars.length; i++) {\n            final char c = sChars[i];\n            sCounts[c]++;\n            count--;\n            while (sCounts[c] > counts[c]) {\n                sCounts[sChars[start++]]--;\n                count++;\n            }\n            if (count == 0) {\n                result.add(start);\n                sCounts[sChars[start++]]--;\n                count++;\n            }\n        }\n        return result;\n    }\n}",
      "total_acs": 55630,
      "total_submitted": 163727
    },
    {
      "id": 439,
      "title": "Ternary Expression Parser",
      "url": "https://leetcode.com/problems/ternary-expression-parser/description",
      "companyTags": [
        "Snapchat"
      ],
      "difficulty": "Medium",
      "content": "Given a string representing arbitrarily nested ternary expressions, calculate the result of the expression. You can always assume that the given expression is valid and only consists of digits 0-9, ?, :, T and F (T and F represent True and False respectively).\r\n\r\nNote:\r\n\r\nThe length of the given string is ≤ 10000.\r\nEach number will contain only one digit.\r\nThe conditional expressions group right-to-left (as usual in most languages).\r\nThe condition will always be either T or F. That is, the condition will never be a digit.\r\nThe result of the expression will always evaluate to either a digit 0-9, T or F.\r\n\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput: \"T?2:3\"\r\n\r\nOutput: \"2\"\r\n\r\nExplanation: If true, then result is 2; otherwise result is 3.\r\n\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: \"F?1:T?4:5\"\r\n\r\nOutput: \"4\"\r\n\r\nExplanation: The conditional expressions group right-to-left. Using parenthesis, it is read/evaluated as:\r\n\r\n             \"(F ? 1 : (T ? 4 : 5))\"                   \"(F ? 1 : (T ? 4 : 5))\"\r\n          -> \"(F ? 1 : 4)\"                 or       -> \"(T ? 4 : 5)\"\r\n          -> \"4\"                                    -> \"4\"\r\n\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput: \"T?T?F:5:3\"\r\n\r\nOutput: \"F\"\r\n\r\nExplanation: The conditional expressions group right-to-left. Using parenthesis, it is read/evaluated as:\r\n\r\n             \"(T ? (T ? F : 5) : 3)\"                   \"(T ? (T ? F : 5) : 3)\"\r\n          -> \"(T ? F : 3)\"                 or       -> \"(T ? F : 5)\"\r\n          -> \"F\"                                    -> \"F\"\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/564",
      "similarQuestions": [
        "MiniParser",
        "RemoveComments",
        "ParseLispExpression"
      ],
      "topicTags": [
        "Stack",
        "Depth-firstSearch"
      ],
      "Solution": "class Solution {\n    public String parseTernary(String expression) {\n        if (expression == null || expression.length() == 0) {\n            return expression;\n        }\n        char[] arr = expression.toCharArray();\n        return helper(arr, 0, arr.length - 1) + \"\";\n    }\n    \n    private char helper(char[] arr, int left, int right) {\n        if (left == right) {\n            return arr[left];\n        }\n        \n        int cnt = 0;\n        int i = left;\n        for (; i <= right; i++) {\n            if (arr[i] == '?') {\n                cnt++;\n            } else if (arr[i] == ':') {\n                cnt--;\n                if (cnt == 0) {\n                    break;\n                }\n            }    \n        }\n        if (arr[left] == 'T') {\n            return helper(arr, left + 2, i - 1);\n        }\n        return helper(arr, i + 1, right);\n    }\n}",
      "total_acs": 9494,
      "total_submitted": 18455
    },
    {
      "id": 440,
      "title": "K-th Smallest in Lexicographical Order",
      "url": "https://leetcode.com/problems/k-th-smallest-in-lexicographical-order/description",
      "companyTags": [
        "Hulu"
      ],
      "difficulty": "Hard",
      "content": "Given integers n and k, find the lexicographically k-th smallest integer in the range from 1 to n.\r\n\r\nNote: 1 ≤ k ≤ n ≤ 109.\r\n\r\nExample:\r\n\r\nInput:\r\nn: 13   k: 2\r\n\r\nOutput:\r\n10\r\n\r\nExplanation:\r\nThe lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.\r\n\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/565",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        ""
      ],
      "Solution": "class Solution {\n    \n    \n    int distance(long curr, long nxt, int n) {\n        int dist = 0;\n        while(n >= curr) {\n            dist += Math.min(n+1, nxt) - curr;\n            curr *= 10;\n            nxt *= 10;\n        }\n        return dist;\n    }\n\n    public int findKthNumber(int n, int k) {\n        int curr = 1;\n        k = k -1;\n        while(k > 0) {\n            int dist = distance(curr, curr+1, n);\n            if(dist <= k) {\n                curr++;\n                k -= dist;\n            } else {\n                curr *= 10;\n                k -= 1;\n            }\n        }\n        return curr;\n    }\n}",
      "total_acs": 5587,
      "total_submitted": 21802
    },
    {
      "id": 441,
      "title": "Arranging Coins",
      "url": "https://leetcode.com/problems/arranging-coins/description",
      "companyTags": [
        "GoDaddy"
      ],
      "difficulty": "Easy",
      "content": "You have a total of n coins that you want to form in a staircase shape, where every k-th row must have exactly k coins.\r\n \r\nGiven n, find the total number of full staircase rows that can be formed.\r\n\r\nn is a non-negative integer and fits within the range of a 32-bit signed integer.\r\n\r\nExample 1:\r\n\r\nn = 5\r\n\r\nThe coins can form the following rows:\r\n¤\r\n¤ ¤\r\n¤ ¤\r\n\r\nBecause the 3rd row is incomplete, we return 2.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nn = 8\r\n\r\nThe coins can form the following rows:\r\n¤\r\n¤ ¤\r\n¤ ¤ ¤\r\n¤ ¤\r\n\r\nBecause the 4th row is incomplete, we return 3.\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/567",
      "similarQuestions": [
        ""
      ],
      "topicTags": [
        "Math",
        "BinarySearch"
      ],
      "Solution": "class Solution {\n    public static int arrangeCoins(int n) {\n    \tlong nlong = (long)n;      //防止整数溢出\n        long lo = 0;\n        long hi = nlong;\n        while(lo <= hi){\n        \tlong mid = (lo + hi) / 2;\n        \tif(mid*(mid+1) < 2*nlong)    lo = mid + 1;\n        \telse if(mid*(mid+1) > 2*nlong)  hi = mid - 1;\n        \telse return (int)mid;\n        }\n        return (int)(lo - 1);\n        \n    }\n}",
      "total_acs": 41417,
      "total_submitted": 113780
    },
    {
      "id": 442,
      "title": "Find All Duplicates in an Array",
      "url": "https://leetcode.com/problems/find-all-duplicates-in-an-array/description",
      "companyTags": [
        "PocketGems"
      ],
      "difficulty": "Medium",
      "content": "Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.\r\n\r\nFind all the elements that appear twice in this array.\r\n\r\nCould you do it without extra space and in O(n) runtime?\r\n\r\nExample:\r\n\r\nInput:\r\n[4,3,2,7,8,2,3,1]\r\n\r\nOutput:\r\n[2,3]\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/568",
      "similarQuestions": [
        "FindAllNumbersDisappearedinanArray"
      ],
      "topicTags": [
        "Array"
      ],
      "Solution": "class Solution {\n    public List<Integer> findDuplicates(int[] nums) {\n        int[] map = new int[nums.length+1];\n        \n        List<Integer> res = new ArrayList<>();\n        for (int i : nums) {\n            if (map[i] == 1) res.add(i);\n            else map[i] = 1;\n        }\n        \n        return res;\n    }\n}",
      "total_acs": 50545,
      "total_submitted": 89203
    },
    {
      "id": 443,
      "title": "String Compression",
      "url": "https://leetcode.com/problems/string-compression/description",
      "companyTags": [
        "Microsoft",
        "Bloomberg",
        "Snapchat",
        "Yelp",
        "Expedia",
        "GoDaddy",
        "Lyft"
      ],
      "difficulty": "Easy",
      "content": "Given an array of characters, compress it in-place.\r\n\r\nThe length after compression must always be smaller than or equal to the original array.\r\n\r\nEvery element of the array should be a character (not int) of length 1.\r\n \r\nAfter you are done modifying the input array in-place, return the new length of the array.\r\n\r\n\r\n\r\nFollow up:\r\nCould you solve it using only O(1) extra space?\r\n\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput:\r\n[\"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\"]\r\n\r\nOutput:\r\nReturn 6, and the first 6 characters of the input array should be: [\"a\",\"2\",\"b\",\"2\",\"c\",\"3\"]\r\n\r\nExplanation:\r\n\"aa\" is replaced by \"a2\". \"bb\" is replaced by \"b2\". \"ccc\" is replaced by \"c3\".\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput:\r\n[\"a\"]\r\n\r\nOutput:\r\nReturn 1, and the first 1 characters of the input array should be: [\"a\"]\r\n\r\nExplanation:\r\nNothing is replaced.\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput:\r\n[\"a\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"]\r\n\r\nOutput:\r\nReturn 4, and the first 4 characters of the input array should be: [\"a\",\"b\",\"1\",\"2\"].\r\n\r\nExplanation:\r\nSince the character \"a\" does not repeat, it is not compressed. \"bbbbbbbbbbbb\" is replaced by \"b12\".\r\nNotice each digit has it's own entry in the array.\r\n\r\n\r\n\r\nNote:\r\n\r\nAll characters have an ASCII value in [35, 126].\r\n1 <= len(chars) <= 1000.\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/569",
      "similarQuestions": [
        "CountandSay",
        "EncodeandDecodeStrings",
        "DesignCompressedStringIterator"
      ],
      "topicTags": [
        "String"
      ],
      "Solution": "class Solution {\n    public int compress(char[] chars) {\n        int length = chars.length;\n        int write = 0;\n        if(length <= 1)\n        \treturn length;\n        char current = chars[0];\n        int num = 1;\n        for(int i = 1; i < length; i++) {\n        \tif(current == chars[i])\n        \t\tnum++;\n        \telse if(num != 1) {\n        \t\tchars[write] = current;\n        \t\twrite++;\n        \t\twhile(num/10 != 0) {\n        \t\t\tchars[write] = (char) (num/10+48);\n        \t\t\tnum = num%10;\n        \t\t\twrite++;\n        \t\t}\n        \t\tchars[write] = (char) (num+48);\n    \t\t\twrite++;\n        \t\tnum = 1;\n        \t\tcurrent = chars[i];\n        \t}\n        \telse {\n        \t\tchars[write] = current;\n        \t\twrite++;\n        \t\tcurrent = chars[i];\n        \t}\n        \t\t\n        }\n        if(num != 1) {\n    \t\tchars[write] = current;\n    \t\twrite++;\n    \t\twhile(num/10 != 0) {\n        \t\t\tchars[write] = (char) (num/10+48);\n        \t\t\tnum = num%10;\n        \t\t\twrite++;\n        \t\t}\n        \t\tchars[write] = (char) (num+48);\n    \t\t\twrite++;\n    \t}\n    \telse {\n    \t\tchars[write] = current;\n    \t\twrite++;\n    \t\t}\n        return write;\n    }\n}",
      "total_acs": 11709,
      "total_submitted": 31956
    },
    {
      "id": 444,
      "title": "Sequence Reconstruction",
      "url": "https://leetcode.com/problems/sequence-reconstruction/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Medium",
      "content": "Check whether the original sequence org can be uniquely reconstructed from the sequences in seqs. The org sequence is a permutation of the integers from 1 to n, with 1 ≤ n ≤ 104. Reconstruction means building a shortest common supersequence of the sequences in seqs (i.e., a shortest sequence so that all sequences in seqs are subsequences of it). Determine whether there is only one sequence that can be reconstructed from seqs and it is the org sequence.\r\n\r\nExample 1:\r\n\r\nInput:\r\norg: [1,2,3], seqs: [[1,2],[1,3]]\r\n\r\nOutput:\r\nfalse\r\n\r\nExplanation:\r\n[1,2,3] is not the only one sequence that can be reconstructed, because [1,3,2] is also a valid sequence that can be reconstructed.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput:\r\norg: [1,2,3], seqs: [[1,2]]\r\n\r\nOutput:\r\nfalse\r\n\r\nExplanation:\r\nThe reconstructed sequence can only be [1,2].\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput:\r\norg: [1,2,3], seqs: [[1,2],[1,3],[2,3]]\r\n\r\nOutput:\r\ntrue\r\n\r\nExplanation:\r\nThe sequences [1,2], [1,3], and [2,3] can uniquely reconstruct the original sequence [1,2,3].\r\n\r\n\r\n\r\nExample 4:\r\n\r\nInput:\r\norg: [4,1,5,2,6,3], seqs: [[5,2,6,3],[4,1,5,2]]\r\n\r\nOutput:\r\ntrue\r\n\r\n\r\n\r\n\r\nUPDATE (2017/1/8):\r\nThe seqs parameter had been changed to a list of list of strings (instead of a 2d array of strings). Please reload the code definition to get the latest changes.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/570",
      "similarQuestions": [
        "CourseScheduleII"
      ],
      "topicTags": [
        "Graph",
        "TopologicalSort"
      ],
      "Solution": "class Solution {\n    public boolean sequenceReconstruction(int[] org, List<List<Integer>> seqs) {\n        int len = org.length;\n        int[] map = new int[len+1];\n        for (int i = 0; i < len; i++) \n            // set up mapping from org val to org index \n            map[org[i]] = i;\n        int[] memo = new int[len];\n        for (List<Integer> seq : seqs) {\n            if (seq.size() == 0)\n                continue;\n            int pre = seq.get(0);\n            // every element in seq should range from 1 to len, its org index map[i] should be larger than or equal to zero\n            if (pre < 1 || pre > len || map[pre] < 0) \n                return false;\n            for (int i = 1; i < seq.size(); i++) {\n                int cur = seq.get(i);\n                if (cur < 1 || cur > len || map[cur] < 0) {\n                    return false;\n                }\n                memo[map[pre]] = Math.max(memo[map[pre]], len - map[cur] + 1);\n                pre = cur;\n            }\n            memo[map[pre]] = Math.max(memo[map[pre]], 1);\n        }\n        for (int i = 0; i < len; i++) {\n            if (memo[i] != len - i) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
      "total_acs": 9032,
      "total_submitted": 45977
    },
    {
      "id": 445,
      "title": "Add Two Numbers II",
      "url": "https://leetcode.com/problems/add-two-numbers-ii/description",
      "companyTags": [
        "Microsoft",
        "Bloomberg"
      ],
      "difficulty": "Medium",
      "content": "You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\r\n\r\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\r\n\r\nFollow up:\r\nWhat if you cannot modify the input lists? In other words, reversing the lists is not allowed.\r\n\r\n\r\n\r\nExample:\r\n\r\nInput: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)\r\nOutput: 7 -> 8 -> 0 -> 7\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/571",
      "similarQuestions": [
        "AddTwoNumbers"
      ],
      "topicTags": [
        "LinkedList"
      ],
      "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        if(l1==null||l2==null)\n            return null;\n        int len1 =0 , len2 =0;\n        ListNode  l1Temp = l1, l2Temp = l2;\n        while(l1Temp!=null){\n            l1Temp=l1Temp.next;\n            len1++;\n        }\n        while(l2Temp!=null){\n            l2Temp=l2Temp.next;\n            len2++;\n        }\n        \n    \n        int len = Math.max(len1,len2);\n        ListNode pre=null, head;\n        head = len1>len2?l1:l2;\n        while(len!=0){\n            int val1 =0 , val2 =0;\n            if(len<=len1){\n                val1 = l1.val;\n                l1 = l1.next;\n            }\n            \n            if(len<=len2){\n                val2 = l2.val;\n                l2 = l2.next;\n            }\n            \n            len--;\n            head.val = val1+val2;\n            head.next = pre;\n            pre = head;\n            head = len1>len2?l1:l2;\n        }\n        head = pre ;\n        pre = null;\n        int carry = 0;\n        while(head!=null){\n            int current = head.val+carry;\n            head.val = current%10;\n            carry = current/10;\n            \n            ListNode temp = head.next;\n            head.next = pre;\n            pre = head;\n            head = temp;\n        }\n        \n        if(carry!=0){\n            ListNode result = new ListNode(carry);\n            result.next=pre;\n            return result;\n        }\n        return pre;\n        \n    }\n}",
      "total_acs": 42846,
      "total_submitted": 92980
    },
    {
      "id": 446,
      "title": "Arithmetic Slices II - Subsequence",
      "url": "https://leetcode.com/problems/arithmetic-slices-ii-subsequence/description",
      "companyTags": [
        "Baidu"
      ],
      "difficulty": "Hard",
      "content": "A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\r\n\r\nFor example, these are arithmetic sequences:\r\n1, 3, 5, 7, 9\r\n7, 7, 7, 7\r\n3, -1, -5, -9\r\n\r\nThe following sequence is not arithmetic. 1, 1, 2, 5, 7 \r\n\r\n\r\nA zero-indexed array A consisting of N numbers is given. A subsequence slice of that array is any sequence of integers (P0, P1, ..., Pk) such that 0 ≤ P0 < P1 < ... < Pk < N.\r\n\r\nA subsequence slice (P0, P1, ..., Pk) of array A is called arithmetic if the sequence A[P0], A[P1], ..., A[Pk-1], A[Pk] is arithmetic. In particular, this means that k ≥ 2.\r\n\r\nThe function should return the number of arithmetic subsequence slices in the array A. \r\n\r\nThe input contains N integers. Every integer is in the range of -231 and 231-1 and 0 ≤ N ≤ 1000. The output is guaranteed to be less than 231-1.\r\n\r\n\r\nExample:\r\n\r\nInput: [2, 4, 6, 8, 10]\r\n\r\nOutput: 7\r\n\r\nExplanation:\r\nAll arithmetic subsequence slices are:\r\n[2,4,6]\r\n[4,6,8]\r\n[6,8,10]\r\n[2,4,6,8]\r\n[4,6,8,10]\r\n[2,4,6,8,10]\r\n[2,6,10]\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/572",
      "similarQuestions": [
        "ArithmeticSlices"
      ],
      "topicTags": [
        "DynamicProgramming"
      ],
      "Solution": "public class Solution {\r\n    public int numberOfArithmeticSlices(int[] A) {\r\n        int len = A.length, ans = 0;\r\n        if(len<3) return 0;\r\n        int[][] count = new int[len][len];\r\n        HashMap<Integer, TreeSet<Integer>> map = new HashMap<>();\r\n        for(int i = 0;i<len;++i){\r\n            if(!map.containsKey(A[i])) map.put(A[i], new TreeSet<Integer>());\r\n            map.get(A[i]).add(i);\r\n        }\r\n        for(int i = len-1;i>=0;--i){\r\n            for(int j = len-1;j>i;--j){\r\n                ans+=find(A,i,j,count,map);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n    private int find(int[] A, int i, int j, int[][] count, HashMap<Integer, TreeSet<Integer>> map){\r\n        long next = (long)A[j]*2-(long)A[i];\r\n        int ans = 0;\r\n        if(next>=(long)Integer.MIN_VALUE&&next<=(long)Integer.MAX_VALUE&&map.containsKey((int)next)){\r\n            for(int k:map.get((int)next).tailSet(j+1)) ans+=1+count[j][k];\r\n        }\r\n        return (count[i][j] = ans);\r\n    }\r\n}",
      "total_acs": 8262,
      "total_submitted": 29677
    },
    {
      "id": 447,
      "title": "Number of Boomerangs",
      "url": "https://leetcode.com/problems/number-of-boomerangs/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Easy",
      "content": "Given n points in the plane that are all pairwise distinct, a \"boomerang\" is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters).\r\n\r\nFind the number of boomerangs. You may assume that n will be at most 500 and coordinates of points are all in the range [-10000, 10000] (inclusive).\r\n\r\nExample:\r\n\r\nInput:\r\n[[0,0],[1,0],[2,0]]\r\n\r\nOutput:\r\n2\r\n\r\nExplanation:\r\nThe two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]]\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/574",
      "similarQuestions": [
        "LineReflection"
      ],
      "topicTags": [
        "HashTable"
      ],
      "Solution": "class Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        if (points == null) return 0;\n        int length = points.length;\n        if (length < 3) return 0;\n        int result = 0;\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n        for (int i = 0; i < length; i++) {\n            for (int j = 0; j < length; j++) {\n                if (i == j) continue;\n                Integer distance = (points[i][0] - points[j][0])*(points[i][0] - points[j][0]) + (points[i][1] - points[j][1])*(points[i][1] - points[j][1]);\n                int n = map.getOrDefault(distance, 0);\n                result += 2*n;\n                map.put(distance, n + 1);\n            }\n            map.clear();\n        }\n        return result;\n    }\n}",
      "total_acs": 32939,
      "total_submitted": 71117
    },
    {
      "id": 448,
      "title": "Find All Numbers Disappeared in an Array",
      "url": "https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/description",
      "companyTags": [
        "Google"
      ],
      "difficulty": "Easy",
      "content": "Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.\r\n\r\nFind all the elements of [1, n] inclusive that do not appear in this array.\r\n\r\nCould you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.\r\n\r\nExample:\r\n\r\nInput:\r\n[4,3,2,7,8,2,3,1]\r\n\r\nOutput:\r\n[5,6]\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/575",
      "similarQuestions": [
        "FirstMissingPositive",
        "FindAllDuplicatesinanArray"
      ],
      "topicTags": [
        "Array"
      ],
      "Solution": "class Solution {\n    public List<Integer> findDisappearedNumbers(int[] nums) {\n        ArrayList<Integer> a=new ArrayList();\n        int n=nums.length;\n        boolean array[]= new boolean[n+1];\n        for(int i=0;i<n;i++)\n        {\n            array[nums[i]]=true;\n            \n        }\n        for(int i=1;i<=n;i++)\n        {\n            if(array[i]==false)\n                a.add(i);\n            \n        }\n        return a;\n        \n    }\n}",
      "total_acs": 77252,
      "total_submitted": 150688
    },
    {
      "id": 449,
      "title": "Serialize and Deserialize BST",
      "url": "https://leetcode.com/problems/serialize-and-deserialize-bst/description",
      "companyTags": [
        "Amazon"
      ],
      "difficulty": "Medium",
      "content": "Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. \r\n\r\nDesign an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure.\r\n\r\n\r\nThe encoded string should be as compact as possible.\r\n\r\n\r\n\r\nNote: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/576",
      "similarQuestions": [
        "SerializeandDeserializeBinaryTree",
        "FindDuplicateSubtrees"
      ],
      "topicTags": [
        "Tree"
      ],
      "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Codec {\n    TreeNode curr;\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        curr=root;\n        return \"\";\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        return curr;\n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec codec = new Codec();\n// codec.deserialize(codec.serialize(root));",
      "total_acs": 23596,
      "total_submitted": 55079
    },
    {
      "id": 450,
      "title": "Delete Node in a BST",
      "url": "https://leetcode.com/problems/delete-node-in-a-bst/description",
      "companyTags": [
        "Uber"
      ],
      "difficulty": "Medium",
      "content": "Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.\r\n\r\nBasically, the deletion can be divided into two stages:\r\n\r\nSearch for a node to remove.\r\nIf the node is found, delete the node.\r\n\r\n\r\n\r\nNote: Time complexity should be O(height of tree).\r\n\r\nExample:\r\n\r\nroot = [5,3,6,2,4,null,7]\r\nkey = 3\r\n\r\n    5\r\n   / \\\r\n  3   6\r\n / \\   \\\r\n2   4   7\r\n\r\nGiven key to delete is 3. So we find the node with value 3 and delete it.\r\n\r\nOne valid answer is [5,4,6,2,null,null,7], shown in the following BST.\r\n\r\n    5\r\n   / \\\r\n  4   6\r\n /     \\\r\n2       7\r\n\r\nAnother valid answer is [5,2,6,null,4,null,7].\r\n\r\n    5\r\n   / \\\r\n  2   6\r\n   \\   \\\r\n    4   7\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/577",
      "similarQuestions": [
        "SplitBST"
      ],
      "topicTags": [
        "Tree"
      ],
      "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode deleteNode(TreeNode root, int key) {\n        if (root == null)\n            return null;\n        \n        if (root.val > key) {\n            root.left = deleteNode(root.left, key);\n        } else if (root.val < key) {\n            root.right = deleteNode(root.right, key);\n        } else {\n            if (root.right == null) {root = root.left;}\n            else if (root.left == null) {root = root.right;}\n            else {\n                int min = findMin(root.right);\n                root.val = min;\n                root.right = deleteNode(root.right, min);\n            }\n        }\n        return root;\n    }\n    \n    private int findMin(TreeNode root) {\n        while (root.left != null) {\n            root = root.left;\n        }\n        return root.val;\n    }\n}",
      "total_acs": 29171,
      "total_submitted": 77584
    },
    {
      "id": 451,
      "title": "Sort Characters By Frequency",
      "url": "https://leetcode.com/problems/sort-characters-by-frequency/description",
      "companyTags": [
        "Google",
        "Amazon"
      ],
      "difficulty": "Medium",
      "content": "Given a string, sort it in decreasing order based on the frequency of characters.\r\n\r\nExample 1:\r\n\r\nInput:\r\n\"tree\"\r\n\r\nOutput:\r\n\"eert\"\r\n\r\nExplanation:\r\n'e' appears twice while 'r' and 't' both appear once.\r\nSo 'e' must appear before both 'r' and 't'. Therefore \"eetr\" is also a valid answer.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput:\r\n\"cccaaa\"\r\n\r\nOutput:\r\n\"cccaaa\"\r\n\r\nExplanation:\r\nBoth 'c' and 'a' appear three times, so \"aaaccc\" is also a valid answer.\r\nNote that \"cacaca\" is incorrect, as the same characters must be together.\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput:\r\n\"Aabb\"\r\n\r\nOutput:\r\n\"bbAa\"\r\n\r\nExplanation:\r\n\"bbaA\" is also a valid answer, but \"Aabb\" is incorrect.\r\nNote that 'A' and 'a' are treated as two different characters.\r\n\r\n",
      "discussUrl": "https://discuss.leetcode.com/category/578",
      "similarQuestions": [
        "TopKFrequentElements",
        "FirstUniqueCharacterinaString"
      ],
      "topicTags": [
        "HashTable",
        "Heap"
      ],
      "Solution": "class Solution {\n    public String frequencySort(String s) {\n        int[] f = new int[256];\n        char[] chars = s.toCharArray();\n        char[] res = new char[s.length()];\n        \n        for (char c : chars) \n            f[c]++;\n        \n        for (int i = 0; i < res.length; ) {\n            int max = 0;\n            int c = 0;\n            \n            for (int j = 0; j < f.length; j++) {\n                if (f[j] > max) {\n                    max = f[j];\n                    c = j;\n                }\n            }\n            \n            f[c] = 0;\n            while (max-- > 0)\n                res[i++] = (char)c;\n        }\n        \n        return new String(res);\n    }\n}",
      "total_acs": 46752,
      "total_submitted": 90724
    }
  ]
}
