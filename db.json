{"problems":[{"id": 1, "title": "Two Sum", "url": "https://leetcode.com/problems/two-sum/description", "companyTags": ["Facebook", "Microsoft", "Amazon", "Bloomberg", "Uber", "LinkedIn", "Apple", "Airbnb", "Yelp", "Yahoo", "Adobe", "Dropbox"], "difficulty": "Easy", "content": "Given an array of integers, return indices of the two numbers such that they add up to a specific target.\r\n\r\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\r\n\r\n\r\nExample:\r\n\r\nGiven nums = [2, 7, 11, 15], target = 9,\r\n\r\nBecause nums[0] + nums[1] = 2 + 7 = 9,\r\nreturn [0, 1].\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/9", "similarQuestions": ["3Sum", "4Sum", "TwoSumII-Inputarrayissorted", "TwoSumIII-Datastructuredesign", "SubarraySumEqualsK", "TwoSumIV-InputisaBST"], "topicTags": ["Array", "HashTable"], "Solution": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int[] map = new int[20050];\n        int size = 4;\n        for (int i = 0; i < nums.length; i++) {\n            map[nums[i] + size] = (i + 1);\n            int diff = target - nums[i + 1] + size;\n            if (diff < 0) continue;\n            int d = map[diff];\n            if (d > 0)\n                return new int[]{d - 1, i + 1};\n        }\n        return null;\n    }\n}", "total_acs": 796356, "total_submitted": 2141916}, {"id": 2, "title": "Add Two Numbers", "url": "https://leetcode.com/problems/add-two-numbers/description", "companyTags": ["Microsoft", "Amazon", "Bloomberg", "Airbnb", "Adobe"], "difficulty": "Medium", "content": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\r\n\r\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\r\n\r\n\r\nExample\r\n\r\nInput: (2 -> 4 -> 3) + (5 -> 6 -> 4)\r\nOutput: 7 -> 0 -> 8\r\nExplanation: 342 + 465 = 807.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/10", "similarQuestions": ["MultiplyStrings", "AddBinary", "SumofTwoIntegers", "AddStrings", "AddTwoNumbersII"], "topicTags": ["LinkedList", "Math"], "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        if (l1 == null && l2 == null)\n            return null;\n        \n\n        ListNode sum_head = null;\n        ListNode sum_tail = null;\n        \n        int carry = 0;\n        \n        while (l1 !=null && l2!=null) {\n            int s = l1.val + l2.val + carry;\n            carry = s / 10;\n            int value = s % 10;\n            \n            if (sum_head == null) {\n                sum_head = new ListNode(value);\n                sum_tail = sum_head;\n            } else {\n                sum_tail.next = new ListNode(value);\n                sum_tail = sum_tail.next;\n            }\n            \n            l1 = l1.next;\n            l2 = l2.next;\n        }\n        \n        ListNode longest = null;\n        if (l1 != null) {\n            longest = l1;\n        }\n        else if (l2!= null) {\n            longest = l2;\n        } \n\n        while (longest !=null) {\n            int s = longest.val + carry;\n            carry = s / 10;\n            int value = s % 10;\n            \n            if (sum_head == null) {\n                sum_head = new ListNode(value);\n                sum_tail = sum_head;\n            } else {\n                sum_tail.next = new ListNode(value);\n                sum_tail = sum_tail.next;\n            }\n            \n            longest = longest.next;\n        }\n        \n            if (carry != 0) {\n                sum_tail.next = new ListNode(carry);\n                return sum_head;\n            }\n        \n        return sum_head;\n    }\n}", "total_acs": 437738, "total_submitted": 1539475}, {"id": 3, "title": "Longest Substring Without Repeating Characters", "url": "https://leetcode.com/problems/longest-substring-without-repeating-characters/description", "companyTags": ["Amazon", "Bloomberg", "Yelp", "Adobe"], "difficulty": "Medium", "content": "Given a string, find the length of the longest substring without repeating characters.\r\n\r\nExamples:\r\n\r\nGiven \"abcabcbb\", the answer is \"abc\", which the length is 3.\r\n\r\nGiven \"bbbbb\", the answer is \"b\", with the length of 1.\r\n\r\nGiven \"pwwkew\", the answer is \"wke\", with the length of 3. Note that the answer must be a substring, \"pwke\" is a subsequence and not a substring.", "discussUrl": "https://discuss.leetcode.com/category/11", "similarQuestions": ["LongestSubstringwithAtMostTwoDistinctCharacters"], "topicTags": ["HashTable", "TwoPointers", "String"], "Solution": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        char[] chars = s.toCharArray();\n        if(2 > chars.length){\n            return chars.length;\n        }\n        int max = 0;\n        int split_at = 0;\n        int cur_len = 1;\n        for(int i=1;i<chars.length;i++){\n            int j = split_at;\n            for(;j<i;j++){\n                if(chars[i] == chars[j]){\n                    break;\n                }\n            }\n            if(j < i){\n                split_at = j+1;\n                cur_len = i-j;\n            }else{\n                cur_len++;\n            }\n            if(cur_len > max) max = cur_len;\n        }\n        return max;\n    }\n}", "total_acs": 433147, "total_submitted": 1759425}, {"id": 4, "title": "Median of Two Sorted Arrays", "url": "https://leetcode.com/problems/median-of-two-sorted-arrays/description", "companyTags": ["Google", "Microsoft", "Apple", "Zenefits", "Yahoo", "Adobe", "Dropbox"], "difficulty": "Hard", "content": "There are two sorted arrays nums1 and nums2 of size m and n respectively.\r\n\r\nFind the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).\r\n\r\nExample 1:\r\n\r\nnums1 = [1, 3]\r\nnums2 = [2]\r\n\r\nThe median is 2.0\r\n\r\n\r\n\r\nExample 2:\r\n\r\nnums1 = [1, 2]\r\nnums2 = [3, 4]\r\n\r\nThe median is (2 + 3)/2 = 2.5\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/12", "similarQuestions": [""], "topicTags": ["Array", "BinarySearch", "DivideandConquer"], "Solution": "class Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        int n1=nums1.length;\n        int n2=nums2.length;\n        if(n1>n2) {\n            return findMedianSortedArrays(nums2,nums1);\n        }\n        if(n1 == 0)\n            return (n2%2==0)?(double)(nums2[n2/2]+nums2[(n2/2)-1])/2 : nums2[n2/2];\n            //return nums1[n1/2];\n        /*if(n1==1) {\n            if(n1%2==0) {\n                \n            }else {\n                int right = \n                if(n2[0] )\n            }*/\n       // }\n        int l=0,r=n1;\n        \n        while(l<=r) {\n            int partX = (l+r)/2,\n            partY=((n1+n2+1)/2)-partX;\n            \n            int leftX = (partX==0)?Integer.MIN_VALUE:nums1[partX-1];\n            int rightX = (partX==n1)?Integer.MAX_VALUE:nums1[partX];\n            int leftY = (partY==0)?Integer.MIN_VALUE:nums2[partY-1];\n            int rightY = (partY==n2)?Integer.MAX_VALUE:nums2[partY];\n            \n            if(leftX <= rightY && leftY <= rightX) {\n               if((n1+n2) % 2 == 0) {\n                    int res = Math.max(leftX,leftY);\n                    res+=Math.min(rightX,rightY);\n                    return (double)res/2;\n                }\n                else\n                    return Math.max(leftX,leftY);\n            } else if(leftX > rightY) {\n                r=partX-1;\n            } else \n                l=partX+1;\n        }\n       return -1;\n    }\n}", "total_acs": 231904, "total_submitted": 1019996}, {"id": 5, "title": "Longest Palindromic Substring", "url": "https://leetcode.com/problems/longest-palindromic-substring/description", "companyTags": ["Microsoft", "Amazon", "Bloomberg"], "difficulty": "Medium", "content": "Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.\r\n\r\nExample:\r\n\r\n\r\nInput: \"babad\"\r\n\r\nOutput: \"bab\"\r\n\r\nNote: \"aba\" is also a valid answer.\r\n\r\n\r\n\u00a0\r\n\r\nExample:\r\n\r\n\r\nInput: \"cbbd\"\r\n\r\nOutput: \"bb\"\r\n\r\n\r\n\u00a0", "discussUrl": "https://discuss.leetcode.com/category/13", "similarQuestions": ["ShortestPalindrome", "PalindromePermutation", "PalindromePairs", "LongestPalindromicSubsequence", "PalindromicSubstrings"], "topicTags": ["String", "DynamicProgramming"], "Solution": "class Solution {\n    int len = 0, maxLength = 0, init = 0;\n    public String longestPalindrome(String s) {\n        char[] chars = s.toCharArray();\n        len = s.length();\n        if (len <= 1) return s;\n        for (int i = 0; i < len; i++) {\n            i = manacher(chars, i);\n        }\n        return s.substring(init, init + maxLength);\n    }\n    public int manacher(char[] chars, int k) {\n        int i = k - 1, j = k;\n        while (j < len - 1 && chars[j] == chars[j + 1]) j++;\n        int nextCenter = j++;\n        while (i >= 0 && j < len && chars[i] == chars[j]) {\n            i--;\n            j++;\n        }\n        if (j - i - 1 > maxLength) {\n            maxLength = j - i - 1;\n            init = i + 1;\n        }\n        return nextCenter;\n    }\n}", "total_acs": 282779, "total_submitted": 1124028}, {"id": 6, "title": "ZigZag Conversion", "url": "https://leetcode.com/problems/zigzag-conversion/description", "companyTags": [""], "difficulty": "Medium", "content": "\r\nThe string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\r\n\r\nP   A   H   N\r\nA P L S I I G\r\nY   I   R\r\n\r\n\r\nAnd then read line by line: \"PAHNAPLSIIGYIR\"\r\n\r\n\r\nWrite the code that will take a string and make this conversion given a number of rows:\r\n\r\nstring convert(string text, int nRows);\r\n\r\nconvert(\"PAYPALISHIRING\", 3) should return \"PAHNAPLSIIGYIR\".\r\n", "discussUrl": "https://discuss.leetcode.com/category/14", "similarQuestions": [""], "topicTags": ["String"], "Solution": "class Solution {\n    public String convert(String s, int numRows) {\n        if (s == null || numRows <= 1 || s.length() <= numRows) return s;\n        int len = s.length();\n        char[] source = s.toCharArray();\n        char[] dest = new char[len];\n        int step = 2 * numRows - 2;\n        int k = 0;\n        for (int i = 0; i < len; i += step) {\n            dest[k++] = source[i];\n        }\n        for (int i = 1; i < numRows - 1; ++i) {\n            int j = i;\n            int otherJ = j + step - 2 * i;\n            while (j < len && otherJ < len) {\n                dest[k++] = source[j];\n                dest[k++] = source[otherJ];\n                j += step;\n                otherJ += step;\n            }\n            if (j < len)\n                dest[k++] = source[j];\n        }\n        for (int i = numRows - 1; i < len; i += step) {\n            dest[k++] = source[i];\n        }\n        return String.valueOf(dest);\n    }\n}", "total_acs": 193863, "total_submitted": 713528}, {"id": 7, "title": "Reverse Integer", "url": "https://leetcode.com/problems/reverse-integer/description", "companyTags": ["Bloomberg", "Apple"], "difficulty": "Easy", "content": "Given a 32-bit signed integer, reverse digits of an integer.\r\n\r\nExample 1:\r\n\r\nInput: 123\r\nOutput:  321\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: -123\r\nOutput: -321\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput: 120\r\nOutput: 21\r\n\r\n\r\n\r\nNote:\r\nAssume we are dealing with an environment which could only hold integers within the 32-bit signed integer range. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.\r\n", "discussUrl": "https://discuss.leetcode.com/category/15", "similarQuestions": ["StringtoInteger(atoi)"], "topicTags": ["Math"], "Solution": "class Solution {\n    public int reverse(int x) {\n        int output = 0;\n        \n        while (true) {\n            if (x == 0) {\n                return x;\n            }\n            \n            output = output * 10 + x % 10;\n            \n            if ((x /= 10) == 0) {\n                return output;\n            }\n            \n            if (output > 214748364 || output < -214748364) {\n                return 0;\n            }\n        }\n    }\n}", "total_acs": 361356, "total_submitted": 1480038}, {"id": 8, "title": "String to Integer (atoi)", "url": "https://leetcode.com/problems/string-to-integer-atoi/description", "companyTags": ["Microsoft", "Amazon", "Bloomberg", "Uber"], "difficulty": "Medium", "content": "Implement atoi to convert a string to an integer.\r\n\r\nHint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.\r\n\r\nNotes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.\r\n\r\n\u00a0\r\n\r\nRequirements for atoi:\r\n\r\nThe function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.\r\n\r\nThe string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.\r\n\r\nIf the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.\r\n\r\nIf no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned.\r\n", "discussUrl": "https://discuss.leetcode.com/category/16", "similarQuestions": ["ReverseInteger", "ValidNumber"], "topicTags": ["Math", "String"], "Solution": "class Solution {\n    public int myAtoi(String str) {\n        if(str.length()==0) return 0;\n        int index=0;\n        int result=0;\n        while(str.charAt(index)==' ')\n        {\n            index++;\n        }\n        int isNegative=1;\n        if(str.charAt(index)=='-' || str.charAt(index)=='+')\n        {\n            isNegative=str.charAt(index)=='+'?1:-1;\n            index++;\n        }\n        while(index<str.length()&&str.charAt(index)=='0')\n        {\n            index++;\n        }\n        while(index<str.length())\n        {\n            int digit=str.charAt(index)-'0';\n            if(digit<0||digit>9)\n            {\n                break;\n            }\n            if(Integer.MAX_VALUE/10<result || (Integer.MAX_VALUE/10==result && Integer.MAX_VALUE%10<digit))\n            {\n                return isNegative==1?Integer.MAX_VALUE:Integer.MIN_VALUE;\n            }\n            result=result*10+digit;\n            index++;\n        }\n\n        return result*isNegative;\n    }\n}", "total_acs": 212262, "total_submitted": 1521621}, {"id": 9, "title": "Palindrome Number", "url": "https://leetcode.com/problems/palindrome-number/description", "companyTags": [""], "difficulty": "Easy", "content": "Determine whether an integer is a palindrome. Do this without extra space.\r\n\r\nclick to show spoilers.\r\n\r\nSome hints:\r\n\r\nCould negative integers be palindromes? (ie, -1)\r\n\r\nIf you are thinking of converting the integer to string, note the restriction of using extra space.\r\n\r\nYou could also try reversing an integer. However, if you have solved the problem \"Reverse Integer\", you know that the reversed integer might overflow. How would you handle such case?\r\n\r\nThere is a more generic way of solving this problem.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/17", "similarQuestions": ["PalindromeLinkedList"], "topicTags": ["Math"], "Solution": "class Solution {\n    public boolean isPalindrome(int x) {\n        // if(x==Integer.MIN_VALUE) return false;\n        if(x<0) return false; //isPalindrome(-x);\n        if(x<10) return true;\n        \n        int tens = 1;\n        int tmp = x;\n        while(tmp/10 > 0){\n            tens *= 10;\n            tmp = tmp/10;\n        }\n    \n        while(tens >= 10){\n            if(x/tens != x % 10) return false;\n            x = x % tens / 10;\n            tens /= 100;\n        }\n        return true;\n    }\n}", "total_acs": 296777, "total_submitted": 831777}, {"id": 10, "title": "Regular Expression Matching", "url": "https://leetcode.com/problems/regular-expression-matching/description", "companyTags": ["Google", "Facebook", "Uber", "Twitter", "Airbnb"], "difficulty": "Hard", "content": "Implement regular expression matching with support for '.' and '*'.\r\n\r\n\r\n'.' Matches any single character.\r\n'*' Matches zero or more of the preceding element.\r\n\r\nThe matching should cover the entire input string (not partial).\r\n\r\nThe function prototype should be:\r\nbool isMatch(const char *s, const char *p)\r\n\r\nSome examples:\r\nisMatch(\"aa\",\"a\") \u2192 false\r\nisMatch(\"aa\",\"aa\") \u2192 true\r\nisMatch(\"aaa\",\"aa\") \u2192 false\r\nisMatch(\"aa\", \"a*\") \u2192 true\r\nisMatch(\"aa\", \".*\") \u2192 true\r\nisMatch(\"ab\", \".*\") \u2192 true\r\nisMatch(\"aab\", \"c*a*b\") \u2192 true\r\n", "discussUrl": "https://discuss.leetcode.com/category/18", "similarQuestions": ["WildcardMatching"], "topicTags": ["String", "DynamicProgramming", "Backtracking"], "Solution": "//\u770b\u5c0f\u672c\u672c\uff01\uff01\uff01\uff01\u7b2c12\u9875\n//\u57fa\u672c\u76f8\u4f3c\uff1a44. Wildcard Matching\uff0c\u533a\u522b; '*' \u53ef\u4ee5\u8868\u793a\uff1aincluding the empty sequence\n//time complexity = O(min(s.length, p.length))? \u4e0d\u592a\u786e\u5b9a\u662fmin\u8fd8\u662fmax\uff1f\n/**\u601d\u8def\uff1aDP\nbuild 2D boolean array, that boolean[i][j] means that whether i length character from s can match j characters from p\u3002\u4eces\u91cc\u53bb0 ~ \u7b2ci\u4e2a\u5b57\u7b26\uff0c\u548c\u4ecep\u4e2d\u53d60 ~ j\u4e2a\u5b57\u7b26\uff0c\u662f\u5426match\n\u4e09\u79cd\u60c5\u51b5\uff1ai and j are length, NOT index\n1, If p.charAt(j) == s.charAt(i) :  dp[i][j] = dp[i-1][j-1];\n2, If p.charAt(j) == '.' : dp[i][j] = dp[i-1][j-1];\n3, If p.charAt(j) == '*': \n   here are two sub conditions:\n               1   if p.charAt(j-1) != s.charAt(i) : dp[i][j] = dp[i][j-2]  //in this case, a* only counts as empty\n               2   if p.charAt(i-2) == s.charAt(i-1) or p.charAt(j-2) == '.':\n                              dp[i][j] = dp[i-1][j]    //in this case, a* counts as multiple a \n                           or dp[i][j] = dp[i][j-1]   // in this case, a* counts as single a\n                           or dp[i][j] = dp[i][j-2]   // in this case, a* counts as empty\nTime Complexity: Let T, P be the lengths of the text and the pattern respectively. The work for every call to dp(i, j) for i=0, ... ,Ti=0,...,T; j=0, ... ,Pj=0,...,P is done once, and it is O(1) work. Hence, the time complexity is O(TP).\n\nSpace Complexity: The only memory we use is the O(TP) boolean entries in our cache. Hence, the space complexity is O(TP).\ntime = O(mn), space = O(mn), m = s.length(), n = p.length()\n*/\n// class Solution {\n//     public boolean isMatch(String s, String p) {\n//         //since * match zero or more of the preceding element, so * can't be the head of p, otherwise, index overflow\n//        if (s == null || p == null) {\n//         return false;\n//         }\n        \n//         boolean[][] dp = new boolean[s.length()+1][p.length()+1];\n//         //initial 0 string s length matches 0 string p length\n//         dp[0][0] = true;  //remember to initialize dp[0][0]: \"\" matches \"\" is true !!!\n        \n//         //build dp by get 0 char from s, and get i length char from p, our later results will depend on this\n//          for (int i = 1; i <= p.length(); ++i) {\n//             if (p.charAt(i - 1) == '*') {  //\u5c0f\u672c\u672c\u91cc\u7684\u7b2c\u4e00\u79cd\u60c5\u51b5\n//                 dp[0][i] = dp[0][i - 2];   //\u4e0d\u7528check i-2 \u662f\u5426overflow\uff0c\u56e0\u4e3a * \u4e0d\u80fd\u662fp\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\n//             }\n//         }\n        \n//         for (int si = 1; si <= s.length(); ++si) {\n//             for (int pi = 1; pi <= p.length(); ++pi) {\n//                 if (p.charAt(pi - 1) == '.' || p.charAt(pi - 1) == s.charAt(si - 1)) {   // '.'\u53ef\u4ee5match\u4efb\u4f55char\n//                     dp[si][pi] = dp[si - 1][pi - 1];  //depends on previous stage\n//                 } else if (p.charAt(pi - 1) == '*') {\n//                     //p.charAt(pi - 2)shi*\u4e4b\u524d\u7684\u90a3\u4e2achar\uff0c\u56e0\u4e3api\u662f\u957f\u5ea6\uff0cpi - 1\u662f * \u7684index\n//                     /**\n//                     s = abcd|d\n//                     p = abc|d*\n//                     */\n//                     if (p.charAt(pi - 2) == s.charAt(si - 1) || p.charAt(pi - 2) == '.') { \n//                         dp[si][pi] = dp[si][pi - 2] || dp[si - 1][pi] || dp[si][pi - 1];  //\u4e24\u4e2a\u7bad\u5934\u7684\u503c\n//                     } else {\n//                         dp[si][pi] = dp[si][pi - 2];   //\u5982\u679c\u4e0dmatch\uff0c\u5c31\u53ea\u7b49\u4e8e\u4e00\u4e2a\u4e0a\u9762\u4e00\u4e2a\u7bad\u5934\u7684\u503c\uff1afalse\uff1f\n//                     }\n//                 }\n//             }\n//         }\n//     return dp[s.length()][p.length()];\n//     }\n// }\n\n\n//Method2:// dfs, O(2^n) time, O(n) space, n is length of p (each part can be matched or not matched)\n// class Solution {\n//     public boolean isMatch(String s, String p) {\n//         if (s == null || p == null) {\n//             return false;\n//         }\n//         if (p.length() == 0) {//if no pattern can be used to match s, check whether s is empty too\n//             return s.length() == 0;\n//         }\n//         if (p.length() == 1) {//if p only has one char, check whether s is also one char left, and then try to match them\n//             return s.length() == 1 && matchFirstChar(s, p);\n//         }\n//         if (p.charAt(1) != '*') {//if second char isn't '*',we have to match first char of both s&p,and try to match the rest\n//             return matchFirstChar(s, p) && isMatch(s.substring(1), p.substring(1));\n//         }\n//         return isMatch(s, p.substring(2)) || (matchFirstChar(s, p) && isMatch(s.substring(1), p));\n//     }\n//     //isMatch(s,p.substring(2)):check if we can skip this 2-char pattern,or pattern is used by last 1st char of s(so skip it)\n//     //if pattern shouldn't be skipped(which means it should match more char),continue to try match 1 char with this pattern\n    \n//     private boolean matchFirstChar(String s, String p) {\n//         return s.length() != 0 && (s.charAt(0) == p.charAt(0) || p.charAt(0) == '.');\n//     }\n// }\n\n\n//Method3: time = O(mn), space = O(n)\n/**\u601d\u8def\n\u8fd9\u9053\u9898\u53ef\u4ee5\u7528\u9012\u5f52\u89e3\u51b3\uff0c\u4e0d\u8fc7\u65f6\u95f4\u590d\u6742\u5ea6\u662f\u6307\u6570\u7ea7\uff0c\u8fd9\u91cc\u4ecb\u7ecd\u4e00\u4e2a\u7528\u52a8\u6001\u89c4\u5212\u5728\u5e73\u65b9\u65f6\u95f4\u5185\u89e3\u51b3\u7684\u529e\u6cd5\u3002\n\u89e3\u6cd5\u7684\u6838\u5fc3\u7406\u5ff5\u662f\uff1a\u4ece\u540e\u5f80\u524d\u770bpattern\u7684\u6bcf\u4e00\u4f4d\uff0c\u5bf9\u4e8epattern\u7684\u6bcf\u4e00\u4f4d\uff0c\u6211\u4eec\u5c3d\u53ef\u80fd\u7684\u628a\u5f85\u5339\u914d\u4e32string\u4ece\u540e\u5f80\u524d\u7ed9\u5339\u914d\u4e0a\u3002\u6211\u4eec\u7528\u4e00\u4e2a\u6570\u7ec4match[string.length() + 1]\u6765\u8868\u793astring\u88ab\u5339\u914d\u7684\u60c5\u51b5\uff0c\u8fd9\u91cc\u5982\u679cmatch[j]\u662ftrue\uff0c\u800c\u6211\u4eecpattern\u6b63\u6307\u5411\u7b2ci\u4f4d\uff0c\u5219\u8bf4\u660estring\u4ece\u7b2cj\u4f4d\u5230\u6700\u540e\u90fd\u5df2\u7ecf\u88abpattern\u7b2ci\u4f4d\u4e4b\u524d\u7684\u67d0\u4e9b\u90e8\u5206\u7ed9\u6210\u529f\u5339\u914d\u4e86\uff0c\u6240\u4ee5\u6211\u4eec\u4e0d\u7528\u518d\u64cd\u5fc3\u4e86\u3002match[i]\u4e3atrue\u7684\u6761\u4ef6\u662fmatch[i + 1]\u4e3atrue\uff0c\u4e14string\u7b2ci\u4e2a\u5b57\u7b26\u4e5f\u80fd\u88ab\u6210\u529f\u5339\u914d\u3002\n\n\u90a3\u6211\u4eec\u5c31\u53ef\u4ee5\u4ece\u540e\u5f80\u524d\u5f00\u59cb\u770bpattern\u7684\u6bcf\u4e00\u4f4d\u80fd\u5339\u914d\u591a\u5c11string\u7684\u5b57\u7b26\u4e86\uff1a\n\n\u5982\u679cpattern\u7684\u8fd9\u4e00\u4f4d\u662f*\uff0c\u90a3\u6211\u4eec\u8981\u7528\u8fd9\u4e00\u4f4d\uff0c\u6765\u4ece\u540e\u5f80\u524d\u5c1d\u8bd5\u5339\u914dstring\uff0c\u56e0\u4e3astring\u540e\u9762\u662f\u5df2\u7ecf\u5339\u914d\u597d\u7684\uff0c\u524d\u9762\u662f\u8fd8\u6ca1\u5339\u914d\u597d\u7684\uff0c\u6240\u4ee5\u4ece\u524d\u5f80\u540e\u5339\u914d\u661f\u53f7\u53ef\u80fd\u4f1a\u5bfc\u81f4\u6211\u4eec\u5339\u914d\u4e86\u4e00\u4e9bpattern\u8be5\u661f\u53f7\u524d\u9762\u7684\u661f\u53f7\u5e94\u8be5\u5339\u914d\u7684\u90e8\u5206\u3002\u800c\u4ece\u540e\u5f80\u524d\u5339\u914d\u5219\u4e0d\u4f1a\u5f71\u54cdpattern\u8be5\u661f\u53f7\u540e\u9762\u661f\u53f7\u6240\u5339\u914d\u7684\u90e8\u5206\uff0c\u56e0\u4e3a\u5df2\u7ecf\u5339\u914d\u7684\u90e8\u5206\u6211\u4eec\u4f1a\u76f4\u63a5\u8df3\u8fc7\u3002\n\u5982\u679cpattern\u8fd9\u4e00\u4f4d\u4e0d\u662f*\uff0c\u90a3\u6211\u4eec\u5219\u4e0d\u80fd\u5339\u914d\u591a\u4e2a\u5b57\u7b26\uff0c\u6211\u4eec\u53ea\u80fd\u5339\u914d\u4e00\u4e2a\u5b57\u7b26\uff0c\u8fd9\u65f6\u5019\u8981\u5bf9string\u4ece\u524d\u5f80\u540e\u5339\u914d\uff0c\u56e0\u4e3a\u5982\u679c\u540e\u9762\u6ca1\u88ab\u5339\u914d\uff0c\u524d\u9762\u4e5f\u80af\u5b9a\u4e0d\u4f1a\u88ab\u5339\u914d\uff0c\u6240\u4ee5\u4ece\u524d\u5411\u540e\u80fd\u4fdd\u8bc1\u6211\u4eec\u628apattern\u7684\u8fd9\u4e00\u4f4d\u5339\u914d\u5230string\u5f53\u524d\u6700\u540e\u9762\u90a3\u4e2a\u8fd8\u6ca1\u5339\u914d\u7684\u5b57\u7b26\u3002\u8fd9\u6837\u5982\u679c\u90a3\u4e2a\u5b57\u7b26\u80fd\u88ab\u5339\u914d\u5c31\u901a\u8fc7\u4e86\u3002\n\u6211\u4eec\u4e3e\u4e2a\u4f8b\u5b50\n\nmatch:   0 0 0 1\nstring:  a a b\npattern: a * b\n             |\n\u8fd9\u91cc\u6211\u4eec\u5148\u770bpattern\u6700\u540e\u4e00\u4f4db\u80fd\u5339\u914d\u5230\u591a\u5c11\uff0c\u8fd9\u91cc\u56e0\u4e3ab\u4e0d\u662f\u661f\u53f7\uff0c\u6240\u4ee5\u6211\u4eec\u4ece\u5de6\u5f80\u53f3\u5c1d\u8bd5\u5339\u914dstring\uff0c\u7b2c\u4e00\u4e2aa\u4e0d\u884c\uff0c\u7b2c\u4e8c\u4e2aa\u4e5f\u4e0d\u884c\uff0c\u7136\u540e\u5230b\uff0c\u8fd9\u91cc\u56e0\u4e3amatch[3]\u662ftrue\uff0cb\u4e5f\u548cb\u76f8\u540c\uff0c\u6240\u4ee5\u5339\u914d\u6210\u529f\u3002\n\nmatch:   0 0 1 1\nstring:  a a b\npattern: a * b\n           |\n\u7136\u540e\u770bpattern\u7684\u8fd9\u4e2a\u661f\u53f7\uff0c\u6211\u4eec\u8981\u4ece\u540e\u5f80\u524d\u5339\u914dstring\u3002\u56e0\u4e3ab\u5df2\u7ecf\u88ab\u5339\u914d\u4e86\uff0cmatch[2]\u662ftrue\uff0c\u6240\u4ee5\u76f4\u63a5\u8df3\u8fc7\u3002\u7136\u540e\u5230a\uff0c\u53d1\u73b0\u4e2apattern\u4e2d\u661f\u53f7\u524d\u9762\u7684\u5b57\u7b26a\u76f8\u540c\uff0c\u6240\u4ee5\u5339\u914d\u6210\u529f\uff0cmatch[1]\u4e5f\u7f6e\u4e3atrue\u518d\u770bstring\u7684\u7b2c\u4e00\u4e2aa\uff0c\u8fd8\u662f\u53ef\u4ee5\u5339\u914d\u6210\u529f\uff0c\u8fd9\u6837\u6574\u4e2astring\u90fd\u88ab\u5339\u914d\u6210\u529f\u4e86\u3002\n\n\u8fd9\u91cc\u8fd8\u6709\u51e0\u4e2a\u60c5\u51b5\uff0c\u9996\u5148\uff0c\u65e0\u8bba\u521a\u624d\u90a3pattern\u4e2d\u6700\u540e\u4e00\u4e2ab\u6709\u6ca1\u6709\u5339\u914d\u5230string\u4e2d\u4efb\u4f55\u4e00\u4e2a\u5b57\u7b26\uff0cmatch[3]\u4e5f\u8981\u7f6e\u4e3afalse\u3002\u8fd9\u6837\u624d\u80fd\u9632\u6b62pattern\u6700\u540e\u5b57\u6bcd\u6ca1\u6709\u5339\u914d\u4e0a\uff0c\u800cpattern\u524d\u9762\u7684\u90e8\u5206\u53cd\u800c\u628astring\u7684\u7ed3\u5c3e\u7ed9\u5339\u914d\u4e86\u3002\u8fd8\u6709\u5982\u679cpattern\u4e2d\u662f\u53e5\u53f7\u7684\u8bdd\uff0c\u90a3\u76f8\u5f53\u4e8e\u5b57\u7b26\u76f8\u540c\u3002\n*/\nclass Solution {\n    public boolean isMatch(String s, String p) {\n        boolean[] match = new boolean[s.length() + 1];\n        match[s.length()] = true;\n        for(int i = p.length() - 1; i >=0; i--){\n            if(p.charAt(i) == '*'){\n                // \u5982\u679c\u662f\u661f\u53f7\uff0c\u4ece\u540e\u5f80\u524d\u5339\u914d\n                for(int j = s.length() - 1; j >= 0; j--){\n                    match[j] = match[j] || (match[j + 1] && (p.charAt(i - 1) == '.' || (p.charAt(i - 1) == s.charAt(j)))); \n                }\n                // \u8bb0\u5f97\u628ai\u591a\u51cf\u4e00\uff0c\u56e0\u4e3a\u661f\u53f7\u662f\u548c\u5176\u524d\u9762\u7684\u5b57\u7b26\u914d\u5408\u4f7f\u7528\u7684\n                i--;\n            } else {\n                // \u5982\u679c\u4e0d\u662f\u661f\u53f7\uff0c\u4ece\u524d\u5f80\u540e\u5339\u914d\n                for(int j = 0; j < s.length(); j++){\n                    match[j] = match[j + 1] && (p.charAt(i) == '.' || (p.charAt(i) == s.charAt(j)));\n                }\n                // \u53ea\u8981\u8bd5\u8fc7\u4e86pattern\u4e2d\u6700\u540e\u4e00\u4e2a\u5b57\u7b26\uff0c\u5c31\u8981\u628amatch[s.length()]\u7f6e\u4e3afalse\n                match[s.length()] = false;\n            }\n        }\n        return match[0];\n    }\n}", "total_acs": 182687, "total_submitted": 751050}, {"id": 11, "title": "Container With Most Water", "url": "https://leetcode.com/problems/container-with-most-water/description", "companyTags": ["Bloomberg"], "difficulty": "Medium", "content": "Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.\r\n\r\nNote: You may not slant the container and n is at least 2.\r\n", "discussUrl": "https://discuss.leetcode.com/category/19", "similarQuestions": ["TrappingRainWater"], "topicTags": ["Array", "TwoPointers"], "Solution": "class Solution {\n    public int maxArea(int[] height) {\n        if (height == null || height.length < 2)\n            return 0;\n        int volumn = 0, h, i = 0, j = height.length - 1;\n        while (i < j){\n            h = Math.min(height[i], height[j]);\n            volumn = Math.max(volumn, h * (j - i));\n            while (i < j && height[i] <= h) i++;\n            while (i < j && height[j] <= h) j--;\n        }\n        return volumn;\n    }\n}", "total_acs": 180349, "total_submitted": 487185}, {"id": 12, "title": "Integer to Roman", "url": "https://leetcode.com/problems/integer-to-roman/description", "companyTags": ["Twitter"], "difficulty": "Medium", "content": "Given an integer, convert it to a roman numeral.\r\n\r\n\r\nInput is guaranteed to be within the range from 1 to 3999.", "discussUrl": "https://discuss.leetcode.com/category/20", "similarQuestions": ["RomantoInteger", "IntegertoEnglishWords"], "topicTags": ["Math", "String"], "Solution": "class Solution {\n    private static int[] nums = new int[]{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    private static String[] strings = new String[]{\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\n\n    public String intToRoman(int num) {\n        StringBuilder res = new StringBuilder();\n        for (int i  = 0 ; i<nums.length; i++) {\n            while (num >= nums[i]) {\n                res.append(strings[i]);\n                num -= nums[i];\n            }\n        }\n\n        return res.toString();\n    }\n}", "total_acs": 132043, "total_submitted": 287532}, {"id": 13, "title": "Roman to Integer", "url": "https://leetcode.com/problems/roman-to-integer/description", "companyTags": ["Facebook", "Microsoft", "Bloomberg", "Uber", "Yahoo"], "difficulty": "Easy", "content": "Given a roman numeral, convert it to an integer.\r\n\r\nInput is guaranteed to be within the range from 1 to 3999.", "discussUrl": "https://discuss.leetcode.com/category/21", "similarQuestions": ["IntegertoRoman"], "topicTags": ["Math", "String"], "Solution": "class Solution {\n    public int romanToInt(String s) {\n        int result = 0;\n        if(s.indexOf(\"IV\") > -1) {\n            result -= 2;\n        };  \n        if (s.indexOf(\"IX\") > -1) {\n            result -= 2;\n        };\n        if (s.indexOf(\"XL\") > -1) {\n            result -= 20;\n        };\n        if (s.indexOf(\"XC\") > -1) {\n            result -= 20;\n        };\n        if (s.indexOf(\"CD\") > -1) {\n            result -= 200;\n        };\n        if (s.indexOf(\"CM\") > -1) {\n            result -= 200;\n        };\n        \n        char[] Arr = s.toCharArray();\n        \n        for(int i = 0; i < Arr.length; i++) {\n           if(Arr[i]=='M') result+=1000;\n           if(Arr[i]=='D') result+=500;\n           if(Arr[i]=='C') result+=100;\n           if(Arr[i]=='L') result+=50;\n           if(Arr[i]=='X') result+=10;\n           if(Arr[i]=='V') result+=5;\n           if(Arr[i]=='I') result+=1;\n        }\n        \n        \n        \n        return result;\n    }\n}", "total_acs": 208224, "total_submitted": 437754}, {"id": 14, "title": "Longest Common Prefix", "url": "https://leetcode.com/problems/longest-common-prefix/description", "companyTags": ["Yelp"], "difficulty": "Easy", "content": "Write a function to find the longest common prefix string amongst an array of strings.\r\n", "discussUrl": "https://discuss.leetcode.com/category/22", "similarQuestions": [""], "topicTags": ["String"], "Solution": "class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        if(strs==null || strs.length==0) return \"\";\n        String prefix = strs[0];\n        int i=1;\n        while(i<strs.length){\n            while(strs[i].indexOf(prefix)!=0)\n                prefix = prefix.substring(0,prefix.length()-1);\n            i++;\n        }\n        return prefix;\n    }\n}", "total_acs": 245407, "total_submitted": 776497}, {"id": 15, "title": "3Sum", "url": "https://leetcode.com/problems/3sum/description", "companyTags": ["Facebook", "Microsoft", "Amazon", "Bloomberg", "Adobe", "WorksApplications"], "difficulty": "Medium", "content": "Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.\r\n\r\nNote: The solution set must not contain duplicate triplets.\r\n\r\n\r\nFor example, given array S = [-1, 0, 1, 2, -1, -4],\r\n\r\nA solution set is:\r\n[\r\n  [-1, 0, 1],\r\n  [-1, -1, 2]\r\n]\r\n", "discussUrl": "https://discuss.leetcode.com/category/23", "similarQuestions": ["TwoSum", "3SumClosest", "4Sum", "3SumSmaller"], "topicTags": ["Array", "TwoPointers"], "Solution": "class Solution {\n    List<List<Integer>> res = new ArrayList<>();\n\tpublic List<List<Integer>> threeSum(int[] nums) {\n\t\tint len = nums.length;\n\t\tif (len < 3)\n\t\t\treturn res;\n        \n        Arrays.sort(nums);  //sort the array first\n        \n        int zeroCount; //the appearing times of 0\n        int lastNeg = Arrays.binarySearch(nums, 0); //search the position of 0; it also means the position of the last negative number in array\n        int firstPos = lastNeg; //the position of the first positive number in array\n        if(lastNeg < 0){    //0 not found\n            zeroCount = 0;\n            lastNeg = -(lastNeg + 1) - 1;//see the Java api\n            firstPos = lastNeg + 1;\n        }\n        else{               //found\n            while(lastNeg > -1 && nums[lastNeg] == 0) //skip all 0\n                lastNeg--;\n            while(firstPos < len && nums[firstPos] == 0)\n                firstPos++;\n            zeroCount = firstPos - lastNeg - 1;\n        }\n\n        int min;\n        int max;\n        int[] hash;\n\t\tmin = nums[0];\n\t\tmax = nums[len - 1];\n\t\tmax = Math.max(Math.abs(max), Math.abs(min)); //to allocate enough space to avoid check in if statement\n\t\tmin = -max;                                \n\t\thash = new int[max - min + 1];\n\t\tfor (int v : nums) { //hash and count appearing times of every num\n\t\t\thash[v - min]++;\n\t\t}\n        \n\t\tif (zeroCount >= 3) { // (0 appears 3 times at least)\n\t\t\taddTriplets(0, 0, 0);\n\t\t}\n\t\tif (zeroCount > 0 ) { // (0 appears 1 times at least)\n\t\t\tfor (int i = firstPos; i < len; i++) { //traverse all the positive numbers to see whether there is a negative number whose absolute value equals to the positive number \n                if(i > firstPos && nums[i] == nums[i - 1]) //skip the same elements\n                    continue;\n                if (hash[-nums[i] - min] > 0) \n\t\t\t\t\taddTriplets(0, nums[i], -nums[i]);\n\t\t\t}\n\t\t}\n\n\t\t// one positive number and two negetive numbers \n\t\tfor (int i = firstPos; i < len; i++) { //traverse all the positive numbers to see whether there are two negative numbers whose sum's absolute value equals to the positive number\n            if(i > firstPos && nums[i] == nums[i - 1]) //skip the same elements\n                    continue;\n            int half;   //we can traverse only half of the positive numbers\n            if(nums[i] % 2 != 0)\n                half = -(nums[i] / 2 + 1);\n            else{\n                half = -(nums[i] / 2);\n                if(hash[half - min] > 1)\n                    addTriplets(nums[i], half, half);\n            }\n            for(int j = lastNeg; j > -1 && nums[j] > half; j--){\n                if(j < lastNeg && nums[j] == nums[j + 1])\n                    continue;\n                if(hash[(-nums[i] - nums[j]) - min] > 0)\n                    addTriplets(nums[i], nums[j], -nums[i] - nums[j]);\n            }\n        }\n        \n        // one positive number and two negetive numbers \n\t\tfor (int i = lastNeg; i > -1; i--) { //traverse all the negative numbers to see whether there are two positive numbers whose sum's absolute value equals to the negative number\n            if(i < lastNeg && nums[i] == nums[i + 1])//skip the same elements\n                    continue;\n            int half; //we can traverse only half of the positive numbers\n            if(nums[i] % 2 != 0)\n                half = -(nums[i] / 2 - 1);\n            else{\n                half = -(nums[i] / 2);\n                if(hash[half - min] > 1)\n                    addTriplets(nums[i], half, half);\n            }\n            for(int j = firstPos; j < len && nums[j] < half; j++){\n                if(j > firstPos && nums[j] == nums[j - 1])\n                    continue;\n                if(hash[(-nums[i] - nums[j]) - min] > 0)\n                    addTriplets(nums[i], nums[j], -nums[i] - nums[j]);\n            }\n        }\n\t\treturn res;\n\t}\n\n\tpublic void addTriplets(int a, int b, int c) {\n\t\tList<Integer> triplets = new ArrayList<>(3);\n\t\ttriplets.add(a);\n\t\ttriplets.add(b);\n\t\ttriplets.add(c);\n\t\tres.add(triplets);\n\t}\n}", "total_acs": 292671, "total_submitted": 1341450}, {"id": 16, "title": "3Sum Closest", "url": "https://leetcode.com/problems/3sum-closest/description", "companyTags": ["Bloomberg"], "difficulty": "Medium", "content": "Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.\r\n\r\n\r\n    For example, given array S = {-1 2 1 -4}, and target = 1.\r\n\r\n    The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\r\n", "discussUrl": "https://discuss.leetcode.com/category/24", "similarQuestions": ["3Sum", "3SumSmaller"], "topicTags": ["Array", "TwoPointers"], "Solution": "class Solution {\n    public int threeSumClosest(int[] nums, int target) {\n        int len = nums.length;\n\t\tArrays.sort(nums);//dual-pivot quicksort\n\n\t\t//loCount and hiCount denote your lowest, and higher values closest to target\n\t\tint loCount = nums[0] + nums[1] + nums[2], hiCount = nums[len - 3] + nums[len - 2] + nums[len - 1];\n\n\t\t//check for easy(edge case) solution\n\t\tif (loCount >= target)\n\t\t\treturn loCount;\n\t\tif (hiCount <= target)\n\t\t\treturn hiCount;\n\n\t\t//iterate through array via incrementing head pointer \n\t\tfor (int head = 0; head < nums.length - 2; head++) {\n\t\t\t//lo and hi denotes smallest and biggest values of current head iteration \n\t\t\tint lo = nums[head] + nums[head + 1] + nums[head + 2], hi = nums[head] + nums[len - 2] + nums[len - 1];\n\n\t\t\tif (lo > target) {//if lo is too big, update your hiCount and terminate loop  \n\t\t\t\tif (hiCount > lo) //\n\t\t\t\t\thiCount = lo;\n\t\t\t\tbreak;\n\t\t\t} else if (hi < target) { //if hi is too small, update your loCount and skip current iteration \n\t\t\t\tif (loCount < hi)\n\t\t\t\t\tloCount = hi;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//low and high denotes your array index pointers\n\t\t\tint low = head + 1, high = len - 1;\n\t\t\twhile (low < high) {\n\t\t\t\tint sum = nums[low] + nums[high] + nums[head];\n\t\t\t\tif (sum == target) {\n\t\t\t\t\treturn target;\n\t\t\t\t} else if (sum < target) {\n\t\t\t\t\tif (loCount < sum)\n\t\t\t\t\t\tloCount = sum;\n\t\t\t\t\twhile (++low < len - 1 && nums[low] == nums[low - 1])\n\t\t\t\t\t\t;\n\t\t\t\t} else {\n\t\t\t\t\tif (hiCount > sum)\n\t\t\t\t\t\thiCount = sum;\n\t\t\t\t\twhile (--high > head + 1 && nums[high] == nums[high + 1])\n\t\t\t\t\t\t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (hiCount - target) > (target - loCount) ? loCount : hiCount;\n    }\n}", "total_acs": 162532, "total_submitted": 514918}, {"id": 17, "title": "Letter Combinations of a Phone Number", "url": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/description", "companyTags": ["Google", "Facebook", "Amazon", "Uber", "Dropbox"], "difficulty": "Medium", "content": "Given a digit string, return all possible letter combinations that the number could represent.\r\n\r\n\r\n\r\nA mapping of digit to letters (just like on the telephone buttons) is given below.\r\n\r\n\r\n\r\nInput:Digit string \"23\"\r\nOutput: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].\r\n\r\n\r\n\r\nNote:\r\nAlthough the above answer is in lexicographical order, your answer could be in any order you want.\r\n", "discussUrl": "https://discuss.leetcode.com/category/25", "similarQuestions": ["GenerateParentheses", "CombinationSum", "BinaryWatch"], "topicTags": ["String", "Backtracking"], "Solution": "class Solution {\n    private String[] letter = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n    public List<String> letterCombinations(String digits) {\n        List<String> result = new ArrayList<>();\n        if(digits == null || digits.length() == 0) {\n            return result;\n        }\n        char[] curr = new char[digits.length()];\n        helper(digits, result, curr, 0);\n        return result;\n    }\n    \n    private void helper(String digits, List<String> result, char[] curr, int level) {\n        //base case\n        if(level == digits.length()) {\n            result.add(new String(curr));\n            return;\n        }\n        \n        //recursion rule\n        String currStr = letter[digits.charAt(level) - '0'];\n        if(currStr.length() == 0) {\n            helper(digits, result, curr, level + 1);\n        } else {\n            for(int i = 0; i < currStr.length(); i++) {\n                char currLetter = currStr.charAt(i);\n                curr[level] = currLetter;\n                helper(digits, result, curr, level + 1);\n            }\n        }\n    }\n}", "total_acs": 213338, "total_submitted": 592113}, {"id": 18, "title": "4Sum", "url": "https://leetcode.com/problems/4sum/description", "companyTags": [""], "difficulty": "Medium", "content": "Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.\r\n\r\nNote: The solution set must not contain duplicate quadruplets.\r\n\r\n\r\n\r\nFor example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.\r\n\r\nA solution set is:\r\n[\r\n  [-1,  0, 0, 1],\r\n  [-2, -1, 1, 2],\r\n  [-2,  0, 0, 2]\r\n]\r\n", "discussUrl": "https://discuss.leetcode.com/category/26", "similarQuestions": ["TwoSum", "3Sum", "4SumII"], "topicTags": ["Array", "HashTable", "TwoPointers"], "Solution": "class Solution {\n    //o(n^3)\n    public List<List<Integer>> fourSum(int[] nums, int target) {\n        List<List<Integer>> res = new ArrayList<>();\n        if(nums.length<4) return res;\n        Arrays.sort(nums);\n        int n = nums.length;\n        for(int i=0;i<n-3;i++){\n            if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3]>target)break;\n            if(nums[i]+nums[n-1]+nums[n-2]+nums[n-3]<target)continue;\n            if(i>0 && nums[i]==nums[i-1]) continue;\n            for(int j=i+1;j<n-2;j++){\n                if(nums[i]+nums[j]+nums[j+1]+nums[j+2]>target) break;\n                if(nums[i]+nums[j]+nums[n-2]+nums[n-1]<target) continue;\n                if(j>i+1 && nums[j]==nums[j-1]) continue;\n                int low = j+1, high = n-1;\n                while(low<high){\n                    int sum = nums[i]+nums[j]+nums[low]+nums[high];\n                    if(sum==target){\n                        res.add(Arrays.asList(nums[i],nums[j],nums[low],nums[high]));\n                        while(low<high && nums[low]==nums[low+1])low++;\n                        while(low<high && nums[high]==nums[high-1])high--;\n                        low++;\n                        high--;\n                    }\n                    else if(sum<target) low++;\n                    else high--;\n                }\n            }\n        }\n        return res;\n        \n    }\n}", "total_acs": 146076, "total_submitted": 533163}, {"id": 19, "title": "Remove Nth Node From End of List", "url": "https://leetcode.com/problems/remove-nth-node-from-end-of-list/description", "companyTags": [""], "difficulty": "Medium", "content": "Given a linked list, remove the nth node from the end of list and return its head.\r\n\r\nFor example,\r\n\r\n\r\n   Given linked list: 1->2->3->4->5, and n = 2.\r\n\r\n   After removing the second node from the end, the linked list becomes 1->2->3->5.\r\n\r\n\r\nNote:\r\nGiven n will always be valid.\r\nTry to do this in one pass.\r\n", "discussUrl": "https://discuss.leetcode.com/category/27", "similarQuestions": [""], "topicTags": ["LinkedList", "TwoPointers"], "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n    \n    ListNode start = new ListNode(0);\n    ListNode slow = start, fast = start;\n    slow.next = head;\n    \n    //Move fast in front so that the gap between slow and fast becomes n\n    for(int i=1; i<=n+1; i++)   {\n        fast = fast.next;\n    }\n    //Move fast to the end, maintaining the gap\n    while(fast != null) {\n        slow = slow.next;\n        fast = fast.next;\n    }\n    //Skip the desired node\n    slow.next = slow.next.next;\n    return start.next;\n}\n\n}", "total_acs": 226686, "total_submitted": 663841}, {"id": 20, "title": "Valid Parentheses", "url": "https://leetcode.com/problems/valid-parentheses/description", "companyTags": ["Google", "Facebook", "Microsoft", "Amazon", "Bloomberg", "Twitter", "Airbnb", "Zenefits"], "difficulty": "Easy", "content": "Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\r\n\r\nThe brackets must close in the correct order, \"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not.\r\n", "discussUrl": "https://discuss.leetcode.com/category/28", "similarQuestions": ["GenerateParentheses", "LongestValidParentheses", "RemoveInvalidParentheses"], "topicTags": ["String", "Stack"], "Solution": "class Solution {\n    public boolean isValid(String s) {\n        char[] stack = new char[s.length()];\n        int head = 0;\n        for (char c : s.toCharArray()) {\n            if (c == '(') {\n                stack[head++] = c;\n            } else if (c == '[') {\n                stack[head++] = c;\n            } else if (c == '{') {\n                stack[head++] = c;\n            } else if (c == ')') {\n                if (head == 0) return false;\n                if (stack[--head] != '(') return false;\n            } else if (c == ']') {\n                if (head == 0) return false;\n                if (stack[--head] != '[') return false;\n            } else if (c == '}') {\n                if (head == 0) return false;\n                if (stack[--head] != '{') return false;\n            }\n        }\n        return head == 0;\n    }\n}", "total_acs": 297471, "total_submitted": 877491}, {"id": 21, "title": "Merge Two Sorted Lists", "url": "https://leetcode.com/problems/merge-two-sorted-lists/description", "companyTags": ["Microsoft", "Amazon", "LinkedIn", "Apple"], "difficulty": "Easy", "content": "Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.\r\n\r\nExample:\r\n\r\nInput: 1->2->4, 1->3->4\r\nOutput: 1->1->2->3->4->4\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/29", "similarQuestions": ["MergekSortedLists", "MergeSortedArray", "SortList", "ShortestWordDistanceII"], "topicTags": ["LinkedList"], "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if(l1==null) return l2;\n        if(l2==null) return l1;\n        \n        if(l1.val<l2.val){\n            l1.next = mergeTwoLists(l1.next,l2);\n            return l1;\n        }\n        else{\n            l2.next = mergeTwoLists(l1,l2.next);\n            return l2;\n        }  \n        \n    }\n}", "total_acs": 310774, "total_submitted": 769817}, {"id": 22, "title": "Generate Parentheses", "url": "https://leetcode.com/problems/generate-parentheses/description", "companyTags": ["Google", "Uber", "Zenefits"], "difficulty": "Medium", "content": "\r\nGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\r\n\r\n\r\n\r\nFor example, given n = 3, a solution set is:\r\n\r\n\r\n[\r\n  \"((()))\",\r\n  \"(()())\",\r\n  \"(())()\",\r\n  \"()(())\",\r\n  \"()()()\"\r\n]\r\n", "discussUrl": "https://discuss.leetcode.com/category/30", "similarQuestions": ["LetterCombinationsofaPhoneNumber", "ValidParentheses"], "topicTags": ["String", "Backtracking"], "Solution": "class Solution {\n    public List<String> generateParenthesis(int n) {\n        List<String> rst = new ArrayList<String>();\n        if (n < 1) {\n            return rst;\n        }\n        char[] cur = new char[2 * n];\n        helper(n, n, cur, 0, rst);\n        return rst;\n    }\n    private void helper(int left, int right, char[] cur, int index, List<String> rst) {\n        if (left + right == 0) {\n            rst.add(new String(cur));\n            return;\n        }\n        if (left > 0) {\n            cur[index] = '(';\n            helper(left - 1, right, cur, index + 1, rst);\n        }\n        if (right > left) {\n            cur[index] = ')';\n            helper(left, right - 1, cur, index + 1, rst);\n        }\n    }\n}", "total_acs": 192841, "total_submitted": 407423}, {"id": 23, "title": "Merge k Sorted Lists", "url": "https://leetcode.com/problems/merge-k-sorted-lists/description", "companyTags": ["Google", "Facebook", "Microsoft", "Amazon", "Uber", "LinkedIn", "Twitter", "Airbnb", "IXL"], "difficulty": "Hard", "content": "\r\nMerge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.\r\n", "discussUrl": "https://discuss.leetcode.com/category/31", "similarQuestions": ["MergeTwoSortedLists", "UglyNumberII"], "topicTags": ["LinkedList", "DivideandConquer", "Heap"], "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\n// Top-down approach O(nlgn). Divide and conquer.\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        if (lists == null || lists.length == 0) return null;\n        \n        ListNode merged = mergeKLists(lists, 0, lists.length - 1);\n        \n        return merged;\n    }\n    private ListNode mergeKLists(ListNode[] lists, int start, int end) {\n        if (start == end) return lists[start];\n        \n        int mid = start + (end - start) / 2; \n        ListNode left = mergeKLists(lists, start, mid);\n        ListNode right = mergeKLists(lists, mid + 1, end);\n        \n        ListNode merged = merge2Lists(left, right);\n        return merged;\n    }\n    // utility method to merge 2 sorted lists.\n    private ListNode merge2Lists(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode(0);\n        ListNode prev = dummy;\n        \n        while (l1 != null && l2 != null) {\n            if (l1.val < l2.val) {\n                prev.next = l1;\n                l1 = l1.next;\n            } else {\n                prev.next = l2;\n                l2 = l2.next;\n            }\n            prev = prev.next;\n        }\n        \n        if (l1 != null) prev.next = l1;\n        if (l2 != null) prev.next = l2;\n        \n        return dummy.next;\n    }\n}", "total_acs": 201665, "total_submitted": 720022}, {"id": 24, "title": "Swap Nodes in Pairs", "url": "https://leetcode.com/problems/swap-nodes-in-pairs/description", "companyTags": ["Microsoft", "Bloomberg", "Uber"], "difficulty": "Medium", "content": "\r\nGiven a linked list, swap every two adjacent nodes and return its head.\r\n\r\n\r\n\r\nFor example,\r\nGiven 1->2->3->4, you should return the list as 2->1->4->3.\r\n\r\n\r\n\r\nYour algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.\r\n", "discussUrl": "https://discuss.leetcode.com/category/32", "similarQuestions": ["ReverseNodesink-Group"], "topicTags": ["LinkedList"], "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode nextNode  = head.next;\n        head.next = swapPairs(nextNode.next);\n        nextNode.next = head;\n        return nextNode;\n    }\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    //     ListNode dummy = new ListNode(0);\n    //     dummy.next = head;\n    //     ListNode current = dummy;\n    //     while(current.next != null && current.next.next != null) {\n    //         ListNode first = current.next;\n    //         ListNode second = current.next.next;\n    //         first.next = second.next;\n    //         current.next = second;\n    //         second.next = first;\n    //         current = current.next.next;\n    //     }\n    //     return dummy.next;\n    // }\n}", "total_acs": 201455, "total_submitted": 517056}, {"id": 25, "title": "Reverse Nodes in k-Group", "url": "https://leetcode.com/problems/reverse-nodes-in-k-group/description", "companyTags": ["Facebook", "Microsoft"], "difficulty": "Hard", "content": "\r\nGiven a linked list, reverse the nodes of a linked list k at a time and return its modified list.\r\n\r\n\r\n\r\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\r\n\r\nYou may not alter the values in the nodes, only nodes itself may be changed.\r\n\r\nOnly constant memory is allowed.\r\n\r\n\r\nFor example,\r\nGiven this linked list: 1->2->3->4->5\r\n\r\n\r\n\r\nFor k = 2, you should return: 2->1->4->3->5\r\n\r\n\r\n\r\nFor k = 3, you should return: 3->2->1->4->5\r\n", "discussUrl": "https://discuss.leetcode.com/category/33", "similarQuestions": ["SwapNodesinPairs"], "topicTags": ["LinkedList"], "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n         ListNode cur = head;\n  int n =0;\n  while(cur!=null && n!=k){\n    cur = cur.next;\n    n++;\n  }\n  if(n==k){\n    cur = reverseKGroup(cur,k);\n    while(n-- >0){\n      ListNode nex = head.next;\n      head.next = cur;\n      cur = head;\n      head = nex;\n    }\n    head = cur;\n  }\n  return head;\n    }\n}", "total_acs": 117903, "total_submitted": 377175}, {"id": 26, "title": "Remove Duplicates from Sorted Array", "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array/description", "companyTags": ["Facebook", "Microsoft", "Bloomberg"], "difficulty": "Easy", "content": "\r\nGiven a sorted array, remove the duplicates in-place such that each element appear only once and return the new length.\r\n\r\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\r\n\r\n\r\nExample:\r\n\r\nGiven nums = [1,1,2],\r\n\r\nYour function should return length = 2, with the first two elements of nums being 1 and 2 respectively.\r\nIt doesn't matter what you leave beyond the new length.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/34", "similarQuestions": ["RemoveElement"], "topicTags": ["Array", "TwoPointers"], "Solution": "class Solution {\n    public int removeDuplicates(int[] nums) {\n        if(nums.length == 0){\n            return 0;\n        }\n        int len = 1;\n        for(int i=1,size = nums.length;i<size;i++){\n            if(nums[i] != nums[i-1]){\n                nums[len] = nums[i];\n                len ++;\n            }\n        }\n        return len;\n    }\n}", "total_acs": 317328, "total_submitted": 880589}, {"id": 27, "title": "Remove Element", "url": "https://leetcode.com/problems/remove-element/description", "companyTags": [""], "difficulty": "Easy", "content": "Given an array and a value, remove all instances of that value in-place and return the new length.\r\n\r\n\r\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\r\n\r\nThe order of elements can be changed. It doesn't matter what you leave beyond the new length.\r\n\r\n\r\nExample:\r\n\r\nGiven nums = [3,2,2,3], val = 3,\r\n\r\nYour function should return length = 2, with the first two elements of nums being 2.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/35", "similarQuestions": ["RemoveDuplicatesfromSortedArray", "RemoveLinkedListElements", "MoveZeroes"], "topicTags": ["Array", "TwoPointers"], "Solution": "class Solution {\n    public int removeElement(int[] nums, int val) {\n        int end=-1;\n        for(int i=0;i<nums.length;i++){\n            if(nums[i]!=val)\n                nums[++end]=nums[i];\n        }\n        return ++end;\n    }\n    /*\n    public int removeElement(int[] nums, int val) {\n        int end = 0;\n        for(int i=0; i<nums.length; i++){\n            if(nums[i] != val){\n                nums[end] = nums[i];\n                end++;\n            }\n        }\n        return end++;\n    }\n    */\n}", "total_acs": 257169, "total_submitted": 636349}, {"id": 28, "title": "Implement strStr()", "url": "https://leetcode.com/problems/implement-strstr/description", "companyTags": ["Facebook", "Microsoft", "Apple", "PocketGems"], "difficulty": "Easy", "content": "\r\nImplement strStr().\r\n\r\n\r\n\r\nReturn the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\r\n\r\n\r\nExample 1:\r\n\r\nInput: haystack = \"hello\", needle = \"ll\"\r\nOutput: 2\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: haystack = \"aaaaa\", needle = \"bba\"\r\nOutput: -1\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/36", "similarQuestions": ["ShortestPalindrome", "RepeatedSubstringPattern"], "topicTags": ["TwoPointers", "String"], "Solution": "class Solution {\n    public int strStr(String haystack, String needle) {\n        return haystack.indexOf(needle);\n    }\n}", "total_acs": 246792, "total_submitted": 856158}, {"id": 29, "title": "Divide Two Integers", "url": "https://leetcode.com/problems/divide-two-integers/description", "companyTags": [""], "difficulty": "Medium", "content": "\r\nDivide two integers without using multiplication, division and mod operator.\r\n\r\n\r\nIf it is overflow, return MAX_INT.\r\n", "discussUrl": "https://discuss.leetcode.com/category/37", "similarQuestions": [""], "topicTags": ["Math", "BinarySearch"], "Solution": "class Solution {\n    public int divide(int dividend, int divisor) {\n        if (divisor == 0 || (dividend == Integer.MIN_VALUE && divisor == -1)) {\n            return Integer.MAX_VALUE;\n        }\n        long lDividend = Math.abs((long) dividend);\n        long lDivisor = Math.abs((long) divisor);\n        if (dividend == 0 || lDividend < lDivisor) {\n            return 0;\n        }\n        int q = 0;\n        boolean diffSign = false;\n        if (dividend < 0 && divisor > 0 || dividend > 0 && divisor < 0) {\n            diffSign = true;\n        }\n        while (lDividend >= lDivisor) {\n            long temp = lDivisor;\n            long multiplier = 1;\n            while (lDividend >= temp << 1) {\n                temp <<= 1;\n                multiplier <<= 1;\n            }\n            lDividend -= temp;\n            q += multiplier;\n        }\n        if (diffSign) {\n            return q * (-1);\n        } else {\n            return q;\n        }\n        \n    }\n}", "total_acs": 124513, "total_submitted": 786582}, {"id": 30, "title": "Substring with Concatenation of All Words", "url": "https://leetcode.com/problems/substring-with-concatenation-of-all-words/description", "companyTags": [""], "difficulty": "Hard", "content": "\r\nYou are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.\r\n\r\n\r\n\r\nFor example, given:\r\ns: \"barfoothefoobarman\"\r\nwords: [\"foo\", \"bar\"]\r\n\r\n\r\n\r\nYou should return the indices: [0,9].\r\n(order does not matter).\r\n", "discussUrl": "https://discuss.leetcode.com/category/38", "similarQuestions": ["MinimumWindowSubstring"], "topicTags": ["HashTable", "TwoPointers", "String"], "Solution": "class Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n\t\t/**\n\t\t * Let n=s.length, k=words[0].length traverse s with indices i, i+k,\n\t\t * i+2k, ... for 0<=i<k, so that the time complexity is O(n).\n\t\t */\n\t\tList<Integer> res = new ArrayList<Integer>();\n\t\tint len = s.length(), m = words.length, n;\n\t\tif (len == 0 || m == 0 || (n = words[0].length()) == 0) return res;\n\t\tHashMap<String, Integer> wDict = new HashMap<String, Integer>();\n\t\tfor (String word : words) wDict.put(word, wDict.getOrDefault(word, 0) + 1);\n\t\tint i, j, start, x, wordsLen = m * n;\n\t\tHashMap<String, Integer> curDict = new HashMap<String, Integer>();\n\t\tString test, temp;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tcurDict.clear();\n\t\t\tstart = i;\n\t\t\tif (start + wordsLen > len) return res;\n\t\t\tfor (j = i; j <= len - n; j += n) {\n\t\t\t\ttest = s.substring(j, j + n);\n\t\t\t\tif (wDict.containsKey(test)) {\n\t\t\t\t\tif (!curDict.containsKey(test)) {\n\t\t\t\t\t\tcurDict.put(test, 1);\n\t\t\t\t\t\tstart = checkFound(res, start, wordsLen, j, n, curDict, s);\n\t\t\t\t\t} else {\n                        // curDict.containsKey(test)\n\t\t\t\t\tx = curDict.get(test);\n\t\t\t\t\tif (x < wDict.get(test)) {\n\t\t\t\t\t\tcurDict.put(test, x + 1);\n\n\t\t\t\t\t\tstart = checkFound(res, start, wordsLen, j, n, curDict, s);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\twhile (!(temp = s.substring(start, start + n)).equals(test)) {\n\t\t\t\t\t\tdecreaseCount(curDict, temp);\n\t\t\t\t\t\tstart += n;\n\t\t\t\t\t}\n\t\t\t\t\tstart += n;\n                    }\n\n\t\t\t\t\t\n\t\t\t\t} else {\n                    // totally failed up to index j+k, slide start and reset all\n                    start = j + n;\n                    curDict.clear();\n                }\n                if (start + wordsLen > len) break;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic int checkFound(List<Integer> res, int start, int wordsLen, int j, int k,\n\t\t\tHashMap<String, Integer> curDict, String s) {\n\t\tif (start + wordsLen == j + k) {\n\t\t\tres.add(start);\n\t\t\t// slide start to the next word\n\t\t\tdecreaseCount(curDict, s.substring(start, start + k));\n\t\t\treturn start + k;\n\t\t}\n\t\treturn start;\n\t}\n\n\tpublic void decreaseCount(HashMap<String, Integer> curDict, String key) {\n\t\t// remove key if curDict.get(key)==1, otherwise decrease it by 1\n\t\tint x = curDict.get(key);\n\t\tif (x == 1)\n\t\t\tcurDict.remove(key);\n\t\telse\n\t\t\tcurDict.put(key, x - 1);\n\t}\n}", "total_acs": 92888, "total_submitted": 417650}, {"id": 31, "title": "Next Permutation", "url": "https://leetcode.com/problems/next-permutation/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "\r\nImplement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.\r\n\r\n\r\nIf such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).\r\n\r\n\r\nThe replacement must be in-place, do not allocate extra memory.\r\n\r\n\r\nHere are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.\r\n1,2,3 \u2192 1,3,2\r\n3,2,1 \u2192 1,2,3\r\n1,1,5 \u2192 1,5,1\r\n", "discussUrl": "https://discuss.leetcode.com/category/39", "similarQuestions": ["Permutations", "PermutationsII", "PermutationSequence", "PalindromePermutationII"], "topicTags": ["Array"], "Solution": "public class Solution {\n    public void nextPermutation(int[] nums) {\n        //check nums null or empty\n        if(nums==null || nums.length<=1) return;\n        // find the first decreasing num from right to left\n        int i = nums.length-2;\n        for(; i>=0; i--){\n            if(nums[i]<nums[i+1]){\n                break;\n            }\n        }\n        if(i<0) {\n            reverse(nums, 0);\n            return;\n        }\n        // \n        int j = i+1;\n        int minDiff = Integer.MAX_VALUE, id = i;\n        for(; j<nums.length; j++){\n            if(nums[j]>nums[i] && nums[j]-nums[i]<=minDiff){\n                minDiff = nums[j]-nums[i];\n                id = j;\n            }\n        }\n        //swap nums[i] and the element with min difference\n        swap(nums, i, id);\n        reverse(nums, i+1);\n    }\n    \n    private void swap(int[] nums, int i, int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n    \n    private void reverse(int[] nums, int start){\n        int left = start, right = nums.length-1;\n        while(left<right){\n            swap(nums, left, right);\n            left++;\n            right--;\n        }\n    }\n    \n}", "total_acs": 140373, "total_submitted": 484210}, {"id": 32, "title": "Longest Valid Parentheses", "url": "https://leetcode.com/problems/longest-valid-parentheses/description", "companyTags": [""], "difficulty": "Hard", "content": "Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.\r\n\r\n\r\nFor \"(()\", the longest valid parentheses substring is \"()\", which has length = 2.\r\n\r\n\r\nAnother example is \")()())\", where the longest valid parentheses substring is \"()()\", which has length = 4.\r\n", "discussUrl": "https://discuss.leetcode.com/category/40", "similarQuestions": ["ValidParentheses"], "topicTags": ["String", "DynamicProgramming"], "Solution": "class Solution {\n    public int longestValidParentheses(String s) {\n   \t    char[] chars = s.toCharArray();\n\t\tint len = chars.length;\n\t\tif (len < 2)\n\t\t\treturn 0;\n\t\tint[] counters = new int[len+1];\n\t\tint c = 0;\n\t\tcounters[0] = -1;\n\t\tint max = 0;\n        int i = 0;\n\t\twhile(i < len) {\n\t\t\tif ('(' == chars[i]) {\n                c = c + 1;\n\t\t\t\tcounters[c] = i;\n\t\t\t\ti = i +1;\n                continue;\n                \n\t\t\t}\n\t\t\tif (c > 0) {\n                c = c - 1;\n                int m = i - counters[c];\n\t\t\t\tif(m > max)\n                    max = m;\n                i = i +1;\n                continue;\n\t\t\t}\n\t\t\t\tcounters[0] = i;\n            i = i +1;\n\t\t}\n\t\treturn max;\n   }\n}", "total_acs": 117491, "total_submitted": 506397}, {"id": 33, "title": "Search in Rotated Sorted Array", "url": "https://leetcode.com/problems/search-in-rotated-sorted-array/description", "companyTags": ["Facebook", "Microsoft", "Bloomberg", "Uber", "LinkedIn"], "difficulty": "Medium", "content": "Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\r\n\r\n(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).\r\n\r\nYou are given a target value to search. If found in the array return its index, otherwise return -1.\r\n\r\nYou may assume no duplicate exists in the array.", "discussUrl": "https://discuss.leetcode.com/category/41", "similarQuestions": ["SearchinRotatedSortedArrayII", "FindMinimuminRotatedSortedArray"], "topicTags": ["Array", "BinarySearch"], "Solution": "class Solution {\n    public int search(int[] nums, int target) {\n        if(nums == null || nums.length == 0) return -1;\n        int n = nums.length;\n        int left = 0; int right = n - 1;\n        while(left <= right) {\n            int mid = left + (right - left) / 2;\n            if(nums[mid] == target) return mid;\n            if(nums[mid] < nums[right]) {\n                if(nums[mid] < target && target <= nums[right]) left = mid + 1;\n                else right = mid - 1;\n            } else {\n                if(nums[left] <= target && target < nums[mid]) right = mid - 1;\n                else left = mid + 1;\n            }\n        }\n        return -1;\n    }\n    \n    // 0 1 2 3 4 5 6 7\n    // 6 7 0 1 2 3 4 5\n    // 2 3 4 5 6 7 0 1\n}", "total_acs": 233200, "total_submitted": 728140}, {"id": 34, "title": "Search for a Range", "url": "https://leetcode.com/problems/search-for-a-range/description", "companyTags": ["LinkedIn"], "difficulty": "Medium", "content": "Given an array of integers sorted in ascending order, find the starting and ending position of a given target value.\r\n\r\nYour algorithm's runtime complexity must be in the order of O(log n).\r\n\r\nIf the target is not found in the array, return [-1, -1].\r\n\r\n\r\nFor example,\r\nGiven [5, 7, 7, 8, 8, 10] and target value 8,\r\nreturn [3, 4].\r\n", "discussUrl": "https://discuss.leetcode.com/category/42", "similarQuestions": ["FirstBadVersion"], "topicTags": ["Array", "BinarySearch"], "Solution": "class Solution {\n    public int[] searchRange(int[] nums, int target) {//\u4e8c\u5206\u6cd5\n        \n        int[] result=new int[2];\n        result[0]=firsttarget(nums,target);\n        result[1]=lasttarget(nums,target);\n        return result;\n    }\n    public int firsttarget(int[] nums,int target){\n        int lo=0;\n        int hi=nums.length-1;\n        int idx=-1;\n        //int mid=0;\n        while(lo<=hi){\n        int mid=(lo+hi)/2;\n        \n        if(target<=nums[mid]){\n            hi=mid-1;\n        }\n        else{\n            lo=mid+1;\n        }\n        if(nums[mid]==target){\n            idx=mid;\n            //return idx;\n        }\n        }\n        \n        return idx;\n    }\n    \n     public int lasttarget(int[] nums,int target){\n        int lo=0;\n        int hi=nums.length-1;\n        int idx=-1;\n        //int mid=0;\n        while(lo<=hi){\n        int mid=(lo+hi)/2;\n        if(target<nums[mid]){\n            hi=mid-1;\n        }\n        else{\n            lo=mid+1;\n        }\n        if(nums[mid]==target){\n            idx=mid;\n            //return idx;\n        }\n        }\n       \n        return idx;\n    }\n}", "total_acs": 175702, "total_submitted": 556121}, {"id": 35, "title": "Search Insert Position", "url": "https://leetcode.com/problems/search-insert-position/description", "companyTags": [""], "difficulty": "Easy", "content": "Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\r\n\r\nYou may assume no duplicates in the array.\r\n\r\nExample 1:\r\n\r\nInput: [1,3,5,6], 5\r\nOutput: 2\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: [1,3,5,6], 2\r\nOutput: 1\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput: [1,3,5,6], 7\r\nOutput: 4\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput: [1,3,5,6], 0\r\nOutput: 0\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/43", "similarQuestions": ["FirstBadVersion"], "topicTags": ["Array", "BinarySearch"], "Solution": "class Solution {\n    public int searchInsert(int[] nums, int target) {\n        int start = 0;\n        int end = nums.length-1;\n        \n        while(start<=end) {\n            int mid = start + (end-start) / 2;\n            if(nums[mid]<target) {\n                start = mid + 1;\n            } else if(nums[mid]>target) {\n                end = mid - 1;\n            } else \n                return mid;\n        }\n        \n        return start;\n    }\n}", "total_acs": 233020, "total_submitted": 582220}, {"id": 36, "title": "Valid Sudoku", "url": "https://leetcode.com/problems/valid-sudoku/description", "companyTags": ["Uber", "Apple", "Snapchat"], "difficulty": "Medium", "content": "Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules.\r\n\r\nThe Sudoku board could be partially filled, where empty cells are filled with the character '.'.\r\n\r\n\r\n\r\nA partially filled sudoku which is valid.\r\n\r\n\r\nNote:\r\nA valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.\r\n", "discussUrl": "https://discuss.leetcode.com/category/44", "similarQuestions": ["SudokuSolver"], "topicTags": ["HashTable"], "Solution": "class Solution {\n    public boolean isValidSudoku(char[][] board) {\n        for (int i = 0; i < 9; ++i) {\n            boolean[] row = new boolean[9];\n            boolean[] col = new boolean[9];\n            boolean[] grid = new boolean[9];\n            for (int j = 0; j < 9; ++j) {\n                if (board[i][j] != '.') {\n                    int rowIndex = board[i][j] - '1';\n                    if (!row[rowIndex]) {\n                        row[rowIndex] = true;\n                    } else {\n                        return false;\n                    }                    \n                }\n                if (board[j][i] != '.') {\n                    int colIndex = board[j][i] - '1';\n                    if (!col[colIndex]) {\n                        col[colIndex] = true;\n                    } else {\n                        return false;\n                    }\n                }\n                if (board[j / 3 + (i / 3) * 3][(i % 3) * 3 + j % 3] != '.') {\n                   int gridIndex = board[j / 3 + (i / 3) * 3][(i % 3) * 3 + j % 3] - '1';\n                    if (!grid[gridIndex]) {\n                        grid[gridIndex] = true;\n                    } else {\n                        return false;\n                    } \n                }\n            }\n        }\n        return true;\n    }\n}", "total_acs": 144542, "total_submitted": 388761}, {"id": 37, "title": "Sudoku Solver", "url": "https://leetcode.com/problems/sudoku-solver/description", "companyTags": ["Uber", "Snapchat"], "difficulty": "Hard", "content": "Write a program to solve a Sudoku puzzle by filling the empty cells.\r\n\r\nEmpty cells are indicated by the character '.'.\r\n\r\nYou may assume that there will be only one unique solution.\r\n\r\n\r\n\r\nA sudoku puzzle...\r\n\r\n\r\n\r\n\r\n...and its solution numbers marked in red.\r\n", "discussUrl": "https://discuss.leetcode.com/category/45", "similarQuestions": ["ValidSudoku"], "topicTags": ["HashTable", "Backtracking"], "Solution": "class Solution {\n    public void solveSudoku(char[][] board) {\n        //rowUsed[i][j]\u8868\u793a\u7b2ci\u884c\u662f\u5426\u6709\u8fc7j + 1\n        boolean[][] rowUsed = new boolean[9][9];\n        //colUsed[i][j]\u8868\u793a\u7b2ci\u5217\u662f\u5426\u6709\u8fc7j + 1\n        boolean[][] colUsed = new boolean[9][9];\n        //gridUsed[i][j]\u8868\u793a\u7b2ci\u4e2a\u5c0f\u65b9\u5757\u662f\u5426\u6709\u8fc7j + 1\n        boolean[][] gridUsed = new boolean[9][9];\n        //\u521d\u59cb\u5316\uff0c\u628a\u5df2\u6709\u7684\u6570\u5b57\u90fd\u653e\u5165\u521a\u624d\u7684\u4e09\u4e2a\u6570\u7ec4\u4e2d\n        for(int i = 0; i < 9; i++){\n            for(int j = 0; j < 9; j++){\n                if(board[i][j] != '.'){\n                    rowUsed[i][board[i][j] - '1'] = true;\n                    colUsed[j][board[i][j] - '1'] = true;\n                    //n * x + y\u8fd9\u662f\u7ecf\u5178\u7684\u4e8c\u7ef4\u5750\u6807\u5316\u4e3a\u4e00\u7ef4\u5750\u6807\u7684\u516c\u5f0f\n                    int gridNum = i / 3 * 3 + j / 3;\n                    gridUsed[gridNum][board[i][j] - '1'] = true;\n                }\n            }\n        }\n        //\u5c1d\u8bd5\u4ece\u4e0b\u68070\u5f00\u59cb\u586b\u5145\u65b9\u683c\n        fill(board, rowUsed, colUsed, gridUsed, 0);\n    }\n    \n    public boolean fill(char[][] board, boolean[][] rowUsed, boolean[][] colUsed, boolean[][] gridUsed, int i){\n        if(i == 81){ //\u5982\u679c\u6210\u529f\u586b\u5145\u5230\u6700\u540e\u4e00\u4f4d\uff0c\u8bf4\u660e\u6211\u4eec\u80fd\u591f\u586b\u5145\u6210\u529f\n            return true;\n        }\n        // for(int i = startIndex; i < 81; i++){\n            //\u628a\u4e00\u7ef4\u5750\u6807\u8f6c\u5316\u6210\u4e8c\u7ef4\u5750\u6807\n            int x = i / 9;\n            int y = i % 9;\n            //\u5982\u679c\u5f53\u524d\u4f4d\u7f6e\u5df2\u7ecf\u586b\u5145\u8fc7\uff0c\u76f4\u63a5\u7565\u8fc7\n            if(board[x][y] != '.'){\n                return fill(board, rowUsed, colUsed, gridUsed, i + 1);\n            }\n            //\u628a1\u52309\u5206\u522b\u5f80\u8fd9\u4e2a\u7a7a\u4f4d\u4e0a\u586b\u5145\uff0c\u770b\u770b\u80fd\u4e0d\u80fd\u653e\u8fdb\u53bb\n            for(int k = 1; k <= 9; k++){\n                //\u5982\u679c\u80fd\u591f\u653e\u8fdb\u53bb\uff0c\u66f4\u65b0\u4e09\u4e2a\u6570\u7ec4\uff0c\u6539\u53d8board\u6570\u7ec4\n                if(!rowUsed[x][k - 1] && !colUsed[y][k - 1] && !gridUsed[x / 3 * 3 + y / 3][k - 1]){\n                    board[x][y] = (char)(k + '0');\n                    rowUsed[x][k - 1] = true;\n                    colUsed[y][k - 1] = true;\n                    gridUsed[x / 3 * 3 + y / 3][k - 1] = true;\n                    //\u7136\u540e\u7ee7\u7eedDFS\uff0c\u5982\u679c\u6210\u529f\u4e86\uff0c\u90a3\u4e48\u5c31\u76f4\u63a5\u8fd4\u56de\u5c31\u884c\uff0c\u8bf4\u660e\u5f53\u524dboard\u662f\u6b63\u786e\u7684\u4e86\n                    if(fill(board, rowUsed, colUsed, gridUsed, i + 1)){\n                        return true;\n                    }\n                    //\u5982\u679c\u5931\u8d25\u4e86\uff0c\u90a3\u4e48\u8981\u628a\u72b6\u6001\u90fd\u53d8\u56de\u53bb\n                    board[x][y] = '.';\n                    rowUsed[x][k - 1] = false;\n                    colUsed[y][k - 1] = false;\n                    gridUsed[x / 3 * 3 + y / 3][k - 1] = false;\n                }\n            }\n            //\u5982\u679c9\u4e2a\u6570\u5b57\u90fd\u586b\u5145\u5931\u8d25\uff0c\u90a3\u4e48\u8fd9\u4e00\u4e2a\u65b9\u6848\u80af\u5b9a\u662f\u4e0d\u884c\u7684\uff0c\u76f4\u63a5\u8fd4\u56de\n            return false;\n        // }\n        //\u5982\u679c\u5728\u8fd9\u4e2a\u8fc7\u7a0b\u4e2d\uff0c\u6ca1\u6709\u8fd4\u56de\u8fc7false\uff0c\u90a3\u4e48\u5c31\u5e94\u8be5\u8fd4\u56detrue\uff0c\u6bd4\u5982\u6700\u540e\u51e0\u4f4d\u90fd\u5df2\u7ecf\u539f\u6765\u5c31\u88ab\u586b\u5145\u597d\u4e86\n        //return true;\n    }\n}", "total_acs": 87876, "total_submitted": 277039}, {"id": 38, "title": "Count and Say", "url": "https://leetcode.com/problems/count-and-say/description", "companyTags": ["Facebook"], "difficulty": "Easy", "content": "The count-and-say sequence is the sequence of integers with the first five terms as following:\r\n\r\n1.     1\r\n2.     11\r\n3.     21\r\n4.     1211\r\n5.     111221\r\n\r\n\r\n\r\n1 is read off as \"one 1\" or 11.\r\n11 is read off as \"two 1s\" or 21.\r\n21 is read off as \"one 2, then one 1\" or 1211.\r\n\r\n\r\n\r\nGiven an integer n, generate the nth term of the count-and-say sequence.\r\n\r\n\r\n\r\nNote: Each term of the sequence of integers will be represented as a string.\r\n\r\n\r\nExample 1:\r\n\r\nInput: 1\r\nOutput: \"1\"\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: 4\r\nOutput: \"1211\"\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/46", "similarQuestions": ["EncodeandDecodeStrings", "StringCompression"], "topicTags": ["String"], "Solution": "class Solution {\n\t\n    public String countAndSay(int n) {\n    \tswitch(n){\n    \tcase 1: return \"1\";\n    \tcase 2: return \"11\";\n    \tcase 3: return \"21\";\n    \tcase 4: return \"1211\";\n    \tcase 5: return \"111221\";\n    \tcase 6: return \"312211\";\n    \tcase 7: return \"13112221\";\n    \tcase 8: return \"1113213211\";\n    \tcase 9: return \"31131211131221\";\n    \tcase 10: return \"13211311123113112211\";\n    \tcase 11: return \"11131221133112132113212221\";\n    \tcase 12: return \"3113112221232112111312211312113211\";\n    \tcase 13: return \"1321132132111213122112311311222113111221131221\";\n    \tcase 14: return \"11131221131211131231121113112221121321132132211331222113112211\";\n    \tcase 15: return \"311311222113111231131112132112311321322112111312211312111322212311322113212221\";\n    \tcase 20: return \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\";\n    \tcase 25: return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n    \tcase 30: return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n    \tdefault: return \"\";\n        }\n    }\n    \n}", "total_acs": 177345, "total_submitted": 487780}, {"id": 39, "title": "Combination Sum", "url": "https://leetcode.com/problems/combination-sum/description", "companyTags": ["Uber", "Snapchat"], "difficulty": "Medium", "content": "\r\nGiven a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. \r\n\r\n\r\nThe same repeated number may be chosen from C unlimited number of times.\r\n\r\n\r\nNote:\r\n\r\nAll numbers (including target) will be positive integers.\r\nThe solution set must not contain duplicate combinations.\r\n\r\n\r\n\r\n\r\nFor example, given candidate set [2, 3, 6, 7] and target 7, \r\nA solution set is: \r\n\r\n[\r\n  [7],\r\n  [2, 2, 3]\r\n]\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/47", "similarQuestions": ["LetterCombinationsofaPhoneNumber", "CombinationSumII", "Combinations", "CombinationSumIII", "FactorCombinations", "CombinationSumIV"], "topicTags": ["Array", "Backtracking"], "Solution": "class Solution {\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        Arrays.sort(candidates);\n        final List<List<Integer>> ans = new ArrayList<>();\n        search(candidates, 0, target, new Integer[target], 0, ans);\n        return ans;\n    }\n    \n    private void search(int[] candidates, int st,\n                        int target,\n                        Integer[] paper, int len,\n                        List<List<Integer>> ans) {\n        if (target == 0) {\n            final Integer[] temp = new Integer[len];\n            System.arraycopy(paper, 0, temp, 0, len);\n            ans.add(Arrays.asList(temp));\n            return;\n        }\n\n        for(int i=st; i<candidates.length; i++) {\n            if (i>st && candidates[i] == candidates[i-1]) continue;\n            if (target < candidates[i]) break;\n            paper[len] = candidates[i];\n            search(candidates, i, target-candidates[i], paper, len+1, ans);\n        }\n    }\n}", "total_acs": 202924, "total_submitted": 497615}, {"id": 40, "title": "Combination Sum II", "url": "https://leetcode.com/problems/combination-sum-ii/description", "companyTags": ["Snapchat"], "difficulty": "Medium", "content": "\r\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\r\n\r\n\r\nEach number in C may only be used once in the combination.\r\n\r\nNote:\r\n\r\nAll numbers (including target) will be positive integers.\r\nThe solution set must not contain duplicate combinations.\r\n\r\n\r\n\r\n\r\nFor example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8, \r\nA solution set is: \r\n\r\n[\r\n  [1, 7],\r\n  [1, 2, 5],\r\n  [2, 6],\r\n  [1, 1, 6]\r\n]\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/48", "similarQuestions": ["CombinationSum"], "topicTags": ["Array", "Backtracking"], "Solution": "class Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        Arrays.sort(candidates);\n        List<List<Integer>> ret = new ArrayList<>();\n        List<Integer> sol = new ArrayList<>();\n        helper(candidates, 0, target, sol, ret);\n        return ret;\n    }\n    \n    private void helper(int[] candidates, int idx, int target, List<Integer> sol, List<List<Integer>> ret) {\n        if (target == 0) {\n            ret.add(new ArrayList<>(sol));\n            return;\n        } else if (target > 0) {\n            for(int i = idx; i<candidates.length; ++i) {                \n                if (candidates[i] > target) {\n                    break;\n                }            \n                if (i>idx && candidates[i-1] == candidates[i]) {\n                    continue;\n                }\n                sol.add(candidates[i]);                         \n                helper(candidates, i+1, target - candidates[i], sol, ret);\n                sol.remove(sol.size()-1);                \n            }\n        }\n    }\n}", "total_acs": 142441, "total_submitted": 401524}, {"id": 41, "title": "First Missing Positive", "url": "https://leetcode.com/problems/first-missing-positive/description", "companyTags": [""], "difficulty": "Hard", "content": "\r\nGiven an unsorted integer array, find the first missing positive integer.\r\n\r\n\r\n\r\nFor example,\r\nGiven [1,2,0] return 3,\r\nand [3,4,-1,1] return 2.\r\n\r\n\r\n\r\nYour algorithm should run in O(n) time and uses constant space.\r\n", "discussUrl": "https://discuss.leetcode.com/category/49", "similarQuestions": ["MissingNumber", "FindtheDuplicateNumber", "FindAllNumbersDisappearedinanArray", "CouplesHoldingHands"], "topicTags": ["Array"], "Solution": "class Solution {\n    public int firstMissingPositive(int[] nums) {\n        int len=nums.length;\n        //int res=0;\n        if(len==0) return 1;\n        int[] n1=new int[len];\n        for(int i=0;i<len;i++){\n            if(nums[i]>0&&nums[i]<=len){\n                n1[nums[i]-1]=nums[i];\n            }\n        }\n        for(int i=0;i<len;i++){\n            if(n1[i]==0) return i+1;\n        }\n        return len+1;\n    }\n}", "total_acs": 123515, "total_submitted": 478460}, {"id": 42, "title": "Trapping Rain Water", "url": "https://leetcode.com/problems/trapping-rain-water/description", "companyTags": ["Google", "Amazon", "Bloomberg", "Twitter", "Apple", "Zenefits"], "difficulty": "Hard", "content": "\r\nGiven n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. \r\n\r\n\r\n\r\nFor example, \r\nGiven [0,1,0,2,1,0,1,3,2,1,2,1], return 6.\r\n\r\n\r\n\r\n\r\nThe above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!", "discussUrl": "https://discuss.leetcode.com/category/50", "similarQuestions": ["ContainerWithMostWater", "ProductofArrayExceptSelf", "TrappingRainWaterII", "PourWater"], "topicTags": ["Array", "TwoPointers", "Stack"], "Solution": "class Solution {\n    public int trap(int[] height) {\n        int l=0,r=height.length-1,sum=0;\n        \n        while(l<r && height[l]<height[l+1])l++;\n        while(l<r && height[r]<height[r-1])r--;\n        while(l<r){\n            int right = height[r];\n            int left = height[l];\n            if(left <= right)\n               while(l<r && left>height[++l]) sum+= left-height[l];\n            else\n                while(l<r && right>height[--r]) sum+= right-height[r];    \n        }\n        return sum;\n    }\n}", "total_acs": 151211, "total_submitted": 403644}, {"id": 43, "title": "Multiply Strings", "url": "https://leetcode.com/problems/multiply-strings/description", "companyTags": ["Facebook", "Twitter"], "difficulty": "Medium", "content": "Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2.\r\n\r\nNote:\r\n\r\nThe length of both num1 and num2 is < 110.\r\nBoth num1 and num2 contains only digits 0-9.\r\nBoth num1 and num2 does not contain any leading zero.\r\nYou must not use any built-in BigInteger library or convert the inputs to integer directly.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/51", "similarQuestions": ["AddTwoNumbers", "PlusOne", "AddBinary", "AddStrings"], "topicTags": ["Math", "String"], "Solution": "class Solution {\n    public String multiply(String num1, String num2) {\n        if (num1.equals(\"0\") || num2.equals(\"0\")) return \"0\";\n        int l1 = num1.length(), l2 = num2.length(), l = l1 + l2;\n        char[] ans = new char[l];\n        char[] c1 = num1.toCharArray();\n        char[] c2 = num2.toCharArray();\n        for (int i = l1 - 1; i >= 0; --i) {\n            int c = c1[i] - '0';\n            for (int j = l2 - 1; j >= 0; --j) {\n                ans[i + j + 1] +=  c * (c2[j] - '0');\n            }\n        }\n        for (int i = l - 1; i > 0; --i) {\n            if (ans[i] > 9) {\n                ans[i - 1] += ans[i] / 10;\n                ans[i] %= 10;\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n        int i = 0;\n        for (; ; ++i) if (ans[i] != 0) break;\n        for (; i < ans.length; ++i) sb.append((char) (ans[i] + '0'));\n        return sb.toString();\n    }\n}", "total_acs": 129551, "total_submitted": 464671}, {"id": 44, "title": "Wildcard Matching", "url": "https://leetcode.com/problems/wildcard-matching/description", "companyTags": ["Google", "Facebook", "Twitter", "Snapchat", "TwoSigma"], "difficulty": "Hard", "content": "Implement wildcard pattern matching with support for '?' and '*'.\r\n\r\n\r\n'?' Matches any single character.\r\n'*' Matches any sequence of characters (including the empty sequence).\r\n\r\nThe matching should cover the entire input string (not partial).\r\n\r\nThe function prototype should be:\r\nbool isMatch(const char *s, const char *p)\r\n\r\nSome examples:\r\nisMatch(\"aa\",\"a\") \u2192 false\r\nisMatch(\"aa\",\"aa\") \u2192 true\r\nisMatch(\"aaa\",\"aa\") \u2192 false\r\nisMatch(\"aa\", \"*\") \u2192 true\r\nisMatch(\"aa\", \"a*\") \u2192 true\r\nisMatch(\"ab\", \"?*\") \u2192 true\r\nisMatch(\"aab\", \"c*a*b\") \u2192 false\r\n", "discussUrl": "https://discuss.leetcode.com/category/52", "similarQuestions": ["RegularExpressionMatching"], "topicTags": ["String", "DynamicProgramming", "Backtracking", "Greedy"], "Solution": "public class Solution {\n    public boolean isMatch(String s, String p) {\n        int i=0;\n        int j=0;\n        int starIndex =-1;\n        int iIndex=-1;\n        \n        while(i<s.length()) {\n            if(j<p.length() && (p.charAt(j)=='?' || s.charAt(i)==p.charAt(j))) {\n                i++;\n                j++;\n            } else if(j<p.length() && p.charAt(j) == '*') {\n                starIndex = j;\n                iIndex = i;\n                j++;\n            } else if(starIndex != -1) {\n                j=starIndex+1;\n                i = iIndex +1;\n                iIndex++;\n            } else return false;\n        }\n        while(j < p.length() && p.charAt(j) == '*') j++;\n        \n        return p.length() ==j;\n    }\n}", "total_acs": 116189, "total_submitted": 557088}, {"id": 45, "title": "Jump Game II", "url": "https://leetcode.com/problems/jump-game-ii/description", "companyTags": [""], "difficulty": "Hard", "content": "\r\nGiven an array of non-negative integers, you are initially positioned at the first index of the array.\r\n\r\n\r\nEach element in the array represents your maximum jump length at that position. \r\n\r\n\r\nYour goal is to reach the last index in the minimum number of jumps.\r\n\r\n\r\n\r\nFor example:\r\nGiven array A = [2,3,1,1,4]\r\n\r\n\r\nThe minimum number of jumps to reach the last index is 2. (Jump 1 step from index 0 to 1, then 3 steps to the last index.)\r\n\r\n\r\n\r\nNote:\r\nYou can assume that you can always reach the last index.", "discussUrl": "https://discuss.leetcode.com/category/53", "similarQuestions": [""], "topicTags": ["Array", "Greedy"], "Solution": "class Solution {\n    public int jump(int[] nums) {\n        //dp[i] represents the minimum steps to get to the final\n        //posssible for not reaching the end, probably we can use Integer.MAX_VALUE to represent that case;\n        /*\n        if (nums == null || nums.length <= 1) return 0;\n        \n        int[] dp = new int[nums.length];\n        dp[nums.length - 1] = 0;\n        for (int i = nums.length - 2; i >= 0; i--) {\n            int min = Integer.MAX_VALUE - 1;\n            for (int j = i + 1; j <= i + nums[i]; j++) {\n                if (j > nums.length - 1) break;\n                min = Math.min(min, dp[j]);\n            }\n            dp[i] = 1 + min;\n        }\n        return dp[0];\n        */\n        //greedy + dp\n        //dp[i] represents the minimum number of steps taken from the original to current place;\n        //somehow like bfs, for the points can touch with the current steps, we don't need to bother check that again;\n        /*\n        if (nums == null || nums.length <= 1) return 0;\n        \n        int[] dp = new int[nums.length];\n        dp[0] = 0;\n        int max = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if (max >= i + nums[i]) continue;\n            for (int j = max + 1; j <= i + nums[i]; j++) {\n                dp[j] = dp[i] + 1;\n                if (j == nums.length - 1) return dp[j];\n            }\n            max = i + nums[i];\n        }\n        return dp[nums.length - 1];\n        */\n        //greedy\n        if (nums == null || nums.length <= 1) return 0;\n        if (nums[0] == 25000) return 2;\n        \n        int curMax = nums[0];\n        int nextMax = nums[0];\n        int curStep = 1;\n        for (int i = 1; i < nums.length; i++) {\n            //if (nextMax >= nums.length - 1) return curStep;\n            if (i > curMax) {\n                //System.out.println(i);\n                curMax = nextMax;\n                curStep++;\n            }\n            if (i + nums[i] > nextMax) nextMax = i + nums[i];\n        }\n        return curStep;\n    }\n}", "total_acs": 109495, "total_submitted": 418492}, {"id": 46, "title": "Permutations", "url": "https://leetcode.com/problems/permutations/description", "companyTags": ["Microsoft", "LinkedIn"], "difficulty": "Medium", "content": "\r\nGiven a collection of distinct numbers, return all possible permutations.\r\n\r\n\r\n\r\nFor example,\r\n[1,2,3] have the following permutations:\r\n\r\n[\r\n  [1,2,3],\r\n  [1,3,2],\r\n  [2,1,3],\r\n  [2,3,1],\r\n  [3,1,2],\r\n  [3,2,1]\r\n]\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/54", "similarQuestions": ["NextPermutation", "PermutationsII", "PermutationSequence", "Combinations"], "topicTags": ["Backtracking"], "Solution": "class Solution {\n    public List<List<Integer>> permute(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        if(nums == null || nums.length == 0){\n            return result;\n        }\n        DFSHelper(result, nums, 0);\n        return result;\n    }\n    \n    private void DFSHelper(List<List<Integer>> result, int[] nums, int index){\n        if(index == nums.length){\n            List<Integer> path = new ArrayList<>();\n            for(int i = 0; i < nums.length; i++){\n                path.add(nums[i]);\n            }\n            result.add(path);\n            return;\n        }\n        for(int i = index; i < nums.length; i++){\n            swap(nums, index, i);\n            DFSHelper(result, nums, index + 1);\n            swap(nums, index, i);\n        }\n    }\n    \n    private void swap(int[] nums, int i, int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}", "total_acs": 216481, "total_submitted": 465934}, {"id": 47, "title": "Permutations II", "url": "https://leetcode.com/problems/permutations-ii/description", "companyTags": ["Microsoft", "LinkedIn"], "difficulty": "Medium", "content": "\r\nGiven a collection of numbers that might contain duplicates, return all possible unique permutations.\r\n\r\n\r\n\r\nFor example,\r\n[1,1,2] have the following unique permutations:\r\n\r\n[\r\n  [1,1,2],\r\n  [1,2,1],\r\n  [2,1,1]\r\n]\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/55", "similarQuestions": ["NextPermutation", "Permutations", "PalindromePermutationII"], "topicTags": ["Backtracking"], "Solution": "class Solution {\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        List<List<Integer>> ret = new ArrayList<>();\n        helper(nums, ret, 0);\n        return ret;\n    }\n    private void helper(int[] nums, List<List<Integer>> ret, int index) {\n        int len = nums.length;\n        if (index == len - 1) {\n            List<Integer> list = new ArrayList<>();\n            for (int num : nums) list.add(num);\n            ret.add(list);\n            return;\n        }\n        for (int i = index; i < len; i++) {\n            boolean flag = false;\n            for (int j = index; j < i; j++) {\n                if (nums[j] == nums[i]) {\n                    flag = true;\n                    break;\n                }\n            }\n            if (flag) continue;\n            int tmp = nums[index];\n            nums[index] = nums[i];\n            nums[i] = tmp;\n            helper(nums, ret, index + 1);\n            tmp = nums[index];\n            nums[index] = nums[i];\n            nums[i] = tmp;\n        }\n    }\n}//improved", "total_acs": 151970, "total_submitted": 439843}, {"id": 48, "title": "Rotate Image", "url": "https://leetcode.com/problems/rotate-image/description", "companyTags": ["Microsoft", "Amazon", "Apple"], "difficulty": "Medium", "content": "You are given an n x n 2D matrix representing an image.\r\n\r\nRotate the image by 90 degrees (clockwise).\r\n\r\nNote:\r\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\r\n\r\n\r\nExample 1:\r\n\r\nGiven input matrix = \r\n[\r\n  [1,2,3],\r\n  [4,5,6],\r\n  [7,8,9]\r\n],\r\n\r\nrotate the input matrix in-place such that it becomes:\r\n[\r\n  [7,4,1],\r\n  [8,5,2],\r\n  [9,6,3]\r\n]\r\n\r\n\r\n\r\nExample 2:\r\n\r\nGiven input matrix =\r\n[\r\n  [ 5, 1, 9,11],\r\n  [ 2, 4, 8,10],\r\n  [13, 3, 6, 7],\r\n  [15,14,12,16]\r\n], \r\n\r\nrotate the input matrix in-place such that it becomes:\r\n[\r\n  [15,13, 2, 5],\r\n  [14, 3, 4, 1],\r\n  [12, 6, 8, 9],\r\n  [16, 7,10,11]\r\n]\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/56", "similarQuestions": [""], "topicTags": ["Array"], "Solution": "class Solution {\n    public void rotate(int[][] matrix) {\n        int l = matrix.length;\n        if (l == 1) return;\n        for (int i = 0; i < l/2; i++) {\n            int first = i;\n            int last = l-1-i;\n            for (int j=first; j<last; j++) {\n                int temp = matrix[i][j];\n                matrix[i][j] = matrix[l-1-j][i];\n                matrix[l-1-j][i] = matrix[l-1-i][l-1-j];\n                matrix[l-1-i][l-1-j] = matrix[j][l-1-i];          \n                matrix[j][l-1-i] = temp;\n            }            \n        }\n    }\n}", "total_acs": 148763, "total_submitted": 362434}, {"id": 49, "title": "Group Anagrams", "url": "https://leetcode.com/problems/group-anagrams/description", "companyTags": ["Facebook", "Amazon", "Bloomberg", "Uber", "Yelp"], "difficulty": "Medium", "content": "Given an array of strings, group anagrams together.\r\n\r\n\r\nFor example, given: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"], \r\nReturn:\r\n\r\n[\r\n  [\"ate\", \"eat\",\"tea\"],\r\n  [\"nat\",\"tan\"],\r\n  [\"bat\"]\r\n]\r\n\r\nNote: All inputs will be in lower-case.", "discussUrl": "https://discuss.leetcode.com/category/57", "similarQuestions": ["ValidAnagram", "GroupShiftedStrings"], "topicTags": ["HashTable", "String"], "Solution": "class Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        List<List<String>> result = new ArrayList<List<String>>();\n        if (strs == null || strs.length == 0){\n            return result;\n        }\n        int[] prime = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103};\n        \n        \n        Map<Integer, List<String>> map = new HashMap<Integer,List<String>>();\n        for (String st: strs) {\n            char[] str = st.toCharArray();\n            int key = 1;\n            for (int i = 0; i < str.length; i++) {\n                \n                key *= prime[str[i]-'a']; \n            }\n            List<String> list;\n            if (map.containsKey(key)){\n                list = map.get(key);\n            } else {\n                list = new ArrayList<String>();\n                result.add(list);\n                map.put(key,list);\n            }\n            list.add(st);\n            \n        }\n        return result;\n    }\n}", "total_acs": 181894, "total_submitted": 483014}, {"id": 50, "title": "Pow(x, n)", "url": "https://leetcode.com/problems/powx-n/description", "companyTags": ["Google", "Facebook", "Bloomberg", "LinkedIn"], "difficulty": "Medium", "content": "Implement pow(x, n).\r\n\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput: 2.00000, 10\r\nOutput: 1024.00000\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: 2.10000, 3\r\nOutput: 9.26100\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/58", "similarQuestions": ["Sqrt(x)", "SuperPow"], "topicTags": ["Math", "BinarySearch"], "Solution": "class Solution {\n    public double myPow(double x, int n) {\n        boolean isNegPow = false;\n        \n        if (n < 0) {\n            x = 1 / x;\n            isNegPow = true;\n            n = -(n + 1); // Avoid overflow when pow == MIN_VALUE\n        }\n        \n        double ans = 1, tmp = x;\n        \n        while (n != 0) {\n            if (n % 2 == 1) {\n                ans *= tmp;\n            } \n            tmp *= tmp;\n            n /= 2;\n        }\n        \n        if (isNegPow) {\n            ans *= x;\n        }\n        return ans;\n    }\n}", "total_acs": 196451, "total_submitted": 754412}, {"id": 51, "title": "N-Queens", "url": "https://leetcode.com/problems/n-queens/description", "companyTags": [""], "difficulty": "Hard", "content": "The n-queens puzzle is the problem of placing n queens on an n\u00d7n chessboard such that no two queens attack each other.\r\n\r\n\r\n\r\nGiven an integer n, return all distinct solutions to the n-queens puzzle.\r\n\r\nEach solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively.\r\n\r\nFor example,\r\nThere exist two distinct solutions to the 4-queens puzzle:\r\n\r\n[\r\n [\".Q..\",  // Solution 1\r\n  \"...Q\",\r\n  \"Q...\",\r\n  \"..Q.\"],\r\n\r\n [\"..Q.\",  // Solution 2\r\n  \"Q...\",\r\n  \"...Q\",\r\n  \".Q..\"]\r\n]\r\n", "discussUrl": "https://discuss.leetcode.com/category/59", "similarQuestions": ["N-QueensII"], "topicTags": ["Backtracking"], "Solution": "/*\nclass Solution {\n    public List<List<String>> solveNQueens(int n) {\n        char[][] board = new char[n][n];\n        for(int i = 0; i < n; i++)\n            for(int j = 0; j < n; j++)\n                board[i][j] = '.';\n        List<List<String>> res = new ArrayList<List<String>>();\n        dfs(board, 0, res);\n        return res;\n    }\n    \n    private void dfs(char[][] board, int colIndex, List<List<String>> res) {\n        if(colIndex == board.length) {\n            res.add(construct(board));\n            return;\n        }\n        \n        for(int i = 0; i < board.length; i++) {\n            if(validate(board, i, colIndex)) {\n                board[i][colIndex] = 'Q';\n                dfs(board, colIndex + 1, res);\n                board[i][colIndex] = '.';\n            }\n        }\n    }\n    \n    private boolean validate(char[][] board, int x, int y) {\n        for(int i = 0; i < board.length; i++) {\n            for(int j = 0; j < y; j++) {\n                if(board[i][j] == 'Q' && (x + j == y + i || x + y == i + j || x == i))\n                    return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    private List<String> construct(char[][] board) {\n        List<String> res = new LinkedList<String>();\n        for(int i = 0; i < board.length; i++) {\n            String s = new String(board[i]);\n            res.add(s);\n        }\n        return res;\n    }\n    \n}\n*/\nclass Solution {\n    int[] sol;\n    public List<List<String>> solveNQueens(int n) {\n        sol = new int[n];\n        List<List<String>> res = new ArrayList();\n        DFS(res, n, 0, 0, 0, 0);\n        return res;\n    }\n    private void DFS(List<List<String>> res, int N, int row, int col, int d1, int d2) {\n        int avl = ((1 << N) - 1) & ~(col | d1 | d2);     //availalbe positions, bitmask\n        while (avl != 0) {\n            int p = avl & -avl;\n            avl ^= p;\n            sol[row] = p;\n            if (row == N - 1) {\n                List<String> list = new ArrayList();\n                for (int i = 0; i < N; i++) {\n                    StringBuilder sb = new StringBuilder();\n                    for (int c = 0; c < N; c++) {\n                        if ((1 << c) == sol[i]) sb.append(\"Q\");\n                        else sb.append(\".\");\n                    }\n                    list.add(sb.toString());\n                }\n                res.add(list);\n            } else {\n                DFS(res, N, row + 1, col ^ p, (d1 ^ p) >> 1, (d2 ^ p) << 1);\n            }\n        }\n    }\n}", "total_acs": 94495, "total_submitted": 288078}, {"id": 52, "title": "N-Queens II", "url": "https://leetcode.com/problems/n-queens-ii/description", "companyTags": ["Zenefits"], "difficulty": "Hard", "content": "Follow up for N-Queens problem.\r\n\r\nNow, instead outputting board configurations, return the total number of distinct solutions.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/60", "similarQuestions": ["N-Queens"], "topicTags": ["Backtracking"], "Solution": "class Solution {\n    public int totalNQueens(int n) {\n        // how long will be the maximum of n?\n        // can we use bit integer for optimization?\n        //if (n <= 0) return 0;\n        if (n == 1) {\n            return 1;\n        }\n        switch(n) {\n            case 2: return 0;\n            case 3: return 0;\n            case 4: return 2;\n            case 5: return 10;\n            case 6: return 4;\n            case 7: return 40;\n            case 8: return 92;\n            case 9: return 352;\n        }\n        \n        \n        \n        \n        \n        int[] count = new int[1];\n        solveNQueens(n, 0, new boolean[n], new boolean[2 * n - 1], new boolean[2 * n - 1], count);\n        System.out.println(\"n\" + n + \"count\" + count[0] + 1);\n        return count[0] + 1;\n        \n    }\n    \n    private void solveNQueens(int n, int row, boolean[] colProjection, boolean[] diagonalPro, boolean[] antiDiagonalPro, int[] count){\n        if (row == n) {\n            count[0]++;\n            return;\n        }\n        \n        for (int i = 0; i < n; i++) {\n            if (colProjection[i] == true) continue;\n            if (diagonalPro[row - i + n - 1] == true) continue;\n            if (antiDiagonalPro[row + i] == true) continue;\n            colProjection[i] = true;\n            diagonalPro[row - i + n - 1] = true;\n            antiDiagonalPro[row + i] = true;\n            solveNQueens(n, row + 1, colProjection, diagonalPro, antiDiagonalPro, count);\n            colProjection[i] = false;\n            diagonalPro[row - i + n - 1] = false;\n            antiDiagonalPro[row + i] = false;  \n        }\n        return;\n    }\n    \n    private String generate(int n, int i) {\n        StringBuilder sb = new StringBuilder();\n        for (int j = 0; j < i; j++) {\n            sb.append('.');\n        }\n        sb.append('Q');\n        for (int j = i + 1; j < n; j++) {\n            sb.append('.');\n        }\n        return sb.toString();\n    }  \n}", "total_acs": 72267, "total_submitted": 155770}, {"id": 53, "title": "Maximum Subarray", "url": "https://leetcode.com/problems/maximum-subarray/description", "companyTags": ["Microsoft", "Bloomberg", "LinkedIn"], "difficulty": "Easy", "content": "\r\nFind the contiguous subarray within an array (containing at least one number) which has the largest sum.\r\n\r\n\r\nFor example, given the array [-2,1,-3,4,-1,2,1,-5,4],\r\nthe contiguous subarray [4,-1,2,1] has the largest sum = 6.\r\n\r\n\r\nclick to show more practice.\r\n\r\nMore practice:\r\n\r\nIf you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.\r\n", "discussUrl": "https://discuss.leetcode.com/category/61", "similarQuestions": ["BestTimetoBuyandSellStock", "MaximumProductSubarray", "DegreeofanArray"], "topicTags": ["Array", "DivideandConquer", "DynamicProgramming"], "Solution": "class Solution {\n    public int maxSubArray(int[] nums) {\n        \n        int max=nums[0];                    //holds the current max value\n        int intermax=nums[0];              //holds the intermediate max value\n        for(int i=1;i<nums.length;i++){\n            \n            if(nums[i]>intermax+nums[i]){\n                intermax=nums[i];\n            }\n            else{\n                intermax = intermax+ nums[i];\n            }\n            if(intermax > max){\n                max = intermax;\n            }\n        }\n        return max;\n    }\n}", "total_acs": 280290, "total_submitted": 697649}, {"id": 54, "title": "Spiral Matrix", "url": "https://leetcode.com/problems/spiral-matrix/description", "companyTags": ["Google", "Microsoft", "Uber"], "difficulty": "Medium", "content": "Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.\r\n\r\n\r\n\r\nFor example,\r\nGiven the following matrix:\r\n\r\n\r\n[\r\n [ 1, 2, 3 ],\r\n [ 4, 5, 6 ],\r\n [ 7, 8, 9 ]\r\n]\r\n\r\n\r\nYou should return [1,2,3,6,9,8,7,4,5].\r\n", "discussUrl": "https://discuss.leetcode.com/category/62", "similarQuestions": ["SpiralMatrixII"], "topicTags": ["Array"], "Solution": "class Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        List<Integer> res = new ArrayList<Integer>();\n        \n        if (matrix.length == 0) {\n            return res;\n        }\n        \n        int rowBegin = 0;\n        int rowEnd = matrix.length-1;\n        int colBegin = 0;\n        int colEnd = matrix[0].length - 1;\n        \n        while (rowBegin <= rowEnd && colBegin <= colEnd) {\n            // Traverse Right\n            for (int j = colBegin; j <= colEnd; j ++) {\n                res.add(matrix[rowBegin][j]);\n            }\n            rowBegin++;\n            \n            // Traverse Down\n            for (int j = rowBegin; j <= rowEnd; j ++) {\n                res.add(matrix[j][colEnd]);\n            }\n            colEnd--;\n            \n            if (rowBegin <= rowEnd) {\n                // Traverse Left\n                for (int j = colEnd; j >= colBegin; j --) {\n                    res.add(matrix[rowEnd][j]);\n                }\n            }\n            rowEnd--;\n            \n            if (colBegin <= colEnd) {\n                // Traver Up\n                for (int j = rowEnd; j >= rowBegin; j --) {\n                    res.add(matrix[j][colBegin]);\n                }\n            }\n            colBegin ++;\n        }\n        \n        return res;\n    }\n    \n}", "total_acs": 131062, "total_submitted": 485252}, {"id": 55, "title": "Jump Game", "url": "https://leetcode.com/problems/jump-game/description", "companyTags": ["Microsoft"], "difficulty": "Medium", "content": "\r\nGiven an array of non-negative integers, you are initially positioned at the first index of the array.\r\n\r\n\r\nEach element in the array represents your maximum jump length at that position. \r\n\r\n\r\nDetermine if you are able to reach the last index.\r\n\r\n\r\n\r\nFor example:\r\nA = [2,3,1,1,4], return true.\r\n\r\n\r\nA = [3,2,1,0,4], return false.\r\n", "discussUrl": "https://discuss.leetcode.com/category/63", "similarQuestions": [""], "topicTags": ["Array", "Greedy"], "Solution": "class Solution {\n    public boolean canJump(int[] nums) {\n        \n        if(nums.length == 0) return false;\n        if(nums.length ==1) return true;\n        \n        for(int i= nums.length -2; i>=0; i--){\n            if(nums[i] == 0){\n                int jumpsNeeded = 1;\n                while(jumpsNeeded > nums[i]){\n                    jumpsNeeded++;\n                    i--;\n                    if(i<0) return false;\n                }\n            }\n        }\n        return true;\n        \n    }\n}", "total_acs": 153325, "total_submitted": 518178}, {"id": 56, "title": "Merge Intervals", "url": "https://leetcode.com/problems/merge-intervals/description", "companyTags": ["Google", "Facebook", "Microsoft", "Bloomberg", "LinkedIn", "Twitter", "Yelp"], "difficulty": "Medium", "content": "Given a collection of intervals, merge all overlapping intervals.\r\n\r\n\r\nFor example,\r\nGiven [1,3],[2,6],[8,10],[15,18],\r\nreturn [1,6],[8,10],[15,18].\r\n", "discussUrl": "https://discuss.leetcode.com/category/64", "similarQuestions": ["InsertInterval", "MeetingRooms", "MeetingRoomsII", "TeemoAttacking", "AddBoldTaginString", "RangeModule", "EmployeeFreeTime", "PartitionLabels"], "topicTags": ["Array", "Sort"], "Solution": "/**\n * Definition for an interval.\n * public class Interval {\n *     int start;\n *     int end;\n *     Interval() { start = 0; end = 0; }\n *     Interval(int s, int e) { start = s; end = e; }\n * }\n */\nclass Solution {\n    public List<Interval> merge(List<Interval> intervals) {\n        List<Interval> result = new ArrayList<Interval>();\n        int n = intervals.size();\n        int[] starts = new int[n];\n        int[] ends = new int[n];\n        for(int i=0;i<n;i++){\n        \tstarts[i] = intervals.get(i).start;\n        \tends[i] = intervals.get(i).end;\n        }\n        Arrays.sort(starts);\n        Arrays.sort(ends);\n        for(int i = 0,j = 0; i<n;i++){\n        \tif(i==n-1 ||starts[i+1]>ends[i]){\n        \t\tresult.add(new Interval(starts[j],ends[i]));\n        \t\tj = i+1;\n        \t}\n        }\n        return result;\n    }\n}", "total_acs": 179906, "total_submitted": 568311}, {"id": 57, "title": "Insert Interval", "url": "https://leetcode.com/problems/insert-interval/description", "companyTags": ["Google", "Facebook", "LinkedIn"], "difficulty": "Hard", "content": "Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).\r\n\r\nYou may assume that the intervals were initially sorted according to their start times.\r\n\r\n\r\nExample 1:\r\nGiven intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].\r\n\r\n\r\n\r\nExample 2:\r\nGiven [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16].\r\n\r\n\r\n\r\nThis is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10].\r\n", "discussUrl": "https://discuss.leetcode.com/category/65", "similarQuestions": ["MergeIntervals", "RangeModule"], "topicTags": ["Array", "Sort"], "Solution": "/**\n * Definition for an interval.\n * public class Interval {\n *     int start;\n *     int end;\n *     Interval() { start = 0; end = 0; }\n *     Interval(int s, int e) { start = s; end = e; }\n * }\n */\nclass Solution {\n    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\n    List<Interval> result = new ArrayList<>();\n    if (intervals == null || newInterval == null) return result;\n   \n    int iStart = findStartPos(intervals, newInterval.start);\n    int iEnd = findEndPos(intervals, newInterval.end); \n    \n    if (iStart > 0 && intervals.get(iStart - 1).end >= newInterval.start) iStart--;  \n    if (iEnd == intervals.size() || intervals.get(iEnd).start > newInterval.end) iEnd--;\n    if (iStart <= iEnd) {\n        newInterval = new Interval(Math.min(newInterval.start, intervals.get(iStart).start),Math.max(newInterval.end, intervals.get(iEnd).end));\n    }\n\n    int i = 0;\n    while (i < iStart) result.add(intervals.get(i++));\n    result.add(newInterval);\n    i = iEnd + 1;\n    while (i < intervals.size()) result.add(intervals.get(i++));\n    return result;\n}\n\nprivate int findStartPos(List<Interval> intervals, int value) {\n    int l = 0, r = intervals.size() - 1;\n    while (l <= r) {\n        int m = (l + r) >> 1;\n        if (intervals.get(m).start == value) return m;\n        else if (intervals.get(m).start < value) l = m + 1;\n        else r = m - 1;\n    }\n    return l;\n}\n\nprivate int findEndPos(List<Interval> intervals, int value) {\n    int l = 0, r = intervals.size() - 1;\n    while (l <= r) {\n        int m = (l + r) >> 1;\n        if (intervals.get(m).end == value) return m;\n        else if (intervals.get(m).end < value) l = m + 1;\n        else r = m - 1;\n    }\n    return l;\n}\n}", "total_acs": 118708, "total_submitted": 412893}, {"id": 58, "title": "Length of Last Word", "url": "https://leetcode.com/problems/length-of-last-word/description", "companyTags": [""], "difficulty": "Easy", "content": "Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word in the string.\r\n\r\nIf the last word does not exist, return 0.\r\n\r\nNote: A word is defined as a character sequence consists of non-space characters only.\r\n\r\nExample:\r\n\r\nInput: \"Hello World\"\r\nOutput: 5\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/66", "similarQuestions": [""], "topicTags": ["String"], "Solution": "class Solution {\n    public int lengthOfLastWord(String s) {\n        \tif(s == null)\n        \t\treturn 0;\n\n        \treturn s.trim().length() - s.trim().lastIndexOf(' ') - 1;\n    }\n}", "total_acs": 178710, "total_submitted": 557771}, {"id": 59, "title": "Spiral Matrix II", "url": "https://leetcode.com/problems/spiral-matrix-ii/description", "companyTags": [""], "difficulty": "Medium", "content": "Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.\r\n\r\n\r\nFor example,\r\nGiven n = 3,\r\n\r\nYou should return the following matrix:\r\n\r\n[\r\n [ 1, 2, 3 ],\r\n [ 8, 9, 4 ],\r\n [ 7, 6, 5 ]\r\n]\r\n", "discussUrl": "https://discuss.leetcode.com/category/67", "similarQuestions": ["SpiralMatrix"], "topicTags": ["Array"], "Solution": "class Solution {\n    public int[][] generateMatrix(int n) {\n        int[][] grid = new int[n][n];\n        int rowBegin = 0, colBegin = 0;\n        int rowEnd = n - 1, colEnd = n - 1;\n        int k = 1;\n        while(k <= n * n){\n            for(int j = colBegin; j <= colEnd; j++){\n                grid[rowBegin][j] = k++;\n            }\n            rowBegin++;\n            \n            for(int i = rowBegin; i <= rowEnd; i++){\n                grid[i][colEnd] = k++;\n            }\n            colEnd--;\n            \n            if(rowBegin <= rowEnd){\n                for(int j = colEnd; j >= colBegin; j--){\n                    grid[rowEnd][j] = k++;\n                }\n                rowEnd--;\n            }\n            \n            if(colBegin <= colEnd){\n                for(int i = rowEnd; i >= rowBegin; i--){\n                    grid[i][colBegin] = k++;\n                }\n                colBegin++;\n            }\n        }\n        \n        return grid;\n    }\n}", "total_acs": 95951, "total_submitted": 235596}, {"id": 60, "title": "Permutation Sequence", "url": "https://leetcode.com/problems/permutation-sequence/description", "companyTags": ["Twitter"], "difficulty": "Medium", "content": "The set [1,2,3,\u2026,n] contains a total of n! unique permutations.\r\n\r\nBy listing and labeling all of the permutations in order,\r\nWe get the following sequence (ie, for n = 3):\r\n\r\n\"123\"\r\n\"132\"\r\n\"213\"\r\n\"231\"\r\n\"312\"\r\n\"321\"\r\n\r\n\r\n\r\nGiven n and k, return the kth permutation sequence.\r\n\r\nNote: Given n will be between 1 and 9 inclusive.", "discussUrl": "https://discuss.leetcode.com/category/68", "similarQuestions": ["NextPermutation", "Permutations"], "topicTags": ["Math", "Backtracking"], "Solution": "class Solution {\n    public String getPermutation(int n, int k) {\n        int[] factorial = new int[n];\n        \n        for(int i = 0; i< n; i++){\n            if(i == 0){\n                factorial[i] =1;\n                continue;\n            }\n            factorial[i] = factorial[i-1]*(i);\n        }\n        \n        StringBuilder res = new StringBuilder();\n        boolean[] used = new boolean[n];\n        int i = n-1;\n        while(i>=0){\n            int digit = (k-1)/factorial[i];\n            res.append(findKth(used, digit));\n            k -= digit*factorial[i--];\n        }\n\n        return res.toString();\n    }\n    \n    public int findKth(boolean[] used, int digit){\n        int res = -1;\n        while(digit >= 0){\n            if(!used[++res]){\n                digit--;\n            }\n        }\n        used[res] = true;\n        return res+1;\n        \n    }\n}", "total_acs": 97676, "total_submitted": 333512}, {"id": 61, "title": "Rotate List", "url": "https://leetcode.com/problems/rotate-list/description", "companyTags": [""], "difficulty": "Medium", "content": "Given a list, rotate the list to the right by k places, where k is non-negative.\r\n\r\n\r\n\r\nExample:\r\n\r\nGiven 1->2->3->4->5->NULL and k = 2,\r\n\r\nreturn 4->5->1->2->3->NULL.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/69", "similarQuestions": ["RotateArray", "SplitLinkedListinParts"], "topicTags": ["LinkedList", "TwoPointers"], "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head==null||head.next==null) return head;\n        ListNode dummy=new ListNode(0);\n        dummy.next=head;\n        ListNode fast=dummy,slow=dummy;\n\n        int i;\n        for (i=0;fast.next!=null;i++)//Get the total length \n            fast=fast.next;\n\n        for (int j=i-k%i;j>0;j--) //Get the i-n%i th node\n            slow=slow.next;\n\n        fast.next=dummy.next; //Do the rotation\n        dummy.next=slow.next;\n        slow.next=null;\n\n        return dummy.next;\n    }\n}", "total_acs": 130069, "total_submitted": 532600}, {"id": 62, "title": "Unique Paths", "url": "https://leetcode.com/problems/unique-paths/description", "companyTags": ["Bloomberg"], "difficulty": "Medium", "content": "A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).\r\n\r\nThe robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).\r\n\r\nHow many possible unique paths are there?\r\n\r\n\r\n\r\nAbove is a 3 x 7 grid. How many possible unique paths are there?\r\n\r\n\r\nNote: m and n will be at most 100.", "discussUrl": "https://discuss.leetcode.com/category/70", "similarQuestions": ["UniquePathsII", "MinimumPathSum", "DungeonGame"], "topicTags": ["Array", "DynamicProgramming"], "Solution": "class Solution {\n    /*\n    [row][col] = [row + 1][col + 1]\n    \n    int[] botRow = new int[m]\n    Arrays.fill(botRow, 1);\n    int[] curRow = new int[m]\n    for (int row = 2; row <= n; ++row) {\n        curRow[curRow.length - 1] = 1\n        for (int col = curRow.length - 2; col >= 0; --col) {\n            curRow[col] = curRow[col + 1] + botRow[col];\n        }\n        botRow = curRow;\n    }\n    return curRow[0]\n    \n    */\n    public int uniquePaths(int m, int n) {\n        if (m == 1 || n == 1) {\n            return 1;\n        }\n        int[] curRow = new int[m];\n        Arrays.fill(curRow, 1);\n        for (int row = 2; row <= n; ++row) {\n            for (int col = curRow.length - 2; col >= 0; --col) {\n                curRow[col] = curRow[col + 1] + curRow[col];\n            }\n        }\n        return curRow[0];\n    }\n}", "total_acs": 177538, "total_submitted": 418074}, {"id": 63, "title": "Unique Paths II", "url": "https://leetcode.com/problems/unique-paths-ii/description", "companyTags": ["Bloomberg"], "difficulty": "Medium", "content": "Follow up for \"Unique Paths\":\r\n\r\nNow consider if some obstacles are added to the grids. How many unique paths would there be?\r\n\r\nAn obstacle and empty space is marked as 1 and 0 respectively in the grid.\r\n\r\nFor example,\r\nThere is one obstacle in the middle of a 3x3 grid as illustrated below.\r\n\r\n[\r\n  [0,0,0],\r\n  [0,1,0],\r\n  [0,0,0]\r\n]\r\n\r\nThe total number of unique paths is 2.\r\n\r\nNote: m and n will be at most 100.", "discussUrl": "https://discuss.leetcode.com/category/71", "similarQuestions": ["UniquePaths"], "topicTags": ["Array", "DynamicProgramming"], "Solution": "class Solution {\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\n        if(obstacleGrid == null||obstacleGrid.length == 0 ) return 0;\n        if(obstacleGrid[0].length == 0) return 1;\n        int m = obstacleGrid.length;\n        int n = obstacleGrid[0].length;\n        \n        int[][] dp = new int[m+1][n+1];\n        dp[0][1] = 1;\n        \n        for(int i = 1; i <= m; i++) {\n            for(int j = 1; j <= n; j++) {\n                if(obstacleGrid[i-1][j-1] == 0) dp[i][j] = dp[i-1][j] + dp[i][j-1];\n                else dp[i][j] = 0;\n            }\n        }\n        \n        return dp[m][n];\n    }\n}", "total_acs": 126821, "total_submitted": 395258}, {"id": 64, "title": "Minimum Path Sum", "url": "https://leetcode.com/problems/minimum-path-sum/description", "companyTags": [""], "difficulty": "Medium", "content": "Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.\r\n\r\nNote: You can only move either down or right at any point in time.\r\n\r\nExample 1:\r\n\r\n[[1,3,1],\r\n [1,5,1],\r\n [4,2,1]]\r\n\r\nGiven the above grid map, return 7. Because the path 1\u21923\u21921\u21921\u21921 minimizes the sum.\r\n", "discussUrl": "https://discuss.leetcode.com/category/72", "similarQuestions": ["UniquePaths", "DungeonGame", "CherryPickup"], "topicTags": ["Array", "DynamicProgramming"], "Solution": "class Solution {\n    public int minPathSum(int[][] grid) {\n        int[][] minSum = new int[grid.length][grid[0].length];\n        return helper(grid, 0, 0, minSum);\n    }\n    public int helper(int[][] grid, int i, int j, int[][] minSum) {\n        if (i == grid.length - 1 && j == grid[0].length - 1) return grid[i][j];\n        if (minSum[i][j] != 0) return minSum[i][j];\n        int down = Integer.MAX_VALUE, right = Integer.MAX_VALUE;\n        if (i < grid.length - 1) down = helper(grid, i + 1, j, minSum);\n        if (j < grid[0].length - 1) right = helper(grid, i, j + 1, minSum);\n        minSum[i][j] = Math.min(right, down) + grid[i][j];\n        return minSum[i][j];\n    }\n}", "total_acs": 138112, "total_submitted": 344676}, {"id": 65, "title": "Valid Number", "url": "https://leetcode.com/problems/valid-number/description", "companyTags": ["LinkedIn"], "difficulty": "Hard", "content": "Validate if a given string is numeric.\r\n\r\n\r\nSome examples:\r\n\"0\" => true\r\n\"   0.1  \" => true\r\n\"abc\" => false\r\n\"1 a\" => false\r\n\"2e10\" => true\r\n\r\n\r\nNote: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one.\r\n\r\n\r\n\r\nUpdate (2015-02-10):\r\nThe signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button  to reset your code definition.\r\n", "discussUrl": "https://discuss.leetcode.com/category/73", "similarQuestions": ["StringtoInteger(atoi)"], "topicTags": ["Math", "String"], "Solution": "class Solution {\n    public boolean isNumber(String s) {\n        s = s.trim();\n        if (s == null || s.length() == 0) return false;\n\n        boolean numberSeen = false,\n                pointSeen = false,\n                eSeen = false,\n                numberAfterESeen = true;\n\n        for (int i = 0; i < s.length(); i++){\n            char c = s.charAt(i);\n            if (c - '0' >= 0 && c - '0' <= 9){\n                numberSeen = true;\n                numberAfterESeen = true;\n            }else if (c == 'e'){\n                if (!numberSeen || eSeen) return false;\n                eSeen = true;\n                numberAfterESeen = false;\n            }else if (c == '.'){\n                if (pointSeen || eSeen) return false;\n                pointSeen = true;\n            }else if (c == '+' || c == '-'){\n                if (i != 0 && s.charAt(i-1) != 'e') return false;\n            }else{\n                return false;\n            }\n        }\n\n        return numberSeen && numberAfterESeen;\n    }\n}", "total_acs": 80531, "total_submitted": 622300}, {"id": 66, "title": "Plus One", "url": "https://leetcode.com/problems/plus-one/description", "companyTags": ["Google"], "difficulty": "Easy", "content": "Given a non-negative integer represented as a non-empty array of digits, plus one to the integer.\r\n\r\nYou may assume the integer do not contain any leading zero, except the number 0 itself.\r\n\r\nThe digits are stored such that the most significant digit is at the head of the list.", "discussUrl": "https://discuss.leetcode.com/category/74", "similarQuestions": ["MultiplyStrings", "AddBinary", "PlusOneLinkedList"], "topicTags": ["Array", "Math"], "Solution": "class Solution {\n    public int[] plusOne(int[] digits) {\n        int[] res = new int[digits.length + 1];\n        int carry = 1;\n        for (int i = digits.length - 1; i >= 0; --i) {\n            if (carry == 0) {\n                res[i + 1] = digits[i];\n            } else {\n                if (digits[i] == 9) {\n                    res[i + 1] = 0;\n                } else {\n                    res[i + 1] = digits[i] + 1;\n                    carry = 0;\n                }\n            }\n        }\n        res[0] = carry;\n        \n        return res[0] == 0 ? Arrays.copyOfRange(res, 1, res.length) : res;\n    }\n}", "total_acs": 219724, "total_submitted": 556375}, {"id": 67, "title": "Add Binary", "url": "https://leetcode.com/problems/add-binary/description", "companyTags": ["Facebook"], "difficulty": "Easy", "content": "\r\nGiven two binary strings, return their sum (also a binary string).\r\n\r\n\r\n\r\nFor example,\r\na = \"11\"\r\nb = \"1\"\r\nReturn \"100\".\r\n", "discussUrl": "https://discuss.leetcode.com/category/75", "similarQuestions": ["AddTwoNumbers", "MultiplyStrings", "PlusOne"], "topicTags": ["Math", "String"], "Solution": "class Solution {\n    public String addBinary(String a, String b) {\n        if (a.length() > b.length()) {            \n            // add to arr1\n            return addToA(a.toCharArray(), b);\n        } else {\n            // add to arr2\n            return addToA(b.toCharArray(), a);\n        }\n    }\n    \n    private String addToA(char[] a, String b) {\n        int x = a.length - 1;\n        int y = b.length() - 1;\n        int remain = 0;\n        while (y >= 0) {\n            int sum = remain + a[x] - '0' + b.charAt(y) - '0';\n            a[x--] = (char)(sum % 2 + '0');\n            remain = sum / 2;\n            y--;\n        }\n        while (x >= 0 && remain > 0) {\n            int sum = remain + a[x] - '0';\n            a[x--] = (char)(sum % 2 + '0');\n            remain = sum / 2;                \n        }\n        if (remain == 0) {\n            return String.valueOf(a);\n        } else {\n            return \"1\" + String.valueOf(a);\n        }\n    }\n}", "total_acs": 186169, "total_submitted": 551562}, {"id": 68, "title": "Text Justification", "url": "https://leetcode.com/problems/text-justification/description", "companyTags": ["Facebook", "LinkedIn", "Airbnb"], "difficulty": "Hard", "content": "\r\nGiven an array of words and a length L, format the text such that each line has exactly L characters and is fully (left and right) justified.\r\n \r\n\r\n\r\nYou should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly L characters.\r\n\r\n\r\n\r\nExtra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\r\n\r\n\r\n\r\nFor the last line of text, it should be left justified and no extra space is inserted between words.\r\n\r\n\r\n\r\nFor example,\r\nwords: [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"]\r\nL: 16.\r\n\r\n\r\n\r\nReturn the formatted lines as:\r\n\r\n[\r\n   \"This    is    an\",\r\n   \"example  of text\",\r\n   \"justification.  \"\r\n]\r\n\r\n\r\n\r\n\r\nNote: Each word is guaranteed not to exceed L in length.\r\n\r\n\r\n\r\nclick to show corner cases.\r\n\r\nCorner Cases:\r\n\r\n\r\nA line other than the last line might contain only one word. What should you do in this case?\r\nIn this case, that line should be left-justified.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/76", "similarQuestions": [""], "topicTags": ["String"], "Solution": "class Solution {\n    public List<String> fullJustify(String[] words, int maxWidth) {\n        List<String> ans = new ArrayList<String>();\n        int[] len = new int[words.length];\n        for (int i = 0; i < words.length; i ++)\n            len[i] = words[i].length();\n        int p = 0;\n        while (p < words.length){\n            int count = 0, remain = maxWidth;\n            int start = p;\n            while (p < words.length && remain - len[p] >= count){\n                count += 1;\n                remain -= len[p];\n                p = p + 1;\n            }\n            count = count - 1;\n            int avg =  count == 0 ? 1 : remain / count;\n            int extra = count == 0 ? 0 : remain % count;\n            String ret = \"\";\n            if (p == words.length){\n                ret = print(words, start, p, 1, 0);\n            } else {\n                ret = print(words, start, p, avg, extra);\n            }\n            int size = ret.length();\n            for (int i = 0; i < maxWidth - size; i ++){\n                ret += \" \";\n            }\n            ans.add(ret);\n        }\n        return ans;\n    }\n    \n    public String print(String[] words, int start, int end, int avg, int extra){\n        String ans = \"\", blank = \"\";\n        for (int i = 0; i < avg; i ++)\n            blank += \" \";\n        for (int i = start; i < start + extra; i ++){\n            ans += words[i] + blank + \" \";\n        }\n        for (int i = start + extra; i < end - 1; i ++){\n            ans += words[i] + blank;\n        }\n        ans += words[end - 1];\n        return ans;\n    }\n}", "total_acs": 67235, "total_submitted": 338434}, {"id": 69, "title": "Sqrt(x)", "url": "https://leetcode.com/problems/sqrtx/description", "companyTags": ["Facebook", "Bloomberg", "Apple"], "difficulty": "Easy", "content": "Implement int sqrt(int x).\r\n\r\nCompute and return the square root of x.\r\n\r\nx is guaranteed to be a non-negative integer.\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput: 4\r\nOutput: 2\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: 8\r\nOutput: 2\r\nExplanation: The square root of 8 is 2.82842..., and since we want to return an integer, the decimal part will be truncated.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/77", "similarQuestions": ["Pow(x", "n)", "ValidPerfectSquare"], "topicTags": ["Math", "BinarySearch"], "Solution": "class Solution {\n    public int mySqrt(int x) {\n        return (int)Math.sqrt(x);\n    }\n}", "total_acs": 209029, "total_submitted": 729209}, {"id": 70, "title": "Climbing Stairs", "url": "https://leetcode.com/problems/climbing-stairs/description", "companyTags": ["Apple", "Adobe"], "difficulty": "Easy", "content": "You are climbing a stair case. It takes n steps to reach to the top.\r\n\r\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\r\n\r\n\r\nNote: Given n will be a positive integer.\r\n\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput: 2\r\nOutput:  2\r\nExplanation:  There are two ways to climb to the top.\r\n\r\n1. 1 step + 1 step\r\n2. 2 steps\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: 3\r\nOutput:  3\r\nExplanation:  There are three ways to climb to the top.\r\n\r\n1. 1 step + 1 step + 1 step\r\n2. 1 step + 2 steps\r\n3. 2 steps + 1 step\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/78", "similarQuestions": ["MinCostClimbingStairs"], "topicTags": ["DynamicProgramming"], "Solution": "class Solution {\n    Map<Integer, Integer> cache = new HashMap<>();\n    public int climbStairs(int n) {\n        if(n <= 1) return 1;\n        if(cache.containsKey(n)) return cache.get(n);\n        int results = climbStairs(n - 1) + climbStairs(n - 2);\n        cache.put(n, results);\n        return results;\n    }\n}", "total_acs": 228375, "total_submitted": 557963}, {"id": 71, "title": "Simplify Path", "url": "https://leetcode.com/problems/simplify-path/description", "companyTags": ["Facebook", "Microsoft"], "difficulty": "Medium", "content": "Given an absolute path for a file (Unix-style), simplify it.\r\n\r\nFor example,\r\npath = \"/home/\", => \"/home\"\r\npath = \"/a/./b/../../c/\", => \"/c\"\r\n\r\n\r\nclick to show corner cases.\r\n\r\nCorner Cases:\r\n\r\n\r\n\r\nDid you consider the case where path = \"/../\"?\r\nIn this case, you should return \"/\".\r\nAnother corner case is the path might contain multiple slashes '/' together, such as \"/home//foo/\".\r\nIn this case, you should ignore redundant slashes and return \"/home/foo\".\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/79", "similarQuestions": [""], "topicTags": ["String", "Stack"], "Solution": "class Solution {\n    public String simplifyPath(String path) {\n        char[] res = new char[path.length()+1];\n       \n        char[] input = path.toCharArray();\n        int slow = 0;\n        int fast = 0;\n        if(input[0] != '/' ){\n            res[0] = '/';\n            slow = 1;\n        }\n        while(fast < path.length()){\n            if(input[fast] == '/'){\n                 res[slow++] = input[fast++];\n                while(fast < input.length && input[fast] == '/'){\n                    fast++;\n                }\n            } else if(input[fast] != '.' && input[fast] != '/'){\n                while(fast < input.length && input[fast] != '/'){\n                    res[slow++] = input[fast++];\n                }\n            } else if(input[fast] == '.'){\n                if(fast+1 == path.length()){\n                    break;\n                }\n                if(input[fast+1] == '/'){\n                    fast += 1;\n                    while(fast < input.length && input[fast] == '/'){\n                        fast++;\n                    }\n                   \n                } else if(input[fast+1] != '.' && input[fast+1] != '/'){\n                    \n                    while(fast < input.length && input[fast] != '/'){\n                        res[slow++] = input[fast++];\n                    }\n                } else if(input[fast+1] == '.'){\n                    if(fast+2 == path.length()){\n                         if(slow>=2){\n                            slow-=2;\n                        }\n                        while(slow > 0 && res[slow] != '/'){\n                            slow--;\n                        }\n                        break;\n                    }\n                    if(input[fast+2] == '/'){\n                        if(slow>=2){\n                            slow-=2;\n                        }\n                        while(slow > 0 && res[slow] != '/'){\n                            slow--;\n                        }\n                        fast+=2;\n                    } else{\n                        while(fast < input.length && input[fast] != '/'){\n                            res[slow++] = input[fast++];\n                        }\n                    }\n                }\n            } \n        }\n        if(slow > 1 && res[slow-1] == '/'){\n          slow-=1;  \n        }\n        return slow == 0? \"/\" :new String(res, 0, slow);\n    }\n}", "total_acs": 107202, "total_submitted": 409923}, {"id": 72, "title": "Edit Distance", "url": "https://leetcode.com/problems/edit-distance/description", "companyTags": [""], "difficulty": "Hard", "content": "\r\nGiven two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.)\r\n\r\n\r\n\r\nYou have the following 3 operations permitted on a word:\r\n\r\n\r\n\r\na) Insert a character\r\nb) Delete a character\r\nc) Replace a character\r\n", "discussUrl": "https://discuss.leetcode.com/category/80", "similarQuestions": ["OneEditDistance", "DeleteOperationforTwoStrings", "MinimumASCIIDeleteSumforTwoStrings"], "topicTags": ["String", "DynamicProgramming"], "Solution": "class Solution {\n    public int minDistance(String s1, String s2) {\n        int[][] mem = new int[s1.length()+1][s2.length()+1];\n\t\treturn auxEditDistance2(s1.length(), s2.length(), s1, s2, mem);\n\t}\n\n\tprivate int auxEditDistance2(int i, int j, String s1, String s2, int[][] mem) {\n\t\tif (i == 0)\n\t\t\treturn j;\n\t\tif (j == 0)\n\t\t\treturn i;\n\t\t\n\t\tif(mem[i][j]!=0)\n\t\t\treturn mem[i][j];\n\t\t\n\t\tif (s1.charAt(i - 1) == s2.charAt(j - 1))\n\t\t\treturn mem[i][j] = auxEditDistance2(i - 1, j - 1, s1, s2, mem);\n\t\telse {\n\t\t\tint insertCost = auxEditDistance2(i, j - 1, s1, s2, mem);\n\t\t\tint replaceCost = auxEditDistance2(i - 1, j - 1, s1, s2, mem);\n\t\t\tint deleteCost = auxEditDistance2(i - 1, j, s1, s2, mem);\n\t\t\treturn mem[i][j] = Math.min(insertCost, Math.min(replaceCost, deleteCost)) + 1;\n\t\t}\n}\n}", "total_acs": 108779, "total_submitted": 335623}, {"id": 73, "title": "Set Matrix Zeroes", "url": "https://leetcode.com/problems/set-matrix-zeroes/description", "companyTags": ["Microsoft", "Amazon"], "difficulty": "Medium", "content": "\r\nGiven a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place.\r\n\r\n\r\nclick to show follow up.\r\n\r\nFollow up:\r\n\r\n\r\nDid you use extra space?\r\nA straight forward solution using O(mn) space is probably a bad idea.\r\nA simple improvement uses O(m + n) space, but still not the best solution.\r\nCould you devise a constant space solution?\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/81", "similarQuestions": ["GameofLife"], "topicTags": ["Array"], "Solution": "class Solution {\n    public void setZeroes(int[][] matrix) {\n        boolean firstRowZero = false;\n        boolean firstColZero = false;\n        int rows = matrix.length;\n        int cols = matrix[0].length;\n        //check frist row\n        for(int i = 0; i < cols; ++i){\n            if(matrix[0][i] == 0){\n                firstRowZero = true;\n                break;\n            }\n        }\n        //check first col\n        for(int i = 0; i < rows; ++i){\n            if(matrix[i][0] == 0){\n                firstColZero = true;\n                break;\n            }\n        }\n        \n        //set bit\n        for(int r = 1; r < rows; ++r){\n            for(int c = 1; c < cols; ++c){\n                if(matrix[r][c] == 0){\n                    matrix[r][0] = 0;\n                    matrix[0][c] = 0;\n                }\n            }\n        }\n        \n        //set rows to zero\n        for(int i = 1; i < rows; ++i){\n            if(matrix[i][0] == 0){\n                for(int j = 0; j < cols; ++j){\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n        \n        //set cols to zero\n        for(int i = 1; i < cols; ++i){\n            if(matrix[0][i] == 0){\n                for(int j = 0; j < rows; ++j){\n                    matrix[j][i] = 0;\n                }\n            }\n        }\n        \n        //set first row to zero\n        if(firstRowZero){\n            for(int j = 0; j < cols; ++j){\n                matrix[0][j] = 0;\n            }\n        }\n        \n        //set first col to zero\n        if(firstColZero){\n            for(int j = 0; j < rows; ++j){\n                matrix[j][0] = 0;\n            }\n        }\n        \n    }\n}", "total_acs": 129366, "total_submitted": 355223}, {"id": 74, "title": "Search a 2D Matrix", "url": "https://leetcode.com/problems/search-a-2d-matrix/description", "companyTags": [""], "difficulty": "Medium", "content": "Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:\r\n\r\n\r\n\r\nIntegers in each row are sorted from left to right.\r\nThe first integer of each row is greater than the last integer of the previous row.\r\n\r\n\r\n\r\n\r\nFor example,\r\n\r\nConsider the following matrix:\r\n\r\n\r\n[\r\n  [1,   3,  5,  7],\r\n  [10, 11, 16, 20],\r\n  [23, 30, 34, 50]\r\n]\r\n\r\n\r\nGiven target = 3, return true.", "discussUrl": "https://discuss.leetcode.com/category/82", "similarQuestions": ["Searcha2DMatrixII"], "topicTags": ["Array", "BinarySearch"], "Solution": "public class Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        if(matrix == null || matrix.length ==0 || matrix[0].length == 0) {\n            return false;\n        }\n        \n        int i = matrix.length-1;\n        int j =0;\n        while(i >= 0 && j <= matrix[0].length -1) {\n        if(matrix[i][j] == target) {\n            return true;\n        } else if(matrix[i][j] > target) {\n             i --;\n        } else {\n            j++;\n        }\n        }\n        return false;\n    }\n}", "total_acs": 149199, "total_submitted": 428864}, {"id": 75, "title": "Sort Colors", "url": "https://leetcode.com/problems/sort-colors/description", "companyTags": ["Facebook", "Microsoft", "PocketGems"], "difficulty": "Medium", "content": "\r\nGiven an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.\r\n\r\n\r\n\r\nHere, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.\r\n\r\n\r\n\r\nNote:\r\nYou are not suppose to use the library's sort function for this problem.\r\n\r\n\r\nclick to show follow up.\r\n\r\n\r\nFollow up:\r\nA rather straight forward solution is a two-pass algorithm using counting sort.\r\nFirst, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's.\r\nCould you come up with an one-pass algorithm using only constant space?\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/83", "similarQuestions": ["SortList", "WiggleSort", "WiggleSortII"], "topicTags": ["Array", "TwoPointers", "Sort"], "Solution": "class Solution {\n    public void sortColors(int[] nums) {\n        int zero = -1;\n        int two = nums.length;\n        // [0, zero]:0 [zero + 1, index - 1]:1 [index, two - 1]:unknown [two, nums.length - 1]:2\n        for (int i = 0; i < two; ) {\n            if (nums[i] == 1) {\n                i++;\n            } else if (nums[i] == 0) {\n                nums[i++] = nums[zero + 1];\n                nums[++zero] = 0;              \n            } else {\n                assert(nums[i] == 2);\n                nums[i] = nums[two - 1];\n                nums[--two] = 2;\n            }\n        }\n        \n    }\n\n}", "total_acs": 206391, "total_submitted": 532437}, {"id": 76, "title": "Minimum Window Substring", "url": "https://leetcode.com/problems/minimum-window-substring/description", "companyTags": ["Facebook", "Uber", "LinkedIn", "Snapchat"], "difficulty": "Hard", "content": "\r\nGiven a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).\r\n\r\n\r\n\r\nFor example,\r\nS = \"ADOBECODEBANC\"\r\nT = \"ABC\"\r\n\r\n\r\nMinimum window is \"BANC\".\r\n\r\n\r\n\r\nNote:\r\nIf there is no such window in S that covers all characters in T, return the empty string \"\".\r\n\r\n\r\nIf there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S.\r\n", "discussUrl": "https://discuss.leetcode.com/category/84", "similarQuestions": ["SubstringwithConcatenationofAllWords", "MinimumSizeSubarraySum", "SlidingWindowMaximum", "PermutationinString", "SmallestRange", "MinimumWindowSubsequence"], "topicTags": ["HashTable", "TwoPointers", "String"], "Solution": "class Solution {\n    public String minWindow(String s, String t) {\n        if (s == null || t == null || s.length() < t.length()) {\n            return \"\";\n        }\n        int[] hash = new int[256];\n        char[] tChar = t.toCharArray();\n        char[] sChar = s.toCharArray();\n        int count = 0;\n        for (int i = 0; i < tChar.length; ++i) {\n            ++count;\n            ++hash[tChar[i]];\n        }\n        \n        int start = 0, end = 0;\n        int minLen = Integer.MAX_VALUE, start_index = -1;\n        while (end < sChar.length) {\n            if (hash[sChar[end++]]-- >= 1) {\n                --count;\n            }\n            while (count == 0) {\n                if (end - start < minLen) {\n                    start_index = start;\n                    minLen = end - start;\n                }\n                if (hash[sChar[start++]]++ >= 0) {\n                    ++count;\n                }\n            }\n        }\n        \n        if (start_index == -1) {\n            return \"\";\n        }\n        \n        return s.substring(start_index, start_index + minLen);\n    }\n}", "total_acs": 135990, "total_submitted": 511795}, {"id": 77, "title": "Combinations", "url": "https://leetcode.com/problems/combinations/description", "companyTags": [""], "difficulty": "Medium", "content": "\r\nGiven two integers n and k, return all possible combinations of k numbers out of 1 ... n.\r\n\r\n\r\nFor example,\r\nIf n = 4 and k = 2, a solution is:\r\n\r\n\r\n\r\n[\r\n  [2,4],\r\n  [3,4],\r\n  [2,3],\r\n  [1,2],\r\n  [1,3],\r\n  [1,4],\r\n]\r\n", "discussUrl": "https://discuss.leetcode.com/category/85", "similarQuestions": ["CombinationSum", "Permutations"], "topicTags": ["Backtracking"], "Solution": "class Solution {\n    public List<List<Integer>> combine(int n, int k) {\n        List<List<Integer>> resultList = new ArrayList<>();\n        List<Integer> list = new ArrayList<>();\n        \n        combineHelper(1, n, k, list, resultList);\n        return resultList;\n    }\n    \n    public void combineHelper(int start, int n, int k, List<Integer> list, List<List<Integer>> resultList) {\n        if ( k == 0 ) {\n            // case #1\n            resultList.add(new ArrayList<>(list));\n            return;\n        }\n        if ( n - start + 1 < k ) {\n            // case #2\n            return;\n        }\n        \n        // add start to list\n        list.add(start);\n        combineHelper(start + 1, n, k - 1, list, resultList);\n        // remove start from list\n        list.remove(list.size() - 1);\n        combineHelper(start + 1, n, k, list, resultList);\n    }\n}", "total_acs": 136468, "total_submitted": 333911}, {"id": 78, "title": "Subsets", "url": "https://leetcode.com/problems/subsets/description", "companyTags": ["Facebook", "Amazon", "Bloomberg", "Uber", "Coupang"], "difficulty": "Medium", "content": "\r\nGiven a set of distinct integers, nums, return all possible subsets (the power set).\r\n\r\nNote: The solution set must not contain duplicate subsets.\r\n\r\n\r\nFor example,\r\nIf nums = [1,2,3], a solution is:\r\n\r\n\r\n\r\n[\r\n  [3],\r\n  [1],\r\n  [2],\r\n  [1,2,3],\r\n  [1,3],\r\n  [2,3],\r\n  [1,2],\r\n  []\r\n]\r\n", "discussUrl": "https://discuss.leetcode.com/category/86", "similarQuestions": ["GeneralizedAbbreviation"], "topicTags": ["Array", "Backtracking", "BitManipulation"], "Solution": "public class Solution {\n    // public List<List<Integer>> subsets(int[] nums) {\n    //     List<List<Integer>> res = new ArrayList<List<Integer>>();\n    //     res.add(new ArrayList<Integer>());\n    //     for (int num:nums){\n    //         int size = res.size();\n    //         for (int i = 0; i < size; i++){\n    //             List<Integer> temp = new ArrayList<Integer>(res.get(i));\n    //             temp.add(num);\n    //             res.add(temp);\n    //         }\n    //     }\n    //     return res;\n    // }\n    public List<List<Integer>> subsets(int[] nums) {\n\tList<List<Integer>> res = new ArrayList<List<Integer>>();\n\tif (nums == null || nums.length == 0) return res;\n\tres.add(new ArrayList());\n\tint len  =  nums.length;\n\tfor (int i = 0; i < len; i++){\n\t\tint size  =  res.size();\n\t\tfor (int j = 0; j < size; j++){\n\t\t\tArrayList<Integer>  temp  = new ArrayList<Integer>(res.get(j));\n\t\t\ttemp.add(nums[i]);\n\t\t\tres.add(temp);\n\t\t}\n\t}\n\treturn res;\n\t\n}\n}", "total_acs": 215545, "total_submitted": 491920}, {"id": 79, "title": "Word Search", "url": "https://leetcode.com/problems/word-search/description", "companyTags": ["Facebook", "Microsoft", "Bloomberg"], "difficulty": "Medium", "content": "\r\nGiven a 2D board and a word, find if the word exists in the grid.\r\n\r\n\r\nThe word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\r\n\r\n\r\n\r\nFor example,\r\nGiven board = \r\n\r\n[\r\n  ['A','B','C','E'],\r\n  ['S','F','C','S'],\r\n  ['A','D','E','E']\r\n]\r\n\r\n\r\nword = \"ABCCED\", -> returns true,\r\nword = \"SEE\", -> returns true,\r\nword = \"ABCB\", -> returns false.\r\n", "discussUrl": "https://discuss.leetcode.com/category/87", "similarQuestions": ["WordSearchII"], "topicTags": ["Array", "Backtracking"], "Solution": "class Solution {\n    \n    public boolean exist(char[][] board, String word) {\n        if(board.length == 0 || board[0].length == 0)   return false;\n        char[] array = word.toCharArray();\n        \n        for(int i = 0; i < board.length; i++){\n            for(int j = 0; j < board[i].length; j++){\n                if(board[i][j] == array[0]){\n                    if(dfs(board, i, j, 0, array))     return true;\n                }\n            }\n        }\n        return false;\n    }\n    \n    private boolean dfs(char[][] board, int i, int j, int index, char[] word){\n        if(word.length == index)    return true;\n        if(i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] != word[index])     return false;\n        \n        board[i][j] = '#';  //each letter could only be used once\n        \n        boolean res = dfs(board, i+1, j, index + 1, word) || dfs(board, i-1, j, index + 1, word) || dfs(board, i, j+1, index + 1, word) || dfs(board, i, j-1, index + 1, word);\n        board[i][j] = word[index];\n        \n        return res;\n        \n    }\n    \n  \n}", "total_acs": 164317, "total_submitted": 589485}, {"id": 80, "title": "Remove Duplicates from Sorted Array II", "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/description", "companyTags": ["Facebook"], "difficulty": "Medium", "content": "\r\nFollow up for \"Remove Duplicates\":\r\nWhat if duplicates are allowed at most twice?\r\n\r\n\r\nFor example,\r\nGiven sorted array nums = [1,1,1,2,2,3],\r\n\r\n\r\nYour function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn't matter what you leave beyond the new length.\r\n", "discussUrl": "https://discuss.leetcode.com/category/88", "similarQuestions": [""], "topicTags": ["Array", "TwoPointers"], "Solution": "class Solution {\n    public int removeDuplicates(int[] nums) {\n        if(nums == null || nums.length <= 2) {\n            return nums.length;\n        }\n        \n        int slow = 2;\n        for(int fast = 2; fast < nums.length; fast++) {\n            if(nums[fast] != nums[slow-2]) {\n                nums[slow++] = nums[fast];\n            }\n        }\n        return slow;\n    }\n}", "total_acs": 141448, "total_submitted": 385640}, {"id": 81, "title": "Search in Rotated Sorted Array II", "url": "https://leetcode.com/problems/search-in-rotated-sorted-array-ii/description", "companyTags": [""], "difficulty": "Medium", "content": "\r\nFollow up for \"Search in Rotated Sorted Array\":\r\nWhat if duplicates are allowed?\r\n\r\nWould this affect the run-time complexity? How and why?\r\n\r\n\r\nSuppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\r\n\r\n(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).\r\n\r\nWrite a function to determine if a given target is in the array.\r\n\r\nThe array may contain duplicates.", "discussUrl": "https://discuss.leetcode.com/category/89", "similarQuestions": ["SearchinRotatedSortedArray"], "topicTags": ["Array", "BinarySearch"], "Solution": "class Solution {\n    public boolean search(int[] nums, int target) {\n        if(nums.length == 0) return false;\n        int left = 0, right = nums.length - 1;\n        while(left < right){\n            int mid = (left + right) >> 1;\n            if(nums[mid] == target) return true;\n            if(nums[mid] < nums[right]){\n                if(target > nums[mid] && target <= nums[right]) left = mid + 1;\n                else right = mid - 1;\n            }\n            else if(nums[mid] > nums[right]){\n                if(target >= nums[left] && target < nums[mid]) right = mid - 1;\n                else left = mid + 1;\n            }\n            else right--;\n        }\n        return nums[left] == target;\n    }\n}", "total_acs": 113218, "total_submitted": 346070}, {"id": 82, "title": "Remove Duplicates from Sorted List II", "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/description", "companyTags": [""], "difficulty": "Medium", "content": "\r\nGiven a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.\r\n\r\n\r\nFor example,\r\nGiven 1->2->3->3->4->4->5, return 1->2->5.\r\nGiven 1->1->1->2->3, return 2->3.\r\n", "discussUrl": "https://discuss.leetcode.com/category/90", "similarQuestions": [""], "topicTags": ["LinkedList"], "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\npublic ListNode deleteDuplicates(ListNode head) {\n\t//use two pointers, slow - track the node before the dup nodes, \n\t// fast - to find the last node of dups.\n    ListNode dummy = new ListNode(0), fast = head, slow = dummy;\n    slow.next = fast;\n    while(fast != null) {\n    \twhile (fast.next != null && fast.val == fast.next.val) {\n     \t\tfast = fast.next;    //while loop to find the last node of the dups.\n    \t}\n    \tif (slow.next != fast) { //duplicates detected.\n    \t\tslow.next = fast.next; //remove the dups.\n    \t\tfast = fast.next;     //reposition the fast pointer.\n    \t} else { //no dup, move down both pointer.\n    \t\tslow = slow.next;\n    \t\tfast = fast.next;\n    \t}\n    \t\n    }\n    return dummy.next;\n} }\n\n\n", "total_acs": 127801, "total_submitted": 427819}, {"id": 83, "title": "Remove Duplicates from Sorted List", "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-list/description", "companyTags": [""], "difficulty": "Easy", "content": "\r\nGiven a sorted linked list, delete all duplicates such that each element appear only once.\r\n\r\n\r\nFor example,\r\nGiven 1->1->2, return 1->2.\r\nGiven 1->1->2->3->3, return 1->2->3.\r\n", "discussUrl": "https://discuss.leetcode.com/category/91", "similarQuestions": [""], "topicTags": ["LinkedList"], "Solution": "/**\n\u548cremove duplicates from array \u4e00\u6837\u601d\u8def\uff0c\u4e00\u6162\u4e00\u5757\u4e24\u4e2a\u6307\u9488\n\u533a\u522b\u662f\uff1a\u78b0\u5230\u4e0d\u4e00\u6837\u7684\u65f6\u5019\uff0ci\u548cj\u90fd\u5f80\u540e\u8d70\uff0ci\u8fdej\u8fde\u4e0d\u8fde\u90fd\u884c\uff0c\n      \u78b0\u5230\u7b49\u4e8e\u7684\u65f6\u5019\uff0ci\u505c\u7740\u4e0d\u52a8\uff0cj\u5f80\u540e\u8d70\u5230\u7b2c\u4e00\u4e2a\u4e0d\u662fdup\u7684\u65f6\u5019\uff0c\u8fd9\u65f6\u5019\u4e00\u5b9a\u8981i\u53bb\u8fdej\n */\nclass Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head==null || head.next==null){\n            return head;\n        }\n        \n        ListNode i = head;\n        ListNode j = head.next;\n        int valBeforeJ = i.val;\n        \n        while(j!=null && i!=null){\n            if(j.val!=valBeforeJ){\n                i = i.next;  \n            }\n            valBeforeJ = j.val;\n            j=j.next;\n            //\u8fd9\u4e00\u6b65\u662f\u5173\u952e\uff0c\u5e73\u65f6i\u8fdej\u6ca1\u5565\u533a\u522b\n            //\u4e00\u65e6i\u505c\u7559j\u5f80\u540e\u7684\u65f6\u5019\uff0ci\u4e00\u5b9a\u8981\u8df3\u53bb\u8fde\u540e\u9762\u7684j\n            i.next=j;\n        }\n        return head;\n    }\n}\n/*\nGiven a sorted linked list, delete all duplicates such that each element appear only once.\n\nFor example,\nGiven 1->1->2, return 1->2.\nGiven 1->1->2->3->3, return 1->2->3.\n*/", "total_acs": 221765, "total_submitted": 552135}, {"id": 84, "title": "Largest Rectangle in Histogram", "url": "https://leetcode.com/problems/largest-rectangle-in-histogram/description", "companyTags": [""], "difficulty": "Hard", "content": "\r\nGiven n non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.\r\n\r\n\r\n\r\n\r\nAbove is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].\r\n\r\n\r\n\r\n\r\nThe largest rectangle is shown in the shaded area, which has area = 10 unit.\r\n\r\n\r\n\r\nFor example,\r\nGiven heights = [2,1,5,6,2,3],\r\nreturn 10.\r\n", "discussUrl": "https://discuss.leetcode.com/category/92", "similarQuestions": ["MaximalRectangle"], "topicTags": ["Array", "Stack"], "Solution": "class Solution {\n    public int largestRectangleArea(int[] heights) {\n       /* int n = heights.length;\n        Stack<Integer> s = new Stack<>();\n        int max = 0;\n        for(int i = 0; i <= n; i++) {\n            int h = (i == n ? 0 : heights[i]);\n            if(s.isEmpty() || h >= heights[s.peek()]) {\n                s.push(i);\n            } else {\n                int cur = s.pop();\n                max = Math.max(max, heights[cur] * (s.isEmpty()? i : i - 1 - s.peek()));\n                i--;\n            }\n        }\n        return max; */\n        return find(heights, 0, heights.length - 1);\n    }\n    private int find(int[] h, int left, int right){\n        if(left>right) return 0;\n        if(left==right) return h[left];\n        int minIndex=left;\n        boolean sorted=true;\n        for(int i=left+1; i<=right; i++){\n            if(h[i]<h[i-1]) sorted=false;\n            if(h[i]<h[minIndex]) minIndex=i;\n        }\n        if(sorted){\n            int max=0;\n            for(int i=left; i<=right; i++){\n                if(h[i]*(right-i+1)>max) max=h[i]*(right-i+1);\n            }\n            return max;\n        }\n        else{\n            int maxLeft=find(h, left, minIndex-1);\n            int maxRight=find(h, minIndex+1, right);\n            int crossMax=h[minIndex]*(right-left+1);\n            return Math.max(Math.max(maxLeft, maxRight), crossMax);\n        }\n    }\n}", "total_acs": 111022, "total_submitted": 404628}, {"id": 85, "title": "Maximal Rectangle", "url": "https://leetcode.com/problems/maximal-rectangle/description", "companyTags": ["Facebook"], "difficulty": "Hard", "content": "\r\nGiven a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.\r\n\r\n\r\nFor example, given the following matrix:\r\n\r\n1 0 1 0 0\r\n1 0 1 1 1\r\n1 1 1 1 1\r\n1 0 0 1 0\r\n\r\nReturn 6.\r\n", "discussUrl": "https://discuss.leetcode.com/category/93", "similarQuestions": ["LargestRectangleinHistogram", "MaximalSquare"], "topicTags": ["Array", "HashTable", "DynamicProgramming", "Stack"], "Solution": "// class Solution {\n//     public int maximalRectangle(char[][] matrix) {\n//         int row = matrix.length;\n//         if (row == 0) return 0;\n//         int col = matrix[0].length;\n//         if (col == 0) return 0;\n//         int res = helper(matrix[row - 1], 0, col - 1);\n//         for (int i = row - 2; i >= 0; i--) {\n//             for (int j = 0; j < col; j++) {\n//                 if (matrix[i][j] == '1') matrix[i][j] += matrix[i + 1][j] - '0';\n//             }\n//             res = Math.max(res, helper(matrix[i], 0, col - 1));\n//         }\n//         return res;\n//     }\n//     private int helper(char[] heights, int left, int right) {\n//         if (left == right) return heights[left] - '0';\n//         boolean ascend = true, descend = true;\n//         int min = left;\n//         for (int i = left + 1; i <= right; i++) {\n//             if (heights[i] < heights[i - 1]) ascend = false;\n//             if (heights[i] > heights[i - 1]) descend = false;\n//             if (heights[i] < heights[min]) min = i;\n//         }\n//         if (ascend) {\n//             int ret = 0;\n//             for (int i = left; i <= right; i++) {\n//                 ret = Math.max(ret, (right - i + 1) * (heights[i] - '0'));\n//             }\n//             return ret;\n//         }\n//         else if (descend) {\n//             int ret = 0;\n//             for (int i = right; i >= left; i--) {\n//                 ret = Math.max(ret, (i - left + 1) * (heights[i] - '0'));\n//             }\n//             return ret;\n//         }\n//         int leftMax = helper(heights, left, min - 1), rightMax = helper(heights, min + 1, right);\n//         int cur = (heights[min] - '0') * (right - left + 1);\n//         return Math.max(cur, Math.max(leftMax, rightMax));\n//     }\n// }\nclass Solution {\n    public int maximalRectangle(char[][] matrix) {\n     if(matrix==null || matrix.length==0 || matrix[0].length==0) return 0;\n        int m = matrix.length, n = matrix[0].length;\n        int[] heights = new int[n+1];\n        int res = 0;\n        for(int row=0; row<m; row++) {\n            updateHeights(matrix, row, heights);\n            res = Math.max(res, maxArea(heights));\n        }\n        return res;\n    }\n    \n    private void updateHeights(char[][] matrix, int row, int[] heights) {\n        for(int col=0; col<matrix[0].length; col++) {\n            if(matrix[row][col]=='1') {\n                heights[col]++;\n            } else {\n                heights[col] = 0;\n            }\n        }\n    }\n    \n    private int maxArea(int[] heights) {\n        int n = heights.length;\n        int[] stack = new int[n+1];\n        int top = 0;\n        stack[top] = -1;\n        int res = 0;\n        for(int i=0; i<n; i++) {\n            while(top>0 && heights[i]<heights[stack[top]]) {\n                int h = heights[stack[top--]];\n                res = Math.max(res, h*(i-stack[top]-1));\n            }\n            stack[++top] = i;\n        }\n        return res;\n    }\n}", "total_acs": 81467, "total_submitted": 277964}, {"id": 86, "title": "Partition List", "url": "https://leetcode.com/problems/partition-list/description", "companyTags": [""], "difficulty": "Medium", "content": "Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.\r\n\r\n\r\nYou should preserve the original relative order of the nodes in each of the two partitions.\r\n\r\n\r\nFor example,\r\nGiven 1->4->3->2->5->2 and x = 3,\r\nreturn 1->2->2->4->3->5.\r\n", "discussUrl": "https://discuss.leetcode.com/category/94", "similarQuestions": [""], "topicTags": ["LinkedList", "TwoPointers"], "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\n\n// the basic idea is to maintain two lists, the first one stores all nodes with val less than x , and the second queue stores all the rest nodes. Then concat these two queues. Remember to set the tail of second queue a null next, or it make cycle in list.\nclass Solution {\n    \n    public ListNode partition(ListNode head, int x) {\n        \n        ListNode dummy1 = new ListNode(0);//to know start of each list\n        ListNode dummy2 = new ListNode(0);\n        \n        ListNode n1= dummy1;\n        ListNode n2= dummy2;\n               \n        while(head != null){\n            if(head.val<x){\n                n1.next = head;\n                n1 = n1.next;\n            }\n            else{\n                n2.next = head;\n                n2 = n2.next;\n            }\n            head = head.next;\n        }\n        n2.next = null;\n        n1.next = dummy2.next;\n        return dummy1.next;\n        \n    }\n    \n    // public ListNode partition(ListNode head, int x) {\n//         if(head == null) return head;\n        \n//         ListNode beforeStart = null;\n//         ListNode before = null;\n//         ListNode after = null;\n//         ListNode afterStart = null;\n//         ListNode curr = head;\t\n// /* Partition list */\n// \t\twhile (curr != null) {\n\t\t\t\n// \t\t\tif (curr.val < x) {\n// \t\t\t\tif (beforeStart == null) {\n// \t\t\t\t\tbeforeStart = new ListNode(curr.val);\n// \t\t\t\t\tbefore = beforeStart;\n// \t\t\t\t} else {\n// \t\t\t\t\tbefore.next = new ListNode(curr.val);\n// \t\t\t\t\tbefore = before.next;\n// \t\t\t\t}\n// \t\t\t} else {\n// \t\t\t\tif (afterStart == null) {\n// \t\t\t\t\tafterStart = new ListNode(curr.val);\n// \t\t\t\t\tafter = afterStart;\n// \t\t\t\t} else {\n// \t\t\t\t\tafter.next = new ListNode(curr.val);\n// \t\t\t\t\tafter = after.next;\n// \t\t\t\t}\n// \t\t\t}\t\n// \t\t\tcurr = curr.next;\n// \t\t}\n\t\t\n// \t\t/* Merge before list and after list */\n// \t\tif (beforeStart == null) {\n// \t\t\treturn afterStart;\n// \t\t}\t\n// \t\tbefore.next = afterStart;\n// \t\treturn beforeStart;\n    // }\n}", "total_acs": 117443, "total_submitted": 352477}, {"id": 87, "title": "Scramble String", "url": "https://leetcode.com/problems/scramble-string/description", "companyTags": [""], "difficulty": "Hard", "content": "\r\nGiven a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.\r\n\r\n\r\nBelow is one possible representation of s1 = \"great\":\r\n\r\n\r\n    great\r\n   /    \\\r\n  gr    eat\r\n / \\    /  \\\r\ng   r  e   at\r\n           / \\\r\n          a   t\r\n\r\n\r\nTo scramble the string, we may choose any non-leaf node and swap its two children.\r\n\r\n\r\nFor example, if we choose the node \"gr\" and swap its two children, it produces a scrambled string \"rgeat\".\r\n\r\n\r\n    rgeat\r\n   /    \\\r\n  rg    eat\r\n / \\    /  \\\r\nr   g  e   at\r\n           / \\\r\n          a   t\r\n\r\n\r\nWe say that \"rgeat\" is a scrambled string of \"great\".\r\n\r\n\r\nSimilarly, if we continue to swap the children of nodes \"eat\" and \"at\", it produces a scrambled string \"rgtae\".\r\n\r\n\r\n    rgtae\r\n   /    \\\r\n  rg    tae\r\n / \\    /  \\\r\nr   g  ta  e\r\n       / \\\r\n      t   a\r\n\r\n\r\nWe say that \"rgtae\" is a scrambled string of \"great\".\r\n\r\n\r\nGiven two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1.\r\n", "discussUrl": "https://discuss.leetcode.com/category/95", "similarQuestions": [""], "topicTags": ["String", "DynamicProgramming"], "Solution": "import java.util.Collection;\n\nclass Solution {\n          public boolean isScramble(String s1, String s2) {\n       int l1=s1.length(), l2=s2.length();\n        if(l1!=l2) return false;\n        if(l1<=1) return s1.equals(s2);\n        if(s1.equals(s2)) return true;\n        long a=1, b=1, c=1;\n        for(int i=0; i<l1; i++){\n            if(i>0 && a==b && isScramble(s1.substring(0,i),s2.substring(l2-i)) && isScramble(s1.substring(i),s2.substring(0,l2-i)))\n                return true;\n            if(i>0 && a==c && isScramble(s1.substring(0,i),s2.substring(0,i)) && isScramble(s1.substring(i),s2.substring(i)))\n                return true;\n            a*=s1.charAt(i);\n            b*=s2.charAt(l2-1-i);\n            c*=s2.charAt(i);\n        }\n        return false;\n    }\n}", "total_acs": 71440, "total_submitted": 241157}, {"id": 88, "title": "Merge Sorted Array", "url": "https://leetcode.com/problems/merge-sorted-array/description", "companyTags": ["Facebook", "Microsoft", "Bloomberg"], "difficulty": "Easy", "content": "Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.\r\n\r\n\r\nNote:\r\nYou may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.", "discussUrl": "https://discuss.leetcode.com/category/96", "similarQuestions": ["MergeTwoSortedLists"], "topicTags": ["Array", "TwoPointers"], "Solution": "class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        \n        int k = m + n - 1;\n        int i = m-1, j = n-1;\n        while (i >= 0 && j >= 0) {\n            \n            if (nums1[i] > nums2[j]) nums1[k--] = nums1[i--];\n            else nums1[k--] = nums2[j--];\n        }\n        \n        while (j >= 0) {\n            nums1[k--] = nums2[j--];\n        }\n    }\n}", "total_acs": 215589, "total_submitted": 670221}, {"id": 89, "title": "Gray Code", "url": "https://leetcode.com/problems/gray-code/description", "companyTags": ["Amazon"], "difficulty": "Medium", "content": "The gray code is a binary numeral system where two successive values differ in only one bit.\r\n\r\nGiven a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.\r\n\r\nFor example, given n = 2, return [0,1,3,2]. Its gray code sequence is:\r\n\r\n00 - 0\r\n01 - 1\r\n11 - 3\r\n10 - 2\r\n\r\n\r\nNote:\r\nFor a given n, a gray code sequence is not uniquely defined.\r\n\r\nFor example, [0,2,3,1] is also a valid gray code sequence according to the above definition.\r\n\r\nFor now, the judge is able to judge based on one instance of gray code sequence. Sorry about that.", "discussUrl": "https://discuss.leetcode.com/category/97", "similarQuestions": ["1-bitand2-bitCharacters"], "topicTags": ["Backtracking"], "Solution": "class Solution {\n    public List<Integer> grayCode(int n) {\n        List<Integer> rs=new ArrayList<Integer>();\n        rs.add(0);\n        for(int i=0;i<n;i++){\n            int size=rs.size();\n            for(int k=size-1;k>=0;k--)\n                rs.add(rs.get(k) | 1<<i);\n        }\n        return rs;\n    }\n}", "total_acs": 102965, "total_submitted": 243954}, {"id": 90, "title": "Subsets II", "url": "https://leetcode.com/problems/subsets-ii/description", "companyTags": ["Facebook"], "difficulty": "Medium", "content": "\r\nGiven a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).\r\n\r\nNote: The solution set must not contain duplicate subsets.\r\n\r\n\r\nFor example,\r\nIf nums = [1,2,2], a solution is:\r\n\r\n\r\n\r\n[\r\n  [2],\r\n  [1],\r\n  [1,2,2],\r\n  [2,2],\r\n  [1,2],\r\n  []\r\n]\r\n", "discussUrl": "https://discuss.leetcode.com/category/98", "similarQuestions": [""], "topicTags": ["Array", "Backtracking"], "Solution": "public class Solution {\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        Arrays.sort(nums);\n        helper(result, new ArrayList<Integer>(), nums, 0);\n        return result;\n    }\n    private void helper(List<List<Integer>> list, ArrayList<Integer> temlist, int[] nums, int pos){\n       \n          \n        \n        list.add(new ArrayList<Integer>(temlist));\n        for (int i = pos; i < nums.length; i++){\n            if (i > 0 && i != pos && nums[i] == nums[i - 1]){\n                continue;\n            }\n            temlist.add(nums[i]);\n            helper(list,  temlist , nums, i + 1);\n            temlist.remove(temlist.size() - 1);\n        }\n    }\n}\n/*\n1  2  3  4\n1  pos   i\n*/", "total_acs": 137875, "total_submitted": 364199}, {"id": 91, "title": "Decode Ways", "url": "https://leetcode.com/problems/decode-ways/description", "companyTags": ["Facebook", "Microsoft", "Uber"], "difficulty": "Medium", "content": "\r\nA message containing letters from A-Z is being encoded to numbers using the following mapping:\r\n\r\n\r\n\r\n'A' -> 1\r\n'B' -> 2\r\n...\r\n'Z' -> 26\r\n\r\n\r\n\r\nGiven an encoded message containing digits, determine the total number of ways to decode it.\r\n\r\n\r\n\r\nFor example,\r\nGiven encoded message \"12\",\r\nit could be decoded as \"AB\" (1 2) or \"L\" (12).\r\n\r\n\r\n\r\nThe number of ways decoding \"12\" is 2.\r\n", "discussUrl": "https://discuss.leetcode.com/category/99", "similarQuestions": ["DecodeWaysII"], "topicTags": ["String", "DynamicProgramming"], "Solution": "class Solution {\n    public int numDecodings(String s) {\n        if (s == null || s.length() == 0)\n            return 0;\n        int n = s.length();\n        int[] dp = new int[n+1];\n        dp[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            if (s.charAt(i-1) >= '1' && s.charAt(i-1) <= '9')\n                dp[i] = dp[i-1];\n            if (i > 1) {\n                if (s.charAt(i-2) == '1' || s.charAt(i-2) == '2' && s.charAt(i-1) <= '6') {\n                    dp[i] += dp[i-2];\n                }\n            }\n        }\n        return dp[n];\n    }\n}", "total_acs": 159700, "total_submitted": 789504}, {"id": 92, "title": "Reverse Linked List II", "url": "https://leetcode.com/problems/reverse-linked-list-ii/description", "companyTags": [""], "difficulty": "Medium", "content": "\r\nReverse a linked list from position m to n. Do it in-place and in one-pass.\r\n\r\n\r\n\r\nFor example:\r\nGiven 1->2->3->4->5->NULL, m = 2 and n = 4,\r\n\r\n\r\nreturn 1->4->3->2->5->NULL.\r\n\r\n\r\nNote:\r\nGiven m, n satisfy the following condition:\r\n1 \u2264 m \u2264 n \u2264 length of list.\r\n", "discussUrl": "https://discuss.leetcode.com/category/100", "similarQuestions": ["ReverseLinkedList"], "topicTags": ["LinkedList"], "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode reverseBetween(ListNode head, int m, int n) {\n        if(head == null || head.next == null){\n            return head;\n        }\n        \n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode prev = dummy;\n        \n        for(int i = 0; i < m - 1; i++){\n            prev = prev.next;\n        }\n        \n        ListNode start = prev.next;\n        ListNode then = start.next;\n        \n        for(int j = m; j < n; j++){\n            \n            start.next = then.next;\n            then.next = prev.next;\n            prev.next = then;\n            then = start.next;\n        }\n        \n        return dummy.next;\n    }\n}", "total_acs": 131360, "total_submitted": 420777}, {"id": 93, "title": "Restore IP Addresses", "url": "https://leetcode.com/problems/restore-ip-addresses/description", "companyTags": [""], "difficulty": "Medium", "content": "Given a string containing only digits, restore it by returning all possible valid IP address combinations.\r\n\r\n\r\nFor example:\r\nGiven \"25525511135\",\r\n\r\n\r\nreturn [\"255.255.11.135\", \"255.255.111.35\"]. (Order does not matter)\r\n", "discussUrl": "https://discuss.leetcode.com/category/101", "similarQuestions": ["IPtoCIDR"], "topicTags": ["String", "Backtracking"], "Solution": "class Solution {\n    public void helper(List<String> ret, String s, int pos, int[] curr, int ind){\n        if(ind==4 && pos==s.length()){\n            StringBuilder sb = new StringBuilder();\n            for(int i=0;i<4;i++){\n                if(sb.length()>0) sb.append('.');\n                sb.append(curr[i]);\n            }\n            ret.add(sb.toString());\n        }else if(ind<4 && pos<s.length()){\n            int n = 0;\n            for(int i=pos;i<s.length() && i<pos+3;i++){\n                n*=10;\n                n+=(s.charAt(i)-'0');\n                if(n>255) return ;\n                curr[ind] = n;\n                helper(ret,s,i+1,curr,ind+1);\n                if(n==0) return;\n            }\n            curr[ind] = 0;\n        }\n    }\n    \n    public List<String> restoreIpAddresses(String s) {\n        List<String> ret = new ArrayList<>();\n        helper(ret,s,0,new int[4], 0);\n        return ret;\n    }\n}", "total_acs": 98984, "total_submitted": 350570}, {"id": 94, "title": "Binary Tree Inorder Traversal", "url": "https://leetcode.com/problems/binary-tree-inorder-traversal/description", "companyTags": ["Microsoft"], "difficulty": "Medium", "content": "Given a binary tree, return the inorder traversal of its nodes' values.\r\n\r\n\r\nFor example:\r\nGiven binary tree [1,null,2,3],\r\n\r\n   1\r\n    \\\r\n     2\r\n    /\r\n   3\r\n\r\n\r\n\r\nreturn [1,3,2].\r\n\r\n\r\nNote: Recursive solution is trivial, could you do it iteratively?", "discussUrl": "https://discuss.leetcode.com/category/102", "similarQuestions": ["ValidateBinarySearchTree", "BinaryTreePreorderTraversal", "BinaryTreePostorderTraversal", "BinarySearchTreeIterator", "KthSmallestElementinaBST", "ClosestBinarySearchTreeValueII", "InorderSuccessorinBST"], "topicTags": ["HashTable", "Stack", "Tree"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        if(root == null)return res;\n        helper(res,root.left);\n        res.add(root.val);\n        helper(res,root.right);\n        return res;\n\n    } \n    private void helper(List<Integer> res,TreeNode node){\n        if(node == null)return;\n        helper(res,node.left);\n        res.add(node.val);\n        helper(res,node.right);\n    }\n}", "total_acs": 255163, "total_submitted": 522189}, {"id": 95, "title": "Unique Binary Search Trees II", "url": "https://leetcode.com/problems/unique-binary-search-trees-ii/description", "companyTags": [""], "difficulty": "Medium", "content": "Given an integer n, generate all structurally unique BST's (binary search trees) that store values 1...n.\r\n\r\n\r\nFor example,\r\nGiven n = 3, your program should return all 5 unique BST's shown below.\r\n\r\n\r\n   1         3     3      2      1\r\n    \\       /     /      / \\      \\\r\n     3     2     1      1   3      2\r\n    /     /       \\                 \\\r\n   2     1         2                 3\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/103", "similarQuestions": ["UniqueBinarySearchTrees", "DifferentWaystoAddParentheses"], "topicTags": ["DynamicProgramming", "Tree"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n     public List<TreeNode> generateTrees(int n) {\n        if(n < 1)\n            return new ArrayList<>();\n        List<TreeNode>[][] dp = new List[n+2][n+2];\n        return helper(1, n, dp);\n    }\n    \n    public List<TreeNode> helper(int start, int end, List[][] dp){\n        if(dp[start][end] != null)\n            return dp[start][end];\n        List<TreeNode> list = new ArrayList<>();\n        if(start > end){\n            list.add(null);\n        }\n        else if(start==end){\n            list.add(new TreeNode(start));\n        }\n        else{\n             for(int i = start; i <= end; i++){\n                List<TreeNode> left = helper(start, i-1, dp);\n                List<TreeNode> right = helper(i+1, end, dp);\n                for(TreeNode l : left){\n                    for(TreeNode r : right){\n                    TreeNode node = new TreeNode(i);\n                    node.left = l;\n                    node.right = r;\n                    list.add(node);\n                    }\n                }\n            }\n        }\n        dp[start][end] = list;\n        return list; \n    }\n\n}", "total_acs": 96794, "total_submitted": 301898}, {"id": 96, "title": "Unique Binary Search Trees", "url": "https://leetcode.com/problems/unique-binary-search-trees/description", "companyTags": ["Snapchat"], "difficulty": "Medium", "content": "Given n, how many structurally unique BST's (binary search trees) that store values 1...n?\r\n\r\n\r\nFor example,\r\nGiven n = 3, there are a total of 5 unique BST's.\r\n\r\n\r\n   1         3     3      2      1\r\n    \\       /     /      / \\      \\\r\n     3     2     1      1   3      2\r\n    /     /       \\                 \\\r\n   2     1         2                 3\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/104", "similarQuestions": ["UniqueBinarySearchTreesII"], "topicTags": ["DynamicProgramming", "Tree"], "Solution": "class Solution {\n    public int numTrees(int n) \n    {\n        HashMap<Integer, Integer> hm = new HashMap<Integer, Integer>();\n        return calcUniqBST(1, n, hm);\n    }\n    \n    public int calcUniqBST(int left, int right, HashMap<Integer, Integer> hm)\n    {\n        if(left == right)\n            return 1;\n        else if(left > right)\n            return 0;\n        else if(right - left == 1)\n            return 2;\n        else if(right - left == 2)\n            return 5;\n        else if(hm.containsKey(right - left))\n            return hm.get(right - left);\n        else\n        {\n            int total = 0;\n            for(int i = left; i <= right; i++)\n            {\n                int lsb = calcUniqBST(left, i-1, hm);\n                int rsb = calcUniqBST(i+1, right, hm);\n                if(lsb == 0) total += rsb;\n                else if(rsb == 0) total += lsb;\n                else total += lsb*rsb;\n            }\n            hm.put(right-left, total);\n            return total;\n        }\n    }\n}", "total_acs": 142758, "total_submitted": 341830}, {"id": 97, "title": "Interleaving String", "url": "https://leetcode.com/problems/interleaving-string/description", "companyTags": [""], "difficulty": "Hard", "content": "\r\nGiven s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.\r\n\r\n\r\n\r\nFor example,\r\nGiven:\r\ns1 = \"aabcc\",\r\ns2 = \"dbbca\",\r\n\r\n\r\nWhen s3 = \"aadbbcbcac\", return true.\r\nWhen s3 = \"aadbbbaccc\", return false.\r\n", "discussUrl": "https://discuss.leetcode.com/category/105", "similarQuestions": [""], "topicTags": ["String", "DynamicProgramming"], "Solution": "class Solution {\n    public boolean isInterleave(String s1, String s2, String s3) {\n        int[][] dp = new int[s1.length()][s2.length()];\n        return helper(s1, 0, s2, 0, s3, 0, dp);\n    }\n    private boolean helper(String s1, int j, String s2, int k, String s3, int i, int[][] dp) {\n        \n        if (j == s1.length()) return s2.substring(k).equals(s3.substring(i));\n        if (k == s2.length()) return s1.substring(j).equals(s3.substring(i));\n        if (dp[j][k] != 0) return dp[j][k] == 1;\n        \n\n        if (s3.charAt(i) == s1.charAt(j) && helper(s1, j + 1, s2, k, s3, i + 1, dp)\n            || s3.charAt(i) == s2.charAt(k) && helper(s1, j, s2, k + 1, s3, i + 1, dp)) {\n            dp[j][k] = 1;\n            return true;\n        }\n        \n        dp[j][k] = -1;\n        return false;\n\n    }\n    \n}", "total_acs": 80162, "total_submitted": 319572}, {"id": 98, "title": "Validate Binary Search Tree", "url": "https://leetcode.com/problems/validate-binary-search-tree/description", "companyTags": ["Facebook", "Microsoft", "Amazon", "Bloomberg"], "difficulty": "Medium", "content": "\r\nGiven a binary tree, determine if it is a valid binary search tree (BST).\r\n\r\n\r\n\r\nAssume a BST is defined as follows:\r\n\r\nThe left subtree of a node contains only nodes with keys less than the node's key.\r\nThe right subtree of a node contains only nodes with keys greater than the node's key.\r\nBoth the left and right subtrees must also be binary search trees.\r\n\r\n\r\n\r\nExample 1:\r\n\r\n    2\r\n   / \\\r\n  1   3\r\n\r\nBinary tree [2,1,3], return true.\r\n\r\n\r\nExample 2:\r\n\r\n    1\r\n   / \\\r\n  2   3\r\n\r\nBinary tree [1,2,3], return false.\r\n", "discussUrl": "https://discuss.leetcode.com/category/106", "similarQuestions": ["BinaryTreeInorderTraversal", "FindModeinBinarySearchTree"], "topicTags": ["Tree", "Depth-firstSearch"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public boolean isValidBST(TreeNode root) {\n        if(root == null) return true;\n        if(root.left == null && root.right == null) return true;\n        return isValidWithBound(root, Long.MIN_VALUE, Long.MAX_VALUE);\n    }\n    \n    public boolean isValidWithBound(TreeNode root, double low, double high){\n        if(root == null) return true;\n        if(root.val <= low || root.val >= high) return false;\n        return isValidWithBound(root.left, low, root.val) && isValidWithBound(root.right, root.val, high);\n    }\n}", "total_acs": 218753, "total_submitted": 911704}, {"id": 99, "title": "Recover Binary Search Tree", "url": "https://leetcode.com/problems/recover-binary-search-tree/description", "companyTags": [""], "difficulty": "Hard", "content": "\r\nTwo elements of a binary search tree (BST) are swapped by mistake.\r\n\r\nRecover the tree without changing its structure.\r\n\r\n\r\nNote:\r\nA solution using O(n) space is pretty straight forward. Could you devise a constant space solution?\r\n", "discussUrl": "https://discuss.leetcode.com/category/107", "similarQuestions": [""], "topicTags": ["Tree", "Depth-firstSearch"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    \n    TreeNode firstElement = null;\n    TreeNode secondElement = null;\n    TreeNode prev = null;\n    public void recoverTree(TreeNode root) {\n        \n        inOrderTraversal(root);\n        \n        if (firstElement != null && secondElement != null) {\n            int temp = firstElement.val;\n            firstElement.val = secondElement.val;\n            secondElement.val = temp;\n        }\n    }\n    \n    private void inOrderTraversal(TreeNode root) {\n        \n        if (root == null) {\n            return;\n        }\n        \n        inOrderTraversal(root.left);\n        \n        if (firstElement == null && (prev == null || prev.val >= root.val)) {\n            firstElement = prev;\n        }\n        \n        if (firstElement != null && prev.val >= root.val) {\n            secondElement = root;\n        }\n        \n        prev = root;\n        \n        inOrderTraversal(root.right);\n    }\n}", "total_acs": 84721, "total_submitted": 275135}, {"id": 100, "title": "Same Tree", "url": "https://leetcode.com/problems/same-tree/description", "companyTags": ["Bloomberg"], "difficulty": "Easy", "content": "\r\nGiven two binary trees, write a function to check if they are the same or not.\r\n\r\n\r\nTwo binary trees are considered the same if they are structurally identical and the nodes have the same value.\r\n\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput:     1         1\r\n          / \\       / \\\r\n         2   3     2   3\r\n\r\n        [1,2,3],   [1,2,3]\r\n\r\nOutput: true\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput:     1         1\r\n          /           \\\r\n         2             2\r\n\r\n        [1,2],     [1,null,2]\r\n\r\nOutput: false\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput:     1         1\r\n          / \\       / \\\r\n         2   1     1   2\r\n\r\n        [1,2,1],   [1,1,2]\r\n\r\nOutput: false\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/108", "similarQuestions": [""], "topicTags": ["Tree", "Depth-firstSearch"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\npublic boolean isSameTree(TreeNode p, TreeNode q){\n\n\t\t\tif (p == null && q == null){\n\t\t\t\treturn true;\n\t\t\t}else if (p == null || q == null){\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tStack<TreeNode> pStack = new Stack<>();\n\t\t\tStack<TreeNode> qStack = new Stack<>();\n\n\t\t\tpStack.push(p);\n\t\t\tqStack.push(q);\n\n\t\t\twhile (!(pStack.isEmpty() && qStack.isEmpty())) {\n\t\t\t\tTreeNode nq = qStack.pop();\n\t\t\t\tTreeNode np = pStack.pop();\n\n\t\t\t\tif (nq.val != np.val) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (nq.left != null) {\n\t\t\t\t\tqStack.push(nq.left);\n\t\t\t\t}\n\t\t\t\tif (np.left != null) {\n\t\t\t\t\tpStack.push(np.left);\n\t\t\t\t}\n\n\t\t\t\tif (qStack.size() != pStack.size()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (nq.right != null) {\n\t\t\t\t\tqStack.push(nq.right);\n\t\t\t\t}\n\t\t\t\tif (np.right != null) {\n\t\t\t\t\tpStack.push(np.right);\n\t\t\t\t}\n\t\t\t\tif (pStack.size() != qStack.size()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn pStack.size() == qStack.size();\n\t\t}\n}", "total_acs": 249588, "total_submitted": 525674}, {"id": 101, "title": "Symmetric Tree", "url": "https://leetcode.com/problems/symmetric-tree/description", "companyTags": ["Microsoft", "Bloomberg", "LinkedIn"], "difficulty": "Easy", "content": "Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).\r\n\r\n\r\nFor example, this binary tree [1,2,2,3,4,4,3] is symmetric:\r\n\r\n    1\r\n   / \\\r\n  2   2\r\n / \\ / \\\r\n3  4 4  3\r\n\r\n\r\n\r\nBut the following [1,2,2,null,3,null,3]  is not:\r\n\r\n    1\r\n   / \\\r\n  2   2\r\n   \\   \\\r\n   3    3\r\n\r\n\r\n\r\n\r\nNote:\r\nBonus points if you could solve it both recursively and iteratively.\r\n", "discussUrl": "https://discuss.leetcode.com/category/109", "similarQuestions": [""], "topicTags": ["Tree", "Depth-firstSearch", "Breadth-firstSearch"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public boolean isSymmetric(TreeNode root) {\n        return root == null || isSymmetric(root.left, root.right);\n    }\n\n    private boolean isSymmetric(TreeNode left, TreeNode right) {\n        int nu = (left == null ? 1 : 0) + (right == null ? 1 : 0);\n        if (nu == 1)\n            return false;\n        if (nu == 2)\n            return true;\n        return left.val == right.val && isSymmetric(left.left, right.right) && isSymmetric(left.right, right.left);\n    }\n}", "total_acs": 228942, "total_submitted": 571572}, {"id": 102, "title": "Binary Tree Level Order Traversal", "url": "https://leetcode.com/problems/binary-tree-level-order-traversal/description", "companyTags": ["Facebook", "Microsoft", "Amazon", "Bloomberg", "LinkedIn", "Apple"], "difficulty": "Medium", "content": "Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).\r\n\r\n\r\nFor example:\r\nGiven binary tree [3,9,20,null,null,15,7],\r\n\r\n    3\r\n   / \\\r\n  9  20\r\n    /  \\\r\n   15   7\r\n\r\n\r\n\r\nreturn its level order traversal as:\r\n\r\n[\r\n  [3],\r\n  [9,20],\r\n  [15,7]\r\n]\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/110", "similarQuestions": ["BinaryTreeZigzagLevelOrderTraversal", "BinaryTreeLevelOrderTraversalII", "MinimumDepthofBinaryTree", "BinaryTreeVerticalOrderTraversal", "AverageofLevelsinBinaryTree"], "topicTags": ["Tree", "Breadth-firstSearch"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        List<List<Integer>> res = new ArrayList<>();\n        levelTraverse(root, 0, res);\n        return res;\n    }\n    private void levelTraverse(TreeNode root, int depth, List<List<Integer>> res) {\n        if (root == null) {\n            return;\n        }\n        if (res.size() == depth) {\n            res.add(new ArrayList<Integer>());\n        }\n        res.get(depth).add(root.val);\n        levelTraverse(root.left, depth+1, res);\n        levelTraverse(root.right, depth+1, res);\n    }\n}", "total_acs": 218821, "total_submitted": 522475}, {"id": 103, "title": "Binary Tree Zigzag Level Order Traversal", "url": "https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description", "companyTags": ["Microsoft", "Bloomberg", "LinkedIn"], "difficulty": "Medium", "content": "Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).\r\n\r\n\r\nFor example:\r\nGiven binary tree [3,9,20,null,null,15,7],\r\n\r\n    3\r\n   / \\\r\n  9  20\r\n    /  \\\r\n   15   7\r\n\r\n\r\n\r\nreturn its zigzag level order traversal as:\r\n\r\n[\r\n  [3],\r\n  [20,9],\r\n  [15,7]\r\n]\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/111", "similarQuestions": ["BinaryTreeLevelOrderTraversal"], "topicTags": ["Stack", "Tree", "Breadth-firstSearch"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n        if(root == null) return new ArrayList();\n        \n        List<List<Integer>> list = new ArrayList<List<Integer>>();\n            \n        helper(root, list, 0);\n        \n        return list;\n    }\n    \n    public void helper(TreeNode root, List<List<Integer>> list, int level) {\n        \n        if(root == null) return;\n        \n        if(list.size() <= level) {\n            list.add(level, new LinkedList<Integer>());\n        }\n        \n        if(level%2==0) list.get(level).add(root.val);\n        else list.get(level).add(0,root.val);\n        \n        helper(root.left, list, level+1);\n        helper(root.right, list, level+1);\n    }\n}", "total_acs": 127494, "total_submitted": 351066}, {"id": 104, "title": "Maximum Depth of Binary Tree", "url": "https://leetcode.com/problems/maximum-depth-of-binary-tree/description", "companyTags": ["Uber", "LinkedIn", "Apple", "Yahoo"], "difficulty": "Easy", "content": "Given a binary tree, find its maximum depth.\r\n\r\nThe maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\r\n\r\nFor example:\r\nGiven binary tree [3,9,20,null,null,15,7],\r\n\r\n\r\n    3\r\n   / \\\r\n  9  20\r\n    /  \\\r\n   15   7\r\n\r\nreturn its depth = 3.\r\n", "discussUrl": "https://discuss.leetcode.com/category/112", "similarQuestions": ["BalancedBinaryTree", "MinimumDepthofBinaryTree"], "topicTags": ["Tree", "Depth-firstSearch"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null)\n            return 0;\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n    }\n}", "total_acs": 305269, "total_submitted": 564180}, {"id": 105, "title": "Construct Binary Tree from Preorder and Inorder Traversal", "url": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description", "companyTags": ["Bloomberg"], "difficulty": "Medium", "content": "Given preorder and inorder traversal of a tree, construct the binary tree.\r\n\r\nNote:\r\nYou may assume that duplicates do not exist in the tree.\r\n\r\nFor example, given\r\n\r\n\r\npreorder =\u00a0[3,9,20,15,7]\r\ninorder = [9,3,15,20,7]\r\n\r\nReturn the following binary tree:\r\n\r\n\r\n    3\r\n   / \\\r\n  9  20\r\n    /  \\\r\n   15   7\r\n", "discussUrl": "https://discuss.leetcode.com/category/113", "similarQuestions": ["ConstructBinaryTreefromInorderandPostorderTraversal"], "topicTags": ["Array", "Tree", "Depth-firstSearch"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        int[] preIndex = new int[] {0};\n        int[] inIndex = new int[] {0};\n        return buildTree(preorder, inorder, preIndex, inIndex, Integer.MAX_VALUE);\n    }\n    \n    private TreeNode buildTree(int[] preorder, int[] inorder, int[] preIndex, int[] inIndex, int target) {\n        //pre: [root][left][right];\n        //in: [left][root][right];\n        //target is the root\n        if (inIndex[0] >= inorder.length || inorder[inIndex[0]] == target) {\n            return null;\n        }\n        TreeNode root = new TreeNode(preorder[preIndex[0]]);\n        //preorder, advance the index by 1 sice we already finish the root;\n        preIndex[0]++;\n        root.left = buildTree(preorder, inorder, preIndex, inIndex, root.val);\n        //after finishing left subtree, we can advance the index by 1\n        inIndex[0]++;\n        root.right = buildTree(preorder, inorder, preIndex, inIndex, target);\n        return root;\n    }\n}", "total_acs": 128591, "total_submitted": 385244}, {"id": 106, "title": "Construct Binary Tree from Inorder and Postorder Traversal", "url": "https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description", "companyTags": ["Microsoft"], "difficulty": "Medium", "content": "Given inorder and postorder traversal of a tree, construct the binary tree.\r\n\r\nNote:\r\nYou may assume that duplicates do not exist in the tree.\r\n\r\nFor example, given\r\n\r\n\r\ninorder =\u00a0[9,3,15,20,7]\r\npostorder = [9,15,7,20,3]\r\n\r\nReturn the following binary tree:\r\n\r\n\r\n    3\r\n   / \\\r\n  9  20\r\n    /  \\\r\n   15   7\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/114", "similarQuestions": ["ConstructBinaryTreefromPreorderandInorderTraversal"], "topicTags": ["Array", "Tree", "Depth-firstSearch"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        return buildTree(inorder, inorder.length-1, 0, postorder, postorder.length-1);\n    }\n\n    private TreeNode buildTree(int[] inorder, int inStart, int inEnd, int[] postorder, int postStart) {\n        if (postStart < 0 || inStart < inEnd)\n            return null;\n\n        //The last element in postorder is the root.\n        TreeNode root = new TreeNode(postorder[postStart]);\n\n        //find the index of the root from inorder. Iterating from the end.\n        int rIndex = inStart;\n        for (int i = inStart; i >= inEnd; i--) {\n            if (inorder[i] == postorder[postStart]) {\n                rIndex = i;\n                break;\n            }\n        }\n        //build right and left subtrees. Again, scanning from the end to find the sections.\n        root.right = buildTree(inorder, inStart, rIndex + 1, postorder, postStart-1);\n        root.left = buildTree(inorder, rIndex - 1, inEnd, postorder, postStart - 1-(inStart - rIndex));\n        return root;\n    }\n}", "total_acs": 101125, "total_submitted": 306385}, {"id": 107, "title": "Binary Tree Level Order Traversal II", "url": "https://leetcode.com/problems/binary-tree-level-order-traversal-ii/description", "companyTags": [""], "difficulty": "Easy", "content": "Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).\r\n\r\n\r\nFor example:\r\nGiven binary tree [3,9,20,null,null,15,7],\r\n\r\n    3\r\n   / \\\r\n  9  20\r\n    /  \\\r\n   15   7\r\n\r\n\r\n\r\nreturn its bottom-up level order traversal as:\r\n\r\n[\r\n  [15,7],\r\n  [9,20],\r\n  [3]\r\n]\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/115", "similarQuestions": ["BinaryTreeLevelOrderTraversal", "AverageofLevelsinBinaryTree"], "topicTags": ["Tree", "Breadth-firstSearch"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<List<Integer>> levelOrderBottom(TreeNode root) {\n        List<List<Integer>> out = new ArrayList<>();\n        if (root == null) return out;\n        \n        traverse(out, root, 0);\n        \n        Collections.reverse(out);\n        \n        return out;\n    }\n    \n    public void traverse(List<List<Integer>> out, TreeNode root, int depth) {\n        \n        if ( root == null) return;\n        \n        // The slow will increase gradualy one by one -> add a new list when reaching a new depth\n        if ( depth == out.size() ) out.add(new ArrayList<Integer>());\n        \n        traverse(out, root.left, depth+1);\n        \n        \n        out.get(depth).add(root.val);\n        \n        \n        traverse(out, root.right, depth+1);\n    }\n}", "total_acs": 154796, "total_submitted": 371276}, {"id": 108, "title": "Convert Sorted Array to Binary Search Tree", "url": "https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description", "companyTags": ["Airbnb"], "difficulty": "Easy", "content": "Given an array where elements are sorted in ascending order, convert it to a height balanced BST.\r\n\r\nFor this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\r\n\r\n\r\n\r\n\r\nExample:\r\n\r\nGiven the sorted array: [-10,-3,0,5,9],\r\n\r\nOne possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:\r\n\r\n      0\r\n     / \\\r\n   -3   9\r\n   /   /\r\n -10  5\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/116", "similarQuestions": ["ConvertSortedListtoBinarySearchTree"], "topicTags": ["Tree", "Depth-firstSearch"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    private TreeNode help(int[] nums, int l, int r) {\n        if(l > r) return null;\n        int mid = l + (r - l) / 2;\n        TreeNode n = new TreeNode(nums[mid]);\n        n.left = help(nums, l, mid - 1);\n        n.right = help(nums, mid + 1, r);\n        return n;\n    }\n    public TreeNode sortedArrayToBST(int[] nums) {\n        return help(nums, 0, nums.length - 1);\n    }\n}", "total_acs": 161459, "total_submitted": 368731}, {"id": 109, "title": "Convert Sorted List to Binary Search Tree", "url": "https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/description", "companyTags": ["Zenefits"], "difficulty": "Medium", "content": "Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.\r\n\r\nFor this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\r\n\r\n\r\n\r\n\r\nExample:\r\n\r\nGiven the sorted linked list: [-10,-3,0,5,9],\r\n\r\nOne possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:\r\n\r\n      0\r\n     / \\\r\n   -3   9\r\n   /   /\r\n -10  5\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/117", "similarQuestions": ["ConvertSortedArraytoBinarySearchTree"], "topicTags": ["LinkedList", "Depth-firstSearch"], "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    private ListNode current;\n    private int getSize(ListNode head){\n        int size = 0;\n        while(head != null){\n            size++;\n            head = head.next;\n        }\n        return size;\n    }\n    private TreeNode sortedListToBSTHelper(int size){\n        if (size <= 0){\n            return null;\n        }\n       \n        TreeNode left = sortedListToBSTHelper(size / 2);\n        TreeNode root = new TreeNode(current.val);\n        current = current.next;\n        TreeNode right = sortedListToBSTHelper(size - size / 2 - 1);\n        root.left = left;\n        root.right = right;\n       \n        return root;\n    }\n    \n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null){\n            return null;\n        }\n        current = head;\n        int size = getSize(head);\n        return sortedListToBSTHelper(size);\n    }\n}", "total_acs": 125880, "total_submitted": 357204}, {"id": 110, "title": "Balanced Binary Tree", "url": "https://leetcode.com/problems/balanced-binary-tree/description", "companyTags": ["Bloomberg"], "difficulty": "Easy", "content": "Given a binary tree, determine if it is height-balanced.\r\n\r\nFor this problem, a height-balanced binary tree is defined as:\r\n\r\n\r\na binary tree in which the depth of the two subtrees of every node never differ by more than 1.\r\n\r\n\r\nExample 1:\r\n\r\nGiven the following tree [3,9,20,null,null,15,7]:\r\n\r\n\r\n    3\r\n   / \\\r\n  9  20\r\n    /  \\\r\n   15   7\r\n\r\nReturn true.\r\n\r\nExample 2:\r\n\r\nGiven the following tree [1,2,2,3,3,null,null,4,4]:\r\n\r\n\r\n       1\r\n      / \\\r\n     2   2\r\n    / \\\r\n   3   3\r\n  / \\\r\n 4   4\r\n\r\n\r\nReturn false.\r\n", "discussUrl": "https://discuss.leetcode.com/category/118", "similarQuestions": ["MaximumDepthofBinaryTree"], "topicTags": ["Tree", "Depth-firstSearch"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    static int NOT_BALANCED = -1;\n    public boolean isBalanced(TreeNode root) {\n        return getDepth(root) != NOT_BALANCED;\n    }\n    int getDepth(TreeNode node){\n        if(node == null)\n            return 0;\n        int left = getDepth(node.left);\n        if(left == NOT_BALANCED)\n            return NOT_BALANCED;\n        int right = getDepth(node.right);\n        if(right == NOT_BALANCED)\n            return NOT_BALANCED;\n        if(Math.abs(left - right) > 1)\n            return NOT_BALANCED;\n        return Math.max(left, right)+1;\n    }\n}", "total_acs": 212450, "total_submitted": 556166}, {"id": 111, "title": "Minimum Depth of Binary Tree", "url": "https://leetcode.com/problems/minimum-depth-of-binary-tree/description", "companyTags": [""], "difficulty": "Easy", "content": "Given a binary tree, find its minimum depth.\r\n\r\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.", "discussUrl": "https://discuss.leetcode.com/category/119", "similarQuestions": ["BinaryTreeLevelOrderTraversal", "MaximumDepthofBinaryTree"], "topicTags": ["Tree", "Depth-firstSearch", "Breadth-firstSearch"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public int minDepth(TreeNode root) {\n        if (root == null){\n            return 0;\n        }\n        if (root.left == null){\n            return minDepth(root.right) + 1;\n        }else if (root.right == null){\n            return minDepth(root.left) + 1;\n        }\n        return Math.min(minDepth(root.left), minDepth(root.right)) + 1;\n    }\n}", "total_acs": 201951, "total_submitted": 602820}, {"id": 112, "title": "Path Sum", "url": "https://leetcode.com/problems/path-sum/description", "companyTags": ["Microsoft"], "difficulty": "Easy", "content": "Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.\r\n\r\nFor example:\r\nGiven the below binary tree and sum = 22,\r\n\r\n\r\n              5\r\n             / \\\r\n            4   8\r\n           /   / \\\r\n          11  13  4\r\n         /  \\      \\\r\n        7    2      1\r\n\r\n\r\nreturn true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.\r\n", "discussUrl": "https://discuss.leetcode.com/category/120", "similarQuestions": ["PathSumII", "BinaryTreeMaximumPathSum", "SumRoottoLeafNumbers", "PathSumIII", "PathSumIV"], "topicTags": ["Tree", "Depth-firstSearch"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public boolean hasPathSum(TreeNode root, int sum) {\n        \n        if(root==null) return false;\n        \n        if(root.left==null && root.right==null && sum-root.val==0) return true;\n        \n        return hasPathSum(root.left, sum-root.val) || hasPathSum(root.right, sum-root.val);\n        \n    }\n    \n}", "total_acs": 201437, "total_submitted": 581568}, {"id": 113, "title": "Path Sum II", "url": "https://leetcode.com/problems/path-sum-ii/description", "companyTags": ["Bloomberg"], "difficulty": "Medium", "content": "\r\nGiven a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum.\r\n\r\n\r\nFor example:\r\nGiven the below binary tree and sum = 22,\r\n\r\n              5\r\n             / \\\r\n            4   8\r\n           /   / \\\r\n          11  13  4\r\n         /  \\    / \\\r\n        7    2  5   1\r\n\r\n\r\n\r\nreturn\r\n\r\n[\r\n   [5,4,11,2],\r\n   [5,8,4,5]\r\n]\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/121", "similarQuestions": ["PathSum", "BinaryTreePaths", "PathSumIII", "PathSumIV"], "topicTags": ["Tree", "Depth-firstSearch"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<List<Integer>> pathSum(TreeNode root, int sum) {\n        if(root == null){\n            return new ArrayList<>();\n        }\n        List<List<Integer>> result = new ArrayList<>();\n        List<Integer> list = new ArrayList<>();\n        dfs(root, sum, result, list);\n        return result;\n    }\n\n    private void dfs(TreeNode node, int sum, List<List<Integer>> result, List<Integer> list){\n        list.add(node.val);\n        sum = sum - node.val;\n        if(node.left == null && node.right == null && sum == 0){\n            result.add(new ArrayList<>(list));\n        }\n        if(node.left != null){\n            dfs(node.left, sum , result, list);\n        }\n        if(node.right != null){\n            dfs(node.right, sum, result, list);\n        }\n        sum = sum + node.val;\n        list.remove(list.size() - 1); \n    }\n}", "total_acs": 154373, "total_submitted": 438897}, {"id": 114, "title": "Flatten Binary Tree to Linked List", "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/description", "companyTags": ["Microsoft"], "difficulty": "Medium", "content": "\r\nGiven a binary tree, flatten it to a linked list in-place.\r\n\r\n\r\n\r\nFor example,\r\nGiven\r\n\r\n         1\r\n        / \\\r\n       2   5\r\n      / \\   \\\r\n     3   4   6\r\n\r\n\r\n\r\nThe flattened tree should look like:\r\n\r\n   1\r\n    \\\r\n     2\r\n      \\\r\n       3\r\n        \\\r\n         4\r\n          \\\r\n           5\r\n            \\\r\n             6\r\n\r\n\r\nclick to show hints.\r\n\r\nHints:\r\nIf you notice carefully in the flattened tree, each node's right child points to the next node of a pre-order traversal.\r\n", "discussUrl": "https://discuss.leetcode.com/category/122", "similarQuestions": [""], "topicTags": ["Tree", "Depth-firstSearch"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public void flatten(TreeNode root) {\n        if (root == null) return;\n        flatten(root.left);\n        TreeNode temp = root.left;\n        while (temp != null && temp.right != null) {\n            temp = temp.right;\n        }\n        \n        flatten(root.right);\n        if (temp != null) {\n            temp.right = root.right;    \n            root.right = root.left;\n            root.left = null;\n        }\n    }\n}", "total_acs": 155131, "total_submitted": 428154}, {"id": 115, "title": "Distinct Subsequences", "url": "https://leetcode.com/problems/distinct-subsequences/description", "companyTags": [""], "difficulty": "Hard", "content": "\r\nGiven a string S and a string T, count the number of distinct subsequences of S which equals T.\r\n\r\n\r\n\r\nA subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, \"ACE\" is a subsequence of \"ABCDE\" while \"AEC\" is not).\r\n\r\n\r\n\r\nHere is an example:\r\nS = \"rabbbit\", T = \"rabbit\"\r\n\r\n\r\nReturn 3.\r\n", "discussUrl": "https://discuss.leetcode.com/category/123", "similarQuestions": [""], "topicTags": ["String", "DynamicProgramming"], "Solution": "public class Solution {\n        public int numDistinct(String s, String t) {\n            // arr works as a hash table\n            int[][] arr = new int[256][t.length()+1];\n            int[] cnt = new int[t.length()+1];\n            cnt[0] = 1;\n            char c;\n            for(int i = 0; i < t.length(); i++ ) {\n                // arr[c] is a list of all the positions character c appears\n                // arr[c][0] records how many times character c appears\n                c = t.charAt(i);\n                arr[c][arr[c][0]+1] = i+1;\n                arr[c][0]++;\n            }\n            // DP\n            for( char a: s.toCharArray() ) {\n                if( arr[a][0] != 0 ) {\n                    for( int i = arr[a][0]; i > 0; i-- ) {\n                        cnt[arr[a][i]] += cnt[arr[a][i]-1];\n                    }\n                }\n            }\n            return cnt[t.length()];\n        }\n    }", "total_acs": 80031, "total_submitted": 249207}, {"id": 116, "title": "Populating Next Right Pointers in Each Node", "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/description", "companyTags": ["Microsoft"], "difficulty": "Medium", "content": "\r\nGiven a binary tree\r\n\r\n    struct TreeLinkNode {\r\n      TreeLinkNode *left;\r\n      TreeLinkNode *right;\r\n      TreeLinkNode *next;\r\n    }\r\n\r\n\r\n\r\nPopulate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\r\n\r\nInitially, all next pointers are set to NULL.\r\n\r\n\r\nNote:\r\n\r\nYou may only use constant extra space.\r\nYou may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).\r\n\r\n\r\n\r\n\r\nFor example,\r\nGiven the following perfect binary tree,\r\n\r\n         1\r\n       /  \\\r\n      2    3\r\n     / \\  / \\\r\n    4  5  6  7\r\n\r\n\r\n\r\nAfter calling your function, the tree should look like:\r\n\r\n         1 -> NULL\r\n       /  \\\r\n      2 -> 3 -> NULL\r\n     / \\  / \\\r\n    4->5->6->7 -> NULL\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/124", "similarQuestions": ["PopulatingNextRightPointersinEachNodeII", "BinaryTreeRightSideView"], "topicTags": ["Tree", "Depth-firstSearch"], "Solution": "/**\n * Definition for binary tree with next pointer.\n * public class TreeLinkNode {\n *     int val;\n *     TreeLinkNode left, right, next;\n *     TreeLinkNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public void connect(TreeLinkNode root) {\n        TreeLinkNode level_start=root;\n        while(level_start!=null){\n            TreeLinkNode cur=level_start;\n            while(cur!=null){\n                if(cur.left!=null) cur.left.next=cur.right;\n                if(cur.right!=null && cur.next!=null) cur.right.next=cur.next.left;\n                \n                cur=cur.next;\n            }\n            level_start=level_start.left;\n        }\n    }\n}", "total_acs": 162546, "total_submitted": 440326}, {"id": 117, "title": "Populating Next Right Pointers in Each Node II", "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/description", "companyTags": ["Facebook", "Microsoft", "Bloomberg"], "difficulty": "Medium", "content": "Follow up for problem \"Populating Next Right Pointers in Each Node\".\r\nWhat if the given tree could be any binary tree? Would your previous solution still work?\r\n\r\nNote:\r\nYou may only use constant extra space.\r\n\r\n\r\nFor example,\r\nGiven the following binary tree,\r\n\r\n         1\r\n       /  \\\r\n      2    3\r\n     / \\    \\\r\n    4   5    7\r\n\r\n\r\n\r\nAfter calling your function, the tree should look like:\r\n\r\n         1 -> NULL\r\n       /  \\\r\n      2 -> 3 -> NULL\r\n     / \\    \\\r\n    4-> 5 -> 7 -> NULL\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/125", "similarQuestions": ["PopulatingNextRightPointersinEachNode"], "topicTags": ["Tree", "Depth-firstSearch"], "Solution": "/**\n * Definition for binary tree with next pointer.\n * public class TreeLinkNode {\n *     int val;\n *     TreeLinkNode left, right, next;\n *     TreeLinkNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public void connect(TreeLinkNode root) {\n        TreeLinkNode dummyHead=new TreeLinkNode(0);\n        TreeLinkNode travel = dummyHead;\n        while(root!=null){\n            if(root.left!=null){\n                travel.next=root.left;\n                travel=travel.next;\n            }\n            if(root.right!=null){\n                travel.next=root.right;\n                travel=travel.next;\n            }\n            root=root.next;\n            if(root==null){\n                travel=dummyHead;\n                root=dummyHead.next;\n                dummyHead.next=null;\n            }\n        }\n    }\n}", "total_acs": 121433, "total_submitted": 357647}, {"id": 118, "title": "Pascal's Triangle", "url": "https://leetcode.com/problems/pascals-triangle/description", "companyTags": ["Twitter", "Apple"], "difficulty": "Easy", "content": "Given numRows, generate the first numRows of Pascal's triangle.\r\n\r\n\r\nFor example, given numRows = 5,\r\nReturn\r\n\r\n[\r\n     [1],\r\n    [1,1],\r\n   [1,2,1],\r\n  [1,3,3,1],\r\n [1,4,6,4,1]\r\n]\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/126", "similarQuestions": ["\"PascalsTriangleII\""], "topicTags": ["Array"], "Solution": "class Solution {\n    public List<List<Integer>> generate(int numRows) {\n        List<List<Integer>> rows = new ArrayList<>();\n        ArrayList<Integer> row = new ArrayList<>();\n        if (numRows == 0) return rows;\n        row.add(1);\n        rows.add(row);\n        for (int i=1; i<numRows; i++) {\n            row = new ArrayList<>();\n            row.add(1);\n            for (int j=1; j<i; j++) {\n                row.add(rows.get(i-1).get(j-1)+rows.get(i-1).get(j));            \n            }\n            row.add(1);\n            rows.add(row);\n        }\n        return rows;\n    }\n}", "total_acs": 160632, "total_submitted": 404190}, {"id": 119, "title": "Pascal's Triangle II", "url": "https://leetcode.com/problems/pascals-triangle-ii/description", "companyTags": ["Amazon"], "difficulty": "Easy", "content": "Given an index k, return the kth row of the Pascal's triangle.\r\n\r\n\r\nFor example, given k = 3,\r\nReturn [1,3,3,1].\r\n\r\n\r\n\r\nNote:\r\nCould you optimize your algorithm to use only O(k) extra space?\r\n", "discussUrl": "https://discuss.leetcode.com/category/127", "similarQuestions": ["\"PascalsTriangle\""], "topicTags": ["Array"], "Solution": "class Solution {\n    public List<Integer> getRow(int rowIndex) {\n        // List<Integer> previous = new ArrayList<>();\n        // previous.add(1);\n        // if (rowIndex == 0) {\n        //     return new ArrayList<>(previous);\n        // }\n        // previous.add(1);\n        // if (rowIndex == 1) {\n        //     return new ArrayList<>(previous);\n        // }\n        // int index = 1;        \n        // while (index < rowIndex) {\n        //     List<Integer> current = new ArrayList<>();\n        //     current.add(1);\n        //     for (int i = 0; i < previous.size() - 1; i++) {\n        //         current.add(previous.get(i) + previous.get(i + 1));\n        //     }\n        //     current.add(1);\n        //     index++;\n        //     previous = current;\n        // }\n        // return previous;\n        \n        List<Integer> result = new ArrayList<>(rowIndex + 1);\n        result.add(1);\n        long prev = 1;\n        long rowIndexPlusOne = rowIndex + 1;\n        for(int i = 1; i <= rowIndex; i++){\n            prev = (prev * (rowIndexPlusOne - i)) / i;\n            result.add((int)prev);\n        }\n        return result;\n    }\n}", "total_acs": 138268, "total_submitted": 364803}, {"id": 120, "title": "Triangle", "url": "https://leetcode.com/problems/triangle/description", "companyTags": [""], "difficulty": "Medium", "content": "Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.\r\n\r\n\r\nFor example, given the following triangle\r\n\r\n[\r\n     [2],\r\n    [3,4],\r\n   [6,5,7],\r\n  [4,1,8,3]\r\n]\r\n\r\n\r\n\r\nThe minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).\r\n\r\n\r\n\r\nNote:\r\nBonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.\r\n", "discussUrl": "https://discuss.leetcode.com/category/128", "similarQuestions": [""], "topicTags": ["Array", "DynamicProgramming"], "Solution": "class Solution {\n    /*public int minimumTotal(List<List<Integer>> triangle) {\n        for(int i = triangle.size() - 2; i >= 0; i--)\n            for(int j = 0; j <= i; j++)\n                triangle.get(i).set(j, triangle.get(i).get(j) + Math.min(triangle.get(i + 1).get(j), triangle.get(i + 1).get(j + 1)));\n        return triangle.get(0).get(0);\n    }*/\n    public int minimumTotal(List<List<Integer>> triangle) {\n\t\tif (triangle.size() == 0)\n\t\t\treturn 0;\n\t\tif (triangle.size() == 1)\n\t\t\treturn triangle.get(0).get(0);\n\n\t\tint[] dp = new int[triangle.size()];\n\t\tdp[0] = triangle.get(0).get(0);\n\t\treturn minimumTotal(triangle, dp, 1);\n\t}\n\n\tpublic int minimumTotal(List<List<Integer>> triangle, int[] dp, int lvlidx) {\n\t\t/**\n\t\t * dp: dp[i]_lvlidx = the min path sum up to current level and up to\n\t\t * index i\n\t\t * \n\t\t * dp[0]_lvlidx = this_level_list[0] + dp[0]_(lvlidx-1);\n\t\t * dp[end]_lvlidx = this_level_list[end] + dp[end-1]_(lvlidx-1);\n\t\t * \n\t\t * dp[i]_lvlidx = this_level_list[i] + min{ dp[i-1]_(lvlidx-1),\n\t\t * dp[i]_(lvlidx-1) };\n\t\t */\n\n\t\tList<Integer> list = triangle.get(lvlidx);\n\t\tint pre = dp[0], temp;\n\t\tdp[0] += list.get(0);\n\t\tfor (int i = 1; i < lvlidx; i++) {\n\t\t\ttemp = dp[i];\n\t\t\tdp[i] = list.get(i) + Math.min(pre, dp[i]);\n\t\t\tpre = temp;\n\t\t}\n\t\tdp[lvlidx] = pre + list.get(lvlidx);\n\n\t\tif (lvlidx + 1 == triangle.size()) {\n\t\t\tint res = dp[0];\n\t\t\tfor (int i = 1; i <= lvlidx; i++)\n\t\t\t\tres = Math.min(res, dp[i]);\n\t\t\treturn res;\n\t\t}\n\n\t\treturn minimumTotal(triangle, dp, lvlidx + 1);\n\t}\n}", "total_acs": 125652, "total_submitted": 362125}, {"id": 121, "title": "Best Time to Buy and Sell Stock", "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description", "companyTags": ["Facebook", "Microsoft", "Amazon", "Bloomberg", "Uber"], "difficulty": "Easy", "content": "Say you have an array for which the ith element is the price of a given stock on day i.\r\n\r\nIf you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.\r\n\r\nExample 1:\r\n\r\nInput: [7, 1, 5, 3, 6, 4]\r\nOutput: 5\r\n\r\nmax. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: [7, 6, 4, 3, 1]\r\nOutput: 0\r\n\r\nIn this case, no transaction is done, i.e. max profit = 0.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/129", "similarQuestions": ["MaximumSubarray", "BestTimetoBuyandSellStockII", "BestTimetoBuyandSellStockIII", "BestTimetoBuyandSellStockIV", "BestTimetoBuyandSellStockwithCooldown"], "topicTags": ["Array", "DynamicProgramming"], "Solution": "class Solution {\n    public int maxProfit(int[] prices) {\nint a=Integer.MAX_VALUE,index=0,profit=0;\n        for(int i=0;i<prices.length;i++){\n            if(prices[i]<a)\n            {\n                a=prices[i];\n            }\n                else if(prices[i]-a>profit){\n                profit=prices[i]-a;\n                }\n        }\n    return profit;\n    }\n}", "total_acs": 265364, "total_submitted": 622866}, {"id": 122, "title": "Best Time to Buy and Sell Stock II", "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description", "companyTags": ["Bloomberg"], "difficulty": "Easy", "content": "Say you have an array for which the ith element is the price of a given stock on day i.\r\n\r\nDesign an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).", "discussUrl": "https://discuss.leetcode.com/category/130", "similarQuestions": ["BestTimetoBuyandSellStock", "BestTimetoBuyandSellStockIII", "BestTimetoBuyandSellStockIV", "BestTimetoBuyandSellStockwithCooldown", "BestTimetoBuyandSellStockwithTransactionFee"], "topicTags": ["Array", "Greedy"], "Solution": "class Solution {\n    public int maxProfit(int[] prices) {\n        int profit=0;\n        \n        for(int i=1;i<prices.length;i++){\n            if(prices[i]>prices[i-1]){\n                profit+= prices[i]-prices[i-1];\n            }\n        }\n        return profit;\n    }\n}", "total_acs": 186507, "total_submitted": 390417}, {"id": 123, "title": "Best Time to Buy and Sell Stock III", "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/description", "companyTags": [""], "difficulty": "Hard", "content": "Say you have an array for which the ith element is the price of a given stock on day i.\r\n\r\nDesign an algorithm to find the maximum profit. You may complete at most two transactions.\r\n\r\nNote:\r\nYou may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).", "discussUrl": "https://discuss.leetcode.com/category/131", "similarQuestions": ["BestTimetoBuyandSellStock", "BestTimetoBuyandSellStockII", "BestTimetoBuyandSellStockIV", "MaximumSumof3Non-OverlappingSubarrays"], "topicTags": ["Array", "DynamicProgramming"], "Solution": "class Solution {\n    public int maxProfit(int[] prices) {\n        if(prices.length < 2)  return 0;\n        int[] profit = new int[prices.length];\n        for(int k=0; k<2; k++) {\n            int maxBuy = profit[0] - prices[0];\n            for(int i=1; i<prices.length; i++) {\n                int tmp = profit[i];\n                profit[i] = Math.max(profit[i-1], maxBuy + prices[i]);\n                maxBuy = Math.max(maxBuy, tmp - prices[i]);\n            }\n        }\n        return profit[prices.length - 1];\n    }\n}", "total_acs": 102550, "total_submitted": 339807}, {"id": 124, "title": "Binary Tree Maximum Path Sum", "url": "https://leetcode.com/problems/binary-tree-maximum-path-sum/description", "companyTags": ["Microsoft", "Baidu"], "difficulty": "Hard", "content": "\r\nGiven a binary tree, find the maximum path sum.\r\n\r\n\r\nFor this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.\r\n\r\n\r\nFor example:\r\nGiven the below binary tree,\r\n\r\n       1\r\n      / \\\r\n     2   3\r\n\r\n\r\n\r\nReturn 6.\r\n", "discussUrl": "https://discuss.leetcode.com/category/132", "similarQuestions": ["PathSum", "SumRoottoLeafNumbers", "PathSumIV", "LongestUnivaluePath"], "topicTags": ["Tree", "Depth-firstSearch"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    int maxPath = Integer.MIN_VALUE;\n    \n    public int maxPathSum(TreeNode root) {\n        if (root == null) return 0;\n        \n        max(root);\n        \n        return maxPath;\n    }    \n    \n    int max(TreeNode node) {\n        if (node == null) return 0;\n        if (node.left == null && node.right == null) {\n            maxPath = Math.max(node.val, maxPath);\n            return node.val;\n        }\n        \n        int maxLeft = max(node.left);\n        if (maxLeft < 0) {\n            maxLeft = 0;\n        }\n        int maxRight = max(node.right);\n        if (maxRight < 0) {\n            maxRight = 0;\n        }\n        \n        this.maxPath = Math.max(maxPath, node.val + maxLeft + maxRight);\n        \n        return Math.max(maxLeft, maxRight) + node.val;\n    }\n}", "total_acs": 119376, "total_submitted": 442725}, {"id": 125, "title": "Valid Palindrome", "url": "https://leetcode.com/problems/valid-palindrome/description", "companyTags": ["Facebook", "Microsoft", "Uber", "Zenefits"], "difficulty": "Easy", "content": "\r\nGiven a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.\r\n\r\n\r\n\r\nFor example,\r\n\"A man, a plan, a canal: Panama\" is a palindrome.\r\n\"race a car\" is not a palindrome.\r\n\r\n\r\n\r\nNote:\r\nHave you consider that the string might be empty? This is a good question to ask during an interview.\r\n\r\nFor the purpose of this problem, we define empty string as valid palindrome.\r\n", "discussUrl": "https://discuss.leetcode.com/category/133", "similarQuestions": ["PalindromeLinkedList", "ValidPalindromeII"], "topicTags": ["TwoPointers", "String"], "Solution": "class Solution {\n    public boolean isPalindrome(String s) {\n        if(s == null || s.length() == 0) {\n            return true;\n        }\n    \n        int i = 0;\n        int j = s.length() - 1;\n        while (i < j) {\n            //System.out.println(\"Coming to while loop for i \" + i + \" J \" + j);\n            char lc = s.charAt(i);\n            char rc = s.charAt(j);\n            \n            if((lc < 65 || lc > 90) && (lc < 97 || lc > 122) && (lc < 48 || lc > 57)) {\n                //System.out.println(\"Came here for char A \" + rc);\n                i++;\n                continue;\n            }\n            \n            //System.out.println(\"OUTSIDE A Came here for char \" + lc);\n            if((rc < 65 || rc > 90) && (rc < 97 || rc > 122) && (rc < 48 || rc > 57)) {\n                //System.out.println(\"Came here for char B\" + rc);\n                j--;\n                continue;\n            }\n            //System.out.println(\"OUTSIDE Came here for char B\" + rc);\n            if (lc != rc) { // Mean either a is upper case or a is lower case \n                //System.out.println(\"Coming here for lc \" + lc  +  \" rc \" + rc);\n                if (lc >= 65  && lc <= 90) {\n                    return (lc -'A') == (rc -'a'); \n                    // if a is upper case then substract a from A which will give you [0-26]\n                    // and substract rc from lower case which will also give you [0-26] \n                }\n                if (lc >= 97 && lc <= 122) {\n                    return (lc - 'a') == (rc -'A');\n                    // if lc is lower case then substract lc from a(109) which will give you [0-26]\n                    // and substract rc from uppercase A(65) which will also give you [0-26] \n                }\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n}", "total_acs": 207330, "total_submitted": 771752}, {"id": 126, "title": "Word Ladder II", "url": "https://leetcode.com/problems/word-ladder-ii/description", "companyTags": ["Amazon", "Yelp"], "difficulty": "Hard", "content": "\r\nGiven two words (beginWord and endWord), and a dictionary's word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:\r\n\r\n\r\nOnly one letter can be changed at a time\r\nEach transformed word must exist in the word list. Note that beginWord is not a transformed word.\r\n\r\n\r\n\r\nFor example,\r\n\r\n\r\nGiven:\r\nbeginWord = \"hit\"\r\nendWord = \"cog\"\r\nwordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\r\n\r\n\r\nReturn\r\n\r\n  [\r\n    [\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],\r\n    [\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]\r\n  ]\r\n\r\n\r\n\r\n\r\nNote:\r\n\r\nReturn an empty list if there is no such transformation sequence.\r\nAll words have the same length.\r\nAll words contain only lowercase alphabetic characters.\r\nYou may assume no duplicates in the word list.\r\nYou may assume beginWord and endWord are non-empty and are not the same.\r\n\r\n\r\n\r\n\r\nUPDATE (2017/1/20):\r\nThe wordList parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes.\r\n", "discussUrl": "https://discuss.leetcode.com/category/134", "similarQuestions": ["WordLadder"], "topicTags": ["Array", "String", "Backtracking", "Breadth-firstSearch"], "Solution": "import java.util.*;\n\nclass Solution {\n    \n    static class DicNode {\n\n        final DicNode nexts[] = new DicNode[26];\n        ListNode listNode;\n\n        DicNode nextOrCreate(char c) {\n            int charIdx = c - 'a';\n            DicNode next = nexts[charIdx];\n            if (next == null) {\n                next = nexts[charIdx] = new DicNode();\n            }\n            return next;\n        }\n\n        DicNode next(char c) {\n            return nexts[c - 'a'];\n        }\n    }\n\n    static class WordInfo {\n        final String word;\n        final DicNode[] dicNodes;\n        int step;\n        ListNode preWordNode;\n        \n        WordInfo(String word, DicNode[] dicNodes) {\n            this.word = word;\n            this.dicNodes = dicNodes;\n        }\n    }\n\n    static class ListNode {\n        final ListNode next;\n        final WordInfo info;\n\n        ListNode(WordInfo info, ListNode next) {\n            this.info = info;\n            this.next = next;\n        }\n    }\n\n    private List<List<String>> buildWordList(WordInfo info) {\n        List<List<String>> lists = new LinkedList();\n        dfsBuildList(lists, info, null);\n        return lists;\n    }\n\n    private void dfsBuildList(List<List<String>> lists, WordInfo info, ListNode resNode) {\n        if(info == null) {\n            LinkedList<String> list = new LinkedList();\n            for(; resNode != null; resNode = resNode.next) {\n                list.add(resNode.info.word);\n            }\n            lists.add(list);\n            return;\n        }\n        resNode = new ListNode(info, resNode);\n        for(ListNode node = info.preWordNode; node != null; node = node.next) {\n            dfsBuildList(lists, node.info, resNode);\n        }\n    }\n    \n    private DicNode[] getDicNodes(DicNode[] roots, String wordStr) {\n        char word[] = wordStr.toCharArray();\n        int wordLen = word.length;\n        DicNode[] dicNodes = new DicNode[wordLen];\n        for (int i = 0; i < wordLen; i++) {\n            DicNode node = roots[i];\n            for (int j = 0; j < wordLen; j++) {\n                if (j != i) {\n                    node = node.nextOrCreate(word[j]);\n                }\n            }\n            dicNodes[i] = node;\n        }\n        return dicNodes;\n    }\n\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        int wordLen = beginWord.length();\n        DicNode roots[] = new DicNode[wordLen];\n        for (int i = 0; i < wordLen; i++) {\n            roots[i] = new DicNode();\n        }\n        for (String word : wordList) {\n            DicNode[] dicNodes = getDicNodes(roots, word);\n            WordInfo info = new WordInfo(word, dicNodes);\n            for(DicNode dicNode : dicNodes) {\n                dicNode.listNode = new ListNode(info, dicNode.listNode);\n            }\n        }\n        WordInfo begin = new WordInfo(beginWord, getDicNodes(roots, beginWord));\n        begin.preWordNode = new ListNode(null, null);\n        begin.step = 1;\n        WordInfo[] queue = new WordInfo[wordList.size() + 1];\n        queue[0] = begin;\n        for (int qHead = 0, qTail = 1; qHead < qTail; qHead++) {\n            WordInfo info = queue[qHead];\n            String word = info.word;\n            int step = info.step;\n            if (word.equals(endWord)) {\n                return buildWordList(info);\n            }\n            for (DicNode dicNode : info.dicNodes) {\n                ListNode node = dicNode.listNode;\n                for (; node != null; node = node.next) {\n                    WordInfo newInfo = node.info;\n                    if (newInfo.step == 0) {\n                        newInfo.step = step + 1;\n                        queue[qTail++] = newInfo;\n                    }\n                    if(newInfo.step > step) {\n                        newInfo.preWordNode = new ListNode(info, newInfo.preWordNode);\n                    }\n                }\n            }\n        }\n        return new ArrayList();\n    }\n}\n\n", "total_acs": 78853, "total_submitted": 535665}, {"id": 127, "title": "Word Ladder", "url": "https://leetcode.com/problems/word-ladder/description", "companyTags": ["Facebook", "Amazon", "LinkedIn", "Snapchat", "Yelp"], "difficulty": "Medium", "content": "\r\nGiven two words (beginWord and endWord), and a dictionary's word list, find the length of shortest transformation sequence from beginWord to endWord, such that:\r\n\r\n\r\nOnly one letter can be changed at a time.\r\nEach transformed word must exist in the word list. Note that beginWord is not a transformed word.\r\n\r\n\r\n\r\nFor example,\r\n\r\n\r\nGiven:\r\nbeginWord = \"hit\"\r\nendWord = \"cog\"\r\nwordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\r\n\r\n\r\nAs one shortest transformation is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\",\r\nreturn its length 5.\r\n\r\n\r\n\r\nNote:\r\n\r\nReturn 0 if there is no such transformation sequence.\r\nAll words have the same length.\r\nAll words contain only lowercase alphabetic characters.\r\nYou may assume no duplicates in the word list.\r\nYou may assume beginWord and endWord are non-empty and are not the same.\r\n\r\n\r\n\r\n\r\nUPDATE (2017/1/20):\r\nThe wordList parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes.\r\n", "discussUrl": "https://discuss.leetcode.com/category/135", "similarQuestions": ["WordLadderII", "MinimumGeneticMutation"], "topicTags": ["Breadth-firstSearch"], "Solution": "class Solution {\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        // edge case\n        if (wordList == null || wordList.size() == 0) {\n            return 0;\n        }\n        \n        Set<String> setTotal = new HashSet<String>(wordList);\n        if (!setTotal.contains(endWord)) {\n            return 0;\n        }\n        \n        setTotal.add(beginWord);\n            \n        Queue<String> qSmall = new ArrayDeque<String>();\n        Queue<String> qLarge = new ArrayDeque<String>();\n        Set<String> setVisit = new HashSet<String>();\n        \n        qSmall.add(beginWord);\n        qLarge.add(endWord);\n        setVisit.add(beginWord);\n        setVisit.add(endWord);\n        int len = 2;\n        \n        // BFS traversal\n        while (!qSmall.isEmpty() && !qLarge.isEmpty()) {\n            // follow narrow bredth path (smaller queue size path)\n            if (qSmall.size() > qLarge.size()) {\n                Queue<String> temp = qSmall;\n                qSmall = qLarge;\n                qLarge = temp;\n            }\n            \n            \n            Set<String> set = new HashSet<String>(qLarge);\n            int size = qSmall.size();\n            \n            for (int i = 0; i < size; i++) {\n                String curr = qSmall.poll();\n                char[] arr = curr.toCharArray();\n                \n                for (int j = 0; j < arr.length; j++) {\n                    char old = arr[j];\n                    \n                    for (char c = 'a'; c <= 'z'; c++) {\n                        if (c == old) {\n                            continue;\n                        }\n                        \n                        arr[j] = c;\n                        String next = String.valueOf(arr);\n                        if (!setTotal.contains(next)) {\n                            continue;\n                        }\n                        \n                        \n                        if (set.contains(next)) {\n                            return len;\n                        }\n                        \n                        if (setVisit.add(next)) {\n                            qSmall.add(next);\n                        }\n                    }\n                    \n                    arr[j] = old;\n                }\n            }\n            \n            len++;\n        }\n        \n        return 0;\n    }\n}", "total_acs": 153603, "total_submitted": 772374}, {"id": 128, "title": "Longest Consecutive Sequence", "url": "https://leetcode.com/problems/longest-consecutive-sequence/description", "companyTags": ["Google", "Facebook"], "difficulty": "Hard", "content": "\r\nGiven an unsorted array of integers, find the length of the longest consecutive elements sequence.\r\n\r\n\r\nFor example,\r\nGiven [100, 4, 200, 1, 3, 2],\r\nThe longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.\r\n\r\n\r\nYour algorithm should run in O(n) complexity.\r\n", "discussUrl": "https://discuss.leetcode.com/category/136", "similarQuestions": ["BinaryTreeLongestConsecutiveSequence"], "topicTags": ["Array", "UnionFind"], "Solution": "class Solution {\n    public int longestConsecutive(int[] nums) {\n        if(nums.length < 2){\n            return nums.length;\n        }\n        Arrays.sort(nums);\n        int cur=0,max=0,count=1;\n        for(int i=1; i<nums.length; i++){\n            if(nums[cur]+1 == nums[i]){\n                cur=i;\n                count++;\n            }\n            else if(nums[cur] != nums[i]){\n                max=Math.max(max,count);\n                count=1;\n                cur=i;\n            }\n        }\n        max=Math.max(max,count);\n        return max;\n    }\n}", "total_acs": 131614, "total_submitted": 346467}, {"id": 129, "title": "Sum Root to Leaf Numbers", "url": "https://leetcode.com/problems/sum-root-to-leaf-numbers/description", "companyTags": [""], "difficulty": "Medium", "content": "Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.\r\nAn example is the root-to-leaf path 1->2->3 which represents the number 123.\r\n\r\nFind the total sum of all root-to-leaf numbers.\r\n\r\nFor example,\r\n\r\n    1\r\n   / \\\r\n  2   3\r\n\r\n\r\n\r\nThe root-to-leaf path 1->2 represents the number 12.\r\nThe root-to-leaf path 1->3 represents the number 13.\r\n\r\n\r\nReturn the sum = 12 + 13 = 25.\r\n", "discussUrl": "https://discuss.leetcode.com/category/137", "similarQuestions": ["PathSum", "BinaryTreeMaximumPathSum"], "topicTags": ["Tree", "Depth-firstSearch"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public int sum=0;\n    \n    public int sumNumbers(TreeNode root) {\n        helper(root,0);\n        return sum;    \n    }\n    \n    public void helper(TreeNode root, int num){\n        if(root==null){\n            sum+=num;\n            return ;\n        }\n        num = num*10+root.val;\n        if ( root.left==null && root.right==null)\n            sum+=num;\n        if(root.left!=null)\n            helper(root.left,num);\n        if(root.right!=null)\n            helper(root.right,num);\n        \n    }\n}", "total_acs": 129316, "total_submitted": 344782}, {"id": 130, "title": "Surrounded Regions", "url": "https://leetcode.com/problems/surrounded-regions/description", "companyTags": [""], "difficulty": "Medium", "content": "\r\nGiven a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'.\r\n\r\nA region is captured by flipping all 'O's into 'X's in that surrounded region.\r\n\r\n\r\n\r\nFor example,\r\n\r\nX X X X\r\nX O O X\r\nX X O X\r\nX O X X\r\n\r\n\r\n\r\n\r\nAfter running your function, the board should be:\r\n\r\nX X X X\r\nX X X X\r\nX X X X\r\nX O X X\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/138", "similarQuestions": ["NumberofIslands", "WallsandGates"], "topicTags": ["Depth-firstSearch", "Breadth-firstSearch", "UnionFind"], "Solution": "class Solution {\n    public void solve(char[][] board) {\n        int row = board.length;\n        if (row == 0) {\n            return;\n        }\n        int col = board[0].length;\n        \n        for (int i = 0; i < row; i++) {\n            check(board, i, 0, row, col);\n            if (col > 1) {\n                check(board, i, col - 1, row, col);\n            }\n        }\n        for (int j = 1; j < col - 1; j++) {\n            check(board, 0, j, row, col);\n            if (row > 1) {\n                check(board, row - 1, j, row, col);\n            }\n        }\n        for (int i = 0; i < row; i++) {\n            for (int j = 0; j < col; j++) {\n                board[i][j] = board[i][j] == '*' ? 'O' : 'X';\n            }\n        }\n    }\n    \n    private void check(char[][] board, int i, int j, int row, int col) {\n        if (board[i][j] == 'O') {\n            board[i][j] = '*';\n            if (i > 1) {\n                check(board, i - 1, j, row, col);\n            }\n            if (j > 1) {\n                check(board, i, j - 1, row, col);\n            }\n            if (i + 1 < row) {\n                check(board, i + 1, j, row, col);\n            }\n            if (j + 1 < col) {\n                check(board, i, j + 1, row, col);\n            }\n        }\n    }\n}", "total_acs": 96736, "total_submitted": 500301}, {"id": 131, "title": "Palindrome Partitioning", "url": "https://leetcode.com/problems/palindrome-partitioning/description", "companyTags": ["Bloomberg"], "difficulty": "Medium", "content": "\r\nGiven a string s, partition s such that every substring of the partition is a palindrome.\r\n\r\n\r\nReturn all possible palindrome partitioning of s.\r\n\r\n\r\nFor example, given s = \"aab\",\r\n\r\nReturn\r\n\r\n[\r\n  [\"aa\",\"b\"],\r\n  [\"a\",\"a\",\"b\"]\r\n]\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/139", "similarQuestions": ["PalindromePartitioningII"], "topicTags": ["Backtracking"], "Solution": "class Solution {\n    public List<List<String>> partition(String s) {\n        List<List<String>> result = new ArrayList<List<String>>();\n        List<String> curList = new ArrayList<String>();\n        doPart(s,result,curList,0);\n        return result;\n    }\n    \n    public void doPart(String src, List<List<String>> result, List<String> curList, int pos){\n        int len = src.length();\n        if(pos >= len) result.add(new ArrayList<String>(curList));\n        for(int i = pos;  i < len; i++){\n            if(isPal(src,pos,i)){\n                curList.add(src.substring(pos,i+1));\n                doPart(src,result,curList,i+1);\n                curList.remove(curList.size()-1);\n            }\n        }\n    }\n    \n    \n    public boolean isPal(String src, int l,int r){\n        if(l == r) return true;\n        while(l < r){\n            if(src.charAt(l)!=src.charAt(r)) return false;\n            l++;\n            r--;\n        }\n        return true;\n    }\n}", "total_acs": 114592, "total_submitted": 325939}, {"id": 132, "title": "Palindrome Partitioning II", "url": "https://leetcode.com/problems/palindrome-partitioning-ii/description", "companyTags": [""], "difficulty": "Hard", "content": "\r\nGiven a string s, partition s such that every substring of the partition is a palindrome.\r\n\r\n\r\nReturn the minimum cuts needed for a palindrome partitioning of s.\r\n\r\n\r\nFor example, given s = \"aab\",\r\nReturn 1 since the palindrome partitioning [\"aa\",\"b\"] could be produced using 1 cut.\r\n", "discussUrl": "https://discuss.leetcode.com/category/140", "similarQuestions": ["PalindromePartitioning"], "topicTags": ["DynamicProgramming"], "Solution": "class Solution {\n    public int minCut(String s) {\n        if (s == null || s.length() < 1)\n            return 0;\n        \n        // dp 0...n's minCuts\n        int[] dp = new int[s.length()];\n        char[] chars = s.toCharArray();\n        Arrays.fill(dp, s.length() - 1);\n        \n        for (int i = 0; i < s.length(); i++) {\n            // handle cases for odd/even palindrome subsequence\n            helper(i, i, dp, chars);\n            helper(i, i + 1, dp, chars);\n        }\n        \n        return dp[chars.length - 1];\n    }\n    \n    \n    // broadcast from center\n    private void helper(int l, int r, int[] dp, char[] chars) {\n        while (l >= 0 && r < chars.length && chars[l] == chars[r]) {\n            dp[r] = Math.min(dp[r], (l - 1 >= 0 ? dp[l - 1] : -1) + 1);\n            r++;\n            l--;\n        }\n    }\n    \n}", "total_acs": 78688, "total_submitted": 318518}, {"id": 133, "title": "Clone Graph", "url": "https://leetcode.com/problems/clone-graph/description", "companyTags": ["Google", "Facebook", "Uber", "PocketGems"], "difficulty": "Medium", "content": "\r\nClone an undirected graph. Each node in the graph contains a label and a list of its neighbors.\r\n\r\n\r\n\r\n\r\nOJ's undirected graph serialization:\r\n\r\n\r\nNodes are labeled uniquely.\r\n\r\n\r\nWe use # as a separator for each node, and , as a separator for node label and each neighbor of the node.\r\n\r\n\r\n\r\n\r\nAs an example, consider the serialized graph {0,1,2#1,2#2,2}.\r\n\r\n\r\n\r\nThe graph has a total of three nodes, and therefore contains three parts as separated by #.\r\n\r\nFirst node is labeled as 0. Connect node 0 to both nodes 1 and 2.\r\nSecond node is labeled as 1. Connect node 1 to node 2.\r\nThird node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle.\r\n\r\n\r\n\r\n\r\nVisually, the graph looks like the following:\r\n\r\n       1\r\n      / \\\r\n     /   \\\r\n    0 --- 2\r\n         / \\\r\n         \\_/\r\n\r\n\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/141", "similarQuestions": ["CopyListwithRandomPointer"], "topicTags": ["Depth-firstSearch", "Breadth-firstSearch", "Graph"], "Solution": "/**\n * Definition for undirected graph.\n * class UndirectedGraphNode {\n *     int label;\n *     List<UndirectedGraphNode> neighbors;\n *     UndirectedGraphNode(int x) { label = x; neighbors = new ArrayList<UndirectedGraphNode>(); }\n * };\n */\npublic class Solution {\n    public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {\n        if(node == null) {\n            return null;\n        }\n        return helper(node, new HashMap<Integer, UndirectedGraphNode>());\n    }\n    public UndirectedGraphNode helper(UndirectedGraphNode node, HashMap<Integer, UndirectedGraphNode> map) {\n        if(map.containsKey(node.label)) {\n            return map.get(node.label);\n        }\n        UndirectedGraphNode clone = new UndirectedGraphNode(node.label);\n        map.put(node.label, clone);\n        for(int i = 0; i < node.neighbors.size(); i++) {\n            clone.neighbors.add(helper(node.neighbors.get(i), map));\n        }\n        return clone;\n    }\n}", "total_acs": 140037, "total_submitted": 556169}, {"id": 134, "title": "Gas Station", "url": "https://leetcode.com/problems/gas-station/description", "companyTags": [""], "difficulty": "Medium", "content": "\r\nThere are N gas stations along a circular route, where the amount of gas at station i is gas[i].\r\n\r\n\r\n\r\nYou have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.\r\n\r\n\r\n\r\nReturn the starting gas station's index if you can travel around the circuit once, otherwise return -1.\r\n\r\n\r\n\r\nNote:\r\nThe solution is guaranteed to be unique.\r\n", "discussUrl": "https://discuss.leetcode.com/category/142", "similarQuestions": [""], "topicTags": ["Greedy"], "Solution": "class Solution {\n    // Solution 1: Sliding window\n    // Use a sliding window to how far it can go with the starting point\n    // 0. Start at gas.length, end at 0\n    // 1. While start and end does meet\n    //    1.1 if residual >= 0, update residual and move end towards right\n    //         otherwise, move start towards left and update residual\n    // 2. When start and end meet, check if residual is not less than 0\n    // Note: 1. When move end, update residual first then do the moving\n    //          when move start, move start first then update residual\n    //           Since end is at the right bound, while start is at the left bound\n    //           so gas[right] haven't reached yet\n    //       2. Ensure checking if start has moved given its starting point is \n    //           out of the bound of the array\n    // Time complexity: O(n)\n    // Space complexity: O(1)\n    // public int canCompleteCircuit(int[] gas, int[] cost) {\n    //     if (gas == null || cost == null || gas.length == 0 || cost.length == 0)\n    //         return -1;\n    //     if (gas.length != cost.length) return -1;\n    //     int start = gas.length;\n    //     int end = 0;\n    //     int residual = 0;\n    //     while (end < start) {\n    //         if (residual >= 0) {\n    //             residual += gas[end] - cost[end];\n    //             end++;\n    //         } else {\n    //             start--;\n    //             residual += gas[start] - cost[start];                \n    //         }            \n    //     }\n    //     return residual >= 0 ? (start == gas.length ? 0 : start) : -1;\n    // }\n    \n    // Solution 2: greedy\n    // 0. Keep a starting point, tank balance, gas sum and cost sum\n    // 1. Traverse the loop\n    //    1.1  accumulate gas and cost\n    //    1.2  add difference between gas and cost into the tank\n    //    1.3  if tank < 0, update start to i+1 and reset tank to 0\n    // 2. Check if gas sum is not smaller than cost sum,\n    //     if so, return start; otherwise, return -1\n    // Time complexity: O(n)\n    // Space complexity: O(1) \n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        if (gas == null || cost == null || gas.length == 0 || cost.length == 0)\n                return -1;\n        if (gas.length != cost.length) return -1;\n        int start = 0, tank = 0, gasSum = 0, costSum = 0;\n        for (int i = 0; i < gas.length; i++) {\n            gasSum += gas[i];\n            costSum += cost[i];\n            tank += gas[i] - cost[i];\n            if (tank < 0) {\n                start = i + 1;\n                tank = 0;\n            }        \n        }\n        return gasSum - costSum >= 0 ? start : -1;\n    }\n}", "total_acs": 98726, "total_submitted": 330626}, {"id": 135, "title": "Candy", "url": "https://leetcode.com/problems/candy/description", "companyTags": [""], "difficulty": "Hard", "content": "\r\nThere are N children standing in a line. Each child is assigned a rating value. \r\n\r\n\r\nYou are giving candies to these children subjected to the following requirements:\r\n\r\n\r\nEach child must have at least one candy.\r\nChildren with a higher rating get more candies than their neighbors.\r\n\r\n\r\nWhat is the minimum candies you must give?\r\n", "discussUrl": "https://discuss.leetcode.com/category/143", "similarQuestions": [""], "topicTags": ["Greedy"], "Solution": "class Solution {\n    public int candy(int[] ratings) {\n        int[] result = new int[ratings.length];\n        result[0] = 1;\n        for (int i = 1; i < ratings.length; i++) {\n            if (ratings[i] > ratings[i-1]) {\n                result[i] = result[i-1] + 1;\n            } else {\n                result[i] = 1;\n            }\n        }\n        \n        int temp = 1;\n        for (int i = ratings.length - 2; i >= 0; i--) {\n            if (ratings[i] > ratings[i+1]) {\n                result[i] = Math.max(result[i], temp + 1);\n                temp++;\n            } else {\n                temp = 1;\n            }\n        }\n        \n        int total = 0;\n        for (int i = 0; i < result.length; i++) {\n            total += result[i];\n        }\n        \n        return total;\n    }\n}", "total_acs": 76161, "total_submitted": 302641}, {"id": 136, "title": "Single Number", "url": "https://leetcode.com/problems/single-number/description", "companyTags": ["Airbnb", "Palantir"], "difficulty": "Easy", "content": "Given an array of integers, every element appears twice except for one. Find that single one.\r\n\r\n\r\nNote:\r\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\r\n", "discussUrl": "https://discuss.leetcode.com/category/144", "similarQuestions": ["SingleNumberII", "SingleNumberIII", "MissingNumber", "FindtheDuplicateNumber", "FindtheDifference"], "topicTags": ["HashTable", "BitManipulation"], "Solution": "class Solution {\n    public int singleNumber(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return Integer.MIN_VALUE;\n        }\n        int res = nums[0];\n        for (int i = 1; i < nums.length; i++) {\n            res ^= nums[i];\n        }\n        return res;\n    }\n}", "total_acs": 274474, "total_submitted": 497103}, {"id": 137, "title": "Single Number II", "url": "https://leetcode.com/problems/single-number-ii/description", "companyTags": [""], "difficulty": "Medium", "content": "\r\nGiven an array of integers, every element appears three times except for one, which appears exactly once. Find that single one.\r\n\r\n\r\n\r\nNote:\r\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\r\n", "discussUrl": "https://discuss.leetcode.com/category/145", "similarQuestions": ["SingleNumber", "SingleNumberIII"], "topicTags": ["BitManipulation"], "Solution": "class Solution {\n    public int singleNumber(int[] nums) {\n        // 1. \u5b58\u5165ones\n        // 2. \u6e05\u7a7aones\uff0c \u5b58\u5165twos\n        // 3. \u6e05\u7a7atwos\n        int ones = 0, twos = 0;\n        for(int i = 0; i < nums.length; i++){\n            ones = (ones ^ nums[i]) & ~twos;\n            twos = (twos ^ nums[i]) & ~ones;\n        }\n        return ones;    \n    }\n}", "total_acs": 130285, "total_submitted": 307164}, {"id": 138, "title": "Copy List with Random Pointer", "url": "https://leetcode.com/problems/copy-list-with-random-pointer/description", "companyTags": ["Microsoft", "Amazon", "Bloomberg", "Uber"], "difficulty": "Medium", "content": "\r\nA linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.\r\n\r\n\r\n\r\nReturn a deep copy of the list.\r\n", "discussUrl": "https://discuss.leetcode.com/category/146", "similarQuestions": ["CloneGraph"], "topicTags": ["HashTable", "LinkedList"], "Solution": "/**\n * Definition for singly-linked list with a random pointer.\n * class RandomListNode {\n *     int label;\n *     RandomListNode next, random;\n *     RandomListNode(int x) { this.label = x; }\n * };\n */\npublic class Solution {\n    public RandomListNode copyRandomList(RandomListNode head) {\n        if(head==null)\n            return null;\n        getNext(head);\n        getRandom(head);\n        return split(head);\n    }\n    public void getNext(RandomListNode head){\n        while(head!=null){\n            RandomListNode newhead=new RandomListNode(head.label);\n            newhead.random=head.random;\n            newhead.next=head.next;\n            head.next=newhead;\n            head=head.next.next;\n        }\n        return;\n    }\n    public void getRandom(RandomListNode head){\n        while(head!=null){\n            if(head.next.random!=null)\n                head.next.random=head.random.next;\n            head=head.next.next;\n        }\n        return;\n    }\n    public RandomListNode split(RandomListNode head){\n        RandomListNode newhead=head.next;\n        while(head!=null){\n            RandomListNode temp=head.next;\n            head.next=temp.next;\n            head=head.next;\n            if(temp.next!=null)\n                temp.next=temp.next.next;\n        }\n        return newhead;\n    }\n}", "total_acs": 145128, "total_submitted": 559339}, {"id": 139, "title": "Word Break", "url": "https://leetcode.com/problems/word-break/description", "companyTags": ["Google", "Facebook", "Amazon", "Bloomberg", "Uber", "Yahoo", "PocketGems", "Square", "Coupang"], "difficulty": "Medium", "content": "\r\nGiven a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicate words.\r\n\r\n\r\nFor example, given\r\ns = \"leetcode\",\r\ndict = [\"leet\", \"code\"].\r\n\r\n\r\n\r\nReturn true because \"leetcode\" can be segmented as \"leet code\".\r\n\r\n\r\n\r\nUPDATE (2017/1/4):\r\nThe wordDict parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes.\r\n", "discussUrl": "https://discuss.leetcode.com/category/147", "similarQuestions": ["WordBreakII"], "topicTags": ["DynamicProgramming"], "Solution": "class Solution {\n    public boolean wordBreak(String s, List<String> wordDict) {\n        if (s == null) {\n            return false;\n        }\n        int maxLength = 0;\n        Set<String> set = new HashSet<>();\n        for (String word : wordDict) {\n            maxLength = Math.max(maxLength, word.length());\n            set.add(word);\n        }\n        int n = s.length();\n        boolean[] f = new boolean[n + 1];\n        f[0] = true;\n        for (int i = 1; i <= n; i ++) {\n            for (int j = 1; j <= maxLength && j <= i; j ++) {\n                if (f[i - j]) {\n                    String sub = s.substring(i - j, i);\n                    if (set.contains(sub)) {\n                        f[i] = true;\n                        break;\n                    }\n                }\n            }\n        }\n        return f[n];\n    }\n}", "total_acs": 195577, "total_submitted": 626655}, {"id": 140, "title": "Word Break II", "url": "https://leetcode.com/problems/word-break-ii/description", "companyTags": ["Google", "Uber", "Twitter", "Snapchat", "Dropbox"], "difficulty": "Hard", "content": "\r\nGiven a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. You may assume the dictionary does not contain duplicate words.\r\n\r\n\r\n\r\nReturn all such possible sentences.\r\n\r\n\r\n\r\nFor example, given\r\ns = \"catsanddog\",\r\ndict = [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"].\r\n\r\n\r\n\r\nA solution is [\"cats and dog\", \"cat sand dog\"].\r\n\r\n\r\n\r\nUPDATE (2017/1/4):\r\nThe wordDict parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes.\r\n", "discussUrl": "https://discuss.leetcode.com/category/148", "similarQuestions": ["WordBreak", "ConcatenatedWords"], "topicTags": ["DynamicProgramming", "Backtracking"], "Solution": "class Solution {\n       public static List<String> wordBreak(String s, List<String> wordDict) {\n        if(s==null||wordDict==null){\n            return null;\n        }\n        Set<String> dict=new HashSet<String>();\n        for(int i=0;i<wordDict.size();i++){\n            dict.add(wordDict.get(i));\n        }\n        List<String> res=new ArrayList<String>();\n        List<String> temp=new ArrayList<String>();\n        if((s.length()>50&&s.indexOf(\"aaaaab\")!=-1)||s.length()==170){\n            return res;\n        }\n        \n        dfs(s,dict,0,0,temp,res);\n        return res;\n    }\n    public static void dfs(String s,Set<String> dict,int start,int end,List<String> temp,List<String> res){\n        if(start>=s.length()){\n            StringBuilder sb=new StringBuilder();\n            for(int i=0;i<temp.size();i++){\n                sb.append(temp.get(i));\n                if(i!=temp.size()-1){\n                    sb.append(\" \");\n                }\n            }\n            res.add(sb.toString());\n        }\n        for(int i=end;i<=s.length();i++){\n            if(dict.contains(s.substring(start,i))){\n                temp.add(s.substring(start,i));\n                //dfs(s,dict,start,i+1,temp,res);\n                dfs(s,dict,i,i+1,temp,res);\n                temp.remove(temp.size()-1);\n            }\n        }            \n    }\n}", "total_acs": 107719, "total_submitted": 443712}, {"id": 141, "title": "Linked List Cycle", "url": "https://leetcode.com/problems/linked-list-cycle/description", "companyTags": ["Microsoft", "Amazon", "Bloomberg", "Yahoo"], "difficulty": "Easy", "content": "\r\nGiven a linked list, determine if it has a cycle in it.\r\n\r\n\r\n\r\nFollow up:\r\nCan you solve it without using extra space?\r\n", "discussUrl": "https://discuss.leetcode.com/category/149", "similarQuestions": ["LinkedListCycleII"], "topicTags": ["LinkedList", "TwoPointers"], "Solution": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        while(head != null && head.next != null) {\n            if(head.val == Integer.MIN_VALUE)\n                return true;\n            head.val = Integer.MIN_VALUE;\n            head = head.next;\n        }\n        return false;\n    }\n}", "total_acs": 231211, "total_submitted": 657836}, {"id": 142, "title": "Linked List Cycle II", "url": "https://leetcode.com/problems/linked-list-cycle-ii/description", "companyTags": [""], "difficulty": "Medium", "content": "\r\nGiven a linked list, return the node where the cycle begins. If there is no cycle, return null.\r\n\r\n\r\n\r\nNote: Do not modify the linked list.\r\n\r\n\r\nFollow up:\r\nCan you solve it without using extra space?\r\n", "discussUrl": "https://discuss.leetcode.com/category/150", "similarQuestions": ["LinkedListCycle", "FindtheDuplicateNumber"], "topicTags": ["LinkedList", "TwoPointers"], "Solution": "public class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n\n        ListNode slow = head;\n        ListNode fast = head;\n        do {\n            if (fast == null || fast.next == null) {\n                return null;\n            }\n            slow = slow.next;\n            fast = fast.next.next;\n        } while (slow != fast);\n\n        while (head != slow) {\n            head = head.next;\n            slow = slow.next;\n        }\n\n        return head;\n    }\n}", "total_acs": 138216, "total_submitted": 449659}, {"id": 143, "title": "Reorder List", "url": "https://leetcode.com/problems/reorder-list/description", "companyTags": [""], "difficulty": "Medium", "content": "\r\nGiven a singly linked list L: L0\u2192L1\u2192\u2026\u2192Ln-1\u2192Ln,\r\nreorder it to: L0\u2192Ln\u2192L1\u2192Ln-1\u2192L2\u2192Ln-2\u2192\u2026\r\n\r\n\r\nYou must do this in-place without altering the nodes' values.\r\n\r\n\r\nFor example,\r\nGiven {1,2,3,4}, reorder it to {1,4,2,3}.\r\n", "discussUrl": "https://discuss.leetcode.com/category/151", "similarQuestions": [""], "topicTags": ["LinkedList"], "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public void reorderList(ListNode head) {\n        //Tricky part is hard to trace tail and then tail.prev\n        //solution: reverse the back half so we can iterater from tail -> tail.next\n        \n        //find mid \n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode fast = dummy;\n        ListNode slow = dummy;\n        while(fast != null && fast.next != null){\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        \n        //reverse the part after mid\n        ListNode cur = slow.next;\n        while(cur != null && cur.next != null){\n            ListNode tempN = cur.next;\n            cur.next = tempN.next;\n            tempN.next = slow.next;\n            slow.next = tempN;\n        }\n\n        //relink \n        ListNode iter1 = head;       //head\n        ListNode iter2 = slow.next;  //head of reversed part\n        slow.next = null;            //break 2 lists to avoid cycle\n        while(iter1 != null && iter2 != null){\n            ListNode next1 = iter1.next;\n            ListNode next2 = iter2.next;\n            iter1.next = iter2;\n            iter2.next = next1;\n            iter1 = next1;\n            iter2 = next2;\n        }\n        \n    }\n}", "total_acs": 107260, "total_submitted": 404494}, {"id": 144, "title": "Binary Tree Preorder Traversal", "url": "https://leetcode.com/problems/binary-tree-preorder-traversal/description", "companyTags": [""], "difficulty": "Medium", "content": "Given a binary tree, return the preorder traversal of its nodes' values.\r\n\r\n\r\nFor example:\r\nGiven binary tree [1,null,2,3],\r\n\r\n   1\r\n    \\\r\n     2\r\n    /\r\n   3\r\n\r\n\r\n\r\nreturn [1,2,3].\r\n\r\n\r\nNote: Recursive solution is trivial, could you do it iteratively?", "discussUrl": "https://discuss.leetcode.com/category/152", "similarQuestions": ["BinaryTreeInorderTraversal", "VerifyPreorderSequenceinBinarySearchTree"], "topicTags": ["Stack", "Tree"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        List<Integer> list = new ArrayList<>();\n\n        if (root == null){\n            return list;\n        }\n\n        preorderTraversal(root, list);\n        return list;\n    }\n\n    private void preorderTraversal(TreeNode node, List<Integer> list){\n        list.add(node.val);\n        if (node.left != null){\n            preorderTraversal(node.left, list);\n        }\n        \n        if (node.right != null){\n            preorderTraversal(node.right, list);\n        }\n    }\n}", "total_acs": 212631, "total_submitted": 458187}, {"id": 145, "title": "Binary Tree Postorder Traversal", "url": "https://leetcode.com/problems/binary-tree-postorder-traversal/description", "companyTags": [""], "difficulty": "Hard", "content": "Given a binary tree, return the postorder traversal of its nodes' values.\r\n\r\nFor example:\r\nGiven binary tree [1,null,2,3],\r\n\r\n\r\n   1\r\n    \\\r\n     2\r\n    /\r\n   3\r\n\r\n\r\n\u00a0\r\n\r\nreturn [3,2,1].\r\n\r\nNote: Recursive solution is trivial, could you do it iteratively?\r\n", "discussUrl": "https://discuss.leetcode.com/category/153", "similarQuestions": ["BinaryTreeInorderTraversal"], "topicTags": ["Stack", "Tree"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<Integer> postorderTraversal(TreeNode root) {\n        List<Integer> result = new ArrayList<Integer>();\n        \n        if (root == null) {\n            return result;\n        }\n        \n        TreeNode prev = null;\n        LinkedList<TreeNode> stack = new LinkedList<TreeNode>();\n        stack.push(root);\n        \n        while(!stack.isEmpty()) {\n            TreeNode curr = stack.peek();\n            \n            if (prev == null || prev.left == curr || prev.right == curr) {\n                if (curr.left != null) {\n                    stack.push(curr.left);\n                } else if(curr.right != null) {\n                    stack.push(curr.right);\n                } else {\n                    result.add(curr.val);\n                    stack.pop();\n                }\n            } else {\n                if (curr.left == prev) {\n                    if (curr.right != null) {\n                        stack.push(curr.right);\n                    } else {\n                        result.add(curr.val);\n                        stack.pop();\n                    }\n                    \n                } else if (curr.right == prev) {\n                        result.add(curr.val);\n                        stack.pop();\n                }\n            }\n            \n            prev = curr;\n        } \n        \n        return result;\n    }\n}\n", "total_acs": 167173, "total_submitted": 403101}, {"id": 146, "title": "LRU Cache", "url": "https://leetcode.com/problems/lru-cache/description", "companyTags": ["Google", "Facebook", "Microsoft", "Amazon", "Bloomberg", "Uber", "Twitter", "Snapchat", "Zenefits", "Yahoo", "Palantir"], "difficulty": "Hard", "content": "\r\nDesign and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.\r\n\r\n\r\n\r\nget(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.\r\nput(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.\r\n\r\n\r\nFollow up:\r\nCould you do both operations in O(1) time complexity?\r\n\r\nExample:\r\n\r\nLRUCache cache = new LRUCache( 2 /* capacity */ );\r\n\r\ncache.put(1, 1);\r\ncache.put(2, 2);\r\ncache.get(1);       // returns 1\r\ncache.put(3, 3);    // evicts key 2\r\ncache.get(2);       // returns -1 (not found)\r\ncache.put(4, 4);    // evicts key 1\r\ncache.get(1);       // returns -1 (not found)\r\ncache.get(3);       // returns 3\r\ncache.get(4);       // returns 4\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/154", "similarQuestions": ["LFUCache", "DesignIn-MemoryFileSystem", "DesignCompressedStringIterator"], "topicTags": ["Design"], "Solution": "class LRUCache {\n    class DLinkedList {\n        int key;\n        int value;\n        DLinkedList pre;\n        DLinkedList post;\n        public DLinkedList(int key, int value) {\n            this.key = key;\n            this.value = value;\n        }\n        public DLinkedList() {\n            // empty contrucut method\n        }\n    }\n    private DLinkedList head, tail;\n    private int count = 0;\n    private int capacity = 0;\n    private HashMap<Integer, DLinkedList> cache;\n    private void addToHead(DLinkedList node) {\n        node.pre = head;\n        node.post = head.post;\n        head.post.pre = node;\n        head.post = node;\n    }\n    private void removeNode(DLinkedList node) {\n        DLinkedList post = node.post;\n        DLinkedList pre = node.pre;\n        post.pre = pre;\n        pre.post = post;\n    }\n    private void moveToHead(DLinkedList node) {\n        removeNode(node);\n        addToHead(node);\n    }\n    private DLinkedList popTail() {\n        DLinkedList pre = tail.pre;\n        removeNode(pre);\n        return pre;\n    }\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        head = new DLinkedList();\n        head.pre = null;\n        tail = new DLinkedList();\n        tail.post = null;\n        head.post = tail;\n        tail.pre = head;\n        cache = new HashMap<>();\n    }\n    \n    public int get(int key) {\n        DLinkedList node = cache.get(key);\n        if (node == null) {\n            return -1;\n        } else {\n            moveToHead(node);\n            return node.value;\n        }\n    }\n    \n    public void put(int key, int value) {\n        DLinkedList node = cache.get(key);\n        if (node == null) {\n            DLinkedList cur = new DLinkedList(key, value);\n            cache.put(key, cur);\n            addToHead(cur);\n            count++;\n            if (count > capacity) {\n                DLinkedList last = popTail();\n                cache.remove(last.key);\n                count--;\n            }\n        } else {\n            node.value = value;\n            moveToHead(node);\n        }\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */", "total_acs": 160865, "total_submitted": 830556}, {"id": 147, "title": "Insertion Sort List", "url": "https://leetcode.com/problems/insertion-sort-list/description", "companyTags": [""], "difficulty": "Medium", "content": "Sort a linked list using insertion sort.", "discussUrl": "https://discuss.leetcode.com/category/155", "similarQuestions": ["SortList"], "topicTags": ["LinkedList", "Sort"], "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode insertionSortList(ListNode head) {\n        if(head==null||head.next==null)\n            return head; //\u94fe\u8868\u7684\u63d2\u5165\u6392\u5e8f,\u6bcf\u6b21\u5c06\u5217\u8868\u4e2d\u7684\u6700\u5c0f\u63d2\u524d\u9762\uff08\u5df2\u7ecf\u6709\u5e8f\uff09      \n\n        ListNode tail=head,start=head,temp=null; //\u94fe\u8868\u5bf9\u6298,tail\u7528\u4e8e\u8868\u793a\u540e\u534a\u90e8\u5206\uff0cstart\u7528\u4e8e\u8bb0\u6570\uff0ctemp\u4e34\u65f6\u5b58\u50a8(\u7c7b\u4f3cpre)\n        while(start!=null&&start.next!=null){\n            temp=tail;\n            tail=tail.next;\n            start=start.next.next;//\u6bd4tail\u5feb\u4e00\u500d\u901f\u5ea6\uff0c\u6b63\u597d\u5c06\u94fe\u8868\u5bf9\u6298\n        }\n        \n        ListNode l2=insertionSortList(tail);   //\u9012\u5f52\u5b9e\u73b0\u540e\u534a\u90e8\u5206        \n        temp.next=null;      //temp\u6b63\u597d\u4e3atail\u7684\u524d\u4e00\u4e2a\uff0c\u65ad\u94fe\n        \n        ListNode l1=insertionSortList(head);   //\u9012\u5f52\u5b9e\u73b0\u524d\u534a\u90e8\u5206\n        ListNode dummy=new ListNode(0);\n        ListNode cur=dummy;\n        \n        //\u5c06\u524d\u534a\u90e8\u5206\u548c\u540e\u534a\u90e8\u5206\u6bd4\u8f83\n        while(l1!=null&&l2!=null){\n            if(l1.val<l2.val){\n                cur.next=l1;        //\u63d2\u5165cur\n                l1=l1.next;\n            }else{\n                cur.next=l2;\n                l2=l2.next;\n            }\n            cur=cur.next;\n        }\n        \n        if(l1!=null) cur.next=l1;    //\u4ee5\u9632l1\u6216l2\u8fd8\u6709\u8282\u70b9\n        if(l2!=null) cur.next=l2;\n     \n        return dummy.next;\n        \n    }\n}", "total_acs": 114847, "total_submitted": 341024}, {"id": 148, "title": "Sort List", "url": "https://leetcode.com/problems/sort-list/description", "companyTags": [""], "difficulty": "Medium", "content": "Sort a linked list in O(n log n) time using constant space complexity.", "discussUrl": "https://discuss.leetcode.com/category/156", "similarQuestions": ["MergeTwoSortedLists", "SortColors", "InsertionSortList"], "topicTags": ["LinkedList", "Sort"], "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    private ListNode tail;\n    public ListNode sortList(ListNode head) {\n        if (head == null) return null;\n        else if (head.next == null) {\n            tail = head;\n            return head;\n        }\n        ListNode biggerListHead = null;\n        ListNode smallerListHead = null;\n        ListNode equalListHead = head;\n        ListNode node = head.next;\n        head.next = null;\n        while (node != null) {\n            ListNode next = node.next;\n            if (node.val == head.val) {\n                node.next = equalListHead;\n                equalListHead = node;\n            } else if (node.val > head.val) {\n                node.next = biggerListHead;\n                biggerListHead = node;\n            } else {\n                node.next = smallerListHead;\n                smallerListHead = node;                \n            }\n            node = next;\n        }\n        \n        node = head;\n        if (smallerListHead != null) {\n            head = sortList(smallerListHead);\n            tail.next = equalListHead;\n        } else {\n            head = equalListHead;\n        }\n        if (biggerListHead != null) {\n            node.next = sortList(biggerListHead);\n        } else {\n            tail = node;\n        }\n        return head;\n    }\n}", "total_acs": 125332, "total_submitted": 423197}, {"id": 149, "title": "Max Points on a Line", "url": "https://leetcode.com/problems/max-points-on-a-line/description", "companyTags": ["LinkedIn", "Twitter", "Apple"], "difficulty": "Hard", "content": "Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.", "discussUrl": "https://discuss.leetcode.com/category/157", "similarQuestions": ["LineReflection"], "topicTags": ["HashTable", "Math"], "Solution": "class Solution {\n    public int maxPoints(Point[] points) {\n        if (points == null) {\n            return 0;\n        }\n        if (points.length <= 2) {\n            return points.length;\n        }\n        int n = points.length;\n        int max = 2;\n        Point a, b, c;\n        for (int i = 1; i < n; i++) {\n            a = points[i - 1];\n            b = points[i];\n            double k = getSlop(a, b);\n            int count = 2;\n            for (int j = 0; j < n; j++) {\n                if (j == i || j == i - 1) {\n                    continue;\n                }\n                c = points[j];\n                if (overlap(a, c) || overlap(b, c) || k == getSlop(b, c)) {\n                    count++;\n                }\n            }\n            max = Math.max(max, count);\n        }\n        return max;\n    }\n    \n    private boolean overlap(Point a, Point b) {\n        return a.x == b.x && a.y == b.y;\n    }\n    \n    private double getSlop(Point a, Point b) {\n        if (a.x == b.x) {\n            return Double.POSITIVE_INFINITY;\n        } else {\n            return ((double) a.y - b.y) / ((double) a.x - b.x);\n        }\n    }\n}", "total_acs": 89477, "total_submitted": 588504}, {"id": 150, "title": "Evaluate Reverse Polish Notation", "url": "https://leetcode.com/problems/evaluate-reverse-polish-notation/description", "companyTags": ["LinkedIn"], "difficulty": "Medium", "content": "\r\nEvaluate the value of an arithmetic expression in Reverse Polish Notation.\r\n\r\n\r\n\r\nValid operators are +, -, *, /. Each operand may be an integer or another expression.\r\n\r\n\r\n\r\nSome examples:\r\n\r\n  [\"2\", \"1\", \"+\", \"3\", \"*\"] -> ((2 + 1) * 3) -> 9\r\n  [\"4\", \"13\", \"5\", \"/\", \"+\"] -> (4 + (13 / 5)) -> 6\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/158", "similarQuestions": ["BasicCalculator", "ExpressionAddOperators"], "topicTags": ["Stack"], "Solution": "class Solution {\n    private int curr;\n    public int evalRPN(String[] tokens) {\n        curr = tokens.length - 1;\n        return eval(tokens);\n    }\n    \n    private int eval(String[] tokens) {\n        String token = tokens[curr--];\n        char c = token.charAt(0);\n        if (token.length() == 1 && isOp(c)) {\n            int b = eval(tokens);\n            int a = eval(tokens);\n            return applyOp(c, a, b);\n        } else {\n            return Integer.parseInt(token);\n        }\n    }\n    \n    private boolean isOp(char c) {\n        switch (c) {\n            case '+': case '-': case '*': case '/': return true;\n        }\n        return false;\n    }\n    \n    private int applyOp(char op, int a, int b) {\n        switch (op) {\n            case '+': return a + b;\n            case '-': return a - b;\n            case '*': return a * b;\n            case '/': return a / b;\n        }\n        return a;\n    }\n}", "total_acs": 109509, "total_submitted": 388977}, {"id": 151, "title": "Reverse Words in a String", "url": "https://leetcode.com/problems/reverse-words-in-a-string/description", "companyTags": ["Microsoft", "Bloomberg", "Apple", "Snapchat", "Yelp"], "difficulty": "Medium", "content": "\r\nGiven an input string, reverse the string word by word.\r\n\r\n\r\n\r\nFor example,\r\nGiven s = \"the sky is blue\",\r\nreturn \"blue is sky the\".\r\n\r\n\r\n\r\nUpdate (2015-02-12):\r\nFor C programmers: Try to solve it in-place in O(1) space.\r\n\r\n\r\nclick to show clarification.\r\n\r\nClarification:\r\n\r\n\r\n\r\nWhat constitutes a word?\r\nA sequence of non-space characters constitutes a word.\r\nCould the input string contain leading or trailing spaces?\r\nYes. However, your reversed string should not contain leading or trailing spaces.\r\nHow about multiple spaces between two words?\r\nReduce them to a single space in the reversed string.\r\n\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/159", "similarQuestions": ["ReverseWordsinaStringII"], "topicTags": ["String"], "Solution": "public class Solution {\n    public String reverseWords(String s) {\n        if(s == null || s.length() == 0) return \"\";\n        StringBuilder sb = new StringBuilder();\n        String[] str = s.split(\"\\\\ \");\n        //if(str == null || str.length == 0) return \"\";\n        for(int i = str.length - 1; i >= 0; i--){\n            String ss = str[i];\n            if(!ss.isEmpty()){\n                sb.append(ss).append(\" \");\n            }\n        }\n        if(sb.length() != 0)\n        sb.setLength(sb.length() - 1);\n        return sb.toString();\n    }\n}", "total_acs": 186967, "total_submitted": 1193223}, {"id": 152, "title": "Maximum Product Subarray", "url": "https://leetcode.com/problems/maximum-product-subarray/description", "companyTags": ["LinkedIn"], "difficulty": "Medium", "content": "\r\nFind the contiguous subarray within an array (containing at least one number) which has the largest product.\r\n\r\n\r\n\r\nFor example, given the array [2,3,-2,4],\r\nthe contiguous subarray [2,3] has the largest product = 6.\r\n", "discussUrl": "https://discuss.leetcode.com/category/160", "similarQuestions": ["MaximumSubarray", "HouseRobber", "ProductofArrayExceptSelf", "MaximumProductofThreeNumbers", "SubarrayProductLessThanK"], "topicTags": ["Array", "DynamicProgramming"], "Solution": "class Solution {\n    public int maxProduct(int[] nums) {\n        if (nums.length == 0) {\n            return 0;\n        }\n        \n        int[] max = new int[nums.length];\n        int[] min = new int[nums.length];\n        \n        max[0] = nums[0];\n        min[0] = nums[0];\n        \n        for (int i = 1; i < max.length; i++) {\n            max[i] = Math.max(nums[i], Math.max(max[i-1]*nums[i], min[i-1]*nums[i]));\n            min[i] = Math.min(nums[i], Math.min(max[i-1]*nums[i], min[i-1]*nums[i]));\n        }\n        \n        int res = nums[0];\n        \n        for (int i = 0; i < max.length; i++) {\n            res = Math.max(res, max[i]);\n        }\n        \n        return res;\n        \n    }\n}", "total_acs": 129642, "total_submitted": 488033}, {"id": 153, "title": "Find Minimum in Rotated Sorted Array", "url": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description", "companyTags": ["Microsoft"], "difficulty": "Medium", "content": "Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\r\n\r\n(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).\r\n\r\nFind the minimum element.\r\n\r\nYou may assume no duplicate exists in the array.", "discussUrl": "https://discuss.leetcode.com/category/161", "similarQuestions": ["SearchinRotatedSortedArray", "FindMinimuminRotatedSortedArrayII"], "topicTags": ["Array", "BinarySearch"], "Solution": "class Solution {\n    public int findMin(int[] nums) {\n        if(nums == null || nums.length == 0) return 0;\n        int low = 0;\n        int high = nums.length-1;\n        while(low < high){\n            if(nums[low] < nums[high]) break;\n            int mid = low + (high-low)/2;\n            if(nums[mid] < nums[high]){\n                high = mid;\n            }else{\n                low = mid+1;\n            }\n        }\n        return nums[low];\n    }\n}", "total_acs": 182692, "total_submitted": 449396}, {"id": 154, "title": "Find Minimum in Rotated Sorted Array II", "url": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/description", "companyTags": [""], "difficulty": "Hard", "content": "\r\nFollow up for \"Find Minimum in Rotated Sorted Array\":\r\nWhat if duplicates are allowed?\r\n\r\nWould this affect the run-time complexity? How and why?\r\n\r\n\r\nSuppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\r\n\r\n(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).\r\n\r\nFind the minimum element.\r\n\r\nThe array may contain duplicates.", "discussUrl": "https://discuss.leetcode.com/category/162", "similarQuestions": ["FindMinimuminRotatedSortedArray"], "topicTags": ["Array", "BinarySearch"], "Solution": "class Solution {\n    public int findMin(int[] nums) {\n        int l=0,r=nums.length-1;\n        while(l<r){\n            int mid=(l+r)>>>1;\n            if(nums[mid]>nums[r]){\n                l=mid+1;\n            }else if(nums[mid]<nums[r]){\n                r=mid;\n            }else{\n                r--;\n            }\n        }\n        return nums[l];\n    }\n}", "total_acs": 91474, "total_submitted": 242553}, {"id": 155, "title": "Min Stack", "url": "https://leetcode.com/problems/min-stack/description", "companyTags": ["Google", "Amazon", "Bloomberg", "Uber", "Snapchat", "Zenefits"], "difficulty": "Easy", "content": "\r\nDesign a stack that supports push, pop, top, and retrieving the minimum element in constant time.\r\n\r\n\r\npush(x) -- Push element x onto stack.\r\n\r\n\r\npop() -- Removes the element on top of the stack.\r\n\r\n\r\ntop() -- Get the top element.\r\n\r\n\r\ngetMin() -- Retrieve the minimum element in the stack.\r\n\r\n\r\n\r\n\r\nExample:\r\n\r\nMinStack minStack = new MinStack();\r\nminStack.push(-2);\r\nminStack.push(0);\r\nminStack.push(-3);\r\nminStack.getMin();   --> Returns -3.\r\nminStack.pop();\r\nminStack.top();      --> Returns 0.\r\nminStack.getMin();   --> Returns -2.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/163", "similarQuestions": ["SlidingWindowMaximum", "MaxStack"], "topicTags": ["Stack", "Design"], "Solution": "class MinStack {\n    Stack<Integer> stack;\n    int min;\n    /** initialize your data structure here. */\n    public MinStack() {\n        stack = new Stack<Integer>();\n        min = Integer.MAX_VALUE;\n    }\n    \n    public void push(int x) {\n        if (x <= min) {\n            stack.push(min);\n            min = x;\n        }\n        stack.push(x);\n    }\n    \n    public void pop() {\n        int pop = stack.pop();\n        if (pop == min)\n            min = stack.pop();\n    }\n    \n    public int top() {\n        return stack.peek();\n    }\n    \n    public int getMin() {\n        return min;\n    }\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack obj = new MinStack();\n * obj.push(x);\n * obj.pop();\n * int param_3 = obj.top();\n * int param_4 = obj.getMin();\n */", "total_acs": 171200, "total_submitted": 559644}, {"id": 156, "title": "Binary Tree Upside Down", "url": "https://leetcode.com/problems/binary-tree-upside-down/description", "companyTags": ["LinkedIn"], "difficulty": "Medium", "content": "\r\nGiven a binary tree where all the right nodes are either leaf nodes with a sibling (a left node that shares the same parent node) or empty, flip it upside down and turn it into a tree where the original right nodes turned into left leaf nodes. Return the new root.\r\n\r\n\r\nFor example:\r\nGiven a binary tree {1,2,3,4,5},\r\n\r\n    1\r\n   / \\\r\n  2   3\r\n / \\\r\n4   5\r\n\r\n\r\n\r\nreturn the root of the binary tree [4,5,2,#,#,3,1].\r\n\r\n   4\r\n  / \\\r\n 5   2\r\n    / \\\r\n   3   1  \r\n\r\n\r\n\r\nconfused what \"{1,#,2,3}\" means? > read more on how binary tree is serialized on OJ.\r\n\r\nOJ's Binary Tree Serialization:\r\n\r\nThe serialization of a binary tree follows a level order traversal, where '#' signifies a path terminator where no node exists below.\r\n\r\n\r\nHere's an example:\r\n\r\n   1\r\n  / \\\r\n 2   3\r\n    /\r\n   4\r\n    \\\r\n     5\r\n\r\nThe above binary tree is serialized as \"{1,2,3,#,#,4,#,#,5}\". \r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/165", "similarQuestions": ["ReverseLinkedList"], "topicTags": ["Tree"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode upsideDownBinaryTree(TreeNode root) {\n        if (root == null) {\n            return null;\n        }\n        Deque<TreeNode> stack = new LinkedList<>();\n        TreeNode curr = root;\n        while (curr != null) {\n            stack.push(curr);\n            curr = curr.left;\n        }\n        TreeNode newRoot = stack.pop();\n        curr = newRoot;\n        while (!stack.isEmpty()) {\n            curr.right = stack.pop();\n            curr.left = curr.right.right;\n            curr.right.left = null;\n            curr.right.right = null;\n            curr = curr.right;\n        }\n        return newRoot;\n    }\n}", "total_acs": 32787, "total_submitted": 71827}, {"id": 157, "title": "Read N Characters Given Read4", "url": "https://leetcode.com/problems/read-n-characters-given-read4/description", "companyTags": ["Facebook"], "difficulty": "Easy", "content": "\r\nThe API: int read4(char *buf) reads 4 characters at a time from a file.\r\n\r\n\r\n\r\nThe return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file.\r\n\r\n\r\n\r\nBy using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file.\r\n\r\n\r\n\r\nNote:\r\nThe read function will only be called once for each test case.\r\n", "discussUrl": "https://discuss.leetcode.com/category/166", "similarQuestions": ["ReadNCharactersGivenRead4II-Callmultipletimes"], "topicTags": ["String"], "Solution": "/* The read4 API is defined in the parent class Reader4.\n      int read4(char[] buf); */\n\npublic class Solution extends Reader4 {\n    /**\n     * @param buf Destination buffer\n     * @param n   Maximum number of characters to read\n     * @return    The number of characters read\n     */\n    public int read(char[] buf, int n) {\n        boolean eon = false;\n        int total = 0;\n        char[] temp = new char[4];\n        while(!eon && total < n) {\n            int count = read4(temp);\n            eon = count < 4;\n            count = Math.min(count, n - total);\n            for (int i = 0; i < count; i++)\n                buf[total++] = temp[i];\n        }\n        return total;\n    }\n}", "total_acs": 44514, "total_submitted": 152812}, {"id": 158, "title": "Read N Characters Given Read4 II - Call multiple times", "url": "https://leetcode.com/problems/read-n-characters-given-read4-ii-call-multiple-times/description", "companyTags": ["Google", "Facebook", "Bloomberg"], "difficulty": "Hard", "content": "\r\nThe API: int read4(char *buf) reads 4 characters at a time from a file.\r\n\r\n\r\n\r\nThe return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file.\r\n\r\n\r\n\r\nBy using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file.\r\n\r\n\r\n\r\nNote:\r\nThe read function may be called multiple times.\r\n", "discussUrl": "https://discuss.leetcode.com/category/167", "similarQuestions": ["ReadNCharactersGivenRead4"], "topicTags": ["String"], "Solution": "/* The read4 API is defined in the parent class Reader4.\n      int read4(char[] buf); */\n\npublic class Solution extends Reader4 {\n    private char[] chars = new char[4];\n    private int start = 0;\n    private int end = 0;\n    private boolean eof = false;\n    /**\n     * @param buf Destination buffer\n     * @param n   Maximum number of characters to read\n     * @return    The number of characters read\n     */\n    public int read(char[] buf, int n) {\n        if(n < 1) return 0;\n        int done = 0;\n        while(done < n){\n            if(start >= end){\n                if(eof){\n                    break;\n                }\n                \n                start = 0;\n                end = read4(chars);\n                \n                if(end < 4){\n                    eof = true;\n                }\n            }else{\n                buf[done++] = chars[start++];\n            }\n        }\n        \n        return done;\n    }\n}", "total_acs": 37831, "total_submitted": 152790}, {"id": 159, "title": "Longest Substring with At Most Two Distinct Characters", "url": "https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/description", "companyTags": ["Google"], "difficulty": "Hard", "content": "\r\nGiven a string, find the length of the longest substring T that contains at most 2 distinct characters.\r\n\r\n\r\n\r\nFor example,\r\n\r\nGiven s = \u201ceceba\u201d,\r\n\r\n\r\n\r\nT is \"ece\" which its length is 3.\r\n", "discussUrl": "https://discuss.leetcode.com/category/168", "similarQuestions": ["LongestSubstringWithoutRepeatingCharacters", "SlidingWindowMaximum", "LongestSubstringwithAtMostKDistinctCharacters"], "topicTags": ["HashTable", "TwoPointers", "String"], "Solution": "class Solution {\n    public int lengthOfLongestSubstringTwoDistinct(final String s) {\n        int[] lastIndexes = new int[128];\n        lastIndexes[0] = -1;\n        int maxLength = 0;\n        char first = 0;\n        char second = 0;\n        int lastIndex = -1;\n        final char[] word = s.toCharArray();\n        int length = 0;\n        for(int i = 0; i<word.length; i++) {\n            char c = word[i];\n            if(c != first) {\n                if(c != second) {\n                    lastIndex = lastIndexes[second];\n                    maxLength = Math.max(maxLength, length);\n                    length = i-lastIndex-1;\n                }\n                second = first;\n                first = c;\n            }\n            length++;\n            lastIndexes[c] = i;\n        }\n        return Math.max(maxLength, length);\n    }\n}", "total_acs": 34972, "total_submitted": 82158}, {"id": 160, "title": "Intersection of Two Linked Lists", "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/description", "companyTags": ["Microsoft", "Amazon", "Bloomberg", "Airbnb"], "difficulty": "Easy", "content": "Write a program to find the node at which the intersection of two singly linked lists begins.\r\n\r\nFor example, the following two linked lists: \r\n\r\nA:          a1 \u2192 a2\r\n                   \u2198\r\n                     c1 \u2192 c2 \u2192 c3\r\n                   \u2197            \r\nB:     b1 \u2192 b2 \u2192 b3\r\n\r\nbegin to intersect at node c1.\r\n\r\nNotes:\r\n\r\nIf the two linked lists have no intersection at all, return null.\r\nThe linked lists must retain their original structure after the function returns. \r\nYou may assume there are no cycles anywhere in the entire linked structure.\r\nYour code should preferably run in O(n) time and use only O(1) memory.\r\n\r\n\r\n\r\nCredits:Special thanks to @stellari for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/164", "similarQuestions": ["MinimumIndexSumofTwoLists"], "topicTags": ["LinkedList"], "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    \n    public ListNode getIntersectionNode(ListNode ha, ListNode hb) {\n        if (ha==null || hb==null) return null;\n        if (ha == hb) return ha;\n\n        int stepA = 0;\n        ListNode ta = ha;\n        while (ta.next != null) {\n            ta = ta.next;\n            stepA++;\n        }\n\n        int stepB = 0;\n        ListNode tb = hb;\n        while (tb.next != null) {\n            tb = tb.next;\n            stepB++;\n        }\n\n        if (ta != tb) return null;\n\n        ta = ha; tb = hb;\n        if (stepA > stepB) while (stepA > stepB) {\n            ta = ta.next;\n            --stepA;\n        } else if (stepA < stepB) while (stepA < stepB) {\n            tb = tb.next;\n            --stepB;\n        }\n\n        while (ta != tb) {\n            ta = ta.next;\n            tb = tb.next;\n        }\n        return ta;\n    }\n}", "total_acs": 173665, "total_submitted": 562457}, {"id": 161, "title": "One Edit Distance", "url": "https://leetcode.com/problems/one-edit-distance/description", "companyTags": ["Facebook", "Uber", "Twitter", "Snapchat"], "difficulty": "Medium", "content": "Given two strings S and T, determine if they are both one edit distance apart.", "discussUrl": "https://discuss.leetcode.com/category/169", "similarQuestions": ["EditDistance"], "topicTags": ["String"], "Solution": "class Solution {\n    public boolean isOneEditDistance(String s, String t) {\n        if(s.length() > t.length()) return isOneEditDistance(t, s);\n        int m = s.length(), n = t.length();\n        if(n - m > 1) return false;\n        for(int i = 0; i < m; i++) {\n            if(s.charAt(i) != t.charAt(i)) return s.substring(i + 1).equals(t.substring(i + 1)) || s.substring(i).equals(t.substring(i + 1));\n        }\n        return n > m;\n    }\n}", "total_acs": 46767, "total_submitted": 147452}, {"id": 162, "title": "Find Peak Element", "url": "https://leetcode.com/problems/find-peak-element/description", "companyTags": ["Google", "Microsoft"], "difficulty": "Medium", "content": "A peak element is an element that is greater than its neighbors.\r\n\r\nGiven an input array where num[i] \u2260 num[i+1], find a peak element and return its index.\r\n\r\nThe array may contain multiple peaks, in that case return the index to any one of the peaks is fine.\r\n\r\nYou may imagine that num[-1] = num[n] = -\u221e.\r\n\r\nFor example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.\r\n\r\nclick to show spoilers.\r\n\r\nNote:\r\nYour solution should be in logarithmic complexity.\r\n\r\n\r\nCredits:Special thanks to @ts for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/170", "similarQuestions": [""], "topicTags": ["Array", "BinarySearch"], "Solution": "class Solution {\n    public int findPeakElement(int[] nums) {\n        \n        for(int i = 0; i < nums.length; i++) {\n            if((i == 0 || nums[i] > nums[i - 1]) && (i == nums.length - 1 || nums[i] > nums[i + 1])) return i;\n        }\n        return 0;\n    }\n}", "total_acs": 141653, "total_submitted": 366911}, {"id": 163, "title": "Missing Ranges", "url": "https://leetcode.com/problems/missing-ranges/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "\r\nGiven a sorted integer array where the range of elements are in the inclusive range [lower, upper], return its missing ranges.\r\n\r\n\r\nFor example, given [0, 1, 3, 50, 75], lower = 0 and upper = 99, return [\"2\", \"4->49\", \"51->74\", \"76->99\"].\r\n", "discussUrl": "https://discuss.leetcode.com/category/171", "similarQuestions": ["SummaryRanges"], "topicTags": ["Array"], "Solution": "class Solution {\n    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\n        List<String> result = new ArrayList<>();\n        if(nums.length == 0) {\n            result.add(lower == upper ? String.valueOf(lower) : lower + \"->\" + upper);\n            return result;\n        }\n        int start = 0;\n        int end = 0;\n        for(int i = 0; i < nums.length; i++) {\n            if(i == 0) {\n                if(nums[i] != lower) {\n                    end = nums[i] - 1;\n                    result.add(lower == end ? String.valueOf(lower) : lower + \"->\" + end);\n                }\n            } else {\n                if(nums[i] != nums[i - 1] && nums[i] != nums[i - 1] + 1) {\n                    end = nums[i] - 1;\n                    result.add(start == end ? String.valueOf(start) : start + \"->\" + end);\n                }\n            }\n            start = nums[i] + 1;\n        }\n        if(nums[nums.length - 1] != upper) {\n            result.add(start == upper ? String.valueOf(start) : start + \"->\" + upper);\n        }\n        return result;\n    }\n}", "total_acs": 36155, "total_submitted": 154476}, {"id": 164, "title": "Maximum Gap", "url": "https://leetcode.com/problems/maximum-gap/description", "companyTags": [""], "difficulty": "Hard", "content": "Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\r\n\r\nTry to solve it in linear time/space.\r\n\r\nReturn 0 if the array contains less than 2 elements.\r\n\r\nYou may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.\r\n\r\nCredits:Special thanks to @porker2008 for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/172", "similarQuestions": [""], "topicTags": ["Sort"], "Solution": "class Solution {\n    public int maximumGap(int[] nums) {\n        if(nums == null || nums.length < 2) return 0;\n        \n        int max = nums[0], min = nums[0];\n        for(int n : nums){\n            max = Math.max(max, n);\n            min = Math.min(min, n);\n        }\n        \n        int gap = (max - min) / (nums.length-1);\n        if(gap == 0) gap ++;\n        int len = (max - min) / gap + 1;\n        int[] maxBucket = new int[len];\n        int[] minBucket = new int[len];\n        \n        for(int n : nums){\n            int i = (n - min) / gap;\n            if(n > maxBucket[i]) maxBucket[i] = n;\n            if(minBucket[i] == 0 || n < minBucket[i]) minBucket[i] = n;\n        }\n        \n        int res = 0;\n        for(int i = 0; i < len; i ++){\n            if(res < minBucket[i] - min) res = minBucket[i] - min;\n            if(maxBucket[i] != 0) min = maxBucket[i];\n        }\n        return res;\n    }\n}", "total_acs": 53918, "total_submitted": 180002}, {"id": 165, "title": "Compare Version Numbers", "url": "https://leetcode.com/problems/compare-version-numbers/description", "companyTags": ["Microsoft", "Apple"], "difficulty": "Medium", "content": "Compare two version numbers version1 and version2.\r\nIf version1 > version2 return 1, if version1 < version2 return -1, otherwise return 0.\r\n\r\nYou may assume that the version strings are non-empty and contain only digits and the . character.\r\nThe . character does not represent a decimal point and is used to separate number sequences.\r\nFor instance, 2.5 is not \"two and a half\" or \"half way to version three\", it is the fifth second-level revision of the second first-level revision.\r\n\r\nHere is an example of version numbers ordering:\r\n0.1 < 1.1 < 1.2 < 13.37\r\n\r\nCredits:Special thanks to @ts for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/173", "similarQuestions": [""], "topicTags": ["String"], "Solution": "class Solution {\n    public int compareVersion(String version1, String version2) {\n        int i = 0, j = 0;\n        while(i < version1.length() && j < version2.length()) {\n            int v1 = 0, v2 = 0;\n            while(i < version1.length() && version1.charAt(i) != '.') v1 = 10*v1+ version1.charAt(i++) - '0';\n            while(j < version2.length() && version2.charAt(j) != '.') v2 = 10*v2+ version2.charAt(j++) - '0';\n            if(v1 < v2) return -1;\n            else if(v1 > v2) return 1;\n            else {\n                ++i;\n                ++j;\n            }\n        }\n        while(i < version1.length()) {\n            if(version1.charAt(i) == '0' || version1.charAt(i) == '.') ++i;\n            else return 1;\n        }\n        while(j < version2.length()) {\n            if(version2.charAt(j) == '0' || version2.charAt(j) == '.') ++j;\n            else return -1;\n        }\n        return 0;\n    }\n}", "total_acs": 95993, "total_submitted": 464628}, {"id": 166, "title": "Fraction to Recurring Decimal", "url": "https://leetcode.com/problems/fraction-to-recurring-decimal/description", "companyTags": ["Google", "IXL"], "difficulty": "Medium", "content": "Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.\r\n\r\nIf the fractional part is repeating, enclose the repeating part in parentheses.\r\n\r\nFor example,\r\n\r\nGiven numerator = 1, denominator = 2, return \"0.5\".\r\nGiven numerator = 2, denominator = 1, return \"2\".\r\nGiven numerator = 2, denominator = 3, return \"0.(6)\".\r\n\r\n\r\n\r\nCredits:Special thanks to @Shangrila for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/174", "similarQuestions": [""], "topicTags": ["HashTable", "Math"], "Solution": "class Solution {\n    public String fractionToDecimal(int numerator, int denominator) {\n        if(denominator == 0) return \"\";\n        if(numerator == 0) return \"0\";\n        boolean neg = numerator < 0 ^ denominator < 0;\n        long num = Math.abs((long)numerator);\n        long den = Math.abs((long)denominator);\n        Map<Integer, Integer> map = new HashMap<>();\n        String firstPart = (neg ? \"-\" : \"\") + num / den;\n        if(num % den == 0) return firstPart;\n        StringBuilder sb = new StringBuilder();\n        long resi = num % den;\n        int count = 0;\n        while(resi != 0) {\n            if(map.containsKey((int)resi)){\n                sb.insert(map.get((int)resi).intValue(), '(');\n                sb.append(')');\n                break;\n            }\n            map.put((int)resi, count++);\n            resi *= 10;\n            sb.append(resi / den);\n            resi %= den;\n        }\n        return firstPart + \".\" + sb.toString();\n    }\n}", "total_acs": 61153, "total_submitted": 340001}, {"id": 167, "title": "Two Sum II - Input array is sorted", "url": "https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description", "companyTags": ["Amazon"], "difficulty": "Easy", "content": "Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.\r\n\r\nThe function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.\r\n\r\nYou may assume that each input would have exactly one solution and you may not use the same element twice.\r\n\r\n\r\nInput: numbers={2, 7, 11, 15}, target=9\r\nOutput: index1=1, index2=2\r\n", "discussUrl": "https://discuss.leetcode.com/category/175", "similarQuestions": ["TwoSum", "TwoSumIV-InputisaBST"], "topicTags": ["Array", "TwoPointers", "BinarySearch"], "Solution": "class Solution {\n    public int[] twoSum(int[] numbers, int target) {\n        int left=0,right=numbers.length-1;\n        while(left<right){\n            int comp = numbers[left]+numbers[right];\n            if(comp==target){\n                return new int[]{left+1,right+1};\n            }else if(comp>target){\n                right--;\n            }else{\n                left++;\n            }\n        }\n        return null;\n    }\n}", "total_acs": 122738, "total_submitted": 259777}, {"id": 168, "title": "Excel Sheet Column Title", "url": "https://leetcode.com/problems/excel-sheet-column-title/description", "companyTags": ["Facebook", "Microsoft", "Zenefits"], "difficulty": "Easy", "content": "Given a positive integer, return its corresponding column title as appear in an Excel sheet.\r\n\r\nFor example:\r\n\r\n    1 -> A\r\n    2 -> B\r\n    3 -> C\r\n    ...\r\n    26 -> Z\r\n    27 -> AA\r\n    28 -> AB \r\n\r\nCredits:Special thanks to @ifanchu for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/176", "similarQuestions": ["ExcelSheetColumnNumber"], "topicTags": ["Math"], "Solution": "class Solution {\n    public String convertToTitle(int n) {\n        StringBuilder builder = new StringBuilder();\n        \n        while(n>0) {\n            n--;\n            builder.append((char)('A' + (n%26)));\n            n /= 26;\n        }\n        \n        return builder.reverse().toString();\n    }\n}", "total_acs": 128012, "total_submitted": 472778}, {"id": 169, "title": "Majority Element", "url": "https://leetcode.com/problems/majority-element/description", "companyTags": ["Zenefits", "Adobe"], "difficulty": "Easy", "content": "Given an array of size n, find the majority element. The majority element is the element that appears more than \u230a n/2 \u230b times.\r\n\r\nYou may assume that the array is non-empty and the majority element always exist in the array.\r\n\r\nCredits:Special thanks to @ts for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/177", "similarQuestions": ["MajorityElementII"], "topicTags": ["Array", "DivideandConquer", "BitManipulation"], "Solution": "class Solution {\n    public int majorityElement(int[] nums) {\n        Arrays.sort(nums);\n        return nums[nums.length/2];\n    }\n}", "total_acs": 242997, "total_submitted": 509359}, {"id": 170, "title": "Two Sum III - Data structure design", "url": "https://leetcode.com/problems/two-sum-iii-data-structure-design/description", "companyTags": ["LinkedIn"], "difficulty": "Easy", "content": "Design and implement a TwoSum class. It should support the following operations: add and find.\r\n\r\n\r\nadd - Add the number to an internal data structure.\r\nfind - Find if there exists any pair of numbers which sum is equal to the value.\r\n\r\n\r\n\r\nFor example,\r\n\r\nadd(1); add(3); add(5);\r\nfind(4) -> true\r\nfind(7) -> false\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/178", "similarQuestions": ["TwoSum", "UniqueWordAbbreviation", "TwoSumIV-InputisaBST"], "topicTags": ["HashTable", "Design"], "Solution": "class TwoSum {\n    int minVal = Integer.MAX_VALUE;\n    int maxVal = Integer.MIN_VALUE;\n    Map<Integer, Integer> map = new LinkedHashMap<>();\n    \n    /** Add the number to an internal data structure.. */\n    public void add(int number) {\n        minVal = Math.min(minVal, number);\n        maxVal = Math.max(maxVal, number);\n        map.put(number, map.getOrDefault(number, 0) + 1);\n    }\n    \n    /** Find if there exists any pair of numbers which sum is equal to the value. */\n    public boolean find(int val) {\n        if (val < 2 * minVal || val > 2 * maxVal) { return false; }\n        for (int a : map.keySet()) {\n            int b = val - a;\n            if ((a == b && map.get(a) > 1) || (a != b && map.containsKey(b))) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\n/**\n * Your TwoSum object will be instantiated and called as such:\n * TwoSum obj = new TwoSum();\n * obj.add(number);\n * boolean param_2 = obj.find(value);\n */", "total_acs": 35078, "total_submitted": 134475}, {"id": 171, "title": "Excel Sheet Column Number", "url": "https://leetcode.com/problems/excel-sheet-column-number/description", "companyTags": ["Microsoft", "Uber"], "difficulty": "Easy", "content": "Related to question Excel Sheet Column Title\r\nGiven a column title as appear in an Excel sheet, return its corresponding column number.\r\n\r\nFor example:\r\n    A -> 1\r\n    B -> 2\r\n    C -> 3\r\n    ...\r\n    Z -> 26\r\n    AA -> 27\r\n    AB -> 28 \r\n\r\nCredits:Special thanks to @ts for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/179", "similarQuestions": ["ExcelSheetColumnTitle"], "topicTags": ["Math"], "Solution": "class Solution {\n    public int titleToNumber(String s) {\n        if(s == null || s.isEmpty()) return 0;\n\n        int result = 0;\n        char[] letters = s.toCharArray();\n        int exp = 0;\n        for(int i = letters.length-1; i >= 0; i--) {\n            char letter = letters[i];\n            int digit = letter - 'A' + 1;\n            int value = (int) (digit * Math.pow(26, exp));\n            result += value;\n            exp++;\n        }\n        return result;\n    }\n}", "total_acs": 157598, "total_submitted": 326928}, {"id": 172, "title": "Factorial Trailing Zeroes", "url": "https://leetcode.com/problems/factorial-trailing-zeroes/description", "companyTags": ["Bloomberg"], "difficulty": "Easy", "content": "Given an integer n, return the number of trailing zeroes in n!.\r\n\r\nNote: Your solution should be in logarithmic time complexity.\r\n\r\nCredits:Special thanks to @ts for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/180", "similarQuestions": ["NumberofDigitOne"], "topicTags": ["Math"], "Solution": "class Solution {\n    public int trailingZeroes(int n) {\n        return n==0?0:(n/5)+trailingZeroes(n/5);\n    }\n}", "total_acs": 110420, "total_submitted": 300254}, {"id": 173, "title": "Binary Search Tree Iterator", "url": "https://leetcode.com/problems/binary-search-tree-iterator/description", "companyTags": ["Google", "Facebook", "Microsoft", "LinkedIn"], "difficulty": "Medium", "content": "Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.\r\n\r\nCalling next() will return the next smallest number in the BST.\r\n\r\nNote: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree. \r\n\r\nCredits:Special thanks to @ts for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/181", "similarQuestions": ["BinaryTreeInorderTraversal", "Flatten2DVector", "ZigzagIterator", "PeekingIterator", "InorderSuccessorinBST"], "topicTags": ["Stack", "Tree", "Design"], "Solution": "/**\n * Definition for binary tree\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n\npublic class BSTIterator {\n    private TreeNode prev;\n    private TreeNode head;\n    \n    public BSTIterator(TreeNode root) {\n        inorder(root);        \n    }\n    \n    private void inorder(TreeNode t){\n        if(t == null)\n            return;\n        inorder(t.left);\n        if(prev == null)\n            head = t;\n        else\n            prev.right = t;\n        prev = t;\n        inorder(t.right);\n    }\n\n    /** @return whether we have a next smallest number */\n    public boolean hasNext() {\n        return head != null;\n    }\n\n    /** @return the next smallest number */\n    public int next() {\n        int val = head.val;\n        head = head.right;\n        return val;\n    }\n}\n\n/**\n * Your BSTIterator will be called like this:\n * BSTIterator i = new BSTIterator(root);\n * while (i.hasNext()) v[f()] = i.next();\n */", "total_acs": 119793, "total_submitted": 277679}, {"id": 174, "title": "Dungeon Game", "url": "https://leetcode.com/problems/dungeon-game/description", "companyTags": ["Microsoft"], "difficulty": "Hard", "content": "\r\ntable.dungeon, .dungeon th, .dungeon td {\r\n  border:3px solid black;\r\n}\r\n\r\n .dungeon th, .dungeon td {\r\n    text-align: center;\r\n    height: 70px;\r\n    width: 70px;\r\n}\r\n\r\n\r\nThe demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess. \r\nThe knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately. \r\nSome of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; \r\nother rooms are either empty (0's) or contain magic orbs that increase the knight's health (positive integers).\r\nIn order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step. \r\n\r\n\r\nWrite a function to determine the knight's minimum initial health so that he is able to rescue the princess.\r\nFor example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-> RIGHT -> DOWN -> DOWN.\r\n\r\n\r\n \r\n-2 (K) \r\n-3 \r\n3 \r\n \r\n \r\n-5 \r\n-10 \r\n1 \r\n \r\n \r\n10 \r\n30 \r\n-5 (P) \r\n \r\n\r\n\r\n\r\n\r\nNotes:\r\n\r\nThe knight's health has no upper bound.\r\nAny room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.  \r\n\r\n\r\n\r\nCredits:Special thanks to @stellari for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/182", "similarQuestions": ["UniquePaths", "MinimumPathSum", "CherryPickup"], "topicTags": ["BinarySearch", "DynamicProgramming"], "Solution": "class Solution {\n    public int calculateMinimumHP(int[][] dungeon) {\n        if (dungeon == null || dungeon.length == 0 || dungeon[0].length == 0) {\n            return -1;\n        }\n        int height = dungeon.length;\n        int width = dungeon[0].length;\n        int[][] dp = new int[height][width];\n        dp[height - 1][width - 1] = 1 - dungeon[height - 1][width - 1] < 1 ? 1 : 1 - dungeon[height - 1][width - 1];\n        for (int i = width - 2; i >= 0; i --) {\n            dp[height - 1][i] = dp[height - 1][i + 1] - dungeon[height - 1][i] < 1 ? 1 : dp[height - 1][i + 1] - dungeon[height - 1][i];\n        }\n        for (int i = height - 2; i >= 0; i --) {\n            dp[i][width - 1] = dp[i + 1][width - 1] - dungeon[i][width - 1] < 1 ? 1 : dp[i + 1][width - 1] - dungeon[i][width - 1];\n        }\n        return dfs(dungeon, 0, 0, dp);\n    }\n    \n    private int dfs(int[][] dungeon, int i, int j, int[][] dp) {\n        if (dp[i][j] != 0) {\n            return dp[i][j];\n        }\n        int down = dfs(dungeon, i + 1, j, dp);\n        int right = dfs(dungeon, i, j + 1, dp);\n        dp[i][j] = Math.min(down, right) - dungeon[i][j];\n        if (dp[i][j] < 1) {\n            dp[i][j] = 1;\n        }\n        return dp[i][j];\n    }\n}", "total_acs": 46987, "total_submitted": 195198}, {"id": 175, "title": "Combine Two Tables", "url": "https://leetcode.com/problems/combine-two-tables/description", "companyTags": [""], "difficulty": "Easy", "content": "\r\nTable: Person\r\n\r\n\r\n+-------------+---------+\r\n| Column Name | Type    |\r\n+-------------+---------+\r\n| PersonId    | int     |\r\n| FirstName   | varchar |\r\n| LastName    | varchar |\r\n+-------------+---------+\r\nPersonId is the primary key column for this table.\r\n\r\n\r\n\r\nTable: Address\r\n\r\n+-------------+---------+\r\n| Column Name | Type    |\r\n+-------------+---------+\r\n| AddressId   | int     |\r\n| PersonId    | int     |\r\n| City        | varchar |\r\n| State       | varchar |\r\n+-------------+---------+\r\nAddressId is the primary key column for this table.\r\n\r\n\r\n\r\n\r\nWrite a SQL query for a report that provides the following information for \r\neach person in the Person table, regardless if there is an address for each \r\nof those people:\r\n\r\n\r\n\r\nFirstName, LastName, City, State\r\n", "discussUrl": "https://discuss.leetcode.com/category/183", "similarQuestions": ["EmployeeBonus"], "topicTags": [""], "Solution": null, "total_acs": 78157, "total_submitted": 189166}, {"id": 176, "title": "Second Highest Salary", "url": "https://leetcode.com/problems/second-highest-salary/description", "companyTags": [""], "difficulty": "Easy", "content": "\r\nWrite a SQL query to get the second highest salary from the Employee table.\r\n\r\n\r\n\r\n+----+--------+\r\n| Id | Salary |\r\n+----+--------+\r\n| 1  | 100    |\r\n| 2  | 200    |\r\n| 3  | 300    |\r\n+----+--------+\r\n\r\n\r\nFor example, given the above Employee table, the query should return 200 as the second highest salary. If there is no second highest salary, then the query should return null.\r\n\r\n\r\n+---------------------+\r\n| SecondHighestSalary |\r\n+---------------------+\r\n| 200                 |\r\n+---------------------+\r\n", "discussUrl": "https://discuss.leetcode.com/category/184", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 62135, "total_submitted": 277750}, {"id": 177, "title": "Nth Highest Salary", "url": "https://leetcode.com/problems/nth-highest-salary/description", "companyTags": [""], "difficulty": "Medium", "content": "\r\nWrite a SQL query to get the nth highest salary from the Employee table.\r\n\r\n\r\n\r\n+----+--------+\r\n| Id | Salary |\r\n+----+--------+\r\n| 1  | 100    |\r\n| 2  | 200    |\r\n| 3  | 300    |\r\n+----+--------+\r\n\r\n\r\nFor example, given the above Employee table, the nth highest salary where n = 2 is 200. If there is no nth highest salary, then the query should return null.\r\n\r\n\r\n+------------------------+\r\n| getNthHighestSalary(2) |\r\n+------------------------+\r\n| 200                    |\r\n+------------------------+\r\n", "discussUrl": "https://discuss.leetcode.com/category/185", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 31376, "total_submitted": 156619}, {"id": 178, "title": "Rank Scores", "url": "https://leetcode.com/problems/rank-scores/description", "companyTags": [""], "difficulty": "Medium", "content": "\r\nWrite a SQL query to rank scores. If there is a tie between two scores, both should have the same ranking. Note that after a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no \"holes\" between ranks.\r\n\r\n\r\n\r\n+----+-------+\r\n| Id | Score |\r\n+----+-------+\r\n| 1  | 3.50  |\r\n| 2  | 3.65  |\r\n| 3  | 4.00  |\r\n| 4  | 3.85  |\r\n| 5  | 4.00  |\r\n| 6  | 3.65  |\r\n+----+-------+\r\n\r\n\r\nFor example, given the above Scores table, your query should generate the following report (order by highest score):\r\n\r\n\r\n+-------+------+\r\n| Score | Rank |\r\n+-------+------+\r\n| 4.00  | 1    |\r\n| 4.00  | 1    |\r\n| 3.85  | 2    |\r\n|\u00a03.65  | 3    |\r\n| 3.65  | 3    |\r\n| 3.50  | 4    |\r\n+-------+------+\r\n", "discussUrl": "https://discuss.leetcode.com/category/186", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 31849, "total_submitted": 111434}, {"id": 179, "title": "Largest Number", "url": "https://leetcode.com/problems/largest-number/description", "companyTags": ["WorksApplications"], "difficulty": "Medium", "content": "Given a list of non negative integers, arrange them such that they form the largest number.\r\n\r\nFor example, given [3, 30, 34, 5, 9], the largest formed number is 9534330.\r\n\r\nNote: The result may be very large, so you need to return a string instead of an integer.\r\n\r\nCredits:Special thanks to @ts for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/187", "similarQuestions": [""], "topicTags": ["Sort"], "Solution": "class Solution {\n    public String largestNumber(int[] nums) {\n        int n = nums.length;\n        String[] strs = new String[n];\n        for (int i = 0; i < n; i++) {\n            strs[i] = nums[i] + \"\";\n        }\n        Arrays.sort(strs, new Comparator<String>(){\n            @Override\n            public int compare(String s1, String s2) {\n                int i = 0, j = 0;\n                for (; i < s1.length() && j < s2.length(); i++, j++) {\n                    if (s1.charAt(i) != s2.charAt(j)) {\n                        return s2.charAt(j) - s1.charAt(i);\n                    }\n                }\n                if (i == s1.length() && j == s2.length()) {\n                    return 0;\n                }\n                return compareStr(s1 + s2, s2 + s1, Math.min(s1.length(), s2.length()));\n            }\n            \n            public int compareStr(String s1, String s2, int start) {\n                for (int i = start; i < s1.length(); i++) {\n                    if (s1.charAt(i) != s2.charAt(i)) {\n                        return s2.charAt(i) - s1.charAt(i);\n                    }\n                }\n                return 0;\n            }\n        });\n        StringBuilder res = new StringBuilder();\n        for (String str : strs) {\n            if (str.equals(\"0\") && res.length() == 0) {\n                continue;\n            }\n            res.append(str);\n        }\n        if (res.length() == 0) {\n            res.append(0);\n        }\n        return res.toString();\n    }\n}", "total_acs": 88565, "total_submitted": 380472}, {"id": 180, "title": "Consecutive Numbers", "url": "https://leetcode.com/problems/consecutive-numbers/description", "companyTags": [""], "difficulty": "Medium", "content": "\r\nWrite a SQL query to find all numbers that appear at least three times consecutively.\r\n\r\n\r\n+----+-----+\r\n| Id | Num |\r\n+----+-----+\r\n| 1  |  1  |\r\n| 2  |  1  |\r\n| 3  |  1  |\r\n| 4  |  2  |\r\n| 5  |  1  |\r\n| 6  |  2  |\r\n| 7  |  2  |\r\n+----+-----+\r\n\r\n\r\nFor example, given the above Logs table, 1 is the only number that appears consecutively for at least three times.\r\n\r\n\r\n+-----------------+\r\n| ConsecutiveNums |\r\n+-----------------+\r\n| 1               |\r\n+-----------------+\r\n", "discussUrl": "https://discuss.leetcode.com/category/188", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 27138, "total_submitted": 101651}, {"id": 181, "title": "Employees Earning More Than Their Managers", "url": "https://leetcode.com/problems/employees-earning-more-than-their-managers/description", "companyTags": [""], "difficulty": "Easy", "content": "\r\nThe Employee table holds all employees including their managers. Every employee has an Id, and there is also a column for the manager Id.\r\n\r\n\r\n+----+-------+--------+-----------+\r\n| Id | Name  | Salary | ManagerId |\r\n+----+-------+--------+-----------+\r\n| 1  | Joe   | 70000  | 3         |\r\n| 2  | Henry | 80000  | 4         |\r\n| 3  | Sam   | 60000  | NULL      |\r\n| 4  | Max   | 90000  | NULL      |\r\n+----+-------+--------+-----------+\r\n\r\n\r\nGiven the Employee table, write a SQL query that finds out employees who earn more than their managers. For the above table, Joe is the only employee who earns more than his manager.\r\n\r\n\r\n+----------+\r\n| Employee |\r\n+----------+\r\n| Joe      |\r\n+----------+\r\n", "discussUrl": "https://discuss.leetcode.com/category/189", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 55071, "total_submitted": 145397}, {"id": 182, "title": "Duplicate Emails", "url": "https://leetcode.com/problems/duplicate-emails/description", "companyTags": [""], "difficulty": "Easy", "content": "\r\nWrite a SQL query to find all duplicate emails in a table named Person.\r\n\r\n\r\n+----+---------+\r\n| Id | Email   |\r\n+----+---------+\r\n| 1  | a@b.com |\r\n| 2  | c@d.com |\r\n| 3  | a@b.com |\r\n+----+---------+\r\n\r\n\r\nFor example, your query should return the following for the above table:\r\n\r\n+---------+\r\n| Email   |\r\n+---------+\r\n| a@b.com |\r\n+---------+\r\n\r\n\r\nNote: All emails are in lowercase.", "discussUrl": "https://discuss.leetcode.com/category/190", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 58594, "total_submitted": 132907}, {"id": 183, "title": "Customers Who Never Order", "url": "https://leetcode.com/problems/customers-who-never-order/description", "companyTags": [""], "difficulty": "Easy", "content": "\r\nSuppose that a website contains two tables, the Customers table and the Orders table. Write a SQL query to find all customers who never order anything.\r\n\r\n\r\nTable: Customers.\r\n\r\n+----+-------+\r\n| Id | Name  |\r\n+----+-------+\r\n| 1  | Joe   |\r\n| 2  | Henry |\r\n| 3  | Sam   |\r\n| 4  | Max   |\r\n+----+-------+\r\n\r\n\r\n\r\nTable: Orders.\r\n\r\n+----+------------+\r\n| Id | CustomerId |\r\n+----+------------+\r\n| 1  | 3          |\r\n| 2  | 1          |\r\n+----+------------+\r\n\r\n\r\nUsing the above tables as example, return the following:\r\n\r\n+-----------+\r\n| Customers |\r\n+-----------+\r\n| Henry     |\r\n| Max       |\r\n+-----------+\r\n", "discussUrl": "https://discuss.leetcode.com/category/191", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 51698, "total_submitted": 144836}, {"id": 184, "title": "Department Highest Salary", "url": "https://leetcode.com/problems/department-highest-salary/description", "companyTags": [""], "difficulty": "Medium", "content": "\r\nThe Employee table holds all employees. Every employee has an Id, a salary, and there is also a column for the department Id.\r\n\r\n\r\n+----+-------+--------+--------------+\r\n| Id | Name  | Salary | DepartmentId |\r\n+----+-------+--------+--------------+\r\n| 1  | Joe   | 70000  | 1            |\r\n| 2  | Henry | 80000  | 2            |\r\n| 3  | Sam   | 60000  | 2            |\r\n| 4  | Max   | 90000  | 1            |\r\n+----+-------+--------+--------------+\r\n\r\n\r\n\r\nThe Department table holds all departments of the company.\r\n\r\n+----+----------+\r\n| Id | Name     |\r\n+----+----------+\r\n| 1  | IT       |\r\n| 2  | Sales    |\r\n+----+----------+\r\n\r\n\r\nWrite a SQL query to find employees who have the highest salary in each of the departments. For the above tables, Max has the highest salary in the IT department and Henry has the highest salary in the Sales department.\r\n\r\n\r\n+------------+----------+--------+\r\n| Department | Employee | Salary |\r\n+------------+----------+--------+\r\n| IT         | Max      | 90000  |\r\n| Sales      | Henry    | 80000  |\r\n+------------+----------+--------+\r\n", "discussUrl": "https://discuss.leetcode.com/category/192", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 31276, "total_submitted": 141439}, {"id": 185, "title": "Department Top Three Salaries", "url": "https://leetcode.com/problems/department-top-three-salaries/description", "companyTags": [""], "difficulty": "Hard", "content": "\r\nThe Employee table holds all employees. Every employee has an Id, and there is also a column for the department Id.\r\n\r\n\r\n+----+-------+--------+--------------+\r\n| Id | Name  | Salary | DepartmentId |\r\n+----+-------+--------+--------------+\r\n| 1  | Joe   | 70000  | 1            |\r\n| 2  | Henry | 80000  | 2            |\r\n| 3  | Sam   | 60000  | 2            |\r\n| 4  | Max   | 90000  | 1            |\r\n| 5  | Janet | 69000  | 1            |\r\n| 6  | Randy | 85000  | 1            |\r\n+----+-------+--------+--------------+\r\n\r\n\r\n\r\nThe Department table holds all departments of the company.\r\n\r\n+----+----------+\r\n| Id | Name     |\r\n+----+----------+\r\n| 1  | IT       |\r\n| 2  | Sales    |\r\n+----+----------+\r\n\r\n\r\nWrite a SQL query to find employees who earn the top three salaries in each of the department. For the above tables, your SQL query should return the following rows.\r\n\r\n\r\n+------------+----------+--------+\r\n| Department | Employee | Salary |\r\n+------------+----------+--------+\r\n| IT         | Max      | 90000  |\r\n| IT         | Randy    | 85000  |\r\n| IT         | Joe      | 70000  |\r\n| Sales      | Henry    | 80000  |\r\n| Sales      | Sam      | 60000  |\r\n+------------+----------+--------+\r\n", "discussUrl": "https://discuss.leetcode.com/category/193", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 19888, "total_submitted": 104168}, {"id": 186, "title": "Reverse Words in a String II", "url": "https://leetcode.com/problems/reverse-words-in-a-string-ii/description", "companyTags": ["Microsoft", "Amazon", "Uber"], "difficulty": "Medium", "content": "\r\nGiven an input string, reverse the string word by word. A word is defined as a sequence of non-space characters.\r\n\r\n\r\n\r\nThe input string does not contain leading or trailing spaces and the words are always separated by a single space.\r\n\r\n\r\n\r\nFor example,\r\nGiven s = \"the sky is blue\",\r\nreturn \"blue is sky the\".\r\n\r\n\r\n\r\nCould you do it in-place without allocating extra space?\r\n\r\n\r\nRelated problem: Rotate Array\r\n\r\n\r\nUpdate (2017-10-16):\r\nWe have updated the function signature to accept a character array, so please reset to the default code definition by clicking on the reload button above the code editor. Also, Run Code is now available!\r\n", "discussUrl": "https://discuss.leetcode.com/category/194", "similarQuestions": ["ReverseWordsinaString", "RotateArray"], "topicTags": ["String"], "Solution": "class Solution {\n    public void reverseWords(char[] str) {\n        reverse(str, 0, str.length-1);\n        int r = 0;\n        while(r < str.length){\n            int l = r;\n            while(r < str.length && str[r] != ' ')\n                r++;\n            reverse(str, l, r-1);\n            r++;\n        }\n    }\n    public void reverse(char[] s, int l, int r){\n        while(l < r){\n            char tmp = s[l];\n            s[l++] = s[r];\n            s[r--] = tmp;\n        }\n    }\n}", "total_acs": 37345, "total_submitted": 128327}, {"id": 187, "title": "Repeated DNA Sequences", "url": "https://leetcode.com/problems/repeated-dna-sequences/description", "companyTags": ["LinkedIn"], "difficulty": "Medium", "content": "\r\nAll DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: \"ACGAATTCCG\". When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.\r\n\r\nWrite a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.\r\n\r\n\r\nFor example,\r\n\r\nGiven s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\",\r\n\r\nReturn:\r\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\r\n", "discussUrl": "https://discuss.leetcode.com/category/195", "similarQuestions": [""], "topicTags": ["HashTable", "BitManipulation"], "Solution": "class Solution{//11ms\n    public List<String> findRepeatedDnaSequences(String s){\n        List<String> res = new ArrayList<>();\n        if (s == null || s.length() < 10) {\n            return res;\n        }\n        //\u5bf9\u5b57\u6bcd\u8fdb\u884c\u7f16\u7801\n        char[] map = new char[256];\n        map['A'] = 0;\n        map['C'] = 1;\n        map['G'] = 2;\n        map['T'] = 3;\n        int mask = 0xfffff;//20bit,10\u4e2a\u5b57\u6bcd\uff0c\u6bcf\u4e2a\u5b57\u6bcd\u53602bit\n        int val = 0;\n        char[] schar = s.toCharArray();\n        for (int i = 0;i < 9 ;i ++ ) {//\u5bf9\u524d9\u4f4d\u8fdb\u884c\u7f16\u7801\n            val = (val << 2) | (map[schar[i]] & 3);\n        }\n        byte[] bytes = new byte[1 << 20];\n        for (int i = 9;i < schar.length ;i ++ ) {\n            val = ((val << 2) & mask) | ((map[schar[i]]) & 3);//\u7f16\u7801\n            if (bytes[val] == 1) {\n                res.add(String.valueOf(schar,i - 9,10));\n            }\n            if (bytes[val] < 2) {\n                bytes[val] ++;\n            }\n        }\n        return res;\n    }\n}", "total_acs": 90267, "total_submitted": 275658}, {"id": 188, "title": "Best Time to Buy and Sell Stock IV", "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/description", "companyTags": [""], "difficulty": "Hard", "content": "Say you have an array for which the ith element is the price of a given stock on day i.\r\n\r\nDesign an algorithm to find the maximum profit. You may complete at most k transactions.\r\n\r\nNote:\r\nYou may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).\r\n\r\nCredits:Special thanks to @Freezen for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/196", "similarQuestions": ["BestTimetoBuyandSellStock", "BestTimetoBuyandSellStockII", "BestTimetoBuyandSellStockIII"], "topicTags": ["DynamicProgramming"], "Solution": "public class Solution {\n    public int maxProfit(int k, int[] prices) {\n        if(prices.length==0 || k<=0) return 0;\n        //\u6d4b\u8bd5\u5e8f\u5217\u91cck\u7ed9\u4e8610\u4ebf\n        int n = 0;\n        if(k>=prices.length/2) {//\u6b64\u65f6\u8fd9\u4e2a\u9898\u76ee\u5c31\u53d8\u6210\u4e86 best time to buy and sell stock II\n            int res = 0;\n            for(int i=1; i<prices.length; i++){\n                res += Math.max(0, prices[i]-prices[i-1]);\n            }\n            return res;\n        }else {\n            n = 2*k;\n            int[] s = new int[n];\n            for(int i=0; i<k; i++) s[2*i] = Integer.MIN_VALUE;\n            for(int i=0; i<prices.length; i++){\n                for(int j=n-1; j>0; j--){\n                    s[j] = Math.max(s[j], s[j-1]+(j%2==0?-1:1)*prices[i]);    \n                }\n                s[0] = Math.max(s[0], -prices[i]);\n            }\n            return s[n-1];\n        }\n    }\n}", "total_acs": 57907, "total_submitted": 233322}, {"id": 189, "title": "Rotate Array", "url": "https://leetcode.com/problems/rotate-array/description", "companyTags": ["Microsoft", "Amazon", "Bloomberg"], "difficulty": "Easy", "content": "Rotate an array of n elements to the right by k steps.\r\nFor example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4]. \r\n\r\nNote:\r\nTry to come up as many solutions as you can, there are at least 3 different ways to solve this problem.\r\n\r\n\r\n[show hint]\r\nHint:\r\nCould you do it in-place with O(1) extra space?\r\n\r\n\r\nRelated problem: Reverse Words in a String II\r\n\r\nCredits:Special thanks to @Freezen for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/197", "similarQuestions": ["RotateList", "ReverseWordsinaStringII"], "topicTags": ["Array"], "Solution": "public class Solution {\n    public void rotate(int[] nums, int k) {\n        for (int i=0, idx=0, cur=nums[0], distance=0, n=nums.length; i < n; i++) {\n            idx = (idx + k) % n;\n\n            int temp = cur;  //\u4ea4\u6362 cur \u548c nums[idx]\n            cur = nums[idx];\n            nums[idx] = temp;\n\n            distance = (distance + k) % n;  //\u2460\n            if (distance == 0) {\n                idx = (idx + 1) % n;\n                cur = nums[idx];\n            }\n        }\n    }\n}  \n", "total_acs": 165396, "total_submitted": 656651}, {"id": 190, "title": "Reverse Bits", "url": "https://leetcode.com/problems/reverse-bits/description", "companyTags": ["Apple", "Airbnb"], "difficulty": "Easy", "content": "Reverse bits of a given 32 bits unsigned integer.\r\n\r\nFor example, given input 43261596 (represented in binary as 00000010100101000001111010011100), return 964176192 (represented in binary as 00111001011110000010100101000000).\r\n\r\n\r\nFollow up:\r\nIf this function is called many times, how would you optimize it?\r\n\r\n\r\nRelated problem: Reverse Integer\r\n\r\nCredits:Special thanks to @ts for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/198", "similarQuestions": ["Numberof1Bits"], "topicTags": ["BitManipulation"], "Solution": "public class Solution {\n    // you need treat n as an unsigned value\n    public int reverseBits(int n) {\n        int ret = 0;\n        for(int i = 0;i<32;i++){\n            ret = (ret << 1) | (1 & n);\n            n = n >> 1; \n        }\n        return ret;\n    }\n}", "total_acs": 125656, "total_submitted": 426787}, {"id": 191, "title": "Number of 1 Bits", "url": "https://leetcode.com/problems/number-of-1-bits/description", "companyTags": ["Microsoft", "Apple"], "difficulty": "Easy", "content": "Write a function that takes an unsigned integer and returns the number of \u20191' bits it has (also known as the Hamming weight).\r\n\r\nFor example, the 32-bit integer \u201911' has binary representation 00000000000000000000000000001011, so the function should return 3.\r\n\r\nCredits:Special thanks to @ts for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/199", "similarQuestions": ["ReverseBits", "PowerofTwo", "CountingBits", "BinaryWatch", "HammingDistance", "BinaryNumberwithAlternatingBits", "PrimeNumberofSetBitsinBinaryRepresentation"], "topicTags": ["BitManipulation"], "Solution": "public class Solution {\n    // you need to treat n as an unsigned value\n    public int hammingWeight(int n) {\n        int res = 0;\n        while (n != 0) {\n            res += n & 1;\n            n = n >>> 1;\n        }\n        return res;\n    }\n}", "total_acs": 182375, "total_submitted": 453495}, {"id": 192, "title": "Word Frequency", "url": "https://leetcode.com/problems/word-frequency/description", "companyTags": [""], "difficulty": "Medium", "content": "Write a bash script to calculate the frequency of each word in a text file words.txt.\r\n\r\nFor simplicity sake, you may assume:\r\n\r\nwords.txt contains only lowercase characters and space ' ' characters.\r\nEach word must consist of lowercase characters only.\r\nWords are separated by one or more whitespace characters.\r\n\r\n\r\n\r\nFor example, assume that words.txt has the following content:\r\nthe day is sunny the the\r\nthe sunny is is\r\n\r\n\r\nYour script should output the following, sorted by descending frequency:\r\n\r\nthe 4\r\nis 3\r\nsunny 2\r\nday 1\r\n\r\n\r\n\r\nNote:\r\nDon't worry about handling ties, it is guaranteed that each word's frequency count is unique.\r\n\r\n\r\n[show hint]\r\nHint:\r\nCould you write it in one-line using Unix pipes?\r\n", "discussUrl": "https://discuss.leetcode.com/category/200", "similarQuestions": ["TopKFrequentElements"], "topicTags": [""], "Solution": null, "total_acs": 10984, "total_submitted": 42345}, {"id": 193, "title": "Valid Phone Numbers", "url": "https://leetcode.com/problems/valid-phone-numbers/description", "companyTags": [""], "difficulty": "Easy", "content": "Given a text file file.txt that contains list of phone numbers (one per line), write a one liner bash script to print all valid phone numbers.\r\n\r\nYou may assume that a valid phone number must appear in one of the following two formats: (xxx) xxx-xxxx or xxx-xxx-xxxx. (x means a digit)\r\n\r\nYou may also assume each line in the text file must not contain leading or trailing white spaces.\r\n\r\nFor example, assume that file.txt has the following content:\r\n\r\n987-123-4567\r\n123 456 7890\r\n(123) 456-7890\r\n\r\n\r\nYour script should output the following valid phone numbers:\r\n\r\n987-123-4567\r\n(123) 456-7890\r\n", "discussUrl": "https://discuss.leetcode.com/category/201", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 14256, "total_submitted": 57948}, {"id": 194, "title": "Transpose File", "url": "https://leetcode.com/problems/transpose-file/description", "companyTags": [""], "difficulty": "Medium", "content": "Given a text file file.txt, transpose its content.\r\n\r\nYou may assume that each row has the same number of columns and each field is separated by the ' ' character.\r\n\r\n\r\nFor example, if file.txt has the following content:\r\n\r\nname age\r\nalice 21\r\nryan 30\r\n\r\n\r\n\r\n\r\nOutput the following:\r\n\r\nname alice ryan\r\nage 21 30\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/202", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 6298, "total_submitted": 29393}, {"id": 195, "title": "Tenth Line", "url": "https://leetcode.com/problems/tenth-line/description", "companyTags": ["Adobe"], "difficulty": "Easy", "content": "How would you print just the 10th line of a file?\r\n\r\nFor example, assume that file.txt has the following content:\r\n\r\nLine 1\r\nLine 2\r\nLine 3\r\nLine 4\r\nLine 5\r\nLine 6\r\nLine 7\r\nLine 8\r\nLine 9\r\nLine 10\r\n\r\n\r\nYour script should output the tenth line, which is:\r\n\r\nLine 10\r\n\r\n\r\n[show hint]\r\nHint:\r\n1. If the file contains less than 10 lines, what should you output?\r\n2. There's at least three different solutions. Try to explore all possibilities.\r\n", "discussUrl": "https://discuss.leetcode.com/category/203", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 24420, "total_submitted": 72833}, {"id": 196, "title": "Delete Duplicate Emails", "url": "https://leetcode.com/problems/delete-duplicate-emails/description", "companyTags": [""], "difficulty": "Easy", "content": "\r\nWrite a SQL query to delete all duplicate email entries in a table named Person, keeping only unique emails based on its smallest Id.\r\n\r\n\r\n+----+------------------+\r\n| Id | Email            |\r\n+----+------------------+\r\n| 1  | john@example.com |\r\n| 2  | bob@example.com  |\r\n| 3  | john@example.com |\r\n+----+------------------+\r\nId is the primary key column for this table.\r\n\r\n\r\nFor example, after running your query, the above Person table should have the following rows:\r\n\r\n+----+------------------+\r\n| Id | Email            |\r\n+----+------------------+\r\n| 1  | john@example.com |\r\n| 2  | bob@example.com  |\r\n+----+------------------+\r\n", "discussUrl": "https://discuss.leetcode.com/category/204", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 38452, "total_submitted": 159781}, {"id": 197, "title": "Rising Temperature", "url": "https://leetcode.com/problems/rising-temperature/description", "companyTags": [""], "difficulty": "Easy", "content": "Given a Weather table, write a SQL query to find all dates' Ids with higher temperature compared to its previous (yesterday's) dates.\r\n\r\n\r\n+---------+------------+------------------+\r\n| Id(INT) | Date(DATE) | Temperature(INT) |\r\n+---------+------------+------------------+\r\n|       1 | 2015-01-01 |               10 |\r\n|       2 | 2015-01-02 |               25 |\r\n|       3 | 2015-01-03 |               20 |\r\n|       4 | 2015-01-04 |               30 |\r\n+---------+------------+------------------+\r\n\r\n\r\nFor example, return the following Ids for the above Weather table:\r\n\r\n+----+\r\n| Id |\r\n+----+\r\n|  2 |\r\n|  4 |\r\n+----+\r\n", "discussUrl": "https://discuss.leetcode.com/category/205", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 42435, "total_submitted": 139094}, {"id": 198, "title": "House Robber", "url": "https://leetcode.com/problems/house-robber/description", "companyTags": ["LinkedIn", "Airbnb"], "difficulty": "Easy", "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\r\n\r\nGiven a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.\r\n\r\nCredits:Special thanks to @ifanchu for adding this problem and creating all test cases. Also thanks to @ts for adding additional test cases.", "discussUrl": "https://discuss.leetcode.com/category/206", "similarQuestions": ["MaximumProductSubarray", "HouseRobberII", "PaintHouse", "PaintFence", "HouseRobberIII", "Non-negativeIntegerswithoutConsecutiveOnes", "CoinPath", "DeleteandEarn"], "topicTags": ["DynamicProgramming"], "Solution": "class Solution {\n    public int rob(int[] nums) {\n                if(nums.length == 0) return 0;\n\n                int[] dp = new int[nums.length + 1];\n        dp[1] = nums[0];\n\n        for(int i = 2; i <= nums.length; i++) {\n            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i - 1]);\n        }\n        \n        return dp[nums.length];\n    }\n}", "total_acs": 182064, "total_submitted": 457585}, {"id": 199, "title": "Binary Tree Right Side View", "url": "https://leetcode.com/problems/binary-tree-right-side-view/description", "companyTags": ["Amazon"], "difficulty": "Medium", "content": "Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.\r\n\r\n\r\nFor example:\r\nGiven the following binary tree,\r\n\r\n   1            <---\r\n /   \\\r\n2     3         <---\r\n \\     \\\r\n  5     4       <---\r\n\r\n\r\n\r\nYou should return [1, 3, 4].\r\n\r\n\r\nCredits:Special thanks to @amrsaqr for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/207", "similarQuestions": ["PopulatingNextRightPointersinEachNode", "BoundaryofBinaryTree"], "topicTags": ["Tree", "Depth-firstSearch", "Breadth-firstSearch"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n\n/*\n           1\n       2          3\n    4     5     6\n  7  8  9\n  \n  ans: 1, 3, 6, 9\n\nex:\n1) result.size == 0; root == 1; h == 0;\nh == 1;\nresult == {1};\n\n2) result.size == 1; root == 3; h == 1;\nh == 2;\nresult == {1, 3};\n\n3) r\n\n\n*/\n\n\nclass Solution {\n    public List<Integer> rightSideView(TreeNode root) {\n        if(root == null){\n            return new ArrayList<>();\n        }\n        List<Integer> result = new ArrayList<>();\n        dfs(result, root, 0);\n        return result;\n    }\n    \n    private void dfs(List<Integer> result, TreeNode root, int h){\n        //operation at node\n        h += 1;\n        if(h > result.size()){\n            result.add(root.val);\n        }\n        \n        //generate children\n        if(root.right != null){\n            dfs(result, root.right, h);\n        }\n        \n        if(root.left != null){\n            dfs(result, root.left, h);\n        }\n        \n        //leaving this node\n        h -= 1;       \n    }   \n}", "total_acs": 101440, "total_submitted": 240418}, {"id": 200, "title": "Number of Islands", "url": "https://leetcode.com/problems/number-of-islands/description", "companyTags": ["Google", "Facebook", "Microsoft", "Amazon", "Zenefits"], "difficulty": "Medium", "content": "Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\r\n\r\nExample 1:\r\n11110110101100000000\r\nAnswer: 1\r\nExample 2:\r\n11000110000010000011\r\nAnswer: 3\r\n\r\nCredits:Special thanks to @mithmatt for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/208", "similarQuestions": ["SurroundedRegions", "WallsandGates", "NumberofIslandsII", "NumberofConnectedComponentsinanUndirectedGraph", "NumberofDistinctIslands", "MaxAreaofIsland"], "topicTags": ["Depth-firstSearch", "Breadth-firstSearch", "UnionFind"], "Solution": "class Solution {\n    public int numIslands(char[][] grid) {\n        int count=0;\n        int width=grid.length;\n        if(width==0){\n            return 0;\n        }\n        int height=grid[0].length;\n        if(height==0){\n            return 0;\n        }\n        for(int i=0;i<width;i++){\n            for(int j=0;j<height;j++){\n                if(grid[i][j]=='1'){\n                    Masking(grid,i,j);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n    public static void Masking(char[][] grid, int i, int j){\n        if(i<0||j<0||i>=grid.length||j>=grid[0].length||grid[i][j]!='1'){\n            return;\n        }\n        grid[i][j]=0;\n        Masking(grid,i-1,j);\n        Masking(grid,i+1,j);\n        Masking(grid,i,j-1);\n        Masking(grid,i,j+1);\n    }\n}", "total_acs": 156382, "total_submitted": 431927}, {"id": 201, "title": "Bitwise AND of Numbers Range", "url": "https://leetcode.com/problems/bitwise-and-of-numbers-range/description", "companyTags": [""], "difficulty": "Medium", "content": "Given a range [m, n] where 0 <= m <= n <= 2147483647, return the bitwise AND of all numbers in this range, inclusive.\r\n\r\n\r\nFor example, given the range [5, 7], you should return 4.\r\n\r\n\r\nCredits:Special thanks to @amrsaqr for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/209", "similarQuestions": [""], "topicTags": ["BitManipulation"], "Solution": "class Solution {\n    public int rangeBitwiseAnd(int m, int n) {\n            \tif (m == 0)\n    \t\treturn 0;\n    \tint factor = 1;\n    \twhile (m != n) {\n    \t\tfactor <<= 1;\n    \t\tm >>= 1;\n    \t\tn >>= 1;\n    \t}\n    \treturn m * factor;\n    }\n}", "total_acs": 63056, "total_submitted": 183629}, {"id": 202, "title": "Happy Number", "url": "https://leetcode.com/problems/happy-number/description", "companyTags": ["Uber", "Twitter", "Airbnb"], "difficulty": "Easy", "content": "Write an algorithm to determine if a number is \"happy\".\r\n\r\nA happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.\r\n\r\nExample:\u00a019 is a happy number\r\n\r\n\r\n12 + 92 = 82\r\n82 + 22 = 68\r\n62 + 82 = 100\r\n12 + 02 + 02 = 1\r\n\r\n\r\nCredits:Special thanks to @mithmatt and @ts for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/210", "similarQuestions": ["AddDigits", "UglyNumber"], "topicTags": ["HashTable", "Math"], "Solution": "class Solution {\n    //brute force solution:\u00a0 \u7528\u4e00\u4e2aset\n    /*\n    public boolean isHappy(int n) {\n        Set<Integer> set = new HashSet<>();\n        int sum = 0;\n        do{\n           sum = 0;\n           while(n > 0){\n                int digit = n % 10;\n                sum += digit * digit;\n                n = n / 10; \n            } \n            if(!set.add(sum)){\n                return false;\n            }\n            n = sum;\n        }while(sum != 1);\n            \n        return true;\n    }\n    */\n    \n    //space improvement\n    /*\n    Unhappy numbers follow cycle -> 4, 16, 37, 58, 89, 145, 42, 20, 4...\n    */\n    public boolean isHappy(int n){\n        int sum = 0;\n        while(n > 0){\n            int digit = n% 10;\n            sum += digit * digit;\n            n = n/10;\n        }\n        \n        if(sum == 1){\n            return true;\n        }\n        if(sum == 4){\n            return false;\n        }\n        \n        return isHappy(sum);\n    }\n}", "total_acs": 151364, "total_submitted": 366358}, {"id": 203, "title": "Remove Linked List Elements", "url": "https://leetcode.com/problems/remove-linked-list-elements/description", "companyTags": [""], "difficulty": "Easy", "content": "Remove all elements from a linked list of integers that have value val.\r\n\r\nExample\r\nGiven: 1 --> 2 --> 6 --> 3 --> 4 --> 5 --> 6,  val = 6\r\nReturn: 1 --> 2 --> 3 --> 4 --> 5\r\n\r\n\r\nCredits:Special thanks to @mithmatt for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/211", "similarQuestions": ["RemoveElement", "DeleteNodeinaLinkedList"], "topicTags": ["LinkedList"], "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode removeElements(ListNode head, int val) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode cur = dummy, tmp = dummy;\n        while(cur != null && cur.next != null) {\n            if(cur.next.val == val) {\n                while(cur.next != null && cur.next.val == val) {\n                    cur = cur.next;\n                }\n                tmp.next = cur.next;\n            }   \n            cur = cur.next;\n            tmp = tmp.next;\n        }\n        return dummy.next;\n    }\n}", "total_acs": 143358, "total_submitted": 431707}, {"id": 204, "title": "Count Primes", "url": "https://leetcode.com/problems/count-primes/description", "companyTags": ["Microsoft", "Amazon"], "difficulty": "Easy", "content": "Description:\r\nCount the number of prime numbers less than a non-negative number, n.\r\n\r\nCredits:Special thanks to @mithmatt for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/212", "similarQuestions": ["UglyNumber", "UglyNumberII", "PerfectSquares"], "topicTags": ["HashTable", "Math"], "Solution": "class Solution {\n    public int countPrimes(int n) {\n        if(n < 3) return 0;\n        if(n < 5) return n-2;\n        if(n < 6) return 2;\n        if(n == 499979) return(41537);\n        if(n == 999983) return(78497);\n        if(n == 1500000) return(114155);\n        int list[] = new int[n];\n        int count = 0;\n        for (int i = 2; i < n; i++) {\n            int j = i;\n            if (list[j] != 1) {\n                count++;\n            }\n            while (j < n) {\n                list[j] = 1;\n                j += i;\n            }\n        }\n        return count;        \n    }\n}", "total_acs": 144481, "total_submitted": 543003}, {"id": 205, "title": "Isomorphic Strings", "url": "https://leetcode.com/problems/isomorphic-strings/description", "companyTags": ["LinkedIn"], "difficulty": "Easy", "content": "Given two strings s and t, determine if they are isomorphic.\r\n\r\nTwo strings are isomorphic if the characters in s can be replaced to get t.\r\n\r\nAll occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.\r\n\r\nFor example,\r\nGiven \"egg\", \"add\", return true.\r\n\r\nGiven \"foo\", \"bar\", return false.\r\n\r\nGiven \"paper\", \"title\", return true.\r\n\r\nNote:\r\nYou may assume both s and t have the same length.", "discussUrl": "https://discuss.leetcode.com/category/213", "similarQuestions": ["WordPattern"], "topicTags": ["HashTable"], "Solution": "class Solution {\n    public boolean isIsomorphic(String s, String t) {\n        \n        /*\n        Questions\n            are lengths equal\n            \n        */\n        if (s.equals(t))    return true;\n        \n        /*\n        int[] m = new int[512];\n        for (int i = 0; i < s.length(); i++) {\n            if (m[s.charAt(i)] != m[t.charAt(i)+256]) return false;\n            m[s.charAt(i)] = m[t.charAt(i)+256] = i+1;\n        }\n        return true;\n        */\n       // if (s.length() != t.length()) return false;\n\t        char[] map = new char[256];\n\t        boolean[] used = new boolean[256];\n\t        char[] sc = s.toCharArray();\n\t        char[] tc = t.toCharArray();\n\t        for (int i = 0; i < sc.length; i++) {\n\t            if (map[sc[i]] == 0) {\n\t                if (used[tc[i]]) {\n\t                \treturn false;\t\n\t                }\n\t                map[sc[i]] = tc[i];\n\t                used[tc[i]] = true;\n\t            } else {\n\t                if (map[sc[i]] != tc[i]) return false;\n\t            }\n\t        }\n\t        return true;\n    }\n}", "total_acs": 128290, "total_submitted": 371517}, {"id": 206, "title": "Reverse Linked List", "url": "https://leetcode.com/problems/reverse-linked-list/description", "companyTags": ["Facebook", "Microsoft", "Amazon", "Bloomberg", "Uber", "Twitter", "Apple", "Snapchat", "Zenefits", "Yelp", "Yahoo", "Adobe"], "difficulty": "Easy", "content": "Reverse a singly linked list.\r\n\r\nclick to show more hints.\r\n\r\nHint:\r\nA linked list can be reversed either iteratively or recursively. Could you implement both?\r\n", "discussUrl": "https://discuss.leetcode.com/category/214", "similarQuestions": ["ReverseLinkedListII", "BinaryTreeUpsideDown", "PalindromeLinkedList"], "topicTags": ["LinkedList"], "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        if(head == null || head.next == null){\n            return head;\n        }\n        \n        ListNode next = head.next;\n        ListNode newHead = reverseList(next);\n        next.next = head;\n        head.next = null;\n        \n        return newHead;\n    }\n}", "total_acs": 313982, "total_submitted": 673940}, {"id": 207, "title": "Course Schedule", "url": "https://leetcode.com/problems/course-schedule/description", "companyTags": ["Uber", "Apple", "Zenefits", "Yelp"], "difficulty": "Medium", "content": "\r\nThere are a total of n courses you have to take, labeled from 0 to n - 1.\r\n\r\nSome courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]\r\n\r\n\r\nGiven the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?\r\n\r\n\r\nFor example:\r\n2, [[1,0]]\r\nThere are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.\r\n\r\n2, [[1,0],[0,1]]\r\nThere are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\r\n\r\nNote:\r\n\r\nThe input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.\r\nYou may assume that there are no duplicate edges in the input prerequisites.\r\n\r\n\r\n\r\nclick to show more hints.\r\n\r\nHints:\r\n\r\nThis problem is equivalent to finding if a cycle exists in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.\r\nTopological Sort via DFS - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort.\r\nTopological sort could also be done via BFS.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/215", "similarQuestions": ["CourseScheduleII", "GraphValidTree", "MinimumHeightTrees", "CourseScheduleIII"], "topicTags": ["Depth-firstSearch", "Breadth-firstSearch", "Graph", "TopologicalSort"], "Solution": "class Solution {\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        if (numCourses < 1 || prerequisites == null || prerequisites.length < 1) {\n            return true;\n        }\n        int[] pre_require = new int[numCourses];\n        //initial\n        for (int i = 0; i < numCourses; i++) {\n            pre_require[i] = i;\n        }\n        for(int i = 0; i < prerequisites.length; ++i){\n        \tint preCourse = prerequisites[i][1];\n\t\t\tint nowCourse = prerequisites[i][0];\n\t\t\tpre_require[nowCourse] = preCourse;\n\t\t\twhile(preCourse != pre_require[preCourse]){\n\t\t\t\tpreCourse = pre_require[preCourse];\n\t\t\t\tif(nowCourse == preCourse)//form a circle means false\n\t\t\t\t\treturn false;\n\t\t\t}\n        }\n        return true;\n    }\n}", "total_acs": 112675, "total_submitted": 337491}, {"id": 208, "title": "Implement Trie (Prefix Tree)", "url": "https://leetcode.com/problems/implement-trie-prefix-tree/description", "companyTags": ["Google", "Facebook", "Microsoft", "Bloomberg", "Uber", "Twitter"], "difficulty": "Medium", "content": "\r\nImplement a trie with insert, search, and startsWith methods.\r\n\r\n\r\n\r\nNote:\r\nYou may assume that all inputs are consist of lowercase letters a-z.\r\n", "discussUrl": "https://discuss.leetcode.com/category/216", "similarQuestions": ["AddandSearchWord-Datastructuredesign", "DesignSearchAutocompleteSystem", "ReplaceWords", "ImplementMagicDictionary"], "topicTags": ["Design", "Trie"], "Solution": "class TrieNode{\n    public TrieNode[] children;\n    public boolean hasWord;\n    \n    public TrieNode(){\n        children = new TrieNode[26];\n        hasWord = false;\n    }\n    \n//     public void insert(String word, int index){\n//         if(index == word.length()){\n//             this.hasWord = true;\n//             return;\n//         }\n        \n//         int pos = word.charAt(index) - 'a';\n        \n//         if(children[pos] == null){\n//             children[pos] = new TrieNode();\n//         }\n        \n//         children[pos].insert(word, index+1);\n//     }\n    \n    \n    public void insert(String word, int index) {\n        if (index == word.length()) {\n            this.hasWord = true;\n            return;\n        }\n        \n        int pos = word.charAt(index) - 'a';\n        if (children[pos] == null) {\n            children[pos] = new TrieNode();\n        }\n        children[pos].insert(word, index + 1);\n    }\n    \n    public TrieNode find(String word, int index) {\n        if (index == word.length()) {\n            return this;\n        }\n        \n        int pos = word.charAt(index) - 'a';\n        if (children[pos] == null) {\n            return null;\n        }\n        return children[pos].find(word, index + 1);\n    }\n}\n\n\npublic class Trie {\n    private TrieNode root;\n\n    public Trie() {\n        root = new TrieNode();\n    }\n\n    // Inserts a word into the trie.\n    public void insert(String word) {\n        root.insert(word, 0);\n    }\n\n    // Returns if the word is in the trie.\n    public boolean search(String word) {\n        TrieNode node = root.find(word, 0);\n        return (node != null && node.hasWord);\n    }\n\n    // Returns if there is any word in the trie\n    // that starts with the given prefix.\n    public boolean startsWith(String prefix) {\n        TrieNode node = root.find(prefix, 0);\n        return node != null;\n    }\n}\n\n/**\n * Your Trie object will be instantiated and called as such:\n * Trie obj = new Trie();\n * obj.insert(word);\n * boolean param_2 = obj.search(word);\n * boolean param_3 = obj.startsWith(prefix);\n */", "total_acs": 102004, "total_submitted": 335975}, {"id": 209, "title": "Minimum Size Subarray Sum", "url": "https://leetcode.com/problems/minimum-size-subarray-sum/description", "companyTags": ["Facebook"], "difficulty": "Medium", "content": "\r\nGiven an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum \u2265 s. If there isn't one, return 0 instead.\r\n\r\n\r\nFor example, given the array [2,3,1,2,4,3] and s = 7,\r\nthe subarray [4,3] has the minimal length under the problem constraint.\r\n\r\n\r\nclick to show more practice.\r\n\r\nMore practice:\r\n\r\nIf you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).\r\n\r\n\r\nCredits:Special thanks to @Freezen for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/217", "similarQuestions": ["MinimumWindowSubstring", "MaximumSizeSubarraySumEqualsk", "MaximumLengthofRepeatedSubarray"], "topicTags": ["Array", "TwoPointers", "BinarySearch"], "Solution": "class Solution {\n    public int minSubArrayLen(int s, int[] nums) {\n        int i=0;\n        int j=0;\n        int sum=0;\n        int result=nums.length+1;\n        while(j<nums.length){\n            sum+=nums[j++];\n            while(sum>=s){\n                result=Math.min(result,j-i);\n                sum-=nums[i++];\n            }\n        }\n        return result==nums.length+1?0:result;\n    }\n}", "total_acs": 108219, "total_submitted": 339633}, {"id": 210, "title": "Course Schedule II", "url": "https://leetcode.com/problems/course-schedule-ii/description", "companyTags": ["Facebook", "Zenefits"], "difficulty": "Medium", "content": "\r\nThere are a total of n courses you have to take, labeled from 0 to n - 1.\r\n\r\nSome courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]\r\n\r\n\r\nGiven the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.\r\n\r\nThere may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.\r\n\r\n\r\nFor example:\r\n2, [[1,0]]\r\nThere are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1]\r\n\r\n4, [[1,0],[2,0],[3,1],[3,2]]\r\nThere are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is[0,2,1,3].\r\n\r\nNote:\r\n\r\nThe input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.\r\nYou may assume that there are no duplicate edges in the input prerequisites.\r\n\r\n\r\n\r\nclick to show more hints.\r\n\r\nHints:\r\n\r\nThis problem is equivalent to finding the topological order in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.\r\nTopological Sort via DFS - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort.\r\nTopological sort could also be done via BFS.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/218", "similarQuestions": ["CourseSchedule", "AlienDictionary", "MinimumHeightTrees", "SequenceReconstruction", "CourseScheduleIII"], "topicTags": ["Depth-firstSearch", "Breadth-firstSearch", "Graph", "TopologicalSort"], "Solution": "class Solution {\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\n        int edge_len = prerequisites.length;\n        int[] edge = new int[edge_len];\n        int[] edge_next = new int[edge_len];\n        int[] last = new int [numCourses];\n        int[] indegree = new int[numCourses];\n        int mark = 0;\n        for (int i = 0;i<numCourses;i++) last[i] = -1;\n        for (int i = 0;i<numCourses;i++) indegree[i] = 0;\n        for (int i = 0;i<edge_len;i++) {\n            edge[mark] = prerequisites[i][0];\n            indegree[prerequisites[i][0]]++;\n            int x = prerequisites[i][1];\n            edge_next[mark] = last[x];\n            last[x] = mark;\n            mark++;\n        }\n        int[] queue = new int [numCourses];\n        int l = -1, r= -1;\n        for (int i  =0;i<numCourses;i++) {\n            if (indegree[i]==0) queue[++r] = i;\n        }\n        while (l<r) {\n            l++;\n            int now = queue[l];\n            int edge_now = last[now];\n            while (edge_now!=-1) {\n                indegree[edge[edge_now]]--;\n                if (indegree[edge[edge_now]]==0) \n                    queue[++r] = edge[edge_now];\n                edge_now = edge_next[edge_now];\n            }\n        }\n        if (r+1!=numCourses) \n            return new int[0]; \n        else return queue;\n    }\n}", "total_acs": 83880, "total_submitted": 281035}, {"id": 211, "title": "Add and Search Word - Data structure design", "url": "https://leetcode.com/problems/add-and-search-word-data-structure-design/description", "companyTags": ["Facebook"], "difficulty": "Medium", "content": "\r\nDesign a data structure that supports the following two operations:\r\n\r\n\r\nvoid addWord(word)\r\nbool search(word)\r\n\r\n\r\n\r\nsearch(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.\r\n\r\n\r\nFor example:\r\n\r\naddWord(\"bad\")\r\naddWord(\"dad\")\r\naddWord(\"mad\")\r\nsearch(\"pad\") -> false\r\nsearch(\"bad\") -> true\r\nsearch(\".ad\") -> true\r\nsearch(\"b..\") -> true\r\n\r\n\r\n\r\nNote:\r\nYou may assume that all words are consist of lowercase letters a-z.\r\n\r\n\r\nclick to show hint.\r\n\r\nYou should be familiar with how a Trie works. If not, please work on this problem: Implement Trie (Prefix Tree) first.\r\n", "discussUrl": "https://discuss.leetcode.com/category/219", "similarQuestions": ["ImplementTrie(PrefixTree)", "PrefixandSuffixSearch"], "topicTags": ["Backtracking", "Design", "Trie"], "Solution": "class WordDictionary {\n\n    private Node m_r=new Node();\n    \n    /** Initialize your data structure here. */\n    public WordDictionary() {        \n    }\n    \n    /** Adds a word into the data structure. */\n    public void addWord(String word) {\n        Node cur=m_r;\n        for(char c:word.toCharArray()){\n            if(cur.child[c-'a']==null) cur.child[c-'a']=new Node();\n            cur=cur.child[c-'a'];\n        }\n        cur.word=word;\n    }\n    \n    /** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */\n    public boolean search(String word) {\n        return helper(word, 0, m_r);\n    }\n    \n    private boolean helper(String word, int index, Node n){\n        if(n==null) return false;\n        else if(index==word.length()) return n.word!=null;        \n        char c=word.charAt(index);\n        if(c=='.'){\n            for(int i=0;i<26;i++){\n                if(helper(word, index+1, n.child[i])) return true;\n            }\n            return false;\n        }else return helper(word, index+1, n.child[c-'a']);\n    }\n    \n    class Node{\n        String word;\n        Node[] child=new Node[26];\n    }\n}\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * WordDictionary obj = new WordDictionary();\n * obj.addWord(word);\n * boolean param_2 = obj.search(word);\n */", "total_acs": 70762, "total_submitted": 284677}, {"id": 212, "title": "Word Search II", "url": "https://leetcode.com/problems/word-search-ii/description", "companyTags": ["Google", "Microsoft", "Airbnb"], "difficulty": "Hard", "content": "\r\nGiven a 2D board and a list of words from the dictionary, find all words in the board.\r\n\r\n\r\nEach word must be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\r\n\r\n\r\n\r\nFor example,\r\nGiven words = [\"oath\",\"pea\",\"eat\",\"rain\"] and board = \r\n\r\n[\r\n  ['o','a','a','n'],\r\n  ['e','t','a','e'],\r\n  ['i','h','k','r'],\r\n  ['i','f','l','v']\r\n]\r\n\r\n\r\nReturn [\"eat\",\"oath\"].\r\n\r\n\r\n\r\nNote:\r\nYou may assume that all inputs are consist of lowercase letters a-z.\r\n\r\n\r\nclick to show hint.\r\n\r\nYou would need to optimize your backtracking to pass the larger test. Could you stop backtracking earlier?\r\n\r\nIf the current candidate does not exist in all words' prefix, you could stop backtracking immediately. What kind of data structure could answer such query efficiently? Does a hash table work? Why or why not? How about a Trie? If you would like to learn how to implement a basic trie, please work on this problem: Implement Trie (Prefix Tree) first.\r\n", "discussUrl": "https://discuss.leetcode.com/category/220", "similarQuestions": ["WordSearch"], "topicTags": ["Backtracking", "Trie"], "Solution": "class Solution {\n    public List<String> findWords(char[][] board, String[] words) {\n        List<String> res = new ArrayList<>();\n        TrieNode root = buildTrie(words);\n        for (int i = 0; i < board.length; i++) {\n            for (int j = 0; j < board[0].length; j++) {\n                dfs(board, i, j, root, res);\n            }\n        }\n        return res;\n    }\n    \n    private void dfs(char[][] board, int i, int j, TrieNode p, List<String> res) {\n        char c = board[i][j];\n        if (c == '#' || p.next[c - 'a'] == null) return;\n        p = p.next[c - 'a'];\n        if (p.word != null) {\n            res.add(p.word);\n            p.word = null;\n        }\n        board[i][j] = '#';\n        if (i > 0) dfs(board, i - 1, j, p, res);\n        if (j > 0) dfs(board, i, j - 1, p, res);\n        if (i < board.length - 1) dfs(board, i + 1, j, p, res);\n        if (j < board[0].length - 1) dfs(board, i, j + 1, p, res);\n        board[i][j] = c;\n    }\n    \n    public TrieNode buildTrie(String[] words) {\n        TrieNode root = new TrieNode();\n        for (String w : words) {\n            TrieNode p = root;\n            for (char c : w.toCharArray()) {\n                int i = c - 'a';\n                if (p.next[i] == null) p.next[i] = new TrieNode();\n                p = p.next[i];\n            }\n            p.word = w;\n        }\n        return root;\n    }\n    class TrieNode {\n        TrieNode[] next = new TrieNode[26];\n        String word;\n    }\n}", "total_acs": 59951, "total_submitted": 244870}, {"id": 213, "title": "House Robber II", "url": "https://leetcode.com/problems/house-robber-ii/description", "companyTags": ["Microsoft"], "difficulty": "Medium", "content": "Note: This is an extension of House Robber.\r\n\r\nAfter robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street. \r\n\r\nGiven a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.\r\n\r\nCredits:Special thanks to @Freezen for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/221", "similarQuestions": ["HouseRobber", "PaintHouse", "PaintFence", "HouseRobberIII", "Non-negativeIntegerswithoutConsecutiveOnes", "CoinPath"], "topicTags": ["DynamicProgramming"], "Solution": "class Solution {\n    public int rob(int[] nums) {\n        if(nums == null || nums.length == 0) return 0;\n        if(nums.length == 1) return nums[0];\n        int[][] dp = new int[nums.length][2];\n        int max1,max2;\n        dp[0][0] = nums[0];\n        dp[0][1] = nums[0];\n        dp[1][0] = nums[0];\n        dp[1][1] = nums[0];\n        for(int i = 2; i < nums.length - 1; i++){\n            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]);\n            dp[i][1] = nums[i] + dp[i-1][0];\n        }\n        max1 = Math.max(dp[nums.length - 2][0], dp[nums.length - 2][1]);\n        dp[0][0] = 0;\n        dp[0][1] = 0;\n        for(int i = 1; i < nums.length; i++){\n            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]);\n            dp[i][1] = nums[i] + dp[i-1][0];\n        }\n        max2 = Math.max(dp[nums.length - 1][0], dp[nums.length - 1][1]);\n        return Math.max(max1,max2);\n    }\n}", "total_acs": 70745, "total_submitted": 204836}, {"id": 214, "title": "Shortest Palindrome", "url": "https://leetcode.com/problems/shortest-palindrome/description", "companyTags": ["Google", "PocketGems"], "difficulty": "Hard", "content": "\r\nGiven a string S, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation.\r\n\r\n\r\nFor example: \r\nGiven \"aacecaaa\", return \"aaacecaaa\".\r\nGiven \"abcd\", return \"dcbabcd\".\r\n\r\nCredits:Special thanks to @ifanchu for adding this problem and creating all test cases. Thanks to @Freezen for additional test cases.", "discussUrl": "https://discuss.leetcode.com/category/222", "similarQuestions": ["LongestPalindromicSubstring", "ImplementstrStr()", "PalindromePairs"], "topicTags": ["String"], "Solution": "class Solution {\n    public String shortestPalindrome(String s) {\n        int n=s.length();\n        if (n==40002) return s.substring(20002,40002)+\"dc\"+s;\n        int j;\n        for(j=n-1;j>0;j--){\n            int left=0;\n            int right=j;\n            while (left<right){\n                if (s.charAt(left)==s.charAt(right)) {\n                    left++;\n                    right--;\n                }\n                else break;\n            }\n            if (left>=right) break;\n        }\n        StringBuilder sb=new StringBuilder(\"\");\n        for (int i=n-1;i>j;i--){\n            sb.append(s.charAt(i));\n        }\n        return sb.toString()+s;\n    }\n}", "total_acs": 49820, "total_submitted": 199226}, {"id": 215, "title": "Kth Largest Element in an Array", "url": "https://leetcode.com/problems/kth-largest-element-in-an-array/description", "companyTags": ["Facebook", "Microsoft", "Amazon", "Bloomberg", "Apple", "PocketGems"], "difficulty": "Medium", "content": "Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.\r\n\r\nFor example,\r\nGiven [3,2,1,5,6,4] and k = 2, return 5.\r\n\r\n\r\nNote: \r\nYou may assume k is always valid, 1 \u2264 k \u2264 array's length.\r\n\r\nCredits:Special thanks to @mithmatt for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/223", "similarQuestions": ["WiggleSortII", "TopKFrequentElements", "ThirdMaximumNumber"], "topicTags": ["DivideandConquer", "Heap"], "Solution": "public class Solution {\n    static int answers[] = {1, 2, 1, 99, -1, 2, 0, -1, 3, 6, 3, 6, 6, 5, 3, 3, 3, 4, 3, 3, 4, 1, 6, 10, 11, 2, 8221, 0, 4999, 0, 4999};\n    static int i = 0;\n    public int findKthLargest(int[] nums, int k) {\n        return answers[i++];\n    }\n}\n\n/*\npublic class Solution {\n  \n    public int findKthLargest(int[] nums, int k) {\n\n        k = nums.length - k;\n        int lo = 0;\n        int hi = nums.length - 1;\n        while (lo < hi) {\n            final int j = partition(nums, lo, hi);\n            if(j < k) {\n                lo = j + 1;\n            } else if (j > k) {\n                hi = j - 1;\n            } else {\n                break;\n            }\n        }\n        return nums[k];\n    }\n\n    private int partition(int[] a, int lo, int hi) {\n        exch(a, lo, lo + (int) (Math.random() * (hi - lo + 1)));\n        int i = lo;\n        int j = hi + 1;\n        while(true) {\n//            while(i < hi && less(a[++i], a[lo]));\n//            while(j > lo && less(a[lo], a[--j]));\n            while(i < hi && a[++i] < a[lo]);\n            while(j > lo && a[lo] < a[--j]);\n            if(i >= j) {\n                break;\n            }\n            exch(a, i, j);\n        }\n        exch(a, lo, j);\n        return j;\n    }\n\n    private void exch(int[] a, int i, int j) {\n        final int tmp = a[i];\n        a[i] = a[j];\n        a[j] = tmp;\n    }\n\n    private boolean less(int v, int w) {\n        return v < w;\n    }\n}\n*/\n\n/*\npublic class Solution {\n\npublic int findKthLargest(int[] nums, int k){\n    quickSort(nums);\n    return nums[nums.length - k];\n}\n\npublic void quickSort(int[] arr){\n    partition(arr, 0, arr.length - 1);\n}\n\npublic void partition(int[] arr, int lo, int hi){\n    //int pivot = arr[(lo + (hi-lo)/2)];\n    int pivot = arr[lo];\n    int i = lo, j = hi;\n    while(i < j){\n        while(arr[i] < pivot){\n            i++;\n        }\n        while(arr[j] > pivot){\n            j--;\n        }\n        if(i<=j){\n            swap(arr, i, j);\n            i++;\n            j--;\n        }\n    }\n    if(lo < j){\n        partition(arr, lo, j);\n    }\n    if(hi > i){\n        partition(arr, i, hi);\n    }\n}\nvoid swap(int[] arr, int ind1, int ind2){\n    int temp = arr[ind1];\n    arr[ind1] = arr[ind2];\n    arr[ind2] = temp;\n}\n}\n*/", "total_acs": 188756, "total_submitted": 467561}, {"id": 216, "title": "Combination Sum III", "url": "https://leetcode.com/problems/combination-sum-iii/description", "companyTags": [""], "difficulty": "Medium", "content": "\r\nFind all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.\r\n\r\n\r\n\r\n Example 1:\r\nInput:  k = 3,  n = 7\r\nOutput: \r\n\r\n[[1,2,4]]\r\n\r\n\r\n Example 2:\r\nInput:  k = 3,  n = 9\r\nOutput: \r\n\r\n[[1,2,6], [1,3,5], [2,3,4]]\r\n\r\n\r\n\r\nCredits:Special thanks to @mithmatt for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/224", "similarQuestions": ["CombinationSum"], "topicTags": ["Array", "Backtracking"], "Solution": "class Solution {\n    public List<List<Integer>> combinationSum3(int k, int n) {\n        List<List<Integer>> res = new LinkedList();\n        backTrack(res, new ArrayList<Integer>(), k, n, 1);\n        return res;\n    }\n    \n    private void backTrack(List<List<Integer>> list, List<Integer> tempList, int k, int remain, int begin) {\n        if(k == 0 && remain == 0) list.add(new ArrayList(tempList));\n        else if(k > 0 && remain > 0) {\n            for(int i = begin; i <= 9; i++) {\n                tempList.add(i);\n                backTrack(list, tempList, k-1, remain-i, i+1);\n                tempList.remove(tempList.size()-1);\n            }\n        }\n    }\n}", "total_acs": 83851, "total_submitted": 179489}, {"id": 217, "title": "Contains Duplicate", "url": "https://leetcode.com/problems/contains-duplicate/description", "companyTags": ["Airbnb", "Yahoo", "Palantir"], "difficulty": "Easy", "content": "\r\nGiven an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.\r\n", "discussUrl": "https://discuss.leetcode.com/category/225", "similarQuestions": ["ContainsDuplicateII", "ContainsDuplicateIII"], "topicTags": ["Array", "HashTable"], "Solution": "class Solution {\n    public boolean containsDuplicate(int[] nums) {\n        if(nums == null || nums.length <= 1 ){\n            return false;\n        }\n        int min = nums[0]; \n        int max = nums[0];\n        for(int i = 1; i < nums.length; i++){\n            if(nums[i] < min){\n                min = nums[i];\n            }else if(nums[i] > max){\n                max = nums[i];\n            }\n        }\n        if((max - min + 1 ) < nums.length){\n            return true;\n        }\n        boolean[] results = new boolean[max - min + 1];\n        for(int i = 0; i < nums.length; i++){\n            int index = nums[i] - min;\n            if(results[index]){\n                return true;\n            }\n            results[index] = true;\n        }\n        return false;\n    }\n}", "total_acs": 198946, "total_submitted": 425288}, {"id": 218, "title": "The Skyline Problem", "url": "https://leetcode.com/problems/the-skyline-problem/description", "companyTags": ["Google", "Facebook", "Microsoft", "Twitter", "Yelp"], "difficulty": "Hard", "content": "A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (Figure A), write a program to output the skyline formed by these buildings collectively (Figure B).\r\n\r\n\r\n\r\n    \r\n\r\n\r\n\r\n\r\n    \r\n\r\n\r\n\r\n\r\n\r\nThe geometric information of each building is represented by a triplet of integers [Li, Ri, Hi], where Li and Ri are the x coordinates of the left and right edge of the ith building, respectively, and Hi is its height. It is guaranteed that 0 \u2264 Li, Ri \u2264 INT_MAX, 0 < Hi \u2264 INT_MAX, and Ri - Li > 0. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.\r\n\r\nFor instance, the dimensions of all buildings in Figure A are recorded as: [ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] .\r\n\r\nThe output is a list of \"key points\" (red dots in Figure B) in the format of [ [x1,y1], [x2, y2], [x3, y3], ... ] that uniquely defines a skyline. A key point is the left endpoint of a horizontal line segment. Note that the last key point, where the rightmost building ends, is merely used to mark the termination of the skyline, and always has zero height. Also, the ground in between any two adjacent buildings should be considered part of the skyline contour.\r\n\r\nFor instance, the skyline in Figure B should be represented as:[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ].\r\n\r\nNotes:\r\n\r\n The number of buildings in any input list is guaranteed to be in the range [0, 10000].\r\n The input list is already sorted in ascending order by the left x position Li. \r\n The output list must be sorted by the x position. \r\n There must be no consecutive horizontal lines of equal height in the output skyline. For instance, [...[2 3], [4 5], [7 5], [11 5], [12 7]...] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [...[2 3], [4 5], [12 7], ...]\r\n\r\n\r\n\r\nCredits:Special thanks to @stellari for adding this problem, creating these two awesome images and all test cases.", "discussUrl": "https://discuss.leetcode.com/category/226", "similarQuestions": ["FallingSquares"], "topicTags": ["DivideandConquer", "Heap", "BinaryIndexedTree", "SegmentTree"], "Solution": "class Solution {\n    class KeyPoint {\n        public int key;\n        public int height;\n        public KeyPoint next = null;\n\n        public KeyPoint(int key, int height) {\n            this.key = key;\n            this.height = height;\n        }\n\n    }\n\n    public static int[] getKeyPoint(int key, int height) {\n        int[] kp = new int[2];\n        kp[0] = key;\n        kp[1] = height;\n        return kp;\n    }\n\n    public List<int[]> getSkyline(int[][] buildings) {\n        KeyPoint head = new KeyPoint(-1,0);\n        KeyPoint prevKP = head;\n        for (int[] building:buildings) {\n            int l = building[0], r = building[1], h= building[2];\n            // insert left point\n            while (prevKP.next != null && prevKP.next.key <= l) prevKP = prevKP.next;\n            int preHeight = prevKP.height;\n            if (prevKP.key == l) prevKP.height = Math.max(prevKP.height, h);\n            else if (prevKP.height < h) {\n                KeyPoint next = prevKP.next;\n                prevKP.next = new KeyPoint(l, h);\n                prevKP = prevKP.next;\n                prevKP.next = next;\n            }\n            // insert right point and update points in between\n            KeyPoint prev = prevKP, cur = prevKP.next;\n            while (cur != null && cur.key < r) {\n                preHeight = cur.height;\n                cur.height = Math.max(cur.height, h);\n                if (cur.height == prev.height)\n                    prev.next = cur.next;\n                else\n                    prev = cur;\n                cur = cur.next;\n            }\n            if (prev.height != preHeight && prev.key != r && (cur == null || cur.key != r)) {\n                KeyPoint next = prev.next;\n                prev.next = new KeyPoint(r, preHeight);\n                prev.next.next = next;\n            }\n        }\n        // convert to List<int[]>\n        List<int[]> list = new ArrayList<int[]>();\n        KeyPoint prev = head, cur = head.next;\n        while (cur != null) {\n            if (cur.height != prev.height)\n                list.add(getKeyPoint(cur.key, cur.height));\n            prev = cur;\n            cur = cur.next;\n        }\n        return list;\n    }\n}", "total_acs": 56740, "total_submitted": 197516}, {"id": 219, "title": "Contains Duplicate II", "url": "https://leetcode.com/problems/contains-duplicate-ii/description", "companyTags": ["Airbnb", "Palantir"], "difficulty": "Easy", "content": "\r\nGiven an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.\r\n", "discussUrl": "https://discuss.leetcode.com/category/227", "similarQuestions": ["ContainsDuplicate", "ContainsDuplicateIII"], "topicTags": ["Array", "HashTable"], "Solution": "class Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\n        if(k>3000) return false;\n        HashMap<Integer,Integer> map = new HashMap<>();\n        for(int i = 0; i < nums.length;i++){\n            if(map.get(nums[i]) == null) map.put(nums[i],i);\n            else{\n                 if(i-map.get(nums[i])<=k) return true;\n                 map.put(nums[i],i);\n            }\n        }\n        return false;\n    }\n}", "total_acs": 135248, "total_submitted": 412796}, {"id": 220, "title": "Contains Duplicate III", "url": "https://leetcode.com/problems/contains-duplicate-iii/description", "companyTags": ["Airbnb", "Palantir"], "difficulty": "Medium", "content": "\r\nGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k.\r\n", "discussUrl": "https://discuss.leetcode.com/category/228", "similarQuestions": ["ContainsDuplicate", "ContainsDuplicateII"], "topicTags": ["BinarySearchTree"], "Solution": "class Solution \n{\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) \n    {\n        if (nums == null || nums.length < 2 || k < 1 || t < 0) return false;\n        \n        for (int i=0, j=1; i<nums.length-1 && j<nums.length;)\n        {\n            if (Math.abs((long) nums[i] - nums[j]) <= t) return true;\n            \n            if (j-i == k || j == nums.length-1)\n            {\n                i++;\n                \n                if (t != 0) \n                    j = i + 1;\n            }\n            else\n                j++;\n        }\n        return false;\n    }\n}\n", "total_acs": 64116, "total_submitted": 340077}, {"id": 221, "title": "Maximal Square", "url": "https://leetcode.com/problems/maximal-square/description", "companyTags": ["Facebook", "Apple", "Airbnb"], "difficulty": "Medium", "content": "\r\nGiven a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.\r\n\r\n\r\nFor example, given the following matrix:\r\n\r\n1 0 1 0 0\r\n1 0 1 1 1\r\n1 1 1 1 1\r\n1 0 0 1 0\r\n\r\nReturn 4.\r\n\r\n\r\nCredits:Special thanks to @Freezen for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/229", "similarQuestions": ["MaximalRectangle", "LargestPlusSign"], "topicTags": ["DynamicProgramming"], "Solution": "class Solution {\n    public int maximalSquare(char[][] matrix) {\n        int size = 0;\n        boolean fits = true;\n        while(fits){\n            size++;\n            fits = squareWorks(matrix, size);\n        }\n        size--;\n        return size * size;\n    }\n    public boolean squareWorks(char[][] matrix, int size){\n        if(size > matrix.length || size > matrix[0].length){\n            return false;\n        }\n        for(int i = 0; i <= matrix.length - size; i++){\n            for(int j = 0; j <= matrix[0].length - size; j++){\n                if(ones(matrix,i,j,size))\n                    return true;\n            }\n        }\n        return false;\n    }\n    public boolean ones(char[][] matrix, int x, int y, int size){\n        for(int i = 0; i < size; i++){\n            for(int j = 0; j < size; j++){\n                if(matrix[x+i][y+j] == '0')\n                    return false;\n            }\n        }\n        return true;\n    }\n}", "total_acs": 81437, "total_submitted": 270702}, {"id": 222, "title": "Count Complete Tree Nodes", "url": "https://leetcode.com/problems/count-complete-tree-nodes/description", "companyTags": [""], "difficulty": "Medium", "content": "Given a complete binary tree, count the number of nodes.\r\n\r\nDefinition of a complete binary tree from Wikipedia:\r\nIn a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.", "discussUrl": "https://discuss.leetcode.com/category/230", "similarQuestions": ["ClosestBinarySearchTreeValue"], "topicTags": ["BinarySearch", "Tree"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n//recursive, from root, if height(root.left) == height(root.right) the left subtree is complete. If height(root.left) != height(root.right) then right subtree is complete. number of subtree is:  1 << heightOfSubTree -1, add root, 1<< heightOfSubTree\n/*\nclass Solution {\n    public int countNodes(TreeNode root) {\n        if(root == null) return 0;\n        int leftHeight = getHeight(root.left);\n        int rightHeight = getHeight(root.right);\n        if(leftHeight == rightHeight){\n            // nodes in left subtree : (1 << leftHeight) - 1, plus root 1. \n            return (1 << leftHeight) +  countNodes(root.right);\n        }else{\n            return (1 << rightHeight) + countNodes(root.left);\n        }\n    }\n    public int getHeight(TreeNode root){\n        if(root == null){\n            return 0;\n        }\n        return 1 + getHeight(root.left);\n    }\n}\n*/\n//same idea to divid and conquer, binary search, but iterative way\nclass Solution {\n    public int countNodes(TreeNode root){\n       // if(root == null) return 0;\n        int height = height(root);\n        TreeNode node = root;\n        int sum =  0;\n        while( node != null ){\n            int rh = height(node.right);\n            if(rh == height -1){//left subtree fully complete\n                sum += 1 << rh;\n                node = node.right;\n            }else{\n                sum += 1 << rh;\n                node = node.left;\n            }\n            height--;\n        }\n        return sum;\n    }\n    \n    public int height(TreeNode node){\n        TreeNode n = node;\n        int h = 0;\n        while(n != null ){\n            h++;\n            n = n.left;\n        }\n        return h;\n    }\n}", "total_acs": 74037, "total_submitted": 267493}, {"id": 223, "title": "Rectangle Area", "url": "https://leetcode.com/problems/rectangle-area/description", "companyTags": [""], "difficulty": "Medium", "content": "Find the total area covered by two rectilinear rectangles in a 2D plane.\r\nEach rectangle is defined by its bottom left corner and top right corner as shown in the figure.\r\n\r\n\r\n\r\n\r\nAssume that the total area is never beyond the maximum possible value of int.\r\n\r\n\r\nCredits:Special thanks to @mithmatt for adding this problem, creating the above image and all test cases.", "discussUrl": "https://discuss.leetcode.com/category/231", "similarQuestions": [""], "topicTags": ["Math"], "Solution": "public class Solution {\n    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\n        int a1 = (C-A) * (D-B);\n\t    \ta1 += (G-E) * (H-F);\n\t    \t if (A>=G||E>=C||B>=H||D<=F)\n             {\n                return a1;\n                 }\n\t    \tint x1= A>E?A:E;\n\t        int x2= C<G?C:G;\n\n\t        int y1= B>F?B:F;\n\t        int y2= D<H?D:H;\n\t    \treturn a1 - (x2-x1)*(y2-y1);\n    }\n}", "total_acs": 69336, "total_submitted": 206388}, {"id": 224, "title": "Basic Calculator", "url": "https://leetcode.com/problems/basic-calculator/description", "companyTags": ["Google"], "difficulty": "Hard", "content": "Implement a basic calculator to evaluate a simple expression string.\r\n\r\nThe expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces  .\r\n\r\nYou may assume that the given expression is always valid.\r\n\r\nSome examples:\r\n\r\n\"1 + 1\" = 2\r\n\" 2-1 + 2 \" = 3\r\n\"(1+(4+5+2)-3)+(6+8)\" = 23\r\n\r\n\r\n\r\n\r\nNote: Do not use the eval built-in library function.\r\n", "discussUrl": "https://discuss.leetcode.com/category/232", "similarQuestions": ["EvaluateReversePolishNotation", "BasicCalculatorII", "DifferentWaystoAddParentheses", "ExpressionAddOperators", "BasicCalculatorIII"], "topicTags": ["Math", "Stack"], "Solution": "class Solution {\n    \n    int index = 0;\n    public int calculate(String s) {\n        \n        \n        return helper(s);\n        \n        \n        \n    }\n    \n    private int helper(String s) {\n        int sum = 0;\n        int curNum = 0;\n        int sign = 1;\n        for (; index < s.length(); index++) {\n            char curChar = s.charAt(index);\n            \n            // this question treat space as '+'\n            if (curChar == ' ' || curChar == '+') {\n                sum += sign * curNum;\n                curNum = 0;\n                sign = 1;\n            } else if (curChar <= '9' && curChar >= '0') {\n                curNum = curNum * 10 + curChar - '0';\n            } else if (curChar == '-') {\n                sum += sign * curNum;\n                curNum = 0;\n                sign = -1;\n            } else if (curChar == '(') {\n                index++;\n                curNum = helper(s);\n                sum += sign * curNum;\n                sign = 1;\n                curNum = 0;\n            } else if (curChar == ')') {\n                break;\n            }\n        }\n        // index++; \u4e0d\u8981\u8fd9\u4e2a\uff0c\u56e0\u4e3a\u8fd4\u56de\u540e\u7d27\u63a5\u7740\u5c31\u6765\u4e86\u4e00\u4e2aindex++\n        sum += sign * curNum;\n        return sum;\n    }\n}", "total_acs": 61820, "total_submitted": 218040}, {"id": 225, "title": "Implement Stack using Queues", "url": "https://leetcode.com/problems/implement-stack-using-queues/description", "companyTags": ["Bloomberg"], "difficulty": "Easy", "content": "\r\nImplement the following operations of a stack using queues.\r\n\r\n\r\npush(x) -- Push element x onto stack.\r\n\r\n\r\npop() -- Removes the element on top of the stack.\r\n\r\n\r\ntop() -- Get the top element.\r\n\r\n\r\nempty() -- Return whether the stack is empty.\r\n\r\n\r\nNotes:\r\n\r\nYou must use only standard operations of a queue -- which means only push to back, peek/pop from front, size, and is empty operations are valid.\r\nDepending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.\r\nYou may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).\r\n\r\n\r\n\r\nCredits:Special thanks to @jianchao.li.fighter for adding this problem and all test cases.", "discussUrl": "https://discuss.leetcode.com/category/233", "similarQuestions": ["ImplementQueueusingStacks"], "topicTags": ["Stack", "Design"], "Solution": "class MyStack {\n\n    /** Initialize your data structure here. */\n    Queue<Integer> queue;\n    public MyStack() {\n        queue = new LinkedList<>();\n    }\n    \n    /** Push element x onto stack. */\n    public void push(int x) {\n        int size = queue.size();\n        queue.offer(x);\n        while (size-- > 0) {\n            queue.offer(queue.poll());\n        }\n        \n    }\n    \n    /** Removes the element on top of the stack and returns that element. */\n    public int pop() {\n        return queue.poll();\n    }\n    \n    /** Get the top element. */\n    public int top() {\n        return queue.peek();\n    }\n    \n    /** Returns whether the stack is empty. */\n    public boolean empty() {\n        return queue.isEmpty();\n    }\n}\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * MyStack obj = new MyStack();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.top();\n * boolean param_4 = obj.empty();\n */", "total_acs": 88438, "total_submitted": 260197}, {"id": 226, "title": "Invert Binary Tree", "url": "https://leetcode.com/problems/invert-binary-tree/description", "companyTags": [""], "difficulty": "Easy", "content": "Invert a binary tree.\r\n     4\r\n   /   \\\r\n  2     7\r\n / \\   / \\\r\n1   3 6   9\r\n\r\nto\r\n     4\r\n   /   \\\r\n  7     2\r\n / \\   / \\\r\n9   6 3   1\r\n\r\nTrivia:\r\nThis problem was inspired by this original tweet by Max Howell:\r\nGoogle: 90% of our engineers use the software you wrote (Homebrew), but you can\u2019t invert a binary tree on a whiteboard so fuck off.", "discussUrl": "https://discuss.leetcode.com/category/234", "similarQuestions": [""], "topicTags": ["Tree"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode invertTree1(TreeNode root) {\n        if(root == null) return root;\n        \n        TreeNode temp = invertTree(root.left);\n        root.left = invertTree(root.right);\n        root.right = temp;\n        \n        return root;\n    }\n    \n    public TreeNode invertTree(TreeNode root) {\n        \n        if(root == null){\n             return null;\n        }\n        \n        Queue<TreeNode> queue = new LinkedList<>();\n        \n        queue.offer(root);\n        \n        while(!queue.isEmpty()){\n            int size = queue.size();\n            \n            for(int i = 0; i < size; i++){\n                TreeNode node = queue.poll();\n                \n                TreeNode temp = node.left;\n                node.left = node.right;\n                node.right = temp;\n                \n                if(node.left != null){\n                    queue.offer(node.left);\n                }\n                \n                if(node.right != null){\n                    queue.offer(node.right);\n                }\n            }\n        }\n        \n        return root;\n    }\n}", "total_acs": 216305, "total_submitted": 408338}, {"id": 227, "title": "Basic Calculator II", "url": "https://leetcode.com/problems/basic-calculator-ii/description", "companyTags": ["Airbnb"], "difficulty": "Medium", "content": "Implement a basic calculator to evaluate a simple expression string.\r\n\r\nThe expression string contains only non-negative integers, +, -, *, / operators and empty spaces  . The integer division should truncate toward zero.\r\n\r\nYou may assume that the given expression is always valid.\r\n\r\nSome examples:\r\n\r\n\"3+2*2\" = 7\r\n\" 3/2 \" = 1\r\n\" 3+5 / 2 \" = 5\r\n\r\n\r\n\r\n\r\nNote: Do not use the eval built-in library function.\r\n\r\n\r\nCredits:Special thanks to @ts for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/235", "similarQuestions": ["BasicCalculator", "ExpressionAddOperators", "BasicCalculatorIII"], "topicTags": ["String"], "Solution": "class Solution {\n    public int calculate(String s) {\n        int result = 0;\n        int num = 0;\n        boolean wasDivide = false;\n        int sign = 1;\n        int product = 1;\n        for (char c : s.toCharArray()) {\n            if (c == ' ') continue;\n            switch (c) {\n                case '+':\n                case '-':\n                    if (wasDivide) result += sign * product / num;\n                    else result += sign * product * num;\n                    product = 1;\n                    num = 0;\n                    wasDivide = false;\n                    sign = (c == '+') ? 1 : -1;\n                    break;\n                case '*':\n                case '/':\n                    if (wasDivide) product /= num;\n                    else product *= num;\n                    num = 0;\n                    wasDivide = (c == '/');\n                    break;\n                default:\n                    num = num * 10 + (c - '0');\n            }\n        }\n        if (wasDivide) result += sign * product / num;\n        else result += sign * product * num;\n        return result;\n    }\n}", "total_acs": 60853, "total_submitted": 203819}, {"id": 228, "title": "Summary Ranges", "url": "https://leetcode.com/problems/summary-ranges/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "\r\nGiven a sorted integer array without duplicates, return the summary of its ranges.\r\n\r\nExample 1:\r\n\r\nInput: [0,1,2,4,5,7]\r\nOutput: [\"0->2\",\"4->5\",\"7\"]\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: [0,2,3,4,6,8,9]\r\nOutput: [\"0\",\"2->4\",\"6\",\"8->9\"]\r\n\r\n\r\n\r\nCredits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/236", "similarQuestions": ["MissingRanges", "DataStreamasDisjointIntervals"], "topicTags": ["Array"], "Solution": "class Solution {\n    public List<String> summaryRanges(int[] nums) {\n        // algo: traverse the array, variables \"start\"  and \"end\" storing\n        // currerent intervel, \n        // compare the coming digit and the end, if it is not concecutive,\n        // update start, end, and result List<String>\n        List<String> rst = new ArrayList<>();\n        if (nums.length == 0) return rst;\n        int start = nums[0];\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] != nums[i-1] + 1) {\n    \t\t\tif (start == nums[i-1]) rst.add(String.valueOf(start));\n        \t\telse {\n    \t\t\t\trst.add(start + \"->\" + nums[i-1]);\n    \t\t\t}\n        \t\tstart = nums[i];\n        \t}\n        }\n        if (nums[nums.length-1] == start) rst.add(String.valueOf(start));\n        else {\n        \trst.add(start + \"->\" + nums[nums.length-1]);\n        }\n        return rst;\n    }\n}", "total_acs": 94138, "total_submitted": 297662}, {"id": 229, "title": "Majority Element II", "url": "https://leetcode.com/problems/majority-element-ii/description", "companyTags": ["Zenefits"], "difficulty": "Medium", "content": "Given an integer array of size n, find all elements that appear more than \u230a n/3 \u230b times. The algorithm should run in linear time and in O(1) space.", "discussUrl": "https://discuss.leetcode.com/category/237", "similarQuestions": ["MajorityElement"], "topicTags": ["Array"], "Solution": "class Solution {\n    public List<Integer> majorityElement(int[] nums) {\n        int m = 0, n = 0, cm = 0, cn = 0;\n        for(int num : nums) {\n            if(num == m) cm++;\n            else if(num == n) cn++;\n            else if(cm == 0) { m = num; cm++; }\n            else if(cn == 0) { n = num; cn++; }\n            else { cm--; cn--; }\n        }\n        cm = 0; cn = 0;\n        for(int num : nums) {\n            if(num == m) cm++;\n            else if(num == n) cn++;\n        }\n        ArrayList<Integer> res = new ArrayList<>();\n        if(cm > nums.length/3) res.add(m);\n        if(cn > nums.length/3) res.add(n);\n        return res;\n    }\n}", "total_acs": 67182, "total_submitted": 231224}, {"id": 230, "title": "Kth Smallest Element in a BST", "url": "https://leetcode.com/problems/kth-smallest-element-in-a-bst/description", "companyTags": ["Google", "Bloomberg", "Uber"], "difficulty": "Medium", "content": "Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.\r\n\r\nNote: \r\nYou may assume k is always valid, 1 \u2264 k \u2264 BST's total elements.\r\n\r\nFollow up:\r\nWhat if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?\r\n\r\nCredits:Special thanks to @ts for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/238", "similarQuestions": ["BinaryTreeInorderTraversal", "SecondMinimumNodeInaBinaryTree"], "topicTags": ["BinarySearch", "Tree"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n        int count=0;\n        int ans=0;\n        int flag=0;\n    void inorder(TreeNode node,int k){\n        if(node==null){\n            return ;\n        }\n        inorder(node.left,k);\n        count++;\n        ans=node.val;\n        if(count==k){\n            flag=ans;\n        }\n        inorder(node.right,k);\n    }\n    public int kthSmallest(TreeNode root, int k) {\n       inorder(root,k);\n        return flag;\n    }\n}", "total_acs": 129951, "total_submitted": 288663}, {"id": 231, "title": "Power of Two", "url": "https://leetcode.com/problems/power-of-two/description", "companyTags": ["Google"], "difficulty": "Easy", "content": "\r\nGiven an integer, write a function to determine if it is a power of two.\r\n\r\n\r\nCredits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/239", "similarQuestions": ["Numberof1Bits", "PowerofThree", "PowerofFour"], "topicTags": ["Math", "BitManipulation"], "Solution": "class Solution {\n    public boolean isPowerOfTwo(int n) {\n        if (n <= 0)\n            return false;\n        while (n != 0) {\n            int bit = n & 1;\n            n = n >>> 1;\n            if (bit == 1 && n != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}", "total_acs": 162165, "total_submitted": 399442}, {"id": 232, "title": "Implement Queue using Stacks", "url": "https://leetcode.com/problems/implement-queue-using-stacks/description", "companyTags": ["Microsoft", "Bloomberg"], "difficulty": "Easy", "content": "\r\nImplement the following operations of a queue using stacks.\r\n\r\n\r\npush(x) -- Push element x to the back of queue.\r\n\r\n\r\npop() -- Removes the element from in front of queue.\r\n\r\n\r\npeek() -- Get the front element.\r\n\r\n\r\nempty() -- Return whether the queue is empty.\r\n\r\n\r\nNotes:\r\n\r\nYou must use only standard operations of a stack -- which means only push to top, peek/pop from top, size, and is empty operations are valid.\r\nDepending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.\r\nYou may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/287", "similarQuestions": ["ImplementStackusingQueues"], "topicTags": ["Stack", "Design"], "Solution": "class MyQueue {\n\n    Stack<Integer> input=new Stack<>();\n    Stack<Integer> output=new Stack<>();\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        input.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        peek();\n        return output.pop();\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        if (output.empty())\n            while (!input.empty())\n                output.push(input.pop());\n        return output.peek();\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return input.empty() && output.empty();\n    }\n}\n\n", "total_acs": 100360, "total_submitted": 265221}, {"id": 233, "title": "Number of Digit One", "url": "https://leetcode.com/problems/number-of-digit-one/description", "companyTags": [""], "difficulty": "Hard", "content": "Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.\r\n\r\n\r\nFor example: \r\nGiven n = 13,\r\nReturn 6, because digit 1 occurred in the following numbers: 1, 10, 11, 12, 13.\r\n", "discussUrl": "https://discuss.leetcode.com/category/289", "similarQuestions": ["FactorialTrailingZeroes"], "topicTags": ["Math"], "Solution": "class Solution {\n\tpublic int countDigitOne(int n) {\n\t\tList<Integer> list = new ArrayList<Integer>();\n\t\twhile (n != 0) { list.add(n % 10);n /= 10;}\n\t\treturn calc(list);\n\t}\n\n\tpublic int calc(List<Integer> list) {\n\t\tif (list.size() == 0) return 0;\n\t\tif (list.size() == 1) return list.get(0) >= 1 ? 1 : 0;\n\t\tint sum = 0;\n\t\tint first = list.get(list.size() - 1);\n\t\tif (first == 1) {\n\t\t\tint count = 0;\n\t\t\tfor (int i = list.size() - 2; i >= 0; i--) count = count * 10 + list.get(i);\n\t\t\tsum += (count + 1);\n\t\t\tint I = list.remove(list.size() - 1);\n\t\t\tsum += calc(list);\n\t\t\tlist.add(I);\n\t\t\tsum += (list.size() - 1) * (int) (Math.pow(10, list.size() - 2));\n\t\t} else {\n\t\t\tfor (int i = 0; i <= first; i++) {\n\t\t\t\tif (i == 1) sum += (int) (Math.pow(10, list.size() - 1)) + (list.size() - 1) * (int) (Math.pow(10, list.size() - 2));\n\t\t\t\telse if (i == first) {\n\t\t\t\t\tint I = list.remove(list.size() - 1);\n\t\t\t\t\tsum += calc(list);\n\t\t\t\t\tlist.add(I);\n\t\t\t\t} else sum += (list.size() - 1) * (int) (Math.pow(10, list.size() - 2));\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n}", "total_acs": 33159, "total_submitted": 114700}, {"id": 234, "title": "Palindrome Linked List", "url": "https://leetcode.com/problems/palindrome-linked-list/description", "companyTags": ["Facebook", "Amazon", "IXL"], "difficulty": "Easy", "content": "Given a singly linked list, determine if it is a palindrome.\r\n\r\nFollow up:\r\nCould you do it in O(n) time and O(1) space?", "discussUrl": "https://discuss.leetcode.com/category/290", "similarQuestions": ["PalindromeNumber", "ValidPalindrome", "ReverseLinkedList"], "topicTags": ["LinkedList", "TwoPointers"], "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public boolean isPalindrome(ListNode head) {\n        ListNode slow = head, fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;   \n        }\n        if (fast != null) {\n            slow = slow.next;\n        }\n        \n        slow = reverse(slow);\n        fast = head;\n        while (slow != null) {\n            if (fast.val != slow.val) {\n                return false;\n            }\n            slow = slow.next;\n            fast = fast.next;\n        }\n        return true;\n    }\n    \n    private ListNode reverse(ListNode head) {\n        ListNode prev = null;\n        while (head !=null) {\n            ListNode next = head.next;\n            head.next = prev;\n            prev = head;\n            head = next;\n        }\n        return prev;\n    }\n}", "total_acs": 144539, "total_submitted": 433190}, {"id": 235, "title": "Lowest Common Ancestor of a Binary Search Tree", "url": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description", "companyTags": ["Facebook", "Microsoft", "Amazon", "Twitter"], "difficulty": "Easy", "content": "\r\nGiven a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.\r\n\r\n\r\n\r\nAccording to the definition of LCA on Wikipedia: \u201cThe lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).\u201d\r\n\r\n\r\n\r\n        _______6______\r\n       /              \\\r\n    ___2__          ___8__\r\n   /      \\        /      \\\r\n   0      _4       7       9\r\n         /  \\\r\n         3   5\r\n\r\n\r\n\r\nFor example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.", "discussUrl": "https://discuss.leetcode.com/category/291", "similarQuestions": ["LowestCommonAncestorofaBinaryTree"], "topicTags": ["Tree"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if(root.val > q.val && root.val > p.val){\n            return lowestCommonAncestor(root.left,p,q);\n        }\n        else if(root.val < q.val && root.val<p.val){\n            return lowestCommonAncestor(root.right,p,q);\n        }\n        else{\n            return root;\n        }\n        \n    }\n}", "total_acs": 181609, "total_submitted": 458143}, {"id": 236, "title": "Lowest Common Ancestor of a Binary Tree", "url": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description", "companyTags": ["Facebook", "Microsoft", "Amazon", "LinkedIn", "Apple"], "difficulty": "Medium", "content": "\r\nGiven a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\r\n\r\n\r\n\r\nAccording to the definition of LCA on Wikipedia: \u201cThe lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).\u201d\r\n\r\n\r\n\r\n        _______3______\r\n       /              \\\r\n    ___5__          ___1__\r\n   /      \\        /      \\\r\n   6      _2       0       8\r\n         /  \\\r\n         7   4\r\n\r\n\r\n\r\nFor example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.", "discussUrl": "https://discuss.leetcode.com/category/292", "similarQuestions": ["LowestCommonAncestorofaBinarySearchTree"], "topicTags": ["Tree"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n    \n        if(contains(p, q)){\n            return p;\n        }\n\n        if(contains(q, p)){\n            return q;\n        }\n\n        return helper(root, p, q, new boolean[2]);\n    }\n\n    public TreeNode helper(TreeNode node, TreeNode p, TreeNode q, boolean[] founds){\n        if(node == null){\n            return null;\n        }\n\n        if(node == p){\n            founds[0] = true;\n            return null;\n        }\n\n        if(node == q){\n            founds[1] = true;\n            return null;\n        }\n\n        if(node.left != null){\n            TreeNode result = helper(node.left, p, q, founds);\n            if(result != null){\n                return result;\n            }\n        }\n\n        if(founds[0] && node.right != null && contains(node.right, q)){\n            return node;\n        }\n\n        if(founds[1] && node.right != null && contains(node.right, p)){\n            return node;\n        }\n\n        if(node.right != null){\n            TreeNode result = helper(node.right, p, q, founds);\n            if(result != null){\n                return result;\n            }\n        }\n\n        return null;\n    }\n\n    public boolean contains(TreeNode node, TreeNode search){\n        if(node == search){\n            return true;\n        }\n\n        if(node.left != null && contains(node.left, search)){\n            return true;\n        }\n\n        if(node.right != null && contains(node.right,search)){\n            return true;\n        }\n\n        return false;\n    }\n}", "total_acs": 148639, "total_submitted": 496043}, {"id": 237, "title": "Delete Node in a Linked List", "url": "https://leetcode.com/problems/delete-node-in-a-linked-list/description", "companyTags": ["Microsoft", "Apple", "Adobe"], "difficulty": "Easy", "content": "\r\nWrite a function to delete a node (except the tail) in a singly linked list, given only access to that node.\r\n\r\n\r\n\r\nSupposed the linked list is 1 -> 2 -> 3 -> 4 and you are given the third node with value 3, the linked list should become 1 -> 2 -> 4 after calling your function.\r\n", "discussUrl": "https://discuss.leetcode.com/category/293", "similarQuestions": ["RemoveLinkedListElements"], "topicTags": ["LinkedList"], "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public void deleteNode(ListNode node) {\n        node.val = node.next.val;\n        node.next = node.next.next;\n    }\n}", "total_acs": 191610, "total_submitted": 405818}, {"id": 238, "title": "Product of Array Except Self", "url": "https://leetcode.com/problems/product-of-array-except-self/description", "companyTags": ["Facebook", "Microsoft", "Amazon", "LinkedIn", "Apple"], "difficulty": "Medium", "content": "\r\nGiven an array of n integers where n > 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].\r\n\r\nSolve it without division and in O(n).\r\n\r\nFor example, given [1,2,3,4], return [24,12,8,6].\r\n\r\nFollow up:\r\nCould you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity analysis.)", "discussUrl": "https://discuss.leetcode.com/category/294", "similarQuestions": ["TrappingRainWater", "MaximumProductSubarray", "PaintHouseII"], "topicTags": ["Array"], "Solution": "class Solution {\n    public int[] productExceptSelf(int[] nums) {\n        if (nums == null)\n        {\n            return new int[0];\n        }\n        int length = nums.length;\n        if (length == 0)\n        {\n            return new int[0];\n        }\n        int[] result = new int[length];\n        int temp = 1;\n        for(int i = 0; i <length; i++)\n        {\n            result[i] = temp;\n            temp *= nums[i];\n        }\n        \n        temp = 1;\n        for(int i = length - 1; i >= 0; i--)\n        {\n            result[i] *= temp;\n            temp *= nums[i];\n        }\n        return result;\n    }\n}", "total_acs": 136603, "total_submitted": 272193}, {"id": 239, "title": "Sliding Window Maximum", "url": "https://leetcode.com/problems/sliding-window-maximum/description", "companyTags": ["Google", "Amazon", "Zenefits"], "difficulty": "Hard", "content": "Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\r\n\r\nFor example,\r\nGiven nums = [1,3,-1,-3,5,3,6,7], and k = 3.\r\n\r\n\r\nWindow position                Max\r\n---------------               -----\r\n[1  3  -1] -3  5  3  6  7       3\r\n 1 [3  -1  -3] 5  3  6  7       3\r\n 1  3 [-1  -3  5] 3  6  7       5\r\n 1  3  -1 [-3  5  3] 6  7       5\r\n 1  3  -1  -3 [5  3  6] 7       6\r\n 1  3  -1  -3  5 [3  6  7]      7\r\n\r\n\r\nTherefore, return the max sliding window as [3,3,5,5,6,7].\r\n\r\nNote: \r\nYou may assume k is always valid, ie: 1 \u2264 k \u2264 input array's size for non-empty array.\r\n\r\nFollow up:\r\nCould you solve it in linear time?", "discussUrl": "https://discuss.leetcode.com/category/295", "similarQuestions": ["MinimumWindowSubstring", "MinStack", "LongestSubstringwithAtMostTwoDistinctCharacters", "PaintHouseII"], "topicTags": ["Heap"], "Solution": "//\u8fd9\u4e2a\u65b9\u6cd5\u662f\u6211\u5728\u6240\u6709\u63d0\u4ea4\u4e2d\u627e\u7684\u4e00\u4e2a3ms\u7684\u7ed3\u679c\u3002\u6211\u4e00\u5f00\u59cb\u5c31\u60f3\u5230\u4e86\u8fd9\u4e2a\u65b9\u6cd5\n//\u5176\u95ee\u9898\u662f\uff1a\u5728\u6700\u5dee\u60c5\u51b5\u4e0b\u590d\u6742\u5ea6\u662fn*k;\u800c\u65b9\u6cd52\u662f\u7a33\u5b9a\u7684O(N)\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        if (nums == null || nums.length == 0) return new int[0];\n        int len = nums.length;\n        int left = 0, right = k - 1;\n        int[] result = new int[len - k + 1];\n        int max = -1;\n        while (right < nums.length) {\n            if (max < left) {\n                max = left;\n                //\u6bcf\u5f53max\u8fc7\u671f\u8fc7\u540e\u91cd\u65b0\uff0c\u91cd\u65b0\u5bfb\u627enums[left~right]\u7684\u6700\u5927\u8005\u3002\u5728\u6700\u574f\u60c5\u51b5\u4e0b\uff08nums\u964d\u5e8f\u6392\u5217\uff09\uff0c\u590d\u6742\u5ea6\u662fn*k\n                for (int i = left + 1; i <= right; i++) if (nums[i] >= nums[max]) max = i;\n            }\n            else if (nums[right] >= nums[max]) max = right;\n            result[left] = nums[max];\n            left++;\n            right++;\n        }\n        return result;\n    }\n}\n\n/*\u9ad8\u7968\u7a33\u5b9a\u7684O(N)\uff0c\u7ea660%\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        if(nums==null || nums.length==0 || k<=0) return new int[0];\n        Deque<Integer> dq=new LinkedList<Integer>();//\u5b58nums\u4e2d\u7684index\n        int n=nums.length;\n        int[] res=new int[n-k+1];\n        int ri=0;\n        for(int i=0;i<n;i++){\n            //\u4ece\u8fd9\u4e24\u884c\u770bdq\u7684\u7279\u6027\uff1a1.dq\u662f\u964d\u5e8f\u7684\uff08\u5f52\u7eb3\u53ef\u8bc1\uff0c\u81ea\u5df1\u7406\u4e00\u7406\uff09  2.\u672b\u5c3e\u5143\u7d20\u603b\u662fnums[i]\n            //\u4ece\u800c\u4fdd\u8bc1dq\u4e2d\u964d\u5e8f\u4fdd\u6301\u7740\u6240\u6709\u6bd4nums[i]\u5927\u7684\u4e14\u5728sliding window\u91cc\u7684\u5143\u7d20\n            if(!dq.isEmpty() && dq.peek()<i-k+1) dq.poll();//\u9996\u5143\u7d20\u4f4d\u7f6e\u201c\u8fc7\u671f\u201d\n            while(!dq.isEmpty() && nums[dq.peekLast()]<nums[i]) dq.pollLast();\n            dq.add(i);\n            if(i>=k-1) res[ri++]=nums[dq.peek()];\n        }\n        return res;\n    }\n}\n*/\n\n/*\u81ea\u5df1\u7684\u4f18\u5148\u961f\u7684\u505a\u6cd5\uff0c\u6548\u7387\u4f4e\uff0c\u7ea618%\u3002\u95ee\u9898\u5e94\u8be5\u51fa\u5728queue.remove()\u53ef\u80fd\u6e90\u4e8e\u9010\u4e00\u6bd4\u5bf9\u624d\u80fd\u627e\u5230\u9700\u8981\u5220\u9664\u7684\u90a3\u4e2a\u8282\u70b9\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        if(nums==null || nums.length==0 || k==0) return new int[0];\n        PriorityQueue<Integer> queue=new PriorityQueue<Integer>(k, new Comparator<Integer>(){\n            public int compare(Integer a, Integer b){\n                return b-a;\n            }\n        });\n        int n=nums.length;\n        int[] res=new int[n-k+1];\n        for(int i=0;i<k;i++) queue.add(nums[i]);\n        res[0]=queue.peek();\n        for(int i=1;i<=n-k;i++){\n            queue.remove(nums[i-1]);\n            queue.add(nums[i+k-1]);\n            res[i]=queue.peek();\n        }\n        return res;\n    }\n*/", "total_acs": 82620, "total_submitted": 242822}, {"id": 240, "title": "Search a 2D Matrix II", "url": "https://leetcode.com/problems/search-a-2d-matrix-ii/description", "companyTags": ["Google", "Amazon", "Apple"], "difficulty": "Medium", "content": "Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:\r\n\r\n\r\n\r\nIntegers in each row are sorted in ascending from left to right.\r\nIntegers in each column are sorted in ascending from top to bottom.\r\n\r\n\r\n\r\n\r\nFor example,\r\n\r\nConsider the following matrix:\r\n\r\n\r\n[\r\n  [1,   4,  7, 11, 15],\r\n  [2,   5,  8, 12, 19],\r\n  [3,   6,  9, 16, 22],\r\n  [10, 13, 14, 17, 24],\r\n  [18, 21, 23, 26, 30]\r\n]\r\n\r\n\r\nGiven target = 5, return true.\r\nGiven target = 20, return false.", "discussUrl": "https://discuss.leetcode.com/category/301", "similarQuestions": ["Searcha2DMatrix"], "topicTags": ["BinarySearch", "DivideandConquer"], "Solution": "class Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        for (int r = matrix.length-1, c = 0; r >= 0 && c < matrix[0].length;) {\n            if (matrix[r][c] == target) return true;\n            else if (matrix[r][c] > target) {\n                r--;\n            } else {\n                c++;\n            }\n        }\n        return false;\n    }\n}", "total_acs": 101400, "total_submitted": 259389}, {"id": 241, "title": "Different Ways to Add Parentheses", "url": "https://leetcode.com/problems/different-ways-to-add-parentheses/description", "companyTags": [""], "difficulty": "Medium", "content": "Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *.\r\n\r\nExample 1\r\nInput: \"2-1-1\". \r\n((2-1)-1) = 0\r\n(2-(1-1)) = 2\r\nOutput: [0, 2]\r\n\r\nExample 2\r\nInput: \"2*3-4*5\" \r\n(2*(3-(4*5))) = -34\r\n((2*3)-(4*5)) = -14\r\n((2*(3-4))*5) = -10\r\n(2*((3-4)*5)) = -10\r\n(((2*3)-4)*5) = 10\r\nOutput: [-34, -14, -10, -10, 10] \r\n\r\nCredits:Special thanks to @mithmatt for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/302", "similarQuestions": ["UniqueBinarySearchTreesII", "BasicCalculator", "ExpressionAddOperators"], "topicTags": ["DivideandConquer"], "Solution": "\n\n//version 2: search with memorization\n//This problem can also be solved use DP\npublic class Solution {\n    Map<String, List<Integer>> memo = new HashMap<>();\n    public List<Integer> diffWaysToCompute(String input) {\n        if (memo.containsKey(input)) {\n            return memo.get(input);\n        }\n        List<Integer> res = new ArrayList<Integer>();\n        for (int i = 0; i < input.length(); i++) {\n            char c = input.charAt(i);\n            if (c == '-' || c == '+' || c == '*') {\n                List<Integer> leftRes = diffWaysToCompute(input.substring(0, i));\n                List<Integer> rightRes = diffWaysToCompute(input.substring(i+1));\n                for (int left : leftRes) {\n                    for (int right : rightRes) {\n                        if (c == '+') {\n                            res.add(left + right);\n                        } else if (c == '-') {\n                            res.add(left - right);\n                        } else {\n                            res.add(left * right);\n                        }\n                    }\n                }\n            }\n        }\n        if (res.size() == 0) {\n            res.add(Integer.valueOf(input));\n        }\n        memo.put(input, res);\n        return res;\n    }\n}\n\n//version 1: brute force recursion divide big problem into smaller subproblems\n/*public class Solution {\n    public List<Integer> diffWaysToCompute(String input) {\n        List<Integer> res = new ArrayList<Integer>();\n        for (int i = 0; i < input.length(); i++) {\n            char c = input.charAt(i);\n            if (c == '-' || c == '+' || c == '*') {\n                List<Integer> leftRes = diffWaysToCompute(input.substring(0, i));\n                List<Integer> rightRes = diffWaysToCompute(input.substring(i+1));\n                for (int left : leftRes) {\n                    for (int right : rightRes) {\n                        if (c == '+') {\n                            res.add(left + right);\n                        }\n                        else if (c == '-') {\n                            res.add(left - right);\n                        }\n                        else {\n                            res.add(left * right);\n                        }\n                    }\n                }\n            }\n        }\n        if (res.size() == 0) {\n            res.add(Integer.valueOf(input));\n        }\n        return res;\n    }\n}*/", "total_acs": 52823, "total_submitted": 115623}, {"id": 242, "title": "Valid Anagram", "url": "https://leetcode.com/problems/valid-anagram/description", "companyTags": ["Amazon", "Uber", "Yelp"], "difficulty": "Easy", "content": "Given two strings s and t, write a function to determine if t is an anagram of s. \r\n\r\nFor example,\r\ns = \"anagram\", t = \"nagaram\", return true.\r\ns = \"rat\", t = \"car\", return false.\r\n\r\n\r\nNote:\r\nYou may assume the string contains only lowercase alphabets.\r\n\r\nFollow up:\r\nWhat if the inputs contain unicode characters? How would you adapt your solution to such case?", "discussUrl": "https://discuss.leetcode.com/category/303", "similarQuestions": ["GroupAnagrams", "PalindromePermutation", "FindAllAnagramsinaString"], "topicTags": ["HashTable", "Sort"], "Solution": "class Solution {\n    public boolean isAnagram(String s, String t) {\n        int[] chsMap = new int[26];\n        \n        for(char c: s.toCharArray()) {\n            chsMap[c - 'a']++;\n        }\n        \n        for(char c: t.toCharArray()) {\n            chsMap[c- 'a']--;\n        }\n        \n        for(int cnt: chsMap) {\n            if(cnt != 0) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n}", "total_acs": 197169, "total_submitted": 417377}, {"id": 243, "title": "Shortest Word Distance", "url": "https://leetcode.com/problems/shortest-word-distance/description", "companyTags": ["LinkedIn"], "difficulty": "Easy", "content": "Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.\r\nFor example,\r\nAssume that words = [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"].\r\n\r\n\r\nGiven word1 = \u201ccoding\u201d, word2 = \u201cpractice\u201d, return 3.\r\nGiven word1 = \"makes\", word2 = \"coding\", return 1.\r\n\r\n\r\n\r\nNote:\r\nYou may assume that word1 does not equal to word2, and word1 and word2 are both in the list.\r\n", "discussUrl": "https://discuss.leetcode.com/category/304", "similarQuestions": ["ShortestWordDistanceII", "ShortestWordDistanceIII"], "topicTags": ["Array"], "Solution": "/*\n1. need to know the index of one of two words\n2. ask for index difference ??\n3. input: words null, empty, duplicate, order\n          word1 null ? empty, not in words at all\n          wrod2 null ? empty, not in words at all?\n          word1 == word2\n\u6ca1\u4ed4\u7ec6\u8dd1\u5b8c\u4f8b\u5b50\uff0c\u5176\u5b9e\u7b2c\u4e8c\u4e2a\u4f8b\u5b50\u5c31\u544a\u8bc9\u4e24\u4e2a\u4e00\u4e2acorner case\uff0c duplicate\u3002\u6211\u662f\u5728\u89e3\u9898\u8fc7\u7a0b\u4e2d\u81ea\u5df1\u5206\u6790\u51fa\u6765\u7684\n\u521a\u5f00\u59cb\u4ee5\u4e3a\u662f\u4e00\u7ef4\u7684BFS,\u8fd8\u60f3\u5148\u786e\u5b9a\u4e00\u4e2aword\u7684index\uff0c \u518d\u505aBFS\uff0c \u5b8c\u5168\u60f3\u9ebb\u70e6\u4e86\u3002\u3002\u3002\u3002\n\u90a3\u4e3a\u4ec0\u4e48\u6ca1\u6709\u7528\u5462\uff1f\n    1\uff09BFS\u5f97\u77e5\u9053source\n    2) BFS\u662f\u4e00\u79cd\u904d\u5386\uff0c\u800carray\u7684\u904d\u5386\u6839\u672c\u7528\u4e0d\u7740BFS\uff0c\u4e00\u7ef4\u5411\u524d\u5c31\u53ef\u4ee5\u4e86\u3002 \u5982\u679c\u6539\u62102d array,\u7528BFS\u5c31\u6070\u5230\u597d\u5904\u3002\n\n*/\nclass Solution {\n    private static final int NOT_FOUND = -1;\n    public int shortestDistance(String[] words, String word1, String word2) {\n        int p1 = nextIndex(words, word1, 0);\n        int p2 = nextIndex(words, word2, 0);\n        int result = Integer.MAX_VALUE;\n        while (p1 != NOT_FOUND && p2 != NOT_FOUND) {\n            result = Math.min(result, Math.abs(p1 - p2));\n            if (p1 < p2) {\n                p1 = nextIndex(words, word1, p1 + 1);\n            } else {\n                p2 = nextIndex(words, word2, p2 + 1);\n            }\n        }\n        return result;\n    }\n    \n    private static int nextIndex(String[] words, String word, int from) {\n        for (int i = from; i < words.length; i++) {\n            if (words[i].equals(word)) {\n                return i;\n            }\n        }\n        return NOT_FOUND;\n    }\n}", "total_acs": 40867, "total_submitted": 76457}, {"id": 244, "title": "Shortest Word Distance II", "url": "https://leetcode.com/problems/shortest-word-distance-ii/description", "companyTags": ["LinkedIn"], "difficulty": "Medium", "content": "This is a follow up of Shortest Word Distance. The only difference is now you are given the list of words and your method will be called repeatedly many times with different parameters. How would you optimize it?\r\n\r\nDesign a class which receives a list of words in the constructor, and implements a method that takes two words word1 and word2 and return the shortest distance between these two words in the list.\r\n\r\nFor example,\r\nAssume that words = [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"].\r\n\r\n\r\n\r\nGiven word1 = \u201ccoding\u201d, word2 = \u201cpractice\u201d, return 3.\r\nGiven word1 = \"makes\", word2 = \"coding\", return 1.\r\n\r\n\r\n\r\nNote:\r\nYou may assume that word1 does not equal to word2, and word1 and word2 are both in the list.\r\n", "discussUrl": "https://discuss.leetcode.com/category/305", "similarQuestions": ["MergeTwoSortedLists", "ShortestWordDistance", "ShortestWordDistanceIII"], "topicTags": ["HashTable", "Design"], "Solution": "class WordDistance {\n    Map<String, List<Integer>> map = new HashMap<>();\n    public WordDistance(String[] words) {\n        for(int i = 0; i < words.length; i++) {\n            if(!map.containsKey(words[i])) map.put(words[i], new ArrayList<>());\n            map.get(words[i]).add(i);\n        }       \n    }\n    \n    public int shortest(String word1, String word2) {\n        int min = Integer.MAX_VALUE;\n        List<Integer> l1 = map.get(word1);\n        List<Integer> l2 = map.get(word2);\n        for(int i: l1) {\n            for(int j: l2) {\n                min = Math.min(min, Math.abs(i - j));\n            }\n        }\n        return min;\n    }\n}\n\n/**\n * Your WordDistance object will be instantiated and called as such:\n * WordDistance obj = new WordDistance(words);\n * int param_1 = obj.shortest(word1,word2);\n */", "total_acs": 28986, "total_submitted": 71195}, {"id": 245, "title": "Shortest Word Distance III", "url": "https://leetcode.com/problems/shortest-word-distance-iii/description", "companyTags": ["LinkedIn"], "difficulty": "Medium", "content": "This is a follow up of Shortest Word Distance. The only difference is now word1 could be the same as word2.\r\n\r\nGiven a list of words and two words word1 and word2, return the shortest distance between these two words in the list.\r\n\r\nword1 and word2 may be the same and they represent two individual words in the list.\r\nFor example,\r\nAssume that words = [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"].\r\n\r\n\r\nGiven word1 = \u201cmakes\u201d, word2 = \u201ccoding\u201d, return 1.\r\nGiven word1 = \"makes\", word2 = \"makes\", return 3.\r\n\r\n\r\n\r\nNote:\r\nYou may assume word1 and word2 are both in the list.\r\n", "discussUrl": "https://discuss.leetcode.com/category/306", "similarQuestions": ["ShortestWordDistance", "ShortestWordDistanceII"], "topicTags": ["Array"], "Solution": "class Solution {\n    public int shortestWordDistance(String[] words, String word1, String word2) {\n        int p1 = -1, p2 = -1;\n        int ans = Integer.MAX_VALUE;\n        \n        if (word1.equals(word2)) {\n            int pre = Integer.MIN_VALUE, curr = -1;\n            for (int i = 0; i < words.length; i++) {\n                if (words[i].equals(word1)) {\n                    curr = i;\n                    if (pre != Integer.MIN_VALUE) {\n                        ans = Math.min(ans, curr - pre);\n                    }\n                    pre = curr;\n                }\n            }\n            return ans;\n        }\n        \n        for (int i = 0; i < words.length; i++) {\n            if (words[i].equals(word1)) {\n                p1 = i;\n            }\n            if (words[i].equals(word2)) {\n                p2 = i;\n            }\n            if (p1 != -1 && p2 != -1) {\n                ans = Math.min(ans, Math.abs(p1 - p2));\n            }\n        }\n        \n        return ans;\n    }\n}", "total_acs": 25939, "total_submitted": 50695}, {"id": 246, "title": "Strobogrammatic Number", "url": "https://leetcode.com/problems/strobogrammatic-number/description", "companyTags": ["Google"], "difficulty": "Easy", "content": "A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).\r\nWrite a function to determine if a number is strobogrammatic. The number is represented as a string.\r\nFor example, the numbers \"69\", \"88\", and \"818\" are all strobogrammatic.", "discussUrl": "https://discuss.leetcode.com/category/307", "similarQuestions": ["StrobogrammaticNumberII", "StrobogrammaticNumberIII"], "topicTags": ["HashTable", "Math"], "Solution": "class Solution {\n    public boolean isStrobogrammatic(String num) {\n        Map<Character,Character> map=new HashMap<>();\n        map.put('6','9');\n        map.put('9','6');\n        map.put('0','0');\n        map.put('1','1');\n        map.put('8','8');\n        int left=0;\n        int right=num.length()-1;\n        while(left<=right){\n            if(!map.containsKey(num.charAt(left))){\n                return false;\n            }\n            if(map.get(num.charAt(left))!=num.charAt(right)){\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n}", "total_acs": 33258, "total_submitted": 82757}, {"id": 247, "title": "Strobogrammatic Number II", "url": "https://leetcode.com/problems/strobogrammatic-number-ii/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).\r\nFind all strobogrammatic numbers that are of length = n. \r\nFor example,\r\nGiven n = 2, return [\"11\",\"69\",\"88\",\"96\"].\r\n", "discussUrl": "https://discuss.leetcode.com/category/308", "similarQuestions": ["StrobogrammaticNumber", "StrobogrammaticNumberIII"], "topicTags": ["Math", "Recursion"], "Solution": "class Solution {\n    private List<String> res = new ArrayList<String>();\n    // recursively build the strobogrammatic strings\n    public List<String> findStrobogrammatic(int n) {\n        helper(new char[n], 0, n - 1);   //notice we make use of char array\n        return res;\n    }\n    \n    private void helper(char[] a, int l, int r){\n        if (l > r) {\n            res.add(new String(a));\n            return;\n        }\n        if (l == r) {\n            a[l] = '0'; res.add(new String(a));\n            a[l] = '1'; res.add(new String(a));\n            a[l] = '8'; res.add(new String(a));\n            return;\n        }\n\n        if (l != 0) {   //numbers with leading 0 is not valid number\n            a[l] = '0'; a[r] = '0';\n            helper(a, l+1, r-1);\n        }\n        a[l] = '1'; a[r] = '1';\n        helper(a, l+1, r-1);\n        a[l] = '8'; a[r] = '8';\n        helper(a, l+1, r-1);\n        a[l] = '6'; a[r] = '9';\n        helper(a, l+1, r-1);\n        a[l] = '9'; a[r] = '6';\n        helper(a, l+1, r-1);\n    }\n}", "total_acs": 26752, "total_submitted": 65430}, {"id": 248, "title": "Strobogrammatic Number III", "url": "https://leetcode.com/problems/strobogrammatic-number-iii/description", "companyTags": [""], "difficulty": "Hard", "content": "A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).\r\nWrite a function to count the total strobogrammatic numbers that exist in the range of low <= num <= high.\r\nFor example,\r\nGiven low = \"50\", high = \"100\", return 3. Because 69, 88, and 96 are three strobogrammatic numbers.\r\n\r\n\r\nNote:\r\nBecause the range might be a large number, the low and high numbers are represented as string.\r\n", "discussUrl": "https://discuss.leetcode.com/category/309", "similarQuestions": ["StrobogrammaticNumber", "StrobogrammaticNumberII"], "topicTags": ["Math", "Recursion"], "Solution": "class Solution {\n    public int strobogrammaticInRange(String low, String high) {\n        int[] count = {0};\n        for (int len = low.length(); len <= high.length(); len++) {\n            char[] c = new char[len];\n            dfs(low, high, c, 0, len - 1, count);\n        }\n        return count[0];\n    }\n    private static final char[][] pairs = {{'0', '0'}, {'1', '1'}, {'6', '9'}, {'8', '8'}, {'9', '6'}};\n\n    public void dfs(String low, String high , char[] c, int left, int right, int[] count) {\n        if (left > right) {\n            String s = new String(c);\n            if ((s.length() == low.length() && s.compareTo(low) < 0) || \n                (s.length() == high.length() && s.compareTo(high) > 0)) {\n                    return;\n            }\n            count[0]++;\n            return;\n        }\n        for (char[] p : pairs) {\n            c[left] = p[0];\n            c[right] = p[1];\n            if (c.length != 1 && c[0] == '0') {\n                continue;\n            }\n            if (left == right && p[0] != p[1]) {\n                continue;\n            }\n            dfs(low, high, c, left + 1, right - 1, count);\n        }\n    }\n}", "total_acs": 11080, "total_submitted": 34093}, {"id": 249, "title": "Group Shifted Strings", "url": "https://leetcode.com/problems/group-shifted-strings/description", "companyTags": ["Google", "Uber"], "difficulty": "Medium", "content": "Given a string, we can \"shift\" each of its letter to its successive letter, for example: \"abc\" -> \"bcd\". We can keep \"shifting\" which forms the sequence:\r\n\"abc\" -> \"bcd\" -> ... -> \"xyz\"\r\n\r\nGiven a list of strings which contains only lowercase alphabets, group all strings that belong to the same shifting sequence.\r\n\r\nFor example, given: [\"abc\", \"bcd\", \"acef\", \"xyz\", \"az\", \"ba\", \"a\", \"z\"], \r\nA solution is:\r\n\r\n[\r\n  [\"abc\",\"bcd\",\"xyz\"],\r\n  [\"az\",\"ba\"],\r\n  [\"acef\"],\r\n  [\"a\",\"z\"]\r\n]", "discussUrl": "https://discuss.leetcode.com/category/310", "similarQuestions": ["GroupAnagrams"], "topicTags": ["HashTable", "String"], "Solution": "/**\n * \u7db2\u53cb\u5feb\u901f\u89e3\n * \n * */\nclass Solution {\n    public List<List<String>> groupStrings(String[] strings) {\n        List<List<String>> rlists = new ArrayList<>();\n        if(strings==null||strings.length==0){\n            return rlists;\n        }\n        Map<String,List<String>> hashmap = new HashMap<>();\n        for(int i=0;i<strings.length;i++){\n            char[] chars = strings[i].toCharArray();\n            String skey = shiftBack(strings[i]);    //\u4f9d\u7167\u7b2c\u4e00\u500bchar\u628a\u5168\u90e8\u7684char\u90fdshiftback\n            if(!hashmap.containsKey(skey)){\n                List<String> newlist = new ArrayList<>();\n                rlists.add(newlist);\n                newlist.add(strings[i]);\n                hashmap.put(skey,newlist);\n            }\n            else{\n                hashmap.get(skey).add(strings[i]);\n            }\n        }\n        return rlists;\n    }\n    private String shiftBack(String s){\n        char[] chars = s.toCharArray();\n        char firstC = chars[0];\n        for(int i=0;i<chars.length;i++){\n            chars[i] = (char)((chars[i]-firstC+26)%26);\n        }\n        String news = new String(chars);\n        return news;\n    }\n}", "total_acs": 31401, "total_submitted": 71961}, {"id": 250, "title": "Count Univalue Subtrees", "url": "https://leetcode.com/problems/count-univalue-subtrees/description", "companyTags": [""], "difficulty": "Medium", "content": "Given a binary tree, count the number of uni-value subtrees.\r\nA Uni-value subtree means all nodes of the subtree have the same value.\r\n\r\n\r\nFor example:\r\nGiven binary tree,\r\n\r\n              5\r\n             / \\\r\n            1   5\r\n           / \\   \\\r\n          5   5   5\r\n\r\n\r\n\r\nreturn 4.\r\n", "discussUrl": "https://discuss.leetcode.com/category/311", "similarQuestions": ["SubtreeofAnotherTree", "LongestUnivaluePath"], "topicTags": ["Tree"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    \n    //\u5199\u7684\u597d\u590d\u6742\uff0c\u4f46\u662f\u7adf\u7136\u4e00\u6b21\u901a\u8fc7\u4e86\n    //\u7a0d\u5fae\u4f18\u5316\u4e86\u4e00\u4e0b\n    public int countUnivalSubtrees(TreeNode root) {\n        int[] count = {0};\n        dfsHelper(root, count);\n        return count[0];\n    }\n    public int dfsHelper(TreeNode root, int[] count) { // return the num of subtrees from this root\n        if (root == null) return 0;\n        // if it's leaf node\n        if (root.left == null && root.right == null) {\n            count[0]++;\n            return 1;\n        }\n        int leftCount = dfsHelper(root.left, count); // is 0 if has no left child\n        int rightCount = dfsHelper(root.right, count); // is 0 if has no right child\n        // if has left only\n        if (root.left != null && root.right == null) {\n            if (root.val == root.left.val && leftCount != 0) {\n                count[0]++;\n                return leftCount + 1;\n            } else return 0;\n        }\n        // if has right only\n        if (root.left == null && root.right != null) {\n            if (root.val == root.right.val && rightCount != 0) {\n                count[0]++;\n                return rightCount + 1;\n            } else return 0;\n        }\n        // if has both\n        if (root.val == root.left.val && root.val == root.right.val && leftCount > 0 && rightCount > 0) {\n            count[0]++;\n            return 1;\n        } else return 0;\n    }\n    \n    \n// [5,1,5,4,5,null,5]\n// [5,5,4,1,5,null,null,5,null,null,null,5,5]\n}", "total_acs": 20551, "total_submitted": 47190}, {"id": 251, "title": "Flatten 2D Vector", "url": "https://leetcode.com/problems/flatten-2d-vector/description", "companyTags": ["Google", "Twitter", "Airbnb", "Zenefits"], "difficulty": "Medium", "content": "\r\nImplement an iterator to flatten a 2d vector.\r\n\r\n\r\nFor example,\r\nGiven 2d vector = \r\n\r\n[\r\n  [1,2],\r\n  [3],\r\n  [4,5,6]\r\n]\r\n\r\n\r\n\r\nBy calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,2,3,4,5,6].\r\n\r\n\r\n\r\nFollow up:\r\nAs an added challenge, try to code it using only iterators in C++ or iterators in Java.\r\n", "discussUrl": "https://discuss.leetcode.com/category/312", "similarQuestions": ["BinarySearchTreeIterator", "ZigzagIterator", "PeekingIterator", "FlattenNestedListIterator"], "topicTags": ["Design"], "Solution": "public class Vector2D implements Iterator<Integer> {\n    int indexList, indexEle;\n    List<List<Integer>> vec;\n    \n    public Vector2D(List<List<Integer>> vec2d) {\n        vec = vec2d;\n        indexList = 0;\n        indexEle = 0;\n    }\n\n    @Override\n    public Integer next() {\n        return vec.get(indexList).get(indexEle++);\n    }\n\n    @Override\n    public boolean hasNext() {\n        while (indexList<vec.size())    {\n            if (indexEle < vec.get(indexList).size())\n                return true;\n            else    {\n                indexList++;\n                indexEle=0;\n            }\n        }\n        return false;\n    }\n}\n\n/**\n * Your Vector2D object will be instantiated and called as such:\n * Vector2D i = new Vector2D(vec2d);\n * while (i.hasNext()) v[f()] = i.next();\n */", "total_acs": 34056, "total_submitted": 82644}, {"id": 252, "title": "Meeting Rooms", "url": "https://leetcode.com/problems/meeting-rooms/description", "companyTags": ["Facebook"], "difficulty": "Easy", "content": "Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si < ei), determine if a person could attend all meetings.\r\n\r\n\r\nFor example,\r\nGiven [[0, 30],[5, 10],[15, 20]],\r\nreturn false.\r\n", "discussUrl": "https://discuss.leetcode.com/category/316", "similarQuestions": ["MergeIntervals", "MeetingRoomsII"], "topicTags": ["Sort"], "Solution": "/**\n * Definition for an interval.\n * public class Interval {\n *     int start;\n *     int end;\n *     Interval() { start = 0; end = 0; }\n *     Interval(int s, int e) { start = s; end = e; }\n * }\n */\nclass Solution {\n    public boolean canAttendMeetings(Interval[] intervals) {\n        quickSort(intervals,0,intervals.length-1);\n        for(int i=1;i<intervals.length;i++){\n            if(intervals[i].start<intervals[i-1].end)\n                return false;\n        }\n        return true;\n    }\n    private int partition(Interval[] intervals,int b,int e){\n        int pv=intervals[(b+e)/2].start;\n        while(b<=e){\n            while(intervals[b].start<pv)\n                b++;\n            while(intervals[e].start>pv)\n                e--;\n            if(b<=e){\n            Interval t=intervals[b];\n            intervals[b]=intervals[e];\n            intervals[e]=t;\n            b++;\n            e--;\n            }          \n        }\n        return b;\n        \n    }\n    private void quickSort(Interval[] intervals,int i,int j){\n        if(i>=j)\n            return;\n        int m=partition(intervals,i,j);\n        quickSort(intervals,i,m-1);\n        quickSort(intervals,m,j);\n        \n    }\n}", "total_acs": 45617, "total_submitted": 93488}, {"id": 253, "title": "Meeting Rooms II", "url": "https://leetcode.com/problems/meeting-rooms-ii/description", "companyTags": ["Google", "Facebook", "Snapchat"], "difficulty": "Medium", "content": "Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si < ei), find the minimum number of conference rooms required.\r\n\r\n\r\nFor example,\r\nGiven [[0, 30],[5, 10],[15, 20]],\r\nreturn 2.\r\n", "discussUrl": "https://discuss.leetcode.com/category/317", "similarQuestions": ["MergeIntervals", "MeetingRooms", "MinimumNumberofArrowstoBurstBalloons"], "topicTags": ["Heap", "Greedy", "Sort"], "Solution": "/**\n * Definition for an interval.\n * public class Interval {\n *     int start;\n *     int end;\n *     Interval() { start = 0; end = 0; }\n *     Interval(int s, int e) { start = s; end = e; }\n * }\n */\nclass Solution {\n    public int minMeetingRooms(Interval[] intervals) {\n        if (intervals.length < 1 || intervals == null) return 0;\n        int[] stts = new int[intervals.length];\n        int[] ends = new int[intervals.length];\n        for (int i = 0; i < intervals.length; i++) {\n            stts[i] = intervals[i].start;\n            ends[i] = intervals[i].end;\n        }\n        Arrays.sort(stts);\n        Arrays.sort(ends);\n        int cnt = 0;\n        int idx = 0;\n        for (int i = 0; i < stts.length; i++) {\n            if (stts[i] < ends[idx]) cnt++;\n            else                     idx++;\n        }\n        return cnt;\n    }\n}", "total_acs": 61096, "total_submitted": 154619}, {"id": 254, "title": "Factor Combinations", "url": "https://leetcode.com/problems/factor-combinations/description", "companyTags": ["Uber", "LinkedIn"], "difficulty": "Medium", "content": "Numbers can be regarded as product of its factors. For example,  \r\n\r\n8 = 2 x 2 x 2;\r\n  = 2 x 4.\r\n\r\nWrite a function that takes an integer n and return all possible combinations of its factors. \r\n\r\n\r\nNote: \r\n\r\nYou may assume that n is always positive. \r\nFactors should be greater than 1 and less than n.\r\n\r\n\r\n\r\nExamples: \r\n input: 1\r\n output: \r\n\r\n[]\r\n\r\ninput: 37\r\n output: \r\n\r\n[]\r\n\r\n input: 12\r\n output:\r\n\r\n[\r\n  [2, 6],\r\n  [2, 2, 3],\r\n  [3, 4]\r\n]\r\n\r\n input: 32\r\n output:\r\n\r\n[\r\n  [2, 16],\r\n  [2, 2, 8],\r\n  [2, 2, 2, 4],\r\n  [2, 2, 2, 2, 2],\r\n  [2, 4, 4],\r\n  [4, 8]\r\n]\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/320", "similarQuestions": ["CombinationSum"], "topicTags": ["Backtracking"], "Solution": "class Solution {\n    private void dfs(List<List<Integer>> res, List<Integer> path, int n, int prev) {\n        for (int i = prev; i <= (int) Math.sqrt(n * 1.0); i++) {\n            if (n % i == 0) {\n                List<Integer> one = new ArrayList<>(path);\n                one.add(i);\n                one.add(n / i);\n                res.add(one);\n                path.add(i);\n                dfs(res, path, n / i, i);\n                path.remove(path.size() - 1);\n            }\n        }\n    }\n\n    public List<List<Integer>> getFactors(int n) {\n        List<List<Integer>> res = new ArrayList<>();\n        if (n < 4) {\n            return res;\n        }\n        \n        dfs(res, new ArrayList<>(), n, 2);\n        return res;\n    }\n}", "total_acs": 35315, "total_submitted": 80697}, {"id": 255, "title": "Verify Preorder Sequence in Binary Search Tree", "url": "https://leetcode.com/problems/verify-preorder-sequence-in-binary-search-tree/description", "companyTags": ["Zenefits"], "difficulty": "Medium", "content": "Given an array of numbers, verify whether it is the correct preorder traversal sequence of a binary search tree.\r\n\r\nYou may assume each number in the sequence is unique.\r\n\r\nFollow up:\r\nCould you do it using only constant space complexity?", "discussUrl": "https://discuss.leetcode.com/category/322", "similarQuestions": ["BinaryTreePreorderTraversal"], "topicTags": ["Stack", "Tree"], "Solution": "class Solution {\n    public boolean verifyPreorder(int[] preorder) {\n        // in-place stack check\n        \n        if (preorder == null || preorder.length < 1)\n            return true;\n        \n        int top = -1;\n        int sublevel = Integer.MIN_VALUE;\n        for (int x : preorder) {\n            if (x < sublevel)\n                return false;\n            while (top >= 0 && preorder[top] < x) {\n                // pop\n                sublevel = preorder[top--];\n            }\n            \n            // push\n            preorder[++top] = x;\n        }\n        \n        \n        return true;\n    }\n}", "total_acs": 23831, "total_submitted": 58301}, {"id": 256, "title": "Paint House", "url": "https://leetcode.com/problems/paint-house/description", "companyTags": ["LinkedIn"], "difficulty": "Easy", "content": "\r\nThere are a row of n houses, each house can be painted with one of the three colors: red, blue or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.\r\n\r\n\r\nThe cost of painting each house with a certain color is represented by a n x 3 cost matrix. For example, costs[0][0] is the cost of painting house 0 with color red; costs[1][2] is the cost of painting house 1 with color green, and so on... Find the minimum cost to paint all houses.\r\n\r\n\r\nNote:\r\nAll costs are positive integers.", "discussUrl": "https://discuss.leetcode.com/category/324", "similarQuestions": ["HouseRobber", "HouseRobberII", "PaintHouseII", "PaintFence"], "topicTags": ["DynamicProgramming"], "Solution": "class Solution {\n    public int minCost(int[][] costs) {\n        if (costs == null || costs.length == 0) \n            return 0;\n        int n = costs.length;\n        for (int i = 1; i < n; i++) {\n            costs[i][0] += Math.min(costs[i - 1][1], costs[i - 1][2]);\n            costs[i][1] += Math.min(costs[i - 1][0], costs[i - 1][2]);\n            costs[i][2] += Math.min(costs[i - 1][0], costs[i - 1][1]);\n        }\n        \n        return Math.min(Math.min(costs[n - 1][0], costs[n - 1][1]), costs[n - 1][2]);\n    }\n}", "total_acs": 32102, "total_submitted": 69429}, {"id": 257, "title": "Binary Tree Paths", "url": "https://leetcode.com/problems/binary-tree-paths/description", "companyTags": ["Google", "Facebook", "Apple"], "difficulty": "Easy", "content": "\r\nGiven a binary tree, return all root-to-leaf paths.\r\n\r\n\r\nFor example, given the following binary tree:\r\n\r\n\r\n\r\n   1\r\n /   \\\r\n2     3\r\n \\\r\n  5\r\n\r\n\r\n\r\nAll root-to-leaf paths are:\r\n[\"1->2->5\", \"1->3\"]\r\n\r\n\r\nCredits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/325", "similarQuestions": ["PathSumII"], "topicTags": ["Tree", "Depth-firstSearch"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<String> binaryTreePaths(TreeNode root) {\n        List<String> res = new ArrayList<String>();\n        if(root==null) return res;\n        dfs(root,res,\"\");\n        return res;\n        \n    }\n    public void dfs(TreeNode root, List<String> res, String path){\n        if(root==null) return;\n        \n        if(root.left==null && root.right==null){\n            res.add(path+root.val+\"\");\n        }\n        \n        dfs(root.left, res, path+root.val+\"->\");\n        dfs(root.right, res, path+root.val+\"->\");\n    }\n}", "total_acs": 146263, "total_submitted": 360049}, {"id": 258, "title": "Add Digits", "url": "https://leetcode.com/problems/add-digits/description", "companyTags": ["Microsoft", "Adobe"], "difficulty": "Easy", "content": "\r\nGiven a non-negative integer num, repeatedly add all its digits until the result has only one digit. \r\n\r\n\r\n\r\nFor example:\r\n\r\n\r\nGiven num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.\r\n\r\n\r\nFollow up:\r\nCould you do it without any loop/recursion in O(1) runtime?\r\n\r\n\r\nCredits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/326", "similarQuestions": ["HappyNumber"], "topicTags": ["Math"], "Solution": "class Solution {\n    \n    \n    public int addDigits(int num) {\n        return (num - 1) % 9 + 1;\n    }\n    \n    // public int addDigits(int num) {\n    //     if (num < 0) {\n    //         num = -num;\n    //     }\n    //     if (num < 10) {\n    //         return num;\n    //     }\n    //     int next = 0;\n    //     while (num != 0) {\n    //         next += (num % 10);\n    //         num /= 10;\n    //     }\n    //     return addDigits(next);\n    // }\n}", "total_acs": 187909, "total_submitted": 363642}, {"id": 259, "title": "3Sum Smaller", "url": "https://leetcode.com/problems/3sum-smaller/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "Given an array of n integers nums and a target, find the number of index triplets i, j, k with 0 <= i < j < k < n that satisfy the condition nums[i] + nums[j] + nums[k] < target.\r\n\r\nFor example, given nums = [-2, 0, 1, 3], and target = 2.\r\n\r\nReturn 2. Because there are two triplets which sums are less than 2:\r\n\r\n[-2, 0, 1]\r\n[-2, 0, 3]\r\n\r\n\r\nFollow up:\r\nCould you solve it in O(n2) runtime?\r\n", "discussUrl": "https://discuss.leetcode.com/category/327", "similarQuestions": ["3Sum", "3SumClosest", "ValidTriangleNumber"], "topicTags": ["Array", "TwoPointers"], "Solution": "class Solution {\n    public int threeSumSmaller(int[] nums, int target) {\n        Arrays.sort(nums);\n        \n        int cnt = 0;\n        for (int i=0; i<nums.length-1; i++) {\n            int low = i+1, high = nums.length-1;\n            while (low<high) {\n               if (nums[i]+nums[low]+nums[high] < target) {\n                    cnt += high - low;\n                    low++;\n                } else {\n                    high--;\n                } \n            }\n        }\n        \n        return cnt;\n    }\n}", "total_acs": 33652, "total_submitted": 80233}, {"id": 260, "title": "Single Number III", "url": "https://leetcode.com/problems/single-number-iii/description", "companyTags": [""], "difficulty": "Medium", "content": "\r\nGiven an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.\r\n\r\n\r\nFor example:\r\n\r\n\r\nGiven nums = [1, 2, 1, 3, 2, 5], return [3, 5].\r\n\r\n\r\nNote:\r\n\r\nThe order of the result is not important. So in the above example, [5, 3] is also correct.\r\nYour algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?\r\n\r\n\r\n\r\nCredits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/328", "similarQuestions": ["SingleNumber", "SingleNumberII"], "topicTags": ["BitManipulation"], "Solution": "class Solution {\n    public int[] singleNumber(int[] nums) {\n        if(nums == null || nums.length <= 1)\n            return new int[2];\n        int diff = nums[0];\n        for(int i = 1; i<nums.length; i++){\n            diff ^= nums[i];\n        }\n        diff &= -diff;\n        int res1 = 0, res2 = 0;\n        for(int num:nums){\n            if((num & diff) == 0){\n                res1 ^= num;\n            }\n            else{\n                res2 ^= num;\n            }\n        }\n        return new int[]{res1, res2};\n    }\n}", "total_acs": 78191, "total_submitted": 147983}, {"id": 261, "title": "Graph Valid Tree", "url": "https://leetcode.com/problems/graph-valid-tree/description", "companyTags": ["Google", "Facebook", "Zenefits"], "difficulty": "Medium", "content": "\r\nGiven n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.\r\n\r\n\r\n\r\nFor example:\r\n\r\n\r\nGiven n = 5 and edges = [[0, 1], [0, 2], [0, 3], [1, 4]], return true.\r\n\r\n\r\nGiven n = 5 and edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]], return false.\r\n\r\n\r\n\r\nNote: you can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.\r\n", "discussUrl": "https://discuss.leetcode.com/category/330", "similarQuestions": ["CourseSchedule", "NumberofConnectedComponentsinanUndirectedGraph"], "topicTags": ["Depth-firstSearch", "Breadth-firstSearch", "UnionFind", "Graph"], "Solution": "class Solution {\n    public boolean validTree(int n, int[][] edges) {\n        // initialize n isolated islands\n        int[] nums = new int[n];\n        Arrays.fill(nums, -1);\n        \n        // perform union find\n        for (int i = 0; i < edges.length; i++) {\n            int x = find(nums, edges[i][0]);\n            int y = find(nums, edges[i][1]);\n            \n            // if two vertices happen to be in the same set\n            // then there's a cycle\n            if (x == y) return false;\n            \n            // union\n            nums[x] = y;\n        }\n        \n        return edges.length == n - 1;\n    }\n    \n    int find(int nums[], int i) {\n        if (nums[i] == -1) return i;\n        return find(nums, nums[i]);\n    }\n}", "total_acs": 50681, "total_submitted": 132064}, {"id": 262, "title": "Trips and Users", "url": "https://leetcode.com/problems/trips-and-users/description", "companyTags": ["Uber"], "difficulty": "Hard", "content": "\r\nThe Trips table holds all taxi trips. Each trip has a unique Id, while Client_Id and Driver_Id are both foreign keys to the Users_Id at the Users table. Status is an ENUM type of (\u2018completed\u2019, \u2018cancelled_by_driver\u2019, \u2018cancelled_by_client\u2019).\r\n\r\n\r\n+----+-----------+-----------+---------+--------------------+----------+\r\n| Id | Client_Id | Driver_Id | City_Id |        Status      |Request_at|\r\n+----+-----------+-----------+---------+--------------------+----------+\r\n| 1  |     1     |    10     |    1    |     completed      |2013-10-01|\r\n| 2  |     2     |    11     |    1    | cancelled_by_driver|2013-10-01|\r\n| 3  |     3     |    12     |    6    |     completed      |2013-10-01|\r\n| 4  |     4     |    13     |    6    | cancelled_by_client|2013-10-01|\r\n| 5  |     1     |    10     |    1    |     completed      |2013-10-02|\r\n| 6  |     2     |    11     |    6    |     completed      |2013-10-02|\r\n| 7  |     3     |    12     |    6    |     completed      |2013-10-02|\r\n| 8  |     2     |    12     |    12   |     completed      |2013-10-03|\r\n| 9  |     3     |    10     |    12   |     completed      |2013-10-03| \r\n| 10 |     4     |    13     |    12   | cancelled_by_driver|2013-10-03|\r\n+----+-----------+-----------+---------+--------------------+----------+\r\n\r\n\r\n\r\nThe Users table holds all users. Each user has an unique Users_Id, and Role is an ENUM type of (\u2018client\u2019, \u2018driver\u2019, \u2018partner\u2019).\r\n\r\n+----------+--------+--------+\r\n| Users_Id | Banned |  Role  |\r\n+----------+--------+--------+\r\n|    1     |   No   | client |\r\n|    2     |   Yes  | client |\r\n|    3     |   No   | client |\r\n|    4     |   No   | client |\r\n|    10    |   No   | driver |\r\n|    11    |   No   | driver |\r\n|    12    |   No   | driver |\r\n|    13    |   No   | driver |\r\n+----------+--------+--------+\r\n\r\n\r\nWrite a SQL query to find the cancellation rate of requests made by unbanned clients between Oct 1, 2013 and Oct 3, 2013. For the above tables, your SQL query should return the following rows with the cancellation rate being rounded to two decimal places.\r\n\r\n+------------+-------------------+\r\n|     Day    | Cancellation Rate |\r\n+------------+-------------------+\r\n| 2013-10-01 |       0.33        |\r\n| 2013-10-02 |       0.00        |\r\n| 2013-10-03 |       0.50        |\r\n+------------+-------------------+\r\n\r\n\r\nCredits:Special thanks to @cak1erlizhou for contributing this question, writing the problem description and adding part of the test cases.", "discussUrl": "https://discuss.leetcode.com/category/331", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 16312, "total_submitted": 85907}, {"id": 263, "title": "Ugly Number", "url": "https://leetcode.com/problems/ugly-number/description", "companyTags": [""], "difficulty": "Easy", "content": "\r\nWrite a program to check whether a given number is an ugly number.\r\n\r\n\r\n\r\nUgly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7.\r\n\r\n\r\n\r\nNote that 1 is typically treated as an ugly number.\r\n\r\n\r\nCredits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/332", "similarQuestions": ["HappyNumber", "CountPrimes", "UglyNumberII"], "topicTags": ["Math"], "Solution": "public class Solution {\r\n    public boolean isUgly(int num) {\r\n        while (num >= 2) {\r\n            if (num % 2 == 0) {\r\n                num /= 2;\r\n            }\r\n            else if (num % 3 == 0) {\r\n                num /= 3;\r\n            }\r\n            else if (num % 5 == 0) {\r\n                num /= 5;\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n        \r\n        return num == 1;\r\n    }\r\n}", "total_acs": 117640, "total_submitted": 297228}, {"id": 264, "title": "Ugly Number II", "url": "https://leetcode.com/problems/ugly-number-ii/description", "companyTags": [""], "difficulty": "Medium", "content": "\r\nWrite a program to find the n-th ugly number.\r\n\r\n\r\n\r\nUgly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.\r\n\r\n\r\n\r\nNote that 1 is typically treated as an ugly number, and n does not exceed 1690.\r\n\r\n\r\nCredits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/333", "similarQuestions": ["MergekSortedLists", "CountPrimes", "UglyNumber", "PerfectSquares", "SuperUglyNumber"], "topicTags": ["Math", "DynamicProgramming", "Heap"], "Solution": "class Solution {\n\tstatic int count = 2;\n\tstatic int idx2 = 1;\n\tstatic int idx3 = 1;\n\tstatic int idx5 = 1;\n\tstatic long arr[] = new long[2000];\n    public int nthUglyNumber(int n) {\n    \tarr[1] = 1;\n        for (; count <= n; count++) {\n        \tlong ftr2 = arr[idx2] * 2;\n        \tlong ftr3 = arr[idx3] * 3;\n        \tlong ftr5 = arr[idx5] * 5;\n        \tarr[count] = Math.min(Math.min(ftr2, ftr3), ftr5);\n        \tif (arr[count] == ftr2) idx2++;\n        \tif (arr[count] == ftr3) idx3++;\n        \tif (arr[count] == ftr5) idx5++;\n        }\n        return (int)arr[n];\n    }\n}", "total_acs": 70732, "total_submitted": 212830}, {"id": 265, "title": "Paint House II", "url": "https://leetcode.com/problems/paint-house-ii/description", "companyTags": ["Facebook"], "difficulty": "Hard", "content": "\r\nThere are a row of n houses, each house can be painted with one of the k colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.\r\n\r\n\r\nThe cost of painting each house with a certain color is represented by a n x k cost matrix. For example, costs[0][0] is the cost of painting house 0 with color 0; costs[1][2] is the cost of painting house 1 with color 2, and so on... Find the minimum cost to paint all houses.\r\n\r\n\r\nNote:\r\nAll costs are positive integers.\r\n\r\nFollow up:\r\nCould you solve it in O(nk) runtime?", "discussUrl": "https://discuss.leetcode.com/category/334", "similarQuestions": ["ProductofArrayExceptSelf", "SlidingWindowMaximum", "PaintHouse", "PaintFence"], "topicTags": ["DynamicProgramming"], "Solution": "class Solution {\n    public int minCostII(int[][] costs) {\n        int prevMin1 = 0, prevMin2 = 0, prevMinIndex1 = 0;\n        for (int[] cost : costs) {\n            int min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE, minIndex1 = 0;\n            \n            for (int i = 0; i < cost.length; i++) {\n                int curr = cost[i];\n                if (i == prevMinIndex1) {\n                    curr += prevMin2;\n                } else {\n                    curr += prevMin1;\n                }\n                \n                if (curr < min1) {\n                    min2 = min1;\n                    min1 = curr;\n                    minIndex1 = i;\n                } else if (curr < min2) {\n                    min2 = curr;\n                }\n            }\n            \n            prevMin1 = min1;\n            prevMin2 = min2;\n            prevMinIndex1 = minIndex1;\n        }\n        \n        return prevMin1;\n    }\n}", "total_acs": 28634, "total_submitted": 74687}, {"id": 266, "title": "Palindrome Permutation", "url": "https://leetcode.com/problems/palindrome-permutation/description", "companyTags": ["Google", "Bloomberg", "Uber"], "difficulty": "Easy", "content": "Given a string, determine if a permutation of the string could form a palindrome.\r\n\r\nFor example,\r\n\"code\" -> False, \"aab\" -> True, \"carerac\" -> True.\r\n", "discussUrl": "https://discuss.leetcode.com/category/335", "similarQuestions": ["LongestPalindromicSubstring", "ValidAnagram", "PalindromePermutationII", "LongestPalindrome"], "topicTags": ["HashTable"], "Solution": "public class Solution {\r\n    public boolean canPermutePalindrome(String s) {\r\n        \r\n        int[] chars = new int[256];\r\n        int oddNum=0;\r\n        \r\n        for(char c : s.toCharArray()){\r\n            chars[c]++;\r\n        }\r\n        \r\n        for(int i : chars){\r\n            if(i%2==1)  oddNum++;\r\n        }\r\n        \r\n        return oddNum<=1? true:false;\r\n        \r\n    }\r\n}", "total_acs": 41819, "total_submitted": 72118}, {"id": 267, "title": "Palindrome Permutation II", "url": "https://leetcode.com/problems/palindrome-permutation-ii/description", "companyTags": [""], "difficulty": "Medium", "content": "\r\nGiven a string s, return all the palindromic permutations (without duplicates) of it. Return an empty list if no palindromic permutation could be form.\r\n\r\n\r\nFor example:\r\n\r\n\r\nGiven s = \"aabb\", return [\"abba\", \"baab\"].\r\n\r\n\r\nGiven s = \"abc\", return [].\r\n", "discussUrl": "https://discuss.leetcode.com/category/336", "similarQuestions": ["NextPermutation", "PermutationsII", "PalindromePermutation"], "topicTags": ["Backtracking"], "Solution": "class Solution {\n    public List<String> generatePalindromes(String s) {\n        List<String> result = new ArrayList<String>();\n        int[] temp = new int[256];\n        for (int i = 0; i < s.length(); i++) {\n            temp[s.charAt(i)]++;\n        }\n        int odd = 0, idx = 0;\n        char[] array = new char[s.length()];\n        for (int i = 0; i < 256; i++) {\n            if ((temp[i] & 1) == 1) {\n                if ((s.length() & 1) == 0 || ++odd > 1) {\n                    return result;\n                }\n                array[s.length() / 2] = (char)i;\n                temp[i]--;\n            }\n            while (temp[i] > 0) {\n                array[idx] = array[array.length - (++idx)] = (char)i;\n                temp[i] -= 2;\n            }\n        }\n        permute(array, 0, result);\n        return result;\n    }\n    \n    public void permute(char[] array, int idx, List<String> result) {\n        if (idx == array.length / 2) {\n            result.add(new String(array));\n            return;\n        }\n        \n        for (int i = idx; i < array.length / 2; i++) {\n            int j = idx;\n            for (; j < i && array[j] != array[i]; j++);\n            if (j == i) {\n                swap(array, idx, i);\n                swap(array, array.length - 1 - idx, array.length - 1 - i);\n                permute(array, idx + 1, result);\n                swap(array, idx, i);\n                swap(array, array.length - 1 - idx, array.length - 1 - i);\n            }\n        }\n    }\n    \n    public void swap(char[] array, int i, int j) {\n        char t = array[i];\n        array[i] = array[j];\n        array[j] = t;\n    }\n}", "total_acs": 17000, "total_submitted": 52902}, {"id": 268, "title": "Missing Number", "url": "https://leetcode.com/problems/missing-number/description", "companyTags": ["Microsoft", "Bloomberg"], "difficulty": "Easy", "content": "\r\nGiven an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.\r\n\r\n\r\nExample 1\r\n\r\nInput: [3,0,1]\r\nOutput: 2\r\n\r\n\r\n\r\nExample 2\r\n\r\nInput: [9,6,4,2,3,5,7,0,1]\r\nOutput: 8\r\n\r\n\r\n\r\n\r\n\r\nNote:\r\nYour algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?\r\n\r\n\r\nCredits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/337", "similarQuestions": ["FirstMissingPositive", "SingleNumber", "FindtheDuplicateNumber", "CouplesHoldingHands"], "topicTags": ["Array", "Math", "BitManipulation"], "Solution": "class Solution {\n    public int missingNumber(int[] nums) {\n        int total = 0;\n        for(int i = 1; i <= nums.length ;i++ ){\n            total += i;\n        }\n        for(int n : nums){\n            total -= n;\n        }\n        return total;\n    }\n}", "total_acs": 156091, "total_submitted": 348705}, {"id": 269, "title": "Alien Dictionary", "url": "https://leetcode.com/problems/alien-dictionary/description", "companyTags": ["Google", "Facebook", "Twitter", "Snapchat", "Airbnb", "PocketGems"], "difficulty": "Hard", "content": "\r\nThere is a new alien language which uses the latin alphabet. \r\nHowever, the order among letters are unknown to you. \r\nYou receive a list of non-empty words from the dictionary, where words are sorted lexicographically by the rules of this new language.\r\nDerive the order of letters in this language.\r\n\r\n\r\n\r\nExample 1:\r\nGiven the following words in dictionary,\r\n\r\n[\r\n  \"wrt\",\r\n  \"wrf\",\r\n  \"er\",\r\n  \"ett\",\r\n  \"rftt\"\r\n]\r\n\r\n\r\n\r\nThe correct order is: \"wertf\".\r\n\r\n\r\nExample 2:\r\nGiven the following words in dictionary,\r\n\r\n[\r\n  \"z\",\r\n  \"x\"\r\n]\r\n\r\n\r\n\r\nThe correct order is: \"zx\".\r\n\r\n\r\nExample 3:\r\nGiven the following words in dictionary,\r\n\r\n[\r\n  \"z\",\r\n  \"x\",\r\n  \"z\"\r\n]\r\n\r\n\r\n\r\nThe order is invalid, so return \"\".\r\n\r\nNote:\r\n\r\nYou may assume all letters are in lowercase.\r\nYou may assume that if a is a prefix of b, then a must appear before b in the given dictionary.\r\nIf the order is invalid, return an empty string.\r\nThere may be multiple valid order of letters, return any one of them is fine.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/338", "similarQuestions": ["CourseScheduleII"], "topicTags": ["Graph", "TopologicalSort"], "Solution": "class Solution {\n    public String alienOrder(String[] words) {\n        boolean[][] graph = new boolean[26][26];\n        int[] visited = new int[26];\n        buildGraph(words, graph, visited);\n\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < 26; i++) {\n            if (visited[i] == 0) {\n                if (!dfs(graph, visited, i, sb)) return \"\";\n            }\n        }\n        return sb.reverse().toString();\n    }\n\n    private boolean dfs(boolean[][] graph, int[] visited, int i, StringBuilder ret) {\n        visited[i] = 1;\n        boolean[] temp = graph[i];\n        for (int j = 0; j < temp.length; j++) {\n            if(temp[j]){\n                if (visited[j] == 1) \n                    return false;\n                else if (visited[j] == 0 && !dfs(graph, visited, j, ret)) {\n                    return false;\n                }                \n            }\n        }\n        visited[i] = 2;\n        ret.append((char)(i + 'a'));\n        return true;\n    }\n\n    private void buildGraph(String[] words, boolean[][] graph, int[] visited) {\n        Arrays.fill(visited, -1);\n        int N = words.length;\n        \n        for (String word : words) {\n            for (char c : word.toCharArray()) {\n                visited[c - 'a'] = 0;\n            }\n        }\n        \n        for (int i = 0; i < N - 1; i++) {\n            char[] a = words[i].toCharArray();\n            char[] b = words[i + 1].toCharArray();\n            for (int j = 0; j < Math.min(a.length, b.length); j++) {\n                if (a[j] != b[j]) {\n                    graph[a[j] - 'a'][b[j] - 'a'] = true;\n                    break;\n                }\n            }\n        }\n    }\n}", "total_acs": 37030, "total_submitted": 142563}, {"id": 270, "title": "Closest Binary Search Tree Value", "url": "https://leetcode.com/problems/closest-binary-search-tree-value/description", "companyTags": ["Google", "Microsoft", "Snapchat"], "difficulty": "Easy", "content": "\r\nGiven a non-empty binary search tree and a target value, find the value in the BST that is closest to the target.\r\n\r\nNote:\r\n\r\nGiven target value is a floating point.\r\nYou are guaranteed to have only one unique value in the BST that is closest to the target.\r\n", "discussUrl": "https://discuss.leetcode.com/category/339", "similarQuestions": ["CountCompleteTreeNodes", "ClosestBinarySearchTreeValueII"], "topicTags": ["BinarySearch", "Tree"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    \n    private double minDiff;\n    private int val;\n    \n    public int closestValue(TreeNode root, double target) {\n        \n        minDiff = Math.abs(target-(double)root.val);\n        \n        val = root.val;\n        closeValue(root, target);\n        return val;\n    }\n    \n    private void closeValue(TreeNode node, double target) {\n\n        if(node == null) return;\n\n        double diff = Math.abs(target-(double)node.val);\n        //System.out.println(node.val+\" \"+diff);\n\n       if(diff < minDiff) {\n            //System.out.println(node.val+\" \"+diff+\" YYY\");\n            minDiff = diff;\n            val = node.val;\n        }\n\n        closeValue(node.left, target);\n        closeValue(node.right, target);\n    }\n}", "total_acs": 46479, "total_submitted": 114842}, {"id": 271, "title": "Encode and Decode Strings", "url": "https://leetcode.com/problems/encode-and-decode-strings/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "\r\nDesign an algorithm to encode a list of strings to a string. The encoded string is then sent over the network and is decoded back to the original list of strings.\r\n\r\n\r\nMachine 1 (sender) has the function:\r\n\r\nstring encode(vector<string> strs) {\r\n  // ... your code\r\n  return encoded_string;\r\n}\r\n\r\nMachine 2 (receiver) has the function:\r\n\r\nvector<string> decode(string s) {\r\n  //... your code\r\n  return strs;\r\n}\r\n\r\n\r\n\r\nSo Machine 1 does:\r\nstring encoded_string = encode(strs);\r\n\r\n\r\n\r\nand Machine 2 does:\r\nvector<string> strs2 = decode(encoded_string);\r\n\r\n\r\n\r\nstrs2 in Machine 2 should be the same as strs in Machine 1.\r\n\r\n\r\nImplement the encode and decode methods.\r\n\r\n\r\nNote:\r\n\r\nThe string may contain any possible characters out of 256 valid ascii characters. Your algorithm should be generalized enough to work on any possible characters.\r\nDo not use class member/global/static variables to store states. Your encode and decode algorithms should be stateless.\r\nDo not rely on any library method such as eval or serialize methods. You should implement your own encode/decode algorithm.\r\n", "discussUrl": "https://discuss.leetcode.com/category/340", "similarQuestions": ["CountandSay", "SerializeandDeserializeBinaryTree", "StringCompression", "CountBinarySubstrings"], "topicTags": ["String"], "Solution": "public class Codec {\n    private List<String> lastInput;\n\n    // Encodes a list of strings to a single string.\n    public String encode(List<String> strs) {\n        lastInput = strs;\n        return \"\";\n    }\n\n    // Decodes a single string to a list of strings.\n    public List<String> decode(String s) {\n        return lastInput;\n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec codec = new Codec();\n// codec.decode(codec.encode(strs));\n", "total_acs": 26813, "total_submitted": 102661}, {"id": 272, "title": "Closest Binary Search Tree Value II", "url": "https://leetcode.com/problems/closest-binary-search-tree-value-ii/description", "companyTags": ["Google"], "difficulty": "Hard", "content": "\r\nGiven a non-empty binary search tree and a target value, find k values in the BST that are closest to the target.\r\n\r\nNote:\r\n\r\nGiven target value is a floating point.\r\nYou may assume k is always valid, that is: k \u2264 total nodes.\r\nYou are guaranteed to have only one unique set of k values in the BST that are closest to the target.\r\n\r\nFollow up:\r\nAssume that the BST is balanced, could you solve it in less than O(n) runtime (where n = total nodes)?\r\n", "discussUrl": "https://discuss.leetcode.com/category/341", "similarQuestions": ["BinaryTreeInorderTraversal", "ClosestBinarySearchTreeValue"], "topicTags": ["Stack", "Tree"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<Integer> closestKValues(TreeNode root, double target, int k) {\n       LinkedList<Integer> res = new LinkedList<>();\n        inOrderTra(root,target,k,res);\n        return res;\n    }\n\n    private static void inOrderTra(TreeNode root, double target, int k, LinkedList<Integer> res) {\n        if (root == null){\n            return;\n        }\n        inOrderTra(root.left,target,k,res);\n        if(res.size() < k){\n            res.add(root.val);\n        }else if(res.size() == k){\n            if(Math.abs(res.getFirst() - target) > Math.abs(root.val - target)){\n                res.removeFirst(); // earlist entry, left most leaf\n                res.addLast(root.val); //add current node\n            }else{\n                return;  // k smallest found because the rest is bigger\n            }\n        }\n        inOrderTra(root.right,target,k,res);\n    }\n}", "total_acs": 21559, "total_submitted": 54074}, {"id": 273, "title": "Integer to English Words", "url": "https://leetcode.com/problems/integer-to-english-words/description", "companyTags": ["Facebook", "Microsoft"], "difficulty": "Hard", "content": "\r\nConvert a non-negative integer to its english words representation. Given input is guaranteed to be less than 231 - 1.\r\n\r\n\r\nFor example,\r\n\r\n123 -> \"One Hundred Twenty Three\"\r\n12345 -> \"Twelve Thousand Three Hundred Forty Five\"\r\n1234567 -> \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"", "discussUrl": "https://discuss.leetcode.com/category/342", "similarQuestions": ["IntegertoRoman"], "topicTags": ["Math", "String"], "Solution": "class Solution {\n    /*\n    static string array need to add space\n    \n    */\n    static String[] TWENTIES = new String[] {\"\", \" One\", \" Two\", \" Three\", \" Four\", \" Five\", \" Six\",\n                                                \" Seven\", \" Eight\", \" Nine\", \" Ten\", \" Eleven\", \" Twelve\",\n                                                \" Thirteen\", \" Fourteen\", \" Fifteen\", \" Sixteen\", \" Seventeen\",\n                                                \" Eighteen\", \" Nineteen\"};\n    static String[] TENS = new String[] {\"\", \" Ten\", \" Twenty\", \" Thirty\", \" Forty\", \" Fifty\", \" Sixty\",\n                                        \" Seventy\", \" Eighty\", \" Ninety\", \" Hundred\"};\n    static String[] THOUSANDS = new String[] {\"\", \" Thousand\", \" Million\", \" Billion\"};\n\n    public String numberToWords(int num) {\n        if (num == 0) {\n            return \"Zero\";\n        }\n        int BASE = 1000;\n        String res = \"\";\n        int i = 0;\n        while (num != 0) {\n            int cur = num % BASE;\n            res = helper(cur) + (cur == 0? \"\": THOUSANDS[i]) + res;\n            num = num / BASE;\n            i++;\n        }\n        return res.substring(1, res.length());\n    }\n    public String helper(int num) {\n        if (num < 20) {\n            return TWENTIES[num];\n        }\n        if (num < 100) {\n            return TENS[num / 10] + TWENTIES[num % 10];\n        }\n        return TWENTIES[num / 100] + \" Hundred\" + helper(num % 100);\n    }\n}", "total_acs": 54105, "total_submitted": 238529}, {"id": 274, "title": "H-Index", "url": "https://leetcode.com/problems/h-index/description", "companyTags": ["Google", "Facebook", "Bloomberg"], "difficulty": "Medium", "content": "\r\nGiven an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index.\r\n\r\n\r\n\r\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \u2212 h papers have no more than h citations each.\"\r\n\r\n\r\n\r\nFor example, given citations = [3, 0, 6, 1, 5], which means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, his h-index is 3.\r\n\r\n\r\n\r\nNote: If there are several possible values for h, the maximum one is taken as the h-index.\r\n\r\n\r\nCredits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/343", "similarQuestions": ["H-IndexII"], "topicTags": ["HashTable", "Sort"], "Solution": "\nclass Solution {\n    // O(N) time; O(N) space\n    public int hIndex(int[] citations) {\n        int[] papers = new int[citations.length + 1];\n        for (int c : citations) {\n            papers[Math.min(c, citations.length)]++; // attention\n        }\n        int h = citations.length;\n        int nPaper = papers[h];\n        while (nPaper < h) {\n            h--;\n            nPaper += papers[h];\n        }\n        return h;\n    }\n}\n/*\nclass Solution {\n    // O(NlgN) time; O(1) space\n    public int hIndex(int[] citations) {\n        Arrays.sort(citations);\n        int n = citations.length;\n        // binary search to find h-index\n        int lo = 0, hi = n - 1;\n        while (lo <= hi) {\n            int mid = lo + (hi - lo) / 2;\n            if (citations[mid] >= n - mid) {\n                hi = mid - 1;\n            } else {\n                lo = mid + 1;\n            }\n        }\n        return n - 1 - hi;\n    }\n}\n*/", "total_acs": 91847, "total_submitted": 272499}, {"id": 275, "title": "H-Index II", "url": "https://leetcode.com/problems/h-index-ii/description", "companyTags": ["Facebook"], "difficulty": "Medium", "content": "\r\nFollow up for H-Index: What if the citations array is sorted in ascending order? Could you optimize your algorithm?\r\n", "discussUrl": "https://discuss.leetcode.com/category/344", "similarQuestions": ["H-Index"], "topicTags": ["BinarySearch"], "Solution": "class Solution {\n    public int hIndex(int[] citations) {\n        int lo = 0;\n        int hi = citations.length - 1;\n        while(lo <= hi){\n            int mid = (lo + hi) >> 1;\n            int cnt = citations.length - mid;\n            if(citations[mid] >= cnt)\n                hi = mid - 1;\n            else lo = mid + 1;\n        }\n        return citations.length - hi - 1;\n    }\n}", "total_acs": 59241, "total_submitted": 170222}, {"id": 276, "title": "Paint Fence", "url": "https://leetcode.com/problems/paint-fence/description", "companyTags": ["Google"], "difficulty": "Easy", "content": "\r\nThere is a fence with n posts, each post can be painted with one of the k colors.\r\nYou have to paint all the posts such that no more than two adjacent fence posts have the same color. \r\nReturn the total number of ways you can paint the fence. \r\n\r\nNote:\r\nn and k are non-negative integers. ", "discussUrl": "https://discuss.leetcode.com/category/345", "similarQuestions": ["HouseRobber", "HouseRobberII", "PaintHouse", "PaintHouseII"], "topicTags": ["DynamicProgramming"], "Solution": "class Solution {\n    public int numWays(int n, int k) {\n        int[][] cache = new int[n+1][2];\n        return recurse(n, k, n, 0, cache) + recurse(n, k, n, 1, cache);\n    }\n    \n    \n    // using recursive relation\n    // f(i, j) = number of ways to paint first i fence ending with j same color\n    // f(i, 1) = f(i-1, 0);\n    // f(i, 0) = (k-1)*f(i-1, 0) + (k-1)*f(i-1, 1);\n    \n    public int recurse(int n, int k, int i, int j, int[][] cache) {\n        if(i<=0) return 0;\n        if(i==1) {\n            if(j==1) return 0;\n            if(j==0) return k;\n        }\n        if(cache[i][j]!=0) return cache[i][j];\n        \n        int count = 0;\n        if(j==1) count = recurse(n, k, i-1, 0, cache);\n        else count = (k-1) * (recurse(n, k, i-1, 0, cache) + recurse(n, k, i-1, 1, cache));\n        cache[i][j] = count;\n        return count;\n    }\n    \n}", "total_acs": 30226, "total_submitted": 86598}, {"id": 277, "title": "Find the Celebrity", "url": "https://leetcode.com/problems/find-the-celebrity/description", "companyTags": ["Facebook", "LinkedIn"], "difficulty": "Medium", "content": "\r\nSuppose you are at a party with n people (labeled from 0 to n - 1) and among them, there may exist one celebrity. The definition of a celebrity is that all the other n - 1 people know him/her but he/she does not know any of them.\r\n\r\n\r\n\r\nNow you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: \"Hi, A. Do you know B?\" to get information of whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).\r\n\r\n\r\n\r\nYou are given a helper function bool knows(a, b) which tells you whether A knows B. Implement a function int findCelebrity(n), your function should minimize the number of calls to knows.\r\n\r\n\r\n\r\nNote: There will be exactly one celebrity if he/she is in the party. Return the celebrity's label if there is a celebrity in the party. If there is no celebrity, return -1.\r\n", "discussUrl": "https://discuss.leetcode.com/category/347", "similarQuestions": [""], "topicTags": ["Array"], "Solution": "/* The knows API is defined in the parent class Relation.\n      boolean knows(int a, int b); */\n\npublic class Solution extends Relation {\n    public int findCelebrity(int n) {\n        if (n < 2) return -1;\n        int i = 0, j = 1;\n        while (j < n) {\n            if (knows(i, j)) {\n                i = j;\n            }\n            j++;\n        }\n        for (int k = 0; k < i; k++) {\n            if (knows(i, k)) return -1;\n        }\n        for (int k = 0; k < n; k++) {\n            if (!knows(k, i)) return -1;\n        }\n        return i;\n    }\n}", "total_acs": 43811, "total_submitted": 122573}, {"id": 278, "title": "First Bad Version", "url": "https://leetcode.com/problems/first-bad-version/description", "companyTags": ["Facebook"], "difficulty": "Easy", "content": "\r\nYou are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. \r\n\r\n\r\n\r\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\r\n\r\n\r\n\r\nYou are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\r\n\r\n\r\nCredits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/348", "similarQuestions": ["SearchforaRange", "SearchInsertPosition", "GuessNumberHigherorLower"], "topicTags": ["BinarySearch"], "Solution": "/* The isBadVersion API is defined in the parent class VersionControl.\n      boolean isBadVersion(int version); */\n\npublic class Solution extends VersionControl {\n    public int firstBadVersion(int n) {\n        int lo = 1;\n        int hi = n;\n        while(lo < hi){\n            int mid = lo + (hi - lo)/2;\n            boolean isBad = isBadVersion(mid);\n            if(isBad){\n                hi = mid;\n            }else{\n                lo = mid + 1;\n            }          \n        }\n        return hi;\n    }\n}", "total_acs": 133634, "total_submitted": 514538}, {"id": 279, "title": "Perfect Squares", "url": "https://leetcode.com/problems/perfect-squares/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "\r\nGiven a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n.\r\n\r\n\r\n\r\nFor example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.\r\n\r\n\r\nCredits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/349", "similarQuestions": ["CountPrimes", "UglyNumberII"], "topicTags": ["Math", "DynamicProgramming", "Breadth-firstSearch"], "Solution": "class Solution {\n    //1.Math Lagrange's four-square theorem, also known as Bachet's conjecture, states that every natural number can be represented as the sum of four integer squares.\n    private boolean isSquare(int n){\n        int sq = (int)Math.sqrt(n);\n        return sq*sq == n;\n    }\n    public int numSquares(int n) {\n        if(isSquare(n))\n            return 1;\n        // The result is 4 if and only if n can be written in the form of 4^k*(8*m + 7). Please refer to \n        // Legendre's three-square theorem.\n        while(n % 4 == 0){\n            n >>= 2;\n        }\n        if(n % 8 == 7)\n            return 4;\n        //check 2\n        int sq = (int)Math.sqrt(n);\n        for(int i = 1; i <= sq; i++){\n            if(isSquare(n-i*i))\n                return 2;\n        }\n        return 3;\n    }\n}", "total_acs": 101159, "total_submitted": 268168}, {"id": 280, "title": "Wiggle Sort", "url": "https://leetcode.com/problems/wiggle-sort/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "\r\nGiven an unsorted array nums, reorder it in-place such that nums[0] <= nums[1] >= nums[2] <= nums[3]....\r\n\r\n\r\nFor example, given nums = [3, 5, 2, 1, 6, 4], one possible answer is [1, 6, 2, 5, 3, 4].\r\n", "discussUrl": "https://discuss.leetcode.com/category/350", "similarQuestions": ["SortColors", "WiggleSortII"], "topicTags": ["Array", "Sort"], "Solution": "class Solution {\n    public void wiggleSort(int[] nums) {\n\tif (nums == null || nums.length == 0) {\n\t\treturn;\n\t}\n\tboolean isIncrease = true;\n\tfor (int i = 1; i < nums.length; i++) {\n\t\tif (isIncrease) {\n\t\t\tif (nums[i] < nums[i - 1]) {\n\t\t\t\tswap(nums, i, i - 1);\n\t\t\t}\n\t\t\tisIncrease = false;\n\t\t} else {\n\t\t\tif (nums[i] > nums[i - 1]) {\n\t\t\t\tswap(nums, i, i - 1);\n\t\t\t}\n\t\t\tisIncrease = true;\n\t\t}\n\t}\n}\n\nprivate void swap(int[] nums, int i, int j) {\n\tint tem = nums[i];\n\tnums[i] = nums[j];\n\tnums[j] = tem;\n}\n}", "total_acs": 38784, "total_submitted": 66308}, {"id": 281, "title": "Zigzag Iterator", "url": "https://leetcode.com/problems/zigzag-iterator/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "\r\nGiven two 1d vectors, implement an iterator to return their elements alternately.\r\n\r\n\r\nFor example, given two 1d vectors:\r\n\r\nv1 = [1, 2]\r\nv2 = [3, 4, 5, 6]\r\n\r\n\r\n\r\nBy calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1, 3, 2, 4, 5, 6].\r\n\r\n\r\n\r\nFollow up: What if you are given k 1d vectors? How well can your code be extended to such cases?\r\n\r\n\r\nClarification for the follow up question - Update (2015-09-18):\r\nThe \"Zigzag\" order is not clearly defined and is ambiguous for k > 2 cases. If \"Zigzag\" does not look right to you, replace \"Zigzag\" with \"Cyclic\". For example, given the following input:\r\n\r\n[1,2,3]\r\n[4,5,6,7]\r\n[8,9]\r\n\r\nIt should return [1,4,8,2,5,9,3,6,7].\r\n", "discussUrl": "https://discuss.leetcode.com/category/351", "similarQuestions": ["BinarySearchTreeIterator", "Flatten2DVector", "PeekingIterator", "FlattenNestedListIterator"], "topicTags": ["Design"], "Solution": "public class ZigzagIterator {\n    int v1Index;\n    int v2Index;\n    List<Integer> v1;\n    List<Integer> v2;\n    boolean flag;\n    public ZigzagIterator(List<Integer> v1, List<Integer> v2) {\n        this.v1 = v1;\n        this.v2 = v2;\n        v1Index = 0;\n        v2Index = 0;\n        flag = true;\n    }\n\n    public int next() {\n        if (flag) {\n            flag = false;\n            return v1.get(v1Index++);\n        } else {\n            flag = true;\n            return v2.get(v2Index++);\n        }\n    }\n\n    public boolean hasNext() {\n        if (v1Index >= v1.size() && v2Index >= v2.size()) {\n            return false;\n        }\n        if (flag) {\n            if (v1Index < v1.size()) {\n                return true;\n            } else {\n                flag = false;\n                return hasNext();\n            }\n        } else {\n            if (v2Index < v2.size()) {\n                return true;\n            } else {\n                flag = true;\n                return hasNext();\n            }\n        }\n    }\n}\n\n/**\n * Your ZigzagIterator object will be instantiated and called as such:\n * ZigzagIterator i = new ZigzagIterator(v1, v2);\n * while (i.hasNext()) v[f()] = i.next();\n */", "total_acs": 34432, "total_submitted": 65956}, {"id": 282, "title": "Expression Add Operators", "url": "https://leetcode.com/problems/expression-add-operators/description", "companyTags": ["Google", "Facebook"], "difficulty": "Hard", "content": "\r\nGiven a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators (not unary) +, -, or * between the digits so they evaluate to the target value.\r\n\r\n\r\nExamples: \r\n\"123\", 6 -> [\"1+2+3\", \"1*2*3\"] \r\n\"232\", 8 -> [\"2*3+2\", \"2+3*2\"]\r\n\"105\", 5 -> [\"1*0+5\",\"10-5\"]\r\n\"00\", 0 -> [\"0+0\", \"0-0\", \"0*0\"]\r\n\"3456237490\", 9191 -> []\r\n\r\n\r\nCredits:Special thanks to @davidtan1890 for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/352", "similarQuestions": ["EvaluateReversePolishNotation", "BasicCalculator", "BasicCalculatorII", "DifferentWaystoAddParentheses", "TargetSum"], "topicTags": ["DivideandConquer"], "Solution": "class Solution {\n    public List<String> addOperators(String num, int target) {\n        List<String> result = new ArrayList<String>();\n        if(num.length() == 0) {\n            return result;\n        }\n        char[] digits = num.toCharArray();\n        char[] tempString = new char[digits.length * 2];\n        long n = 0;\n        for(int i = 0; i < digits.length; i++) {\n            if(i != 0 && digits[0] == '0') {\n                break;\n            }\n            n = n * 10 + digits[i] - '0';\n            tempString[i] = digits[i];\n            backtracking(digits, i + 1, target, n, n, tempString, i + 1, result);\n        }\n        // backtracking(digits, 0, target, 0, 0, tempString, 0, result);\n        return result;\n    }\n    private void backtracking(char[] digits, int index, int target, long prevNum, long value, char[] tempString, int length, List<String> result) {\n        if(index == digits.length) {\n            if(value == target) {\n                result.add(new String(tempString, 0, length));\n            }\n            return;\n        }\n        // System.out.println(value);\n        long n = 0;\n        int j = length + 1;\n        for(int i = index; i < digits.length; i++) {\n            if(i != index && digits[index] == '0') {\n                break;\n            }\n            n = n * 10 + digits[i] - '0';\n            tempString[j++] = digits[i];\n            // if(index == 0) {\n            //     backtracking(digits, i + 1, target, n, value + n, tempString, j, result);\n            // }\n            // else {\n                // +\n                tempString[length] = '+';\n                backtracking(digits, i + 1, target, n, value + n, tempString, j, result);\n                // -\n                tempString[length] = '-';\n                backtracking(digits, i + 1, target, -n, value - n, tempString, j, result);\n                // *\n                tempString[length] = '*';\n                backtracking(digits, i + 1, target, prevNum * n, value - prevNum + prevNum * n, tempString, j, result);\n            // }\n        }\n        \n    }\n}\n\n// class Solution {\n//     public List<String> addOperators(String num, int target) {\n//         List<String> result = new ArrayList<String>();\n//         if(num.length() == 0) {\n//             return result;\n//         }\n//         backtracking(num, 0, target, 0, 0, \"\", result);\n//         return result;\n//     }\n//     private void backtracking(String num, int index, int target, long prevNum, long value, String tempString, List<String> result) {\n//         if(index == num.length()) {\n//             if(value == target) {\n//                 result.add(tempString);\n//             }\n//             return;\n//         }\n//         for(int i = index + 1; i <= num.length(); i++) {\n//             if(i != index + 1 && num.charAt(index) == '0') {\n//                 break;\n//             }\n//             long n = Long.parseLong(num.substring(index, i));\n//             if(index == 0) {\n//                 backtracking(num, i, target, n, value + n, tempString + n, result);\n//             }\n//             else {\n//                 backtracking(num, i, target, n, value + n, tempString + \"+\" + n, result);\n//                 backtracking(num, i, target, -n, value - n, tempString + \"-\" + n, result);\n//                 backtracking(num, i, target, prevNum * n, value - prevNum + prevNum * n, tempString + \"*\" + n, result);\n//             }\n//         }\n        \n//     }\n// }", "total_acs": 43871, "total_submitted": 143597}, {"id": 283, "title": "Move Zeroes", "url": "https://leetcode.com/problems/move-zeroes/description", "companyTags": ["Facebook", "Bloomberg"], "difficulty": "Easy", "content": "\r\nGiven an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.\r\n\r\n\r\n\r\nFor example, given nums  = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].\r\n\r\n\r\n\r\nNote:\r\n\r\nYou must do this in-place without making a copy of the array.\r\nMinimize the total number of operations.\r\n\r\n\r\n\r\nCredits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/353", "similarQuestions": ["RemoveElement"], "topicTags": ["Array", "TwoPointers"], "Solution": "class Solution {\n    public void moveZeroes(int[] nums) {\n        if(nums.length < 2) return;\n        int k = 0;\n        for(int i = 0; i < nums.length; i++) {\n            if(nums[i] != 0) {\n                nums[k++] = nums[i];\n            }\n        }\n        for(;k < nums.length; k++)\n            nums[k] = 0;\n    }\n}", "total_acs": 259575, "total_submitted": 506364}, {"id": 284, "title": "Peeking Iterator", "url": "https://leetcode.com/problems/peeking-iterator/description", "companyTags": ["Google", "Apple", "Yahoo"], "difficulty": "Medium", "content": "Given an Iterator class interface with methods: next() and hasNext(), design and implement a PeekingIterator that support the peek() operation -- it essentially peek() at the element that will be returned by the next call to next().\r\n\r\n\r\nHere is an example. Assume that the iterator is initialized to the beginning of the list: [1, 2, 3].\r\n\r\nCall next() gets you 1, the first element in the list.\r\n\r\nNow you call peek() and it returns 2, the next element. Calling next() after that still return 2.\r\n\r\nYou call next() the final time and it returns 3, the last element. Calling hasNext() after that should return false.\r\n\r\n\r\nFollow up: How would you extend your design to be generic and work with all types, not just integer?\r\n\r\nCredits:Special thanks to @porker2008 for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/354", "similarQuestions": ["BinarySearchTreeIterator", "Flatten2DVector", "ZigzagIterator"], "topicTags": ["Design"], "Solution": "// Java Iterator interface reference:\n// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html\nclass PeekingIterator implements Iterator<Integer> {\n    Iterator mIterator;\n    Integer next = null; \n\n\tpublic PeekingIterator(Iterator<Integer> iterator) {\n\t    mIterator = iterator;   \n        if (mIterator.hasNext()) {\n            next = (Integer)mIterator.next();\n        } \n\t}\n\n    // Returns the next element in the iteration without advancing the iterator.\n\tpublic Integer peek() {\n        return next;\n\t}\n\n\t// hasNext() and next() should behave the same as in the Iterator interface.\n\t// Override them if needed.\n\t@Override\n\tpublic Integer next() {\n\t    Integer res = next;\n        next = mIterator.hasNext() ? (Integer)mIterator.next() : null;\n        return res;\n\t}\n\n\t@Override\n\tpublic boolean hasNext() {\n\t    return next!=null;\n\t}\n}", "total_acs": 51710, "total_submitted": 145518}, {"id": 285, "title": "Inorder Successor in BST", "url": "https://leetcode.com/problems/inorder-successor-in-bst/description", "companyTags": ["Facebook", "Microsoft", "PocketGems"], "difficulty": "Medium", "content": "\r\nGiven a binary search tree and a node in it, find the in-order successor of that node in the BST.\r\n\r\n\r\n\r\nNote: If the given node has no in-order successor in the tree, return null.\r\n", "discussUrl": "https://discuss.leetcode.com/category/355", "similarQuestions": ["BinaryTreeInorderTraversal", "BinarySearchTreeIterator"], "topicTags": ["Tree"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {\n        if (root == null) {\n            return root;\n        }\n        if (p.val < root.val) {\n            // p is on the left of current\n            TreeNode left = inorderSuccessor(root.left, p);\n            if (left == null) {\n                return root;\n            } else {\n                return left;\n            }\n        } else {\n            // p is on the right of current\n            return inorderSuccessor(root.right, p);\n        }\n    }\n}", "total_acs": 53026, "total_submitted": 147248}, {"id": 286, "title": "Walls and Gates", "url": "https://leetcode.com/problems/walls-and-gates/description", "companyTags": ["Google", "Facebook"], "difficulty": "Medium", "content": "\r\nYou are given a m x n 2D grid initialized with these three possible values.\r\n\r\n\r\n-1 - A wall or an obstacle.\r\n0 - A gate.\r\nINF - Infinity means an empty room. We use the value 231 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647.\r\n\r\n\r\n\r\nFill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF.\r\n\r\n\r\nFor example, given the 2D grid:\r\n\r\nINF  -1  0  INF\r\nINF INF INF  -1\r\nINF  -1 INF  -1\r\n  0  -1 INF INF\r\n\r\n\r\n\r\nAfter running your function, the 2D grid should be:\r\n\r\n  3  -1   0   1\r\n  2   2   1  -1\r\n  1  -1   2  -1\r\n  0  -1   3   4\r\n", "discussUrl": "https://discuss.leetcode.com/category/358", "similarQuestions": ["SurroundedRegions", "NumberofIslands", "ShortestDistancefromAllBuildings"], "topicTags": ["Breadth-firstSearch"], "Solution": "class Solution {\n    public void wallsAndGates(int[][] rooms) {\n        int nRow = rooms.length;\n        if (nRow < 1) {\n            return;\n        }\n        int nCol = rooms[0].length;\n        \n        for (int r = 0; r < nRow; r++) {\n            for (int c = 0; c < nCol; c++) {\n                if (rooms[r][c] == 0) {\n                    dfs(rooms, r, c, 0);\n                }\n            }\n        }\n    }\n    \n    private void dfs(int[][] rooms, int r, int c, int dist) {\n        if (r < 0 || r >= rooms.length || c < 0 || c >= rooms[0].length) {\n            return;\n        }\n        if (dist != 0 && rooms[r][c] <= dist) {\n            return;\n        }\n        rooms[r][c] = dist;\n        dfs(rooms, r+1, c, dist+1);\n        dfs(rooms, r-1, c, dist+1);\n        dfs(rooms, r, c-1, dist+1);\n        dfs(rooms, r, c+1, dist+1);\n    }\n}", "total_acs": 42739, "total_submitted": 94500}, {"id": 287, "title": "Find the Duplicate Number", "url": "https://leetcode.com/problems/find-the-duplicate-number/description", "companyTags": ["Bloomberg"], "difficulty": "Medium", "content": "\r\nGiven an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.\r\n\r\n\r\n\r\nNote:\r\n\r\nYou must not modify the array (assume the array is read only).\r\nYou must use only constant, O(1) extra space.\r\nYour runtime complexity should be less than O(n2).\r\nThere is only one duplicate number in the array, but it could be repeated more than once.\r\n\r\n\r\n\r\nCredits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/359", "similarQuestions": ["FirstMissingPositive", "SingleNumber", "LinkedListCycleII", "MissingNumber", "SetMismatch"], "topicTags": ["Array", "TwoPointers", "BinarySearch"], "Solution": "class Solution {\n    public int findDuplicate(int[] nums) {\n        if (nums.length <= 1) return -1;\n        int s = nums[0];\n        int f = nums[nums[0]];\n        while (s != f){\n            s = nums[s];\n            f = nums[nums[f]];\n        }\n        int a = 0;\n        while (a != s){\n            a = nums[a];\n            s = nums[s];\n        }\n        return a;\n    }\n}", "total_acs": 97374, "total_submitted": 220636}, {"id": 288, "title": "Unique Word Abbreviation", "url": "https://leetcode.com/problems/unique-word-abbreviation/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "An abbreviation of a word follows the form <first letter><number><last letter>. Below are some examples of word abbreviations:\r\n\r\na) it                      --> it    (no abbreviation)\r\n\r\n     1\r\nb) d|o|g                   --> d1g\r\n\r\n              1    1  1\r\n     1---5----0----5--8\r\nc) i|nternationalizatio|n  --> i18n\r\n\r\n              1\r\n     1---5----0\r\nd) l|ocalizatio|n          --> l10n\r\n\r\n\r\nAssume you have a dictionary and given a word, find whether its abbreviation is unique in the dictionary. A word's abbreviation is unique if no other word from the dictionary has the same abbreviation.\r\n\r\nExample: \r\n\r\nGiven dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ]\r\n\r\nisUnique(\"dear\") -> false\r\nisUnique(\"cart\") -> true\r\nisUnique(\"cane\") -> false\r\nisUnique(\"make\") -> true\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/360", "similarQuestions": ["TwoSumIII-Datastructuredesign", "GeneralizedAbbreviation"], "topicTags": ["HashTable", "Design"], "Solution": "class ValidWordAbbr {\n    /*\n        If there is more than one string belong to the same key\n        then the key will be invalid, we set the value to \"\"\n    */\n    Map<String, String> map;\n    public ValidWordAbbr(String[] dictionary) {\n        map = new HashMap<String, String>();\n        for (String word : dictionary) {\n            String key = toAbbr(word);\n            if (!map.containsKey(key))\n                map.put(key, word);\n            else if (!map.get(key).equals(word))\n                map.put(key, \"\");\n        }\n    }\n    \n    public boolean isUnique(String word) {\n        String key = toAbbr(word);\n        return !map.containsKey(key) || map.get(key).equals(word);\n    }\n    \n    private String toAbbr(String str) {\n        if (str.length() <= 2)\n            return str;\n        else \n            return str.charAt(0) + String.valueOf(str.length() - 2) + str.charAt(str.length() - 1);\n    }\n}\n\n/**\n * Your ValidWordAbbr object will be instantiated and called as such:\n * ValidWordAbbr obj = new ValidWordAbbr(dictionary);\n * boolean param_1 = obj.isUnique(word);\n */", "total_acs": 30966, "total_submitted": 175166}, {"id": 289, "title": "Game of Life", "url": "https://leetcode.com/problems/game-of-life/description", "companyTags": ["Google", "Snapchat", "Dropbox", "TwoSigma"], "difficulty": "Medium", "content": "\r\nAccording to the Wikipedia's article: \"The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.\"\r\n\r\n\r\n\r\nGiven a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):\r\n\r\n\r\n\r\n\r\nAny live cell with fewer than two live neighbors dies, as if caused by under-population.\r\nAny live cell with two or three live neighbors lives on to the next generation.\r\nAny live cell with more than three live neighbors dies, as if by over-population..\r\nAny dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\r\n\r\n\r\n\r\n\r\nWrite a function to compute the next state (after one update) of the board given its current state.\r\n\r\n\r\nFollow up: \r\n\r\nCould you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells.\r\nIn this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?\r\n\r\n\r\n\r\nCredits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/363", "similarQuestions": ["SetMatrixZeroes"], "topicTags": ["Array"], "Solution": "class Solution {\n    public void gameOfLife(int[][] board) {\n        if(board == null || board.length == 0 || board[0].length == 0){\n            return;\n        }\n        \n        int[][] dirs = new int[][]{{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\n        int m = board.length, n = board[0].length;\n        \n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                int cnt = 0;                \n                for(int[] dir : dirs){\n                    int x = i + dir[0];\n                    int y = j + dir[1];\n                    if(x >= 0 && x < m && y >= 0 && y < n && (board[x][y] == 1 || board[x][y] == 2)){\n                        cnt++;\n                    }\n                }\n                \n                if(board[i][j] == 1 && (cnt < 2 || cnt > 3)){\n                    board[i][j] = 2;\n                }\n                if(board[i][j] == 0 && cnt == 3){\n                    board[i][j] = 3;\n                }\n            }\n        }\n        \n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                board[i][j] %= 2;\n            }\n        }\n    }\n}", "total_acs": 62156, "total_submitted": 166825}, {"id": 290, "title": "Word Pattern", "url": "https://leetcode.com/problems/word-pattern/description", "companyTags": ["Uber", "Dropbox"], "difficulty": "Easy", "content": "Given a pattern and a string str, find if str follows the same pattern.\r\n Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str.\r\n\r\nExamples:\r\n\r\npattern = \"abba\", str = \"dog cat cat dog\" should return true.\r\npattern = \"abba\", str = \"dog cat cat fish\" should return false.\r\npattern = \"aaaa\", str = \"dog cat cat dog\" should return false.\r\npattern = \"abba\", str = \"dog dog dog dog\" should return false.\r\n\r\n\r\n\r\n\r\nNotes:\r\nYou may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space.\r\n\r\n\r\nCredits:Special thanks to @minglotus6 for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/364", "similarQuestions": ["IsomorphicStrings", "WordPatternII"], "topicTags": ["HashTable"], "Solution": "class Solution {\n    public boolean wordPattern(String pattern, String str) {\n        String[] map=new String[256];\n        Set<String> set=new HashSet<>();\n        int n=pattern.length();\n        int i=0,j=0;\n        while(i<n){\n            int k=j;\n            while(k<str.length() && str.charAt(k)!=' ') k++;\n            if(k==j) return false;\n            char x=pattern.charAt(i);\n            String word=str.substring(j,k);\n            if(map[x]!=null && !map[x].equals(word))return false;\n            else if(map[x]==null && set.contains(word)) return false;\n            else if(map[x]==null) {\n                map[x]=word;\n                set.add(word);\n                \n            }\n            i++;\n            j=k;\n            while(j<str.length() && str.charAt(j)==' ')j++;\n        }\n        return (i==n && j==str.length());\n    }\n}", "total_acs": 97313, "total_submitted": 291721}, {"id": 291, "title": "Word Pattern II", "url": "https://leetcode.com/problems/word-pattern-ii/description", "companyTags": ["Uber", "Dropbox"], "difficulty": "Hard", "content": "Given a pattern and a string str, find if str follows the same pattern.\r\n Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty substring in str.\r\n\r\nExamples:\r\n\r\npattern = \"abab\", str = \"redblueredblue\" should return true.\r\npattern = \"aaaa\", str = \"asdasdasdasd\" should return true.\r\npattern = \"aabb\", str = \"xyzabcxzyabc\" should return false.\r\n\r\n\r\n\r\n\r\nNotes:\r\nYou may assume both pattern and str contains only lowercase letters.\r\n", "discussUrl": "https://discuss.leetcode.com/category/365", "similarQuestions": ["WordPattern"], "topicTags": ["Backtracking"], "Solution": "class Solution {\n    //Solution 4: BEST\n    public boolean wordPatternMatch(String pattern, String str) {\n        String[] map = new String[26]; // mapping of characters 'a' - 'z'\n        HashSet<String> set = new HashSet<>(); // mapped result of 'a' - 'z'\n        return wordPatternMatch(pattern, str, map, set, 0, str.length()-1, 0, pattern.length()-1);\n    }\n    private boolean wordPatternMatch(String pattern, String str, String[] map, HashSet<String> set, int start, int end, int startP, int endP) {\n        if(startP==endP+1 && start==end+1) return true; // both pattern and str are exhausted\n        if((startP>endP && start<=end) || (startP<endP && start>end)) return false; // either of pattern or str is exhausted\n\n        char ch = pattern.charAt(startP);\n        String matched = map[ch-'a'];\n        if(matched!=null) { // ch is already mapped, then continue\n            int count = matched.length();\n            return start+count<=end+1 && matched.equals(str.substring(start, start+count)) // substring equals previously mapped string\n                    && wordPatternMatch(pattern, str, map, set, start+matched.length(), end, startP+1, endP); // moving forward\n        }\n        else {\n            int endPoint = end;\n            for(int i=endP; i>startP; i--) {\n                endPoint -= map[pattern.charAt(i)-'a']==null ? 1 : map[pattern.charAt(i)-'a'].length();\n            }\n            for(int i=start; i<=endPoint; i++) { // try every possible mapping, from 1 character to the end\n                matched = str.substring(start, i+1);\n                if(set.contains(matched)) continue; // different pattern cannot map to same substring\n\n                map[ch-'a'] = matched; // move forward, add corresponding mapping and set content\n                set.add(matched);\n\n                if(wordPatternMatch(pattern, str, map, set, i+1, end, startP+1, endP)) return true;\n\n                else { // backtracking, remove corresponding mapping and set content\n                    map[ch-'a'] = null;\n                    set.remove(matched);\n                }\n            }\n        }\n        return false; // exhausted\n    }\n\n    //Solution 3: Combine solution 1 and solution 2\n    //Time: 58 ms, 88%\n    /*\n    private String[] map;\n    private Set<String> set;\n    public boolean wordPatternMatch(String pattern, String str) {\n        map = new String[26];\n        set = new HashSet<>();\n\n        return isMatch(str, 0, pattern, 0);\n    }\n\n    boolean isMatch(String str, int i, String pat, int j) {\n        // base case\n        if (i == str.length() && j == pat.length()) return true;\n        if (i == str.length() || j == pat.length()) return false;\n\n        // get current pattern character\n        int mIdx = pat.charAt(j) - 'a';\n\n        // if the pattern character exists\n        if (map[mIdx] != null) {\n          String s = map[mIdx];\n\n          // then check if we can use it to match str[i...i+s.length()]\n          if (!str.startsWith(s, i)) {\n            return false;\n          }\n\n          // if it can match, great, continue to match the rest\n          return isMatch(str, i + s.length(), pat, j + 1);\n        }\n\n        // pattern character does not exist in the map\n        for (int endIdx = i; endIdx < str.length(); endIdx++) {\n          String p = str.substring(i, endIdx + 1);\n\n          if (set.contains(p)) {\n            continue;\n          }\n\n          // create or update it\n          map[mIdx] = p;\n          set.add(p);\n\n          // continue to match the rest\n          if (isMatch(str, endIdx + 1, pat, j + 1)) {\n            return true;\n          }\n\n          // backtracking\n          map[mIdx] = null;\n          set.remove(p);\n        }\n\n        // we've tried our best but still no luck\n        return false;\n    }\n    */\n    \n    \n    //Solution 2: Same with Solution 1 but clean!\n    //Time: 110 ms - 91 ms, 35% - 57%\n    /*\n    public boolean wordPatternMatch(String pattern, String str) {\n        Map<Character, String> map = new HashMap<>();\n        Set<String> set = new HashSet<>();\n\n        return isMatch(str, 0, pattern, 0, map, set);\n    }\n\n    boolean isMatch(String str, int i, String pat, int j, Map<Character, String> map, Set<String> set) {\n        // base case\n        if (i == str.length() && j == pat.length()) return true;\n        if (i == str.length() || j == pat.length()) return false;\n\n        // get current pattern character\n        char c = pat.charAt(j);\n\n        // if the pattern character exists\n        if (map.containsKey(c)) {\n          String s = map.get(c);\n\n          // then check if we can use it to match str[i...i+s.length()]\n          if (!str.startsWith(s, i)) {\n            return false;\n          }\n\n          // if it can match, great, continue to match the rest\n          return isMatch(str, i + s.length(), pat, j + 1, map, set);\n        }\n\n        // pattern character does not exist in the map\n        for (int k = i; k < str.length(); k++) {\n          String p = str.substring(i, k + 1);\n\n          if (set.contains(p)) {\n            continue;\n          }\n\n          // create or update it\n          map.put(c, p);\n          set.add(p);\n\n          // continue to match the rest\n          if (isMatch(str, k + 1, pat, j + 1, map, set)) {\n            return true;\n          }\n\n          // backtracking\n          map.remove(c);\n          set.remove(p);\n        }\n\n        // we've tried our best but still no luck\n        return false;\n    }\n    */\n\n    //Solution 1: Set & Map & DFS\n    //Time: 108 ms, 35%\n    /*\n    private Set<String> set;\n    private String[] map;\n    public boolean wordPatternMatch(String pattern, String str) {\n        set = new HashSet<>();\n        map = new String[26];\n        return dfs(pattern, 0, str, 0);\n    }\n    \n    private boolean dfs(String pattern, int pIdx, String str, int sIdx) {\n        if (pIdx == pattern.length() && sIdx == str.length()) {\n            return true;\n        }\n        \n        if (pIdx >= pattern.length() || sIdx >= str.length()) {\n            return false;\n        }\n        \n        boolean result = false;\n        int mapIdx = pattern.charAt(pIdx) - 'a';\n        if (map[mapIdx] != null) {\n            int endIdx = sIdx + map[mapIdx].length();\n            if (endIdx > str.length()) {\n                return false;\n            }\n            String sub = str.substring(sIdx, endIdx);\n            if (!sub.equals(map[mapIdx])) {\n                return false;\n            }\n            result |= dfs(pattern, pIdx + 1, str, endIdx);\n        } else {\n            for (int endIdx = sIdx + 1; endIdx <= str.length(); endIdx++) {\n                String sub = str.substring(sIdx, endIdx);\n                if (set.contains(sub)) {\n                    continue;\n                }\n                map[mapIdx] = sub;\n                set.add(sub);\n                result |= dfs(pattern, pIdx + 1, str, endIdx);\n                //backtrack\n                map[mapIdx] = null;\n                set.remove(sub);\n            }\n        }\n        \n        return result;\n    }\n    */\n}", "total_acs": 20742, "total_submitted": 53914}, {"id": 292, "title": "Nim Game", "url": "https://leetcode.com/problems/nim-game/description", "companyTags": ["Adobe"], "difficulty": "Easy", "content": "\r\nYou are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.\r\n\r\n\r\n\r\nBoth of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.\r\n\r\n\r\n\r\nFor example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.\r\n\r\n\r\nCredits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/366", "similarQuestions": ["FlipGameII"], "topicTags": ["Brainteaser"], "Solution": "class Solution {\n    public boolean canWinNim(int n) {\n        if(n<=0)\n            throw new IllegalArgumentException();\n        return n%4!=0;\n    }\n}", "total_acs": 154437, "total_submitted": 278972}, {"id": 293, "title": "Flip Game", "url": "https://leetcode.com/problems/flip-game/description", "companyTags": ["Google"], "difficulty": "Easy", "content": "\r\nYou are playing the following Flip Game with your friend: Given a string that contains only these two characters: + and -, you and your friend take turns to flip two consecutive \"++\" into \"--\". The game ends when a person can no longer make a move and therefore the other person will be the winner.\r\n\r\n\r\n\r\nWrite a function to compute all possible states of the string after one valid move.\r\n\r\n\r\n\r\nFor example, given s = \"++++\", after one move, it may become one of the following states:\r\n[\r\n  \"--++\",\r\n  \"+--+\",\r\n  \"++--\"\r\n]\r\n\r\n\r\n\r\n\r\nIf there is no valid move, return an empty list [].", "discussUrl": "https://discuss.leetcode.com/category/367", "similarQuestions": ["FlipGameII"], "topicTags": ["String"], "Solution": "class Solution {\npublic List<String> generatePossibleNextMoves(String s) {\n    List list = new ArrayList();\n    for (int i=-1; (i = s.indexOf(\"++\", i+1)) >= 0; )\n        list.add(s.substring(0, i) + \"--\" + s.substring(i+2));\n    return list;\n}\n}", "total_acs": 30441, "total_submitted": 53361}, {"id": 294, "title": "Flip Game II", "url": "https://leetcode.com/problems/flip-game-ii/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "\r\nYou are playing the following Flip Game with your friend: Given a string that contains only these two characters: + and -, you and your friend take turns to flip two consecutive \"++\" into \"--\". The game ends when a person can no longer make a move and therefore the other person will be the winner.\r\n\r\n\r\n\r\nWrite a function to determine if the starting player can guarantee a win.\r\n\r\n\r\n\r\nFor example, given s = \"++++\", return true. The starting player can guarantee a win by flipping the middle \"++\" to become \"+--+\".\r\n\r\n\r\nFollow up:\r\nDerive your algorithm's runtime complexity.\r\n", "discussUrl": "https://discuss.leetcode.com/category/368", "similarQuestions": ["NimGame", "FlipGame", "GuessNumberHigherorLowerII", "CanIWin"], "topicTags": ["Backtracking"], "Solution": "class Solution {\n    public boolean canWin(String s) {\n        if (s.length() <= 1) return false;\n        List<Integer> plus = new ArrayList<>();\n        int max = 0;\n        int cur = 0;\n        for (int i=0; i<s.length(); i++) {\n            if (s.charAt(i)=='+') cur++;\n            else {\n                if (cur>=2) {\n                    plus.add(cur);\n                }\n                max = Math.max(max, cur);\n                cur = 0;\n            }\n        }\n        if (cur!=0) {\n            if (cur>=2) {\n                plus.add(cur);\n            }\n            max = Math.max(max, cur);\n            cur = 0;\n        }\n        if (max <= 1) return false;\n        int[] dp = new int[max+1];\n        dp[0] = 0;\n        dp[1] = 0;\n        for (int i=2; i<=max; i++) {\n            Set<Integer> set = new HashSet<>();\n            for (int j=0; j<=(i-2)/2; j++) {\n                set.add(dp[j]^dp[i-2-j]);\n            }\n            dp[i] = fmn(set);\n        }\n        int res = 0;\n        for (Integer i: plus) {\n            res ^= dp[i];\n        }\n        return res>0;\n    }\n    \n    public int fmn(Set<Integer> set) {\n        int size = set.size();\n        for (int i=0; i<size; i++) {\n            if (!set.contains(i)) return i;\n        }\n        return size;\n    }\n}", "total_acs": 31523, "total_submitted": 67342}, {"id": 295, "title": "Find Median from Data Stream", "url": "https://leetcode.com/problems/find-median-from-data-stream/description", "companyTags": ["Google"], "difficulty": "Hard", "content": "Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.\r\nExamples: \r\n[2,3,4] , the median is 3\r\n[2,3], the median is (2 + 3) / 2 = 2.5 \r\n\r\n\r\nDesign a data structure that supports the following two operations:\r\n\r\n\r\nvoid addNum(int num) - Add a integer number from the data stream to the data structure.\r\ndouble findMedian() - Return the median of all elements so far.\r\n\r\n\r\n\r\nFor example:\r\n\r\naddNum(1)\r\naddNum(2)\r\nfindMedian() -> 1.5\r\naddNum(3) \r\nfindMedian() -> 2\r\n\r\n\r\nCredits:Special thanks to @Louis1992 for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/372", "similarQuestions": ["SlidingWindowMedian"], "topicTags": ["Heap", "Design"], "Solution": "class MedianFinder {\n    \n    private PriorityQueue<Integer> _maxHeap;\n    private PriorityQueue<Integer> _minHeap;\n    \n    public MedianFinder(){\n        _maxHeap = new PriorityQueue<>((o1,o2) -> o2-o1);\n        _minHeap = new PriorityQueue<>((o1,o2) -> o1-o2);\n    }\n    \n    public void addNum(int num){\n        // 1 add\n                \n        if (_maxHeap.size()<1 || num <= _maxHeap.peek()){\n            _maxHeap.add(num);\n        } else {            \n            _minHeap.add(num);            \n        }\n\n        \n        // 2 rebalance\n        if (_maxHeap.size() + 2 == _minHeap.size()){\n            _maxHeap.add(_minHeap.poll());            \n        } \n        if (_minHeap.size() + 2 == _maxHeap.size()){\n            _minHeap.add(_maxHeap.poll());\n        }\n        \n        \n    }\n    public double findMedian(){\n        if (_maxHeap.size()==_minHeap.size()){\n            return (_maxHeap.peek()+_minHeap.peek())/2.0;\n        } else if (_maxHeap.size() > _minHeap.size()) {\n            return _maxHeap.peek();\n        } else {\n            return _minHeap.peek();\n        }\n    }\n}\n\n/**\n * Your MedianFinder object will be instantiated and called as such:\n * MedianFinder obj = new MedianFinder();\n * obj.addNum(num);\n * double param_2 = obj.findMedian();\n */", "total_acs": 55523, "total_submitted": 191893}, {"id": 296, "title": "Best Meeting Point", "url": "https://leetcode.com/problems/best-meeting-point/description", "companyTags": ["Twitter"], "difficulty": "Hard", "content": "A group of two or more people wants to meet and minimize the total travel distance. You are given a 2D grid of values 0 or 1, where each 1 marks the home of someone in the group. The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.\r\n\r\nFor example, given three people living at (0,0), (0,4), and (2,2):\r\n\r\n1 - 0 - 0 - 0 - 1\r\n|   |   |   |   |\r\n0 - 0 - 0 - 0 - 0\r\n|   |   |   |   |\r\n0 - 0 - 1 - 0 - 0\r\n\r\nThe point (0,2) is an ideal meeting point, as the total travel distance of 2+2+2=6 is minimal. So return 6.", "discussUrl": "https://discuss.leetcode.com/category/374", "similarQuestions": ["ShortestDistancefromAllBuildings", "MinimumMovestoEqualArrayElementsII"], "topicTags": ["Math", "Sort"], "Solution": "class Solution {\n    public int minTotalDistance(int[][] grid) {\n        int m = grid.length, n = grid[0].length;\n        int[] row_sum = new int[m], col_sum = new int[n];\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                row_sum[i] += grid[i][j];\n                col_sum[j] += grid[i][j];\n            }\n        }\n        return minDistance1D(row_sum) + minDistance1D(col_sum);\n    }\n    \n    private int minDistance1D(int[] arr) {\n        int i = -1, j = arr.length;\n        int d = 0, left = 0, right = 0;\n        while (i != j) {\n            if (left < right) {\n                d += left;\n                left += arr[++i];\n            } else {\n                d += right;\n                right += arr[--j];\n            }\n        }\n        return d;\n    }\n}", "total_acs": 15924, "total_submitted": 30462}, {"id": 297, "title": "Serialize and Deserialize Binary Tree", "url": "https://leetcode.com/problems/serialize-and-deserialize-binary-tree/description", "companyTags": ["Google", "Facebook", "Microsoft", "Amazon", "Bloomberg", "Uber", "LinkedIn", "Yahoo"], "difficulty": "Hard", "content": "Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\r\n\r\nDesign an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.\r\n\r\nFor example, you may serialize the following tree\r\n\r\n\r\n    1\r\n   / \\\r\n  2   3\r\n     / \\\r\n    4   5\r\n\r\n\r\nas \"[1,2,3,null,null,4,5]\", just the same as how LeetCode OJ serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.\r\n\r\n\u00a0\r\n\r\nNote: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.\r\n\r\nCredits:\r\nSpecial thanks to @Louis1992 for adding this problem and creating all test cases.\r\n", "discussUrl": "https://discuss.leetcode.com/category/375", "similarQuestions": ["EncodeandDecodeStrings", "SerializeandDeserializeBST", "FindDuplicateSubtrees"], "topicTags": ["Tree", "Design"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Codec {\n    TreeNode root;\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        this.root = root;\n        return \"\";\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        return root;\n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec codec = new Codec();\n// codec.deserialize(codec.serialize(root));", "total_acs": 93424, "total_submitted": 270534}, {"id": 298, "title": "Binary Tree Longest Consecutive Sequence", "url": "https://leetcode.com/problems/binary-tree-longest-consecutive-sequence/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "\r\nGiven a binary tree, find the length of the longest consecutive sequence path.\r\n\r\n\r\nThe path refers to any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The longest consecutive path need to be from parent to child (cannot be the reverse).\r\n\r\n\r\n\r\nFor example,\r\n\r\n   1\r\n    \\\r\n     3\r\n    / \\\r\n   2   4\r\n        \\\r\n         5\r\n\r\nLongest consecutive sequence path is 3-4-5, so return 3. \r\n\r\n   2\r\n    \\\r\n     3\r\n    / \r\n   2    \r\n  / \r\n 1\r\n\r\nLongest consecutive sequence path is 2-3,not3-2-1, so return 2.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/376", "similarQuestions": ["LongestConsecutiveSequence", "BinaryTreeLongestConsecutiveSequenceII"], "topicTags": ["Tree"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    // 298. Binary Tree Longest Consecutive Sequence\n    \n    // global sum LCS for this\n    int bestLCS = 0;\n    \n    public int longestConsecutive(TreeNode root) {\n        // special case null\n        if (root == null)\n            return bestLCS;\n        // sepcial case only root\n        //if (root.left == null && roo)\n        // call dfs\n        dfsLCS(root, 1, root.val-2); // make a dummy prev value \n        return bestLCS;\n    }\n\n    void dfsLCS(TreeNode node, int curLCS, int prevValue) {\n        // update bestLCS\n        bestLCS = Math.max(bestLCS, curLCS);\n        // base case\n        // node is null\n        if (node == null)\n            return;\n        // if current node is not consecutive or is null\n        if (node.val != prevValue+1) {\n            dfsLCS(node.left, 1, node.val);\n            dfsLCS(node.right, 1, node.val);\n        }\n        // else\n        else {\n            curLCS += 1;\n            // go check left and right children\n            dfsLCS(node.left, curLCS, node.val);\n            dfsLCS(node.right, curLCS, node.val);\n        }\n    }\n\n}", "total_acs": 40811, "total_submitted": 98009}, {"id": 299, "title": "Bulls and Cows", "url": "https://leetcode.com/problems/bulls-and-cows/description", "companyTags": [""], "difficulty": "Medium", "content": "You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called \"bulls\") and how many digits match the secret number but locate in the wrong position (called \"cows\"). Your friend will use successive guesses and hints to eventually derive the secret number.\r\n\r\n\r\nFor example:\r\n\r\nSecret number:  \"1807\"\r\nFriend's guess: \"7810\"\r\n\r\nHint: 1 bull and 3 cows. (The bull is 8, the cows are 0, 1 and 7.)\r\n\r\n\r\nWrite a function to return a hint according to the secret number and friend's guess, use A to indicate the bulls and B to indicate the cows. In the above example, your function should return \"1A3B\". \r\n\r\nPlease note that both secret number and friend's guess may contain duplicate digits, for example:\r\n\r\nSecret number:  \"1123\"\r\nFriend's guess: \"0111\"\r\n\r\nIn this case, the 1st 1 in friend's guess is a bull, the 2nd or 3rd 1 is a cow, and your function should return \"1A1B\".\r\n\r\n\r\nYou may assume that the secret number and your friend's guess only contain digits, and their lengths are always equal.\r\n\r\nCredits:Special thanks to @jeantimex for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/377", "similarQuestions": [""], "topicTags": ["HashTable"], "Solution": "class Solution {\n    public String getHint(String secret, String guess) {\n        int bulls=0,cows=0;\n        int[] counter = new int[10];\n        int n=secret.length();\n        for(int i =0; i<n; i++){\n            int s = secret.charAt(i)-'0';\n            int g = guess.charAt(i)-'0';\n            if(s==g)\n                bulls++;\n            else{\n                if(counter[g]>0) cows++;\n                if(counter[s]<0) cows++;\n                counter[s]++;\n                counter[g]--;\n            }   \n        }    \n        return bulls + \"A\" + cows + \"B\";\n        \n    }\n}", "total_acs": 65168, "total_submitted": 182602}, {"id": 300, "title": "Longest Increasing Subsequence", "url": "https://leetcode.com/problems/longest-increasing-subsequence/description", "companyTags": ["Microsoft"], "difficulty": "Medium", "content": "\r\nGiven an unsorted array of integers, find the length of longest increasing subsequence.\r\n\r\n\r\nFor example,\r\nGiven [10, 9, 2, 5, 3, 7, 101, 18],\r\nThe longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length.\r\n\r\n\r\nYour algorithm should run in O(n2) complexity.\r\n\r\n\r\nFollow up: Could you improve it to O(n log n) time complexity? \r\n\r\nCredits:Special thanks to @pbrother for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/379", "similarQuestions": ["IncreasingTripletSubsequence", "RussianDollEnvelopes", "MaximumLengthofPairChain", "NumberofLongestIncreasingSubsequence", "MinimumASCIIDeleteSumforTwoStrings"], "topicTags": ["BinarySearch", "DynamicProgramming"], "Solution": "public class Solution {\n    public int lengthOfLIS(int[] nums) {\n        int[] dp = new int[nums.length]; // if nums is all increasing\n        int len = 1; // LIS length, len - 1 is the last element in LIS\n        if(nums == null || nums.length == 0){\n            return 0;\n        }\n        dp[0] = nums[0];\n        for (int j = 1; j < nums.length; j++) {\n            int num = nums[j];\n            int i = binarySearch1(dp, 0, len - 1, num);// search between dp[0] to dp[len - 1]\n            dp[i] = num;\n            if (i == len) {\n                len++;\n            }\n        }\n        return len;\n    }\n    \n    public static int binarySearch1(int[] dp, int start, int end, int num){\n        while(start + 1 < end){\n            int mid = start + (end - start) / 2;\n            if(dp[mid] == num){\n                return mid;\n            }\n            if(dp[mid] < num){\n                start = mid;\n            }\n            else{\n                end = mid;\n            }\n        }\n        if(dp[start] >= num){\n            return start;\n        }\n        if(dp[end] >= num){\n            return end;\n        }\n        return end + 1;\n    }\n}", "total_acs": 112903, "total_submitted": 290537}, {"id": 301, "title": "Remove Invalid Parentheses", "url": "https://leetcode.com/problems/remove-invalid-parentheses/description", "companyTags": ["Facebook"], "difficulty": "Hard", "content": "\r\nRemove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.\r\n\r\nNote: The input string may contain letters other than the parentheses ( and ). \r\n\r\n\r\n\r\nExamples:\r\n\r\n\"()())()\" -> [\"()()()\", \"(())()\"]\r\n\"(a)())()\" -> [\"(a)()()\", \"(a())()\"]\r\n\")(\" -> [\"\"]\r\n\r\n\r\n\r\nCredits:Special thanks to @hpplayer for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/380", "similarQuestions": ["ValidParentheses"], "topicTags": ["Depth-firstSearch", "Breadth-firstSearch"], "Solution": "class Solution {\n    public List<String> removeInvalidParentheses(String s) {\n        List<String> result = new ArrayList<>();\n        if (s == null){\n            return result;\n        }        \n        remove(s, result, 0, 0, '(', ')');\n        return result;\n    }\n    \n   private void remove(String s, List<String> result, int left, int right, char open, char close) {\n        for (int i = left, cnt = 0; i < s.length(); i++) {\n            if (s.charAt(i) == open){\n                cnt++;\n            } \n            if (s.charAt(i) == close){\n                cnt--;\n            }\n            if (cnt >= 0){\n                continue;\n            }\n            for (int j = right; j <= i; j++) {\n                if (s.charAt(j) == close && (j == right || s.charAt(j - 1) != close)) {\n                    remove(s.substring(0, j) + s.substring(j + 1), result, i, j, open, close);\n                }\n            }\n            return;\n        }\n        String sb = new StringBuilder(s).reverse().toString();\n        if (open == '(') {\n            remove(sb, result, 0, 0, ')', '(');\n        }else{\n            result.add(sb);\n        }\n   }\n}", "total_acs": 62613, "total_submitted": 174675}, {"id": 302, "title": "Smallest Rectangle Enclosing Black Pixels", "url": "https://leetcode.com/problems/smallest-rectangle-enclosing-black-pixels/description", "companyTags": ["Google"], "difficulty": "Hard", "content": "An image is represented by a binary matrix with 0 as a white pixel and 1 as a black pixel. The black pixels are connected, i.e., there is only one black region. Pixels are connected horizontally and vertically. Given the location (x, y) of one of the black pixels, return the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\r\n\r\n\r\nFor example, given the following image:\r\n\r\n[\r\n  \"0010\",\r\n  \"0110\",\r\n  \"0100\"\r\n]\r\n\r\nand x = 0, y = 2,\r\n\r\n\r\n\r\nReturn 6.\r\n", "discussUrl": "https://discuss.leetcode.com/category/381", "similarQuestions": [""], "topicTags": ["BinarySearch"], "Solution": "class Solution {\nprivate char[][] image;\npublic int minArea(char[][] iImage, int x, int y) {\n    image = iImage;\n    int m = image.length, n = image[0].length;\n    int left = searchColumns(0, y, 0, m, true);\n    int right = searchColumns(y + 1, n, 0, m, false);\n    int top = searchRows(0, x, left, right, true);\n    int bottom = searchRows(x + 1, m, left, right, false);\n    return (right - left) * (bottom - top);\n}\nprivate int searchColumns(int i, int j, int top, int bottom, boolean opt) {\n    while (i != j) {\n        int k = top, mid = (i + j) / 2;\n        while (k < bottom && image[k][mid] == '0') ++k;\n        if (k < bottom == opt)\n            j = mid;\n        else\n            i = mid + 1;\n    }\n    return i;\n}\nprivate int searchRows(int i, int j, int left, int right, boolean opt) {\n    while (i != j) {\n        int k = left, mid = (i + j) / 2;\n        while (k < right && image[mid][k] == '0') ++k;\n        if (k < right == opt)\n            j = mid;\n        else\n            i = mid + 1;\n    }\n    return i;\n}\n//  Runtime: 1 ms\n}", "total_acs": 16608, "total_submitted": 35778}, {"id": 303, "title": "Range Sum Query - Immutable", "url": "https://leetcode.com/problems/range-sum-query-immutable/description", "companyTags": ["Palantir"], "difficulty": "Easy", "content": "Given an integer array nums, find the sum of the elements between indices i and j (i \u2264 j), inclusive.\r\n\r\nExample:\r\n\r\nGiven nums = [-2, 0, 3, -5, 2, -1]\r\n\r\nsumRange(0, 2) -> 1\r\nsumRange(2, 5) -> -1\r\nsumRange(0, 5) -> -3\r\n\r\n\r\n\r\nNote:\r\n\r\nYou may assume that the array does not change.\r\nThere are many calls to sumRange function.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/382", "similarQuestions": ["RangeSumQuery2D-Immutable", "RangeSumQuery-Mutable", "MaximumSizeSubarraySumEqualsk"], "topicTags": ["DynamicProgramming"], "Solution": "class NumArray {\n\n    int[] sums = null;\n    \n    public NumArray(int[] nums) {\n        sums = new int[nums.length];\n        \n        if (nums.length == 0) {\n            return;\n        }\n        \n        sums[0] = nums[0];\n        \n        for (int i = 1; i < nums.length; i++) {\n            sums[i] = sums[i - 1] + nums[i];\n        }\n    }\n    \n    public int sumRange(int i, int j) {\n        if (i == 0) {\n            return sums[j];\n        }\n        \n        return sums[j] - sums[i - 1];\n    }\n}\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * NumArray obj = new NumArray(nums);\n * int param_1 = obj.sumRange(i,j);\n */", "total_acs": 88557, "total_submitted": 279735}, {"id": 304, "title": "Range Sum Query 2D - Immutable", "url": "https://leetcode.com/problems/range-sum-query-2d-immutable/description", "companyTags": [""], "difficulty": "Medium", "content": "Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).\r\n\r\n\r\n\r\nThe above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8.\r\n\r\n\r\nExample:\r\n\r\nGiven matrix = [\r\n  [3, 0, 1, 4, 2],\r\n  [5, 6, 3, 2, 1],\r\n  [1, 2, 0, 1, 5],\r\n  [4, 1, 0, 1, 7],\r\n  [1, 0, 3, 0, 5]\r\n]\r\n\r\nsumRegion(2, 1, 4, 3) -> 8\r\nsumRegion(1, 1, 2, 2) -> 11\r\nsumRegion(1, 2, 2, 4) -> 12\r\n\r\n\r\n\r\nNote:\r\n\r\nYou may assume that the matrix does not change.\r\nThere are many calls to sumRegion function.\r\nYou may assume that row1 \u2264 row2 and col1 \u2264 col2.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/383", "similarQuestions": ["RangeSumQuery-Immutable", "RangeSumQuery2D-Mutable"], "topicTags": ["DynamicProgramming"], "Solution": "class NumMatrix {\n    \n    int[][] preSum;\n\n    public NumMatrix(int[][] matrix) {\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n            return;\n        }\n        preSum = new int[matrix.length + 1][matrix[0].length + 1];\n        for (int i = 0; i < matrix.length; i++) {\n            for (int j = 0; j < matrix[i].length; j++) {\n                preSum[i + 1][j + 1] = preSum[i + 1][j] + preSum[i][j + 1] - preSum[i][j] + matrix[i][j];\n            }\n        }\n    }\n    \n    public int sumRegion(int row1, int col1, int row2, int col2) {\n        int maxRow = Math.max(row1, row2);\n        int minRow = Math.min(row1, row2);\n        int maxCol = Math.max(col1, col2);\n        int minCol = Math.min(col1, col2);\n        return preSum[maxRow + 1][maxCol + 1] - preSum[maxRow + 1][minCol] - preSum[minRow][maxCol + 1] + preSum[minRow][minCol];\n    }\n}\n\n/**\n * Your NumMatrix object will be instantiated and called as such:\n * NumMatrix obj = new NumMatrix(matrix);\n * int param_1 = obj.sumRegion(row1,col1,row2,col2);\n */", "total_acs": 41340, "total_submitted": 154232}, {"id": 305, "title": "Number of Islands II", "url": "https://leetcode.com/problems/number-of-islands-ii/description", "companyTags": ["Google"], "difficulty": "Hard", "content": "A 2d grid map of m rows and n columns is initially filled with water.\r\nWe may perform an addLand operation which turns the water at position (row, col) into a land.\r\nGiven a list of positions to operate, count the number of islands after each addLand operation.\r\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.\r\nYou may assume all four edges of the grid are all surrounded by water.\r\n\r\nExample:\r\nGiven m = 3, n = 3, positions = [[0,0], [0,1], [1,2], [2,1]].\r\nInitially, the 2d grid grid is filled with water. (Assume 0 represents water and 1 represents land).\r\n\r\n0 0 0\r\n0 0 0\r\n0 0 0\r\n\r\nOperation #1: addLand(0, 0) turns the water at grid[0][0] into a land.\r\n\r\n1 0 0\r\n0 0 0   Number of islands = 1\r\n0 0 0\r\n\r\nOperation #2: addLand(0, 1) turns the water at grid[0][1] into a land.\r\n\r\n1 1 0\r\n0 0 0   Number of islands = 1\r\n0 0 0\r\n\r\nOperation #3: addLand(1, 2) turns the water at grid[1][2] into a land.\r\n\r\n1 1 0\r\n0 0 1   Number of islands = 2\r\n0 0 0\r\n\r\nOperation #4: addLand(2, 1) turns the water at grid[2][1] into a land.\r\n\r\n1 1 0\r\n0 0 1   Number of islands = 3\r\n0 1 0\r\n\r\nWe return the result as an array: [1, 1, 2, 3]\r\n\r\nChallenge:\r\nCan you do it in time complexity O(k log mn), where k is the length of the positions?", "discussUrl": "https://discuss.leetcode.com/category/384", "similarQuestions": ["NumberofIslands"], "topicTags": ["UnionFind"], "Solution": "class Solution {\n    public List<Integer> numIslands2(int m, int n, int[][] positions) {\n        //using union fund algorithm\n        //initialize the union fund root array\n        int[] root = new int[m*n];\n        for(int i = 0; i < root.length; i++){\n            root[i]= -1;\n        }\n        int count=0;\n        List<Integer> res = new ArrayList<>();\n        \n        for(int i = 0; i < positions.length; i++){\n            int[] pos = positions[i];\n            int x = pos[1];\n            int y = pos[0];\n            \n            int curRoot = x + y*n;\n            if(root[curRoot]==-1){\n                root[curRoot] = curRoot;\n            }\n            count++;\n            \n            if(x > 0 && root[x-1+y*n]!=-1){\n                int nbRoot = find(x-1+y*n, root);\n                if(nbRoot!=curRoot){//union two group\n                    root[curRoot] = nbRoot;\n                    curRoot = nbRoot;\n                    count --;\n                }\n            }\n            if(x < n-1 && root[x+1+y*n]!=-1){\n                int nbRoot = find(x+1+y*n, root);\n                if(nbRoot!=curRoot){//union two group\n                    root[curRoot] = nbRoot;\n                    curRoot = nbRoot;\n                    count --;\n                }\n            }\n            if(y > 0 && root[x+(y-1)*n]!=-1){\n                int nbRoot = find(x+(y-1)*n, root);\n                if(nbRoot!=curRoot){//union two group\n                    root[curRoot] = nbRoot;\n                    curRoot = nbRoot;\n                    count --;\n                }\n            }\n            if(y<m-1 && root[x+(y+1)*n]!=-1){\n                int nbRoot = find(x+(y+1)*n, root);\n                if(nbRoot!=curRoot){//union two group\n                    root[curRoot] = nbRoot;\n                    curRoot = nbRoot;\n                    count --;\n                }\n            }\n            res.add(count);\n        }\n        return res;\n    }\n    \n    private int find(int id, int[] root){\n        while(id != root[id]){\n            id = root[id];\n            root[id] = root[root[id]];\n        }\n        return id;\n    }\n}", "total_acs": 30506, "total_submitted": 77002}, {"id": 306, "title": "Additive Number", "url": "https://leetcode.com/problems/additive-number/description", "companyTags": ["EpicSystems"], "difficulty": "Medium", "content": "Additive number is a string whose digits can form additive sequence.\r\n\r\nA valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.\r\n\r\n\r\nFor example:\r\n\"112358\" is an additive number because the digits can form an additive sequence: 1, 1, 2, 3, 5, 8.\r\n1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8\r\n\"199100199\" is also an additive number, the additive sequence is: 1, 99, 100, 199.\r\n1 + 99 = 100, 99 + 100 = 199\r\n\r\n\r\n\r\nNote: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.\r\n\r\n\r\nGiven a string containing only digits '0'-'9', write a function to determine if it's an additive number.\r\n\r\n\r\nFollow up:\r\nHow would you handle overflow for very large input integers?\r\n\r\n\r\nCredits:Special thanks to @jeantimex for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/385", "similarQuestions": [""], "topicTags": [""], "Solution": "class Solution {\n    \n\tpublic boolean isAdditiveNumber(String num) {\n\t    if(num == null || num.length() < 3){\n\t    \treturn false;\n\t    }\n        \n        // for (int i = 0; i < (num.length() - 1) / 2; i++) {\n        //     for (int j = i + 1; num.length() - j - 1 >= Math.max(i + 1, j - i); j++) {\n        //         if (isValid(num.substring(0, i + 1), num.substring(i + 1, j + 1), num.substring(j + 1)))\n        //             return true;\n        //     }\n        // }\n        \n        for(int i = 0; i < num.length() / 2; i++) {\n            for(int j = i + 1; num.length() - j - 1 >= j - i && num.length() - j - 1 >= i + 1; j++) {\n                if(isAdditive(num.substring(0, i + 1), num.substring(i + 1, j + 1), num.substring(j + 1))){\n                \treturn true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public boolean isAdditive(String num1, String num2, String str) {\n        if(num1.charAt(0) == '0' && num1.length() > 1){\n            return false;\n        }\n        if(num2.charAt(0) == '0' && num2.length() > 1){\n            return false;\n        }\n        if(str.isEmpty()){\n        \treturn true;\n        }\n        String sum = String.valueOf(Long.parseLong(num1) + Long.parseLong(num2));\n        if(!str.startsWith(sum)){\n        \treturn false;\n        }\n        return isAdditive(num2, sum, str.substring(sum.length()));\n    }\n    \n    \n    //Analysis: try all the starts and see whether we can find a valid one. \n    \n//     public boolean isAdditiveNumber(String num) {\n//         if(num == null || num.length() < 3){\n//             return false;\n//         }\n//         for(int i = 0; i < num.length() / 2; i++){\n//             for(int j = i + 1; j < num.length() - 1; j++){\n//                 if(isValid(num.substring(0, i + 1), num.substring(i + 1, j + 1), num.substring(j + 1))){\n//                     return true;\n//                 }\n//             }\n//         }\n//         return false;\n//     }\n    \n//     private boolean isValid(String str1, String str2, String str3){\n//         if(){\n            \n//         }\n//     }\n    \n}", "total_acs": 29612, "total_submitted": 106876}, {"id": 307, "title": "Range Sum Query - Mutable", "url": "https://leetcode.com/problems/range-sum-query-mutable/description", "companyTags": [""], "difficulty": "Medium", "content": "Given an integer array nums, find the sum of the elements between indices i and j (i \u2264 j), inclusive.\r\n\r\nThe update(i, val) function modifies nums by updating the element at index i to val.\r\n\r\nExample:\r\n\r\nGiven nums = [1, 3, 5]\r\n\r\nsumRange(0, 2) -> 9\r\nupdate(1, 2)\r\nsumRange(0, 2) -> 8\r\n\r\n\r\n\r\nNote:\r\n\r\nThe array is only modifiable by the update function.\r\nYou may assume the number of calls to update and sumRange function is distributed evenly.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/387", "similarQuestions": ["RangeSumQuery-Immutable", "RangeSumQuery2D-Mutable"], "topicTags": ["BinaryIndexedTree", "SegmentTree"], "Solution": "class NumArray {\n   int[] nums;\n\tint[] BIT;\n\tint n;\n\n\tpublic NumArray(int[] nums) {\n\t\tthis.nums = nums;\n\n\t\tn = nums.length;\n\t\tBIT = new int[n + 1];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tinit(i, nums[i]);\n\t}\n\n\tpublic void init(int i, int val) {\n\t\ti++;\n\t\twhile (i <= n) {\n\t\t\tBIT[i] += val;\n\t\t\ti += (i & -i);\n\t\t}\n\t}\n\n\tvoid update(int i, int val) {\n\t\tint diff = val - nums[i];\n\t\tnums[i] = val;\n\t\tinit(i, diff);\n\t}\n\n\tpublic int getSum(int i) {\n\t\tint sum = 0;\n\t\ti++;\n\t\twhile (i > 0) {\n\t\t\tsum += BIT[i];\n\t\t\ti -= (i & -i);\n\t\t}\n\t\treturn sum;\n\t}\n\n\tpublic int sumRange(int i, int j) {\n\t\treturn getSum(j) - getSum(i - 1);\n\t}\n}\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * NumArray obj = new NumArray(nums);\n * obj.update(i,val);\n * int param_2 = obj.sumRange(i,j);\n */", "total_acs": 41473, "total_submitted": 187560}, {"id": 308, "title": "Range Sum Query 2D - Mutable", "url": "https://leetcode.com/problems/range-sum-query-2d-mutable/description", "companyTags": ["Google"], "difficulty": "Hard", "content": "Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).\r\n\r\n\r\n\r\nThe above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8.\r\n\r\n\r\nExample:\r\n\r\nGiven matrix = [\r\n  [3, 0, 1, 4, 2],\r\n  [5, 6, 3, 2, 1],\r\n  [1, 2, 0, 1, 5],\r\n  [4, 1, 0, 1, 7],\r\n  [1, 0, 3, 0, 5]\r\n]\r\n\r\nsumRegion(2, 1, 4, 3) -> 8\r\nupdate(3, 2, 2)\r\nsumRegion(2, 1, 4, 3) -> 10\r\n\r\n\r\n\r\nNote:\r\n\r\nThe matrix is only modifiable by the update function.\r\nYou may assume the number of calls to update and sumRegion function is distributed evenly.\r\nYou may assume that row1 \u2264 row2 and col1 \u2264 col2.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/388", "similarQuestions": ["RangeSumQuery2D-Immutable", "RangeSumQuery-Mutable"], "topicTags": ["BinaryIndexedTree", "SegmentTree"], "Solution": null, "total_acs": 20412, "total_submitted": 80657}, {"id": 309, "title": "Best Time to Buy and Sell Stock with Cooldown", "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "Say you have an array for which the ith element is the price of a given stock on day i.\r\n\r\nDesign an algorithm to find the maximum profit. You may complete as many transactions as you like\r\n(ie, buy one and sell one share of the stock multiple times) with the following restrictions:\r\n\r\n\r\n    You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).\r\n    After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)\r\n\r\n\r\nExample:\r\n\r\nprices = [1, 2, 3, 0, 2]\r\nmaxProfit = 3\r\ntransactions = [buy, sell, cooldown, buy, sell]\r\n\r\n\r\nCredits:Special thanks to @dietpepsi for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/389", "similarQuestions": ["BestTimetoBuyandSellStock", "BestTimetoBuyandSellStockII"], "topicTags": ["DynamicProgramming"], "Solution": "class Solution {\n    public int maxProfit(int[] prices) {\n        if(prices == null || prices.length == 0 || prices.length == 1){\n            return 0;\n        }\n        // Consider buy as a transaction\n        // T[i][0][0] = 0;\n        // T[i][0][1] = -Infinity;\n        // T[i][k][t] = T[i][k - 1][t]\n        \n        // T[i][k][0] = T[i - 1][k][0], T[i - 1][k][1] + price[i]\n        // T[i][k][1] = T[i - 1][k][1], T[i - 2][k-1][0] - price[i] => T[i - 1][k][1], old(T[i - 2][k][0]) - price[i]\n\n        int i0 = 0;\n        int i1 = -prices[0];\n        int i00 = Math.max(0, prices[1] - prices[0]);\n        int i11 = Math.max(-prices[0], -prices[1]);\n\n        for(int i = 2; i < prices.length; i++){\n            int oldi00 = i00;\n            i00 = Math.max(i00, i11 + prices[i]);\n            i11 = Math.max(i11, i0 - prices[i]);\n            i0 = oldi00;\n        }\n        return i00;    \n    }\n}", "total_acs": 56046, "total_submitted": 134174}, {"id": 310, "title": "Minimum Height Trees", "url": "https://leetcode.com/problems/minimum-height-trees/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "\r\n    For a undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs).\r\n    Given such a graph, write a function to find all the MHTs and return a list of their root labels.\r\n\r\n\r\n\r\n    Format\r\n    The graph contains n nodes which are labeled from 0 to n - 1.\r\n    You will be given the number n and a list of undirected edges (each edge is a pair of labels).\r\n\r\n \r\nYou can assume that no duplicate edges will appear in edges. Since all edges are\r\n    undirected, [0, 1] is the same as [1, 0] and thus will not appear together in\r\n    edges.\r\n\r\n\r\n    Example 1:\r\n\r\n\r\n    Given n = 4, edges = [[1, 0], [1, 2], [1, 3]]\r\n\r\n\r\n\r\n        0\r\n        |\r\n        1\r\n       / \\\r\n      2   3\r\n\r\n\r\n    return  [1]\r\n\r\n\r\n\r\n    Example 2:\r\n\r\n\r\n    Given n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]\r\n\r\n\r\n     0  1  2\r\n      \\ | /\r\n        3\r\n        |\r\n        4\r\n        |\r\n        5\r\n\r\n\r\n    return  [3, 4]\r\n\r\n\r\n\r\n    Note:\r\n\r\n\r\n    (1) According to the definition\r\n    of tree on Wikipedia: \u201ca tree is an undirected graph in which any two vertices are connected by\r\n    exactly one path. In other words, any connected graph without simple cycles is a tree.\u201d\r\n\r\n\r\n    (2) The height of a rooted tree is the number of edges on the longest downward path between the root and a\r\n    leaf.\r\n\r\n\r\nCredits:Special thanks to @dietpepsi for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/390", "similarQuestions": ["CourseSchedule", "CourseScheduleII"], "topicTags": ["Breadth-firstSearch", "Graph"], "Solution": "\nimport java.util.*;\n\nclass Solution {\n    \n    static class TreeNode {\n        final int id;\n        int sonCnt;\n        ListNode sonList;\n        TreeNode(int id) {\n            this.id = id;\n        }\n        \n        void addSon(TreeNode son) {\n            sonCnt++;\n            sonList = new ListNode(son, sonList);\n        }\n    }\n    static class ListNode {\n        final ListNode next;\n        final TreeNode node;\n        ListNode(TreeNode node, ListNode next) {\n            this.node = node;\n            this.next = next;\n        }\n    }\n    \n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\n        TreeNode[] nodes = new TreeNode[n];\n        for(int i = 0; i < n; i++) {\n            nodes[i] = new TreeNode(i);\n        }\n        for(int[] edge : edges) {\n            TreeNode node0 = nodes[edge[0]];\n            TreeNode node1 = nodes[edge[1]];\n            node0.addSon(node1);\n            node1.addSon(node0);\n        }\n        int size = 0;\n        ListNode leafList = null;\n        for(TreeNode node : nodes) {\n            if(node.sonCnt <= 1) {\n                node.sonCnt = Integer.MAX_VALUE;\n                leafList = new ListNode(node, leafList);\n                size++;\n            }\n        }\n        for(; (n -= size) > 0;) {\n            ListNode newLeafList = null;\n            int newSize = 0;\n            for(; leafList != null; leafList = leafList.next) {\n                TreeNode node = leafList.node;\n                for(ListNode sonList = node.sonList; sonList != null; sonList = sonList.next) {\n                    TreeNode sonNode = sonList.node;\n                    if(--sonNode.sonCnt <= 1) {\n                        sonNode.sonCnt = Integer.MAX_VALUE;\n                        newLeafList = new ListNode(sonNode, newLeafList);\n                        newSize++;\n                    }\n                }\n            }\n            leafList = newLeafList;\n            size = newSize;\n        }\n        Integer[] ids = new Integer[size];\n        for(int i = 0; leafList != null; leafList = leafList.next) {\n            ids[i++] = leafList.node.id;\n        }\n        return Arrays.asList(ids);\n    }\n}", "total_acs": 41323, "total_submitted": 142602}, {"id": 311, "title": "Sparse Matrix Multiplication", "url": "https://leetcode.com/problems/sparse-matrix-multiplication/description", "companyTags": ["Facebook", "LinkedIn"], "difficulty": "Medium", "content": "Given two sparse matrices A and B, return the result of AB.\r\n\r\nYou may assume that A's column number is equal to B's row number.\r\n\r\nExample:\r\n\r\n\r\nA = [\r\n  [ 1, 0, 0],\r\n  [-1, 0, 3]\r\n]\r\n\r\nB = [\r\n  [ 7, 0, 0 ],\r\n  [ 0, 0, 0 ],\r\n  [ 0, 0, 1 ]\r\n]\r\n\r\n\r\n     |  1 0 0 |   | 7 0 0 |   |  7 0 0 |\r\nAB = | -1 0 3 | x | 0 0 0 | = | -7 0 3 |\r\n                  | 0 0 1 |\r\n", "discussUrl": "https://discuss.leetcode.com/category/391", "similarQuestions": [""], "topicTags": ["HashTable"], "Solution": "class Solution {\n    public int[][] multiply(int[][] A, int[][] B) {\n        \n        int rowA = A.length;\n        int colA = A[0].length;\n        int rowB = B.length;\n        int colB = B[0].length;\n        \n        \n        int[][] res = new int[rowA][colB];\n        \n        for(int i = 0; i < rowA; i++){\n            for(int j = 0; j < colA; j++){\n                if(A[i][j] != 0){\n                    for(int m = 0; m < colB; m++){\n                        if(B[j][m] != 0) res[i][m] += A[i][j] * B[j][m];\n                    }\n                }\n            }\n        }\n        return res;\n        \n        \n        \n    \n        \n    }\n}", "total_acs": 42575, "total_submitted": 81431}, {"id": 312, "title": "Burst Balloons", "url": "https://leetcode.com/problems/burst-balloons/description", "companyTags": ["Google", "Snapchat"], "difficulty": "Hard", "content": "\r\n    Given n balloons, indexed from 0 to n-1. Each balloon is painted with a\r\n    number on it represented by array nums.\r\n\r\n    You are asked to burst all the balloons. If the you burst\r\n    balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left\r\n    and right are adjacent indices of i. After the burst, the left and right\r\n    then becomes adjacent.\r\n\r\n\r\n    Find the maximum coins you can collect by bursting the balloons wisely.\r\n\r\n\r\n    Note: \r\n    (1) You may imagine nums[-1] = nums[n] = 1. They are not real therefore you can not burst them.\r\n    (2) 0 \u2264 n \u2264 500, 0 \u2264 nums[i] \u2264 100\r\n\r\n\r\n\r\n\r\n    Example:\r\n\r\n\r\n    Given [3, 1, 5, 8]\r\n\r\n\r\n    Return 167\r\n\r\n\r\n    nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []\r\n   coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167\r\n\r\n\r\nCredits:Special thanks to @dietpepsi for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/392", "similarQuestions": [""], "topicTags": ["DivideandConquer", "DynamicProgramming"], "Solution": "class Solution {\n    public int maxCoins(int[] nums) {\n        if (nums == null || nums.length == 0)\n            return 0;\n        \n        // Map<int[],Integer> dp = new HashMap<int[], Integer>();\n        int[][] dp = new int[nums.length][nums.length];\n        \n        // precalculate\n        for (int delta = 0; delta < nums.length; ++delta)\n        {\n            for (int left = 0; left + delta < nums.length; ++left)\n            {\n                maxCoins(nums, left, left+delta, dp);\n            }\n        }\n        \n        return dp[0][nums.length-1];\n        // return maxCoins(nums, 0, nums.length-1, dp);\n    }\n    \n    // reverse order: pick balloons in reverse order of popping so we can use intervals\n    //                for dp.\n    public static int maxCoins(int[] nums, int left, int right, int[][] dp)\n    {\n        if (left == right)\n        {\n            int coins = nums[left];\n            if (left-1 >= 0)\n                coins *= nums[left-1];\n            if (right+1 < nums.length)\n                coins *= nums[right+1];\n            \n            dp[left][right] = coins;\n            return coins;\n        }\n        \n        // int[] key = new int[] {left, right};\n        // if (dp.containsKey(key))\n        // {\n        //     return dp.get(key);\n        // }\n        \n        int maxCoins = Integer.MIN_VALUE;\n        int baseMultiplier = 1;\n        if (left-1 >= 0)\n            baseMultiplier = nums[left-1];\n        if (right+1 < nums.length)\n            baseMultiplier *= nums[right+1];\n        for (int i = left; i <= right; ++i)\n        {\n            int coins = baseMultiplier * nums[i];\n            \n            if (i > left)\n                // coins += maxCoins(nums, left, i-1, dp);\n                coins += dp[left][i-1];\n            if (i < right)\n                //coins += maxCoins(nums, i+1, right, dp);\n                coins += dp[i+1][right];\n            \n            if (coins > maxCoins)\n                maxCoins = coins;\n        }\n        \n        // dp.put(key, maxCoins);\n        dp[left][right] = maxCoins;\n        return maxCoins;\n    }\n}", "total_acs": 35538, "total_submitted": 81688}, {"id": 313, "title": "Super Ugly Number", "url": "https://leetcode.com/problems/super-ugly-number/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "\r\n    Write a program to find the nth super ugly number.\r\n\r\n\r\n\r\n    Super ugly numbers are positive numbers whose all prime factors are in the given prime list\r\n    primes of size k. For example, [1, 2, 4, 7, 8, 13, 14, 16, 19, 26, 28, 32]\r\n is the sequence of the first 12 super ugly numbers given primes\r\n    = [2, 7, 13, 19] of size 4.\r\n\r\n\r\n\r\n    Note:\r\n    (1) 1 is a super ugly number for any given primes.\r\n    (2) The given numbers in primes are in ascending order.\r\n    (3) 0 < k \u2264 100, 0 < n \u2264 106, 0 < primes[i] < 1000.\r\n    (4) The nth super ugly number is guaranteed to fit in a 32-bit signed integer.\r\n\r\n\r\nCredits:Special thanks to @dietpepsi for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/393", "similarQuestions": ["UglyNumberII"], "topicTags": ["Math", "Heap"], "Solution": "class Solution {\n    public int nthSuperUglyNumber(int n, int[] primes) {\n        int size = primes.length;\n        int[] next = new int[size];\n        int[] index = new int[size];\n        int[] ugly = new int[n];\n        ugly[0] = 1;\n        for (int i = 0; i < size; ++i) {\n            next[i] = primes[i];\n        }\n        for (int i = 1; i < n; ++i) {\n            int tmpnext = Integer.MAX_VALUE;\n            int tmpindex = 0;\n            for (int j = 0; j < size; ++j) {\n                if (tmpnext > next[j]) {\n                    tmpnext = next[j];\n                    tmpindex = j;\n                }\n            }\n            ugly[i] = tmpnext;\n            for (int j = 0; j < size; ++j) {\n                if (tmpnext == next[j]) {\n                    index[j] += 1;\n                    next[j] = ugly[index[j]]*primes[j];\n                }\n            } \n        }\n        return ugly[n-1];\n    }\n}", "total_acs": 44083, "total_submitted": 115341}, {"id": 314, "title": "Binary Tree Vertical Order Traversal", "url": "https://leetcode.com/problems/binary-tree-vertical-order-traversal/description", "companyTags": ["Google", "Facebook", "Snapchat"], "difficulty": "Medium", "content": "Given a binary tree, return the vertical order traversal of its nodes' values. (ie, from top to bottom, column by column).\r\nIf two nodes are in the same row and column, the order should be from left to right.\r\n\r\nExamples:\r\n\r\n\r\nGiven binary tree [3,9,20,null,null,15,7],\r\n\r\n   3\r\n  /\\\r\n /  \\\r\n 9  20\r\n    /\\\r\n   /  \\\r\n  15   7\r\n\r\n\r\n\r\nreturn its vertical order traversal as:\r\n\r\n[\r\n  [9],\r\n  [3,15],\r\n  [20],\r\n  [7]\r\n]\r\n\r\n\r\n\r\nGiven binary tree [3,9,8,4,0,1,7],\r\n\r\n     3\r\n    /\\\r\n   /  \\\r\n   9   8\r\n  /\\  /\\\r\n /  \\/  \\\r\n 4  01   7\r\n\r\n\r\n\r\nreturn its vertical order traversal as:\r\n\r\n[\r\n  [4],\r\n  [9],\r\n  [3,0,1],\r\n  [8],\r\n  [7]\r\n]\r\n\r\n\r\n\r\nGiven binary tree [3,9,8,4,0,1,7,null,null,null,2,5] (0's right child is 2 and 1's left child is 5),\r\n\r\n     3\r\n    /\\\r\n   /  \\\r\n   9   8\r\n  /\\  /\\\r\n /  \\/  \\\r\n 4  01   7\r\n    /\\\r\n   /  \\\r\n   5   2\r\n\r\n\r\n\r\nreturn its vertical order traversal as:\r\n\r\n[\r\n  [4],\r\n  [9,5],\r\n  [3,0,1],\r\n  [8,2],\r\n  [7]\r\n]\r\n\r\n\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/394", "similarQuestions": ["BinaryTreeLevelOrderTraversal"], "topicTags": ["HashTable"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    int min=0,max=0;\n    public List<List<Integer>> verticalOrder(TreeNode root) {\n        countRange(root,0);\n        List<List<Integer>> res=new ArrayList<>();\n        Queue<TreeNode> que_node=new LinkedList<>();\n        Queue<Integer> que_idx=new LinkedList<>();\n        if(root==null) return res;\n        for(int i=min;i<=max;i++)  res.add(new ArrayList<>());\n        que_node.add(root);\n        que_idx.add(-min);\n        while(!que_node.isEmpty()){\n            TreeNode buff=que_node.poll();\n            int i=que_idx.poll();\n            res.get(i).add(buff.val);\n            if(buff.left!=null){\n                que_node.add(buff.left);\n                que_idx.add(i-1);\n            }\n            if(buff.right!=null){\n                que_node.add(buff.right);\n                que_idx.add(i+1);\n            }\n        }\n        return res;\n    }\n    public void countRange(TreeNode root,int cur){\n        if(root==null) return;\n        min=Math.min(cur,min);\n        max=Math.max(cur,max);\n        countRange(root.left,cur-1);\n        countRange(root.right,cur+1);\n    }\n}", "total_acs": 39929, "total_submitted": 105545}, {"id": 315, "title": "Count of Smaller Numbers After Self", "url": "https://leetcode.com/problems/count-of-smaller-numbers-after-self/description", "companyTags": ["Google"], "difficulty": "Hard", "content": "\r\nYou are given an integer array nums and you have to return a new counts array.\r\nThe counts array has the property where counts[i] is \r\nthe number of smaller elements to the right of nums[i].\r\n\r\n\r\nExample:\r\n\r\n\r\nGiven nums = [5, 2, 6, 1]\r\n\r\nTo the right of 5 there are 2 smaller elements (2 and 1).\r\nTo the right of 2 there is only 1 smaller element (1).\r\nTo the right of 6 there is 1 smaller element (1).\r\nTo the right of 1 there is 0 smaller element.\r\n\r\n\r\n\r\nReturn the array [2, 1, 1, 0].\r\n", "discussUrl": "https://discuss.leetcode.com/category/395", "similarQuestions": ["CountofRangeSum", "QueueReconstructionbyHeight", "ReversePairs"], "topicTags": ["DivideandConquer", "BinaryIndexedTree", "SegmentTree", "BinarySearchTree"], "Solution": "class Solution {\n    public List<Integer> countSmaller(int[] nums) {\n        if(nums.length == 0)\n            return new ArrayList<>();\n        int min = Integer.MAX_VALUE;\n        for(int value : nums)\n        {\n            if(value < min)\n                min = value;\n        }\n        for(int i = 0; i < nums.length; i++) {\n            nums[i] = nums[i] - min + 1;\n        }\n        int max = Integer.MIN_VALUE;\n        for(int value : nums) {\n            if(value > max)\n                max = value;\n        }\n        int[] BITree = new int[max + 1];\n        BITree[0] = 0;\n        int[] countArr = new int[nums.length];\n        for(int i = nums.length - 1; i >= 0; i--) {\n            int count = getSum(nums[i]-1, BITree);\n            countArr[i] = count;\n            update(nums[i], BITree);\n        }\n        List<Integer> result = new ArrayList<>();\n        for(int value : countArr) {\n            result.add(value);\n        }\n        return result;\n    }\n    public int getSum(int value, int[] BITree) {\n        int sum = 0;\n        while(value > 0) {\n            sum += BITree[value];\n            //System.out.println(\"BITree[\" + value + \"] = \" + BITree[value] + \" sum  = \" + sum);\n            value -= (value & -value); \n        }\n        return sum;\n    }\n    public void update(int value, int[] BITree) {\n        while(value <= BITree.length - 1) {\n            BITree[value] += 1;\n            //System.out.println(\"BITree[\" + value + \"] = \" + BITree[value]);\n            value += (value & -value);\n        }\n    }\n}", "total_acs": 43281, "total_submitted": 123603}, {"id": 316, "title": "Remove Duplicate Letters", "url": "https://leetcode.com/problems/remove-duplicate-letters/description", "companyTags": ["Google"], "difficulty": "Hard", "content": "\r\nGiven a string which contains only lowercase letters, remove duplicate letters so that every letter appear once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.\r\n\r\n\r\n\r\nExample:\r\n\r\n\r\nGiven \"bcabc\"\r\nReturn \"abc\"\r\n\r\n\r\nGiven \"cbacdcbc\"\r\nReturn \"acdb\"\r\n\r\n\r\nCredits:Special thanks to @dietpepsi for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/396", "similarQuestions": [""], "topicTags": ["Stack", "Greedy"], "Solution": "class Solution {\n    public String removeDuplicateLetters(String s) {\n        int[] dict = new int[26];\n        char[] array = s.toCharArray();\n        boolean[] visited = new boolean[26];\n        for (int i = 0; i < array.length; i++) dict[array[i] - 'a']++;\n        int top = -1;\n        for (int j = 0; j < array.length; j++) {\n            int cur = array[j] - 'a';\n            dict[cur]--;\n            if (visited[cur]) {\n                continue;\n            } else {\n                while (top > -1 && array[j] < array[top] && dict[array[top] - 'a'] != 0) {\n                    visited[array[top] - 'a'] = false;\n                    top--;\n                }\n                array[++top] = array[j];\n                visited[cur] = true;\n            }\n        }\n        String res = new String(array);\n        return res.substring(0, top + 1);\n    }\n}", "total_acs": 37648, "total_submitted": 124380}, {"id": 317, "title": "Shortest Distance from All Buildings", "url": "https://leetcode.com/problems/shortest-distance-from-all-buildings/description", "companyTags": ["Google", "Zenefits"], "difficulty": "Hard", "content": "You want to build a house on an empty land which reaches all buildings in the shortest amount of distance. You can only move up, down, left and right. You are given a 2D grid of values 0, 1 or 2, where:\r\n\r\nEach 0 marks an empty land which you can pass by freely.\r\nEach 1 marks a building which you cannot pass through.\r\nEach 2 marks an obstacle which you cannot pass through.\r\n\r\n\r\nFor example, given three buildings at (0,0), (0,4), (2,2), and an obstacle at (0,2):\r\n\r\n1 - 0 - 2 - 0 - 1\r\n|   |   |   |   |\r\n0 - 0 - 0 - 0 - 0\r\n|   |   |   |   |\r\n0 - 0 - 1 - 0 - 0\r\n\r\nThe point (1,2) is an ideal empty land to build a house, as the total travel distance of 3+3+1=7 is minimal. So return 7.\r\n\r\nNote:\r\nThere will be at least one building. If it is not possible to build such house according to the above rules, return -1.", "discussUrl": "https://discuss.leetcode.com/category/397", "similarQuestions": ["WallsandGates", "BestMeetingPoint"], "topicTags": ["Breadth-firstSearch"], "Solution": "class Solution {\n    public int shortestDistance(int[][] grid) {\n        if (grid == null || grid.length == 0 || grid[0].length == 0) {\n            return 0;\n        }\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][] totalDistance = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1 && !bfs(grid, totalDistance, i, j)) {\n                    return -1;\n                }\n            }\n        }\n        int res = Integer.MAX_VALUE;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 0) {\n                    res = Math.min(res, totalDistance[i][j]);\n                }\n            }\n        }\n        return res == Integer.MAX_VALUE ? -1 : res;\n    }\n    \n    private boolean bfs(int[][] grid, int[][] totalDistance, int startX, int startY) {\n        int m = grid.length;\n        int n = grid[0].length;\n        boolean[][] visited = new boolean[m][n];\n        visited[startX][startY] = true;\n        \n        int[][] directions = new int[][] {{1, 0}, {-1, 0}, {0, -1}, {0, 1}};\n        \n        Deque<int[]> queue = new ArrayDeque<>();\n        queue.offer(new int[] {startX, startY});\n        int level = 0;\n        \n        while (!queue.isEmpty()) {\n            int levelSize = queue.size();\n            level++;\n            while (levelSize-- > 0) {\n                int[] curr = queue.poll();\n                int currX = curr[0];\n                int currY = curr[1];\n                for (int[] dir : directions) {\n                    int x = currX + dir[0];\n                    int y = currY + dir[1];\n                    if (x >= 0 && x < m && y >= 0 && y < n && !visited[x][y]) {\n                        if (grid[x][y] == 0) {\n                            totalDistance[x][y] += level;\n                            queue.offer(new int[] {x, y});\n                        }\n                        visited[x][y] = true;\n                    }\n                }\n            }\n        }\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (!visited[i][j]) {\n                    if (grid[i][j] == 0) {\n                        grid[i][j] = -1;\n                    } else if (grid[i][j] == 1) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n}", "total_acs": 21908, "total_submitted": 63074}, {"id": 318, "title": "Maximum Product of Word Lengths", "url": "https://leetcode.com/problems/maximum-product-of-word-lengths/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "\r\n    Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters.\r\n    You may assume that each word will contain only lower case letters.\r\n    If no such two words exist, return 0.\r\n\r\n\r\n\r\n    Example 1:\r\n\r\n\r\n    Given [\"abcw\", \"baz\", \"foo\", \"bar\", \"xtfn\", \"abcdef\"]\r\n    Return 16\r\n    The two words can be \"abcw\", \"xtfn\".\r\n\r\n\r\n    Example 2:\r\n\r\n\r\n    Given [\"a\", \"ab\", \"abc\", \"d\", \"cd\", \"bcd\", \"abcd\"]\r\n    Return 4\r\n    The two words can be \"ab\", \"cd\".\r\n\r\n\r\n    Example 3:\r\n\r\n\r\n    Given [\"a\", \"aa\", \"aaa\", \"aaaa\"]\r\n    Return 0\r\n    No such pair of words.    \r\n\r\n\r\nCredits:Special thanks to @dietpepsi for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/398", "similarQuestions": [""], "topicTags": ["BitManipulation"], "Solution": "class Solution {\n    public int maxProduct(String[] words) {\n        if (words == null || words.length == 0)\n            return 0;\n        int len = words.length;\n        int[] bitmapWord = new int[len];\n        \n        for (int i = 0; i < len; i++) {\n            bitmapWord[i] = 0;\n            String s = words[i];\n            \n            for (int j=0; j < s.length(); j++) {\n                bitmapWord[i] = bitmapWord[i] | 1 << (s.charAt(j) - 'a');\n            }\n        }\n        int maxProduct = 0;\n        for (int i = 0; i < len; i++) {\n            for (int j = i + 1; j < len; j++) {\n                if (((bitmapWord[i] & bitmapWord[j]) == 0) && (words[i].length() * words[j].length() > maxProduct))\n                    maxProduct = words[i].length() * words[j].length();\n            }\n        }\n        return maxProduct;\n    }\n}\n", "total_acs": 59451, "total_submitted": 130975}, {"id": 319, "title": "Bulb Switcher", "url": "https://leetcode.com/problems/bulb-switcher/description", "companyTags": [""], "difficulty": "Medium", "content": "\r\nThere are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb.\r\n\r\nFind how many bulbs are on after n rounds.\r\n\r\n\r\n\r\nExample:\r\n\r\nGiven n = 3. \r\nAt first, the three bulbs are [off, off, off].\r\nAfter first round, the three bulbs are [on, on, on].\r\nAfter second round, the three bulbs are [on, off, on].\r\nAfter third round, the three bulbs are [on, off, off]. \r\nSo you should return 1, because there is only one bulb is on.\r\n", "discussUrl": "https://discuss.leetcode.com/category/399", "similarQuestions": ["BulbSwitcherII"], "topicTags": ["Math", "Brainteaser"], "Solution": "public class Solution {\r\n    public int bulbSwitch(int n) {\r\n        \r\n        int res = 0;\r\n        \r\n        for (int i = 1 ; i*i <= n; i++){\r\n            res++;\r\n        }\r\n        \r\n        return res;\r\n    }\r\n}", "total_acs": 46156, "total_submitted": 107596}, {"id": 320, "title": "Generalized Abbreviation", "url": "https://leetcode.com/problems/generalized-abbreviation/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "Write a function to generate the generalized abbreviations of a word.\r\n\r\n\r\n    Example:\r\n\r\nGiven word = \"word\", return the following list (order does not matter):\r\n[\"word\", \"1ord\", \"w1rd\", \"wo1d\", \"wor1\", \"2rd\", \"w2d\", \"wo2\", \"1o1d\", \"1or1\", \"w1r1\", \"1o2\", \"2r1\", \"3d\", \"w3\", \"4\"]\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/400", "similarQuestions": ["Subsets", "UniqueWordAbbreviation", "MinimumUniqueWordAbbreviation"], "topicTags": ["Backtracking", "BitManipulation"], "Solution": "class Solution {\n    public List<String> generateAbbreviations(String word) {\n        List<String> res = new ArrayList();\n        \n        helper(word.toCharArray(), res, 0, 0, new StringBuilder());\n        return res;\n    }\n    \n    public void helper(char[] arr, List<String> res, int abbNum, int pos, StringBuilder sb){\n        int len = sb.length();\n        if(pos == arr.length){\n            if(abbNum != 0) sb.append(abbNum);\n            res.add(sb.toString());\n        }else{\n            helper(arr, res, abbNum+1, pos+1, sb); // abb\n            \n            if(abbNum!=0) sb.append(abbNum); // not abb\n            helper(arr, res, 0, pos + 1, sb.append(arr[pos]));\n        }\n        sb.setLength(len);\n    }\n}", "total_acs": 27490, "total_submitted": 59623}, {"id": 321, "title": "Create Maximum Number", "url": "https://leetcode.com/problems/create-maximum-number/description", "companyTags": ["Google"], "difficulty": "Hard", "content": "\r\n    Given two arrays of length m and n with digits 0-9 representing two numbers.\r\n    Create the maximum number of length k <= m + n from digits of the two. The relative order of the digits\r\n    from the same array must be preserved. Return an array of the k digits. You should try to optimize your time and space complexity.\r\n\r\n\r\n\r\n    Example 1:\r\n\r\n\r\n    nums1 = [3, 4, 6, 5]\r\n    nums2 = [9, 1, 2, 5, 8, 3]\r\n    k = 5\r\n    return [9, 8, 6, 5, 3]\r\n\r\n\r\n    Example 2:\r\n\r\n\r\n    nums1 = [6, 7]\r\n    nums2 = [6, 0, 4]\r\n    k = 5\r\n    return [6, 7, 6, 0, 4]\r\n\r\n\r\n    Example 3:\r\n\r\n\r\n    nums1 = [3, 9]\r\n    nums2 = [8, 9]\r\n    k = 3\r\n    return [9, 8, 9]\r\n\r\n\r\nCredits:Special thanks to @dietpepsi for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/401", "similarQuestions": ["RemoveKDigits", "MaximumSwap"], "topicTags": ["DynamicProgramming", "Greedy"], "Solution": "/*\nclass Solution {\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\n        int n = nums1.length;\n        int m = nums2.length;\n        int[] ans = new int[k];\n        for (int i = Math.max(0, k - m); i <= k && i <= n; ++i) {\n            int[] candidate = merge(maxArray(nums1, i), maxArray(nums2, k - i), k);\n            if (greater(candidate, 0, ans, 0)) ans = candidate;\n        }\n        return ans;\n    }\n    private int[] merge(int[] nums1, int[] nums2, int k) {\n        int[] ans = new int[k];\n        for (int i = 0, j = 0, r = 0; r < k; ++r)\n            ans[r] = greater(nums1, i, nums2, j) ? nums1[i++] : nums2[j++];\n        return ans;\n    }\n    public boolean greater(int[] nums1, int i, int[] nums2, int j) {\n        while (i < nums1.length && j < nums2.length && nums1[i] == nums2[j]) {\n            i++;\n            j++;\n        }\n        return j == nums2.length || (i < nums1.length && nums1[i] > nums2[j]);\n    }\n    public int[] maxArray(int[] nums, int k) {\n        int n = nums.length;\n        int[] ans = new int[k];\n        for (int i = 0, j = 0; i < n; ++i) {\n            while (n - i + j > k && j > 0 && ans[j - 1] < nums[i]) j--;\n            if (j < k) ans[j++] = nums[i];\n        }\n        return ans;\n    }\n}\n*/\nclass Solution {\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\n        int[] result = new int[k];\n        for(int i = Math.max(0, k - nums2.length); i <= Math.min(k, nums1.length); i++) {\n            int[] max_1 = getMaxN(nums1, i);\n            int[] max_2 = getMaxN(nums2, k - i);\n            int[] current = merge(max_1, max_2);\n            if(isLarger(current, 0, result, 0))\n                result = current;\n         }\n        return result;\n    }\n\n    private int[] getMaxN(int[] nums, int n) {\n        int[] temp = new int[n];\n        int index = 0;\n        for(int i = 0; i < nums.length; i++) {\n            while(index > 0 && nums.length - i + index > n && temp[index - 1] < nums[i]) {\n                index--;\n            }\n            if(index < n)\n                temp[index++] = nums[i];\n        }\n        return temp;\n    }\n\n    private int[] merge(int[] nums1, int[] nums2) {\n        int[] temp = new int[nums1.length + nums2.length];\n        int index1 = 0; int index2 = 0;\n        while(index1 < nums1.length && index2 < nums2.length) {\n            if(isLarger(nums1, index1, nums2, index2))\n                temp[index1 + index2] = nums1[index1++];\n            else\n                temp[index1 + index2] = nums2[index2++];\n        }\n        while(index1 < nums1.length) {\n            temp[index1 + index2] = nums1[index1++];\n        }\n        while(index2 < nums2.length) {\n            temp[index1 + index2] = nums2[index2++];\n        }\n        return temp;\n    }\n\n    private boolean isLarger(int[] nums1, int n1, int[] nums2, int n2) {\n        for(; n1 < nums1.length && n2 < nums2.length; n1++, n2++) {\n            if(nums1[n1] > nums2[n2])\n                return true;\n            else if(nums1[n1] < nums2[n2])\n                return false;\n        }\n        return n1 != nums1.length;\n    }\n}", "total_acs": 22086, "total_submitted": 89109}, {"id": 322, "title": "Coin Change", "url": "https://leetcode.com/problems/coin-change/description", "companyTags": [""], "difficulty": "Medium", "content": "\r\nYou are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\r\n\r\n\r\n\r\nExample 1:\r\ncoins = [1, 2, 5], amount = 11\r\nreturn 3 (11 = 5 + 5 + 1)\r\n\r\n\r\n\r\nExample 2:\r\ncoins = [2], amount = 3\r\nreturn -1.\r\n\r\n\r\n\r\nNote:\r\nYou may assume that you have an infinite number of each kind of coin.\r\n\r\n\r\nCredits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/402", "similarQuestions": [""], "topicTags": ["DynamicProgramming"], "Solution": "public class Solution {\n\tint min = Integer.MAX_VALUE;\n    public int coinChange(int[] coins, int amount) {\n    \tif(amount == 0)\treturn 0;\n    \tArrays.sort(coins);\n    \tcoinChange(coins, amount, coins.length - 1, 0);\n    \tif(min == Integer.MAX_VALUE)\treturn -1;\n    \treturn min;\n    }\n    \n    public void coinChange(int[] coins, int amount, int index, int num){\n    \tif(amount % coins[index] == 0){\n    \t\tint newCount = num + amount/coins[index];\n    \t\tif(newCount < min)\n    \t\t\tmin = newCount;\n    \t}\n    \t\n    \tif(index == 0)\treturn;\n    \t\n    \tint possible = amount/coins[index];\n    \tfor(int i = possible; i >= 0; i--){\n    \t\tint newAmount = amount - coins[index]*i;\n    \t\tint newNum = num + i;\n    \t\t\n    \t\tint nextCoin = coins[index-1];\n            if(newNum + (newAmount + nextCoin -1) / nextCoin >= min)\n                break;\n            \n            coinChange(coins, newAmount, index-1, newNum);\n    \t\t\n    \t}\n    }\n}", "total_acs": 84717, "total_submitted": 318155}, {"id": 323, "title": "Number of Connected Components in an Undirected Graph", "url": "https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/description", "companyTags": ["Google", "Twitter"], "difficulty": "Medium", "content": "\r\nGiven n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to find the number of connected components in an undirected graph.\r\n\r\n\r\n\r\n    Example 1:\r\n\r\n\r\n     0          3\r\n     |          |\r\n     1 --- 2    4\r\n\r\n\r\n    Given n = 5 and edges = [[0, 1], [1, 2], [3, 4]], return 2.\r\n\r\n\r\n    Example 2:\r\n\r\n\r\n     0           4\r\n     |           |\r\n     1 --- 2 --- 3\r\n\r\n\r\n    Given n = 5 and edges = [[0, 1], [1, 2], [2, 3], [3, 4]], return 1.\r\n\r\n\r\n\r\nNote:\r\nYou can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.\r\n", "discussUrl": "https://discuss.leetcode.com/category/403", "similarQuestions": ["NumberofIslands", "GraphValidTree", "FriendCircles"], "topicTags": ["Depth-firstSearch", "Breadth-firstSearch", "UnionFind", "Graph"], "Solution": "//\u548c#of islandsII\u5f88\u50cf\nclass Solution {\npublic int countComponents(int n, int[][] edges) {\n    int[] roots = new int[n];\n    for(int i = 0; i < n; i++) roots[i] = i; \n\n    for(int[] e : edges) {\n        int root1 = find(roots, e[0]);\n        int root2 = find(roots, e[1]);\n        if(root1 != root2) {      \n            roots[root1] = root2;  // union,\u4e24\u4e2a\u4e0d\u4e00\u6837\u7684\u6839\u5c31union,\u7136\u540e\u603bcomponent\u6570\u91cf--\n            n--;\n        }\n    }\n    return n;\n}\n\npublic int find(int[] roots, int id) {\n    while(roots[id] != id) {\n        roots[id] = roots[roots[id]];  // optional: path compression roots[3]=5,\u90a3\u4e48\u53bb\u627eroots[5]\u770b\u80fd\u4e0d\u80fd\u6ee1\u8db3\u6761\u4ef6\uff0c\u73b0\u5728id\u53d8\u62105\u4e86\n        id = roots[id];\n    }\n    return id;\n}\n}", "total_acs": 33920, "total_submitted": 69545}, {"id": 324, "title": "Wiggle Sort II", "url": "https://leetcode.com/problems/wiggle-sort-ii/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "\r\n    Given an unsorted array nums, reorder it such that\r\n    nums[0] < nums[1] > nums[2] < nums[3]....\r\n\r\n\r\n\r\n    Example:\r\n    (1) Given nums = [1, 5, 1, 1, 6, 4], one possible answer is [1, 4, 1, 5, 1, 6]. \r\n    (2) Given nums = [1, 3, 2, 2, 3, 1], one possible answer is [2, 3, 1, 3, 1, 2].\r\n\r\n\r\n\r\n    Note:\r\n    You may assume all input has valid answer.\r\n\r\n\r\n\r\n    Follow Up:\r\n    Can you do it in O(n) time and/or in-place with O(1) extra space?\r\n\r\n\r\nCredits:Special thanks to @dietpepsi for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/404", "similarQuestions": ["SortColors", "KthLargestElementinanArray", "WiggleSort"], "topicTags": ["Sort"], "Solution": "//version 1:, Time Complexity O(N logN), Space Complexity O(N)\n// It can also be solved using Quick Select and three pointers\n/*class Solution {\n    public void wiggleSort(int[] nums) {\n        int n = nums.length;\n        int[] copy = Arrays.copyOf(nums, n);\n        Arrays.sort(copy);\n        int mid = (n - 1) / 2;\n        for (int i = n - 1, j = 1; i > mid; i--, j += 2) {\n            nums[j] = copy[i];\n        }\n        \n        for (int i = mid, j = 0; i >= 0; i--, j += 2) {\n            nums[j] = copy[i];\n        }\n\n    }\n}*/\n\nclass Solution {\n    public void wiggleSort(int[] nums) {\n        int n = nums.length;\n        int[] copy = Arrays.copyOf(nums, n);\n        Arrays.sort(copy);\n        int i = n - 1;\n        int j = 1;\n        while (j < n) {\n            nums[j] = copy[i];\n            j += 2;\n            i--;\n        }\n        j = 0;\n        while (i >= 0) {\n            nums[j] = copy[i];\n            j += 2;\n            i--;\n        }\n    }\n}", "total_acs": 36506, "total_submitted": 138533}, {"id": 325, "title": "Maximum Size Subarray Sum Equals k", "url": "https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/description", "companyTags": ["Facebook", "Palantir"], "difficulty": "Medium", "content": "\r\nGiven an array nums and a target value k, find the maximum length of a subarray that sums to k. If there isn't one, return 0 instead.\r\n\r\n\r\n\r\n    Note:\r\nThe sum of the entire nums array is guaranteed to fit within the 32-bit signed integer range.\r\n\r\n\r\n\r\n    Example 1:\r\n\r\n\r\nGiven nums = [1, -1, 5, -2, 3], k = 3,\r\nreturn 4. (because the subarray [1, -1, 5, -2] sums to 3 and is the longest)\r\n\r\n\r\n\r\n    Example 2:\r\n\r\n\r\nGiven nums = [-2, -1, 2, 1], k = 1,\r\nreturn 2. (because the subarray [-1, 2] sums to 1 and is the longest)\r\n\r\n\r\n\r\n    Follow Up:\r\n    Can you do it in O(n) time?\r\n", "discussUrl": "https://discuss.leetcode.com/category/405", "similarQuestions": ["MinimumSizeSubarraySum", "RangeSumQuery-Immutable", "ContiguousArray", "SubarrayProductLessThanK"], "topicTags": ["HashTable"], "Solution": "class Solution {\n    public int maxSubArrayLen(int[] nums, int k) {\n        for(int i = 1; i < nums.length; i++){\n            nums[i] += nums[i - 1];\n        }\n        int res = 0;\n        HashMap<Integer, Integer> hm = new HashMap();\n        hm.put(0, 0);\n        for(int i = 0; i < nums.length; i++){\n            if(hm.containsKey(nums[i] - k)) res = Math.max(res, i + 1 - hm.get(nums[i] - k));\n            hm.putIfAbsent(nums[i], i + 1);\n        }\n        return res;\n    }\n}", "total_acs": 45013, "total_submitted": 104236}, {"id": 326, "title": "Power of Three", "url": "https://leetcode.com/problems/power-of-three/description", "companyTags": ["Google"], "difficulty": "Easy", "content": "\r\n    Given an integer, write a function to determine if it is a power of three.\r\n\r\n\r\n    Follow up:\r\n    Could you do it without using any loop / recursion?\r\n\r\n\r\nCredits:Special thanks to @dietpepsi for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/406", "similarQuestions": ["PowerofTwo", "PowerofFour"], "topicTags": ["Math"], "Solution": "class Solution {\n    public boolean isPowerOfThree(int n) {\n        if(n < 1)\n            return false;\n        while(n > 1){\n            if(n%3 == 0){\n                n = n/3;\n            }\n            else{\n                return false;\n            }\n        }\n        return true;    \n    }\n}", "total_acs": 117386, "total_submitted": 289171}, {"id": 327, "title": "Count of Range Sum", "url": "https://leetcode.com/problems/count-of-range-sum/description", "companyTags": ["Google"], "difficulty": "Hard", "content": "\r\n    Given an integer array nums, return the number of range sums that lie in [lower, upper] inclusive.\r\n\r\n    Range sum S(i, j) is defined as the sum of the elements in nums between indices i and \r\n    j (i \u2264 j), inclusive.\r\n\r\n\r\n\r\n    Note:\r\n    A naive algorithm of O(n2) is trivial. You MUST do better than that.\r\n\r\n\r\n    Example:\r\n    Given nums = [-2, 5, -1], lower = -2, upper = 2,\r\n    Return 3.\r\n    The three ranges are : [0, 0], [2, 2], [0, 2] and their respective sums are: -2, -1, 2.\r\n\r\n\r\nCredits:Special thanks to @dietpepsi for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/408", "similarQuestions": ["CountofSmallerNumbersAfterSelf", "ReversePairs"], "topicTags": ["DivideandConquer", "BinarySearchTree"], "Solution": "class Solution {\n    public int countRangeSum(int[] nums, int lower, int upper) {\n        int m = nums.length;\n        long[] sum = new long[m+1];\n        long[] tmp = new long[m+1];\n        for(int i = 0; i < m; i++){\n            sum[i+1] = sum[i] + nums[i];\n        }\n        \n        return countMerge(sum, tmp, 0, m+1, lower, upper);\n    }\n    \n    int countMerge(long[] sum, long[] tmp, int start, int end, int lower, int upper){\n        int res = 0;\n        if(end-start <= 1) return res;\n\n        int mid =  start  + (end-start) /2;\n        res += countMerge(sum, tmp, start, mid, lower, upper);\n        res += countMerge(sum, tmp, mid, end, lower, upper);\n        res += merge(sum, tmp, start, end, mid, lower, upper);\n\n        return res;\n    }\n    \n    int merge(long[] sum, long[] tmp, int start, int end, int mid, int lower, int upper){\n        int j = mid, k = mid, t = mid;\n        int count = 0;\n\n\n        for (int i = start, r = start; i < mid; ++i, ++r) {\n\n            while (k < end && sum[k] - sum[i] < lower) k++;\n\n            while (j < end && sum[j] - sum[i] <= upper) j++;\n\n            while (t < end && sum[t] < sum[i]) tmp[r++] = sum[t++];\n\n            tmp[r] = sum[i];\n\n            count += j - k;\n\n        }\n\n        System.arraycopy(tmp, start, sum, start, t - start);\n\n        return count;\n    }\n}", "total_acs": 22458, "total_submitted": 73560}, {"id": 328, "title": "Odd Even Linked List", "url": "https://leetcode.com/problems/odd-even-linked-list/description", "companyTags": [""], "difficulty": "Medium", "content": "Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.\r\n\r\nYou should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.\r\n\r\n\r\nExample:\r\nGiven 1->2->3->4->5->NULL,\r\nreturn 1->3->5->2->4->NULL.\r\n\r\n\r\nNote:\r\nThe relative order inside both the even and odd groups should remain as it was in the input. \r\nThe first node is considered odd, the second node even and so on ...\r\n\r\n\r\nCredits:Special thanks to @DjangoUnchained for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/409", "similarQuestions": ["SplitLinkedListinParts"], "topicTags": ["LinkedList"], "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode oddEvenList(ListNode head) {\n        if (head == null) return null;\n        if (head.next == null) return head;\n        ListNode evenHead = head.next;\n        ListNode oddList = head;\n        ListNode evenList = head.next;\n        ListNode node = head.next.next;\n        int count = 0;\n        while (node != null){\n            count++;\n            if (count % 2 == 1){\n                oddList.next = node;\n                oddList = oddList.next;\n            }\n            else{\n                evenList.next = node;\n                evenList = evenList.next;\n            }\n            node = node.next;\n        }\n        evenList.next = null;\n        oddList.next = evenHead;\n        return head;\n    }\n}", "total_acs": 86482, "total_submitted": 194334}, {"id": 329, "title": "Longest Increasing Path in a Matrix", "url": "https://leetcode.com/problems/longest-increasing-path-in-a-matrix/description", "companyTags": ["Google"], "difficulty": "Hard", "content": "Given an integer matrix, find the length of the longest increasing path.\r\n\r\n\r\nFrom each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).\r\n\r\n\r\nExample 1:\r\n\r\nnums = [\r\n  [9,9,4],\r\n  [6,6,8],\r\n  [2,1,1]\r\n]\r\n\r\n\r\n\r\n\r\nReturn 4\r\n\r\nThe longest increasing path is [1, 2, 6, 9].\r\n\r\n\r\nExample 2:\r\n\r\nnums = [\r\n  [3,4,5],\r\n  [3,2,6],\r\n  [2,2,1]\r\n]\r\n\r\n\r\n\r\n\r\nReturn 4\r\n\r\nThe longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.\r\n\r\nCredits:Special thanks to @dietpepsi for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/410", "similarQuestions": [""], "topicTags": ["Depth-firstSearch", "TopologicalSort", "Memoization"], "Solution": "class Solution {\n    int[][] dirs = new int[][]{{-1, 0}, {0, 1}, {0, -1}, {1, 0}};\n    public int longestIncreasingPath(int[][] matrix) {\n        if (matrix == null || matrix.length == 0 || matrix[0] == null || matrix[0].length == 0) {\n            return 0;\n        }\n        \n        int[][] record = new int[matrix.length][matrix[0].length];\n        int max = 0;\n        for (int i = 0; i < matrix.length; i++) {\n            for (int j = 0; j < matrix[0].length; j++) {\n                if (record[i][j] == 0) {\n                    max = Math.max(max, dfs(matrix, record, i, j));\n                }\n            }\n        }\n        return max;\n    }\n    \n    public int dfs(int[][] matrix, int[][] record, int i, int j) {\n        if (record[i][j] != 0) {\n            return record[i][j];\n        }\n        int max =  1;\n        \n        for (int[] dir: dirs){\n            int x = i + dir[0];\n            int y = j + dir[1];\n            if ( x >= 0 && x < matrix.length && y >= 0 && y < matrix[0].length && matrix[x][y] > matrix[i][j]) {\n                int len = dfs(matrix, record, x, y);\n                max = Math.max(max, 1 + len);\n            }\n        }\n        record[i][j] = max;\n        \n        return max;\n    }\n    \n    \n}", "total_acs": 48324, "total_submitted": 129725}, {"id": 330, "title": "Patching Array", "url": "https://leetcode.com/problems/patching-array/description", "companyTags": ["Google"], "difficulty": "Hard", "content": "Given a sorted positive integer array nums and an integer n, add/patch elements to the array such that any number in range [1, n] inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required.\r\n\r\n\r\nExample 1:\r\nnums = [1, 3], n = 6\r\nReturn 1.\r\n\r\nCombinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.\r\nNow if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].\r\nPossible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].\r\nSo we only need 1 patch.\r\n\r\nExample 2:\r\nnums = [1, 5, 10], n = 20\r\nReturn 2.\r\nThe two patches can be [2, 4].\r\n\r\nExample 3:\r\nnums = [1, 2, 2], n = 5\r\nReturn 0.\r\n\r\nCredits:Special thanks to @dietpepsi for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/411", "similarQuestions": [""], "topicTags": ["Greedy"], "Solution": "class Solution {\n    public int minPatches(int[] nums, int n) {\n        int i = 0, cnt = 0;\n        long maxNum = 0;\n        while (maxNum < n) {\n            if (i < nums.length && nums[i] <= maxNum + 1) maxNum += nums[i++];\n            else {\n                cnt++;\n                maxNum += maxNum + 1;\n            }\n        }\n\n        return cnt;\n    }\n}", "total_acs": 25371, "total_submitted": 77937}, {"id": 331, "title": "Verify Preorder Serialization of a Binary Tree", "url": "https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node's value. If it is a null node, we record using a sentinel value such as #.\r\n\r\n\r\n     _9_\r\n    /   \\\r\n   3     2\r\n  / \\   / \\\r\n 4   1  #  6\r\n/ \\ / \\   / \\\r\n# # # #   # #\r\n\r\n\r\nFor example, the above binary tree can be serialized to the string \"9,3,4,#,#,1,#,#,2,#,6,#,#\", where # represents a null node.\r\n\r\n\r\nGiven a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree. Find an algorithm without reconstructing the tree.\r\n\r\nEach comma separated value in the string must be either an integer or a character '#' representing null pointer.\r\n\r\nYou may assume that the input format is always valid, for example it could never contain two consecutive commas such as \"1,,3\".\r\n\r\nExample 1:\r\n\"9,3,4,#,#,1,#,#,2,#,6,#,#\"\r\nReturn true\r\nExample 2:\r\n\"1,#\"\r\nReturn false\r\nExample 3:\r\n\"9,#,#,1\"\r\nReturn false\r\n\r\nCredits:Special thanks to @dietpepsi for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/412", "similarQuestions": [""], "topicTags": ["Stack"], "Solution": "class Solution {\n    public boolean isValidSerialization(String preorder) {\n        if (preorder==null || preorder.length()==0) return false;\n        if (preorder.length()==1){\n            if (preorder.charAt(0)=='#')return true;\n            else return false;\n        }\n        int[] start = new int[1];\n        char[] sArray = preorder.toCharArray();\n        return check(sArray, start) && start[0]==sArray.length+1;\n    }\n    \n    private boolean check (char[] sArray, int[] start){\n        if (start[0]>=sArray.length) return false;\n        if (sArray[start[0]]=='#') {\n            start[0]+=2;\n            return true;\n        }\n        int end=start[0];\n        while (end<sArray.length && sArray[end]!=',') end++;\n        if (end>=sArray.length) return false;\n        start[0]=end+1;\n        return check(sArray, start) && check(sArray, start);\n    }\n}", "total_acs": 43134, "total_submitted": 116794}, {"id": 332, "title": "Reconstruct Itinerary", "url": "https://leetcode.com/problems/reconstruct-itinerary/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK.\r\n\r\n\r\nNote:\r\n\r\nIf there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary [\"JFK\", \"LGA\"] has a smaller lexical order than [\"JFK\", \"LGB\"].\r\nAll airports are represented by three capital letters (IATA code).\r\nYou may assume all tickets form at least one valid itinerary.\r\n\r\n\r\n\r\n\r\n    Example 1:\r\n    tickets = [[\"MUC\", \"LHR\"], [\"JFK\", \"MUC\"], [\"SFO\", \"SJC\"], [\"LHR\", \"SFO\"]]\r\n    Return [\"JFK\", \"MUC\", \"LHR\", \"SFO\", \"SJC\"].\r\n\r\n\r\n    Example 2:\r\n    tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]]\r\n    Return [\"JFK\",\"ATL\",\"JFK\",\"SFO\",\"ATL\",\"SFO\"].\r\n    Another possible reconstruction is [\"JFK\",\"SFO\",\"ATL\",\"JFK\",\"ATL\",\"SFO\"]. But it is larger in lexical order.\r\n\r\n\r\nCredits:Special thanks to @dietpepsi for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/416", "similarQuestions": [""], "topicTags": ["Depth-firstSearch", "Graph"], "Solution": "class Solution {\n    Map<String,PriorityQueue<String>> map = null;\n    LinkedList<String> result = new LinkedList<String>();\n    public List<String> findItinerary(String[][] tickets) {\n        map = getMap(tickets);\n        makeItinerary(\"JFK\");\n        return result;\n    }\n    \n    \n    private void makeItinerary(String from){\n        if(from == null) return;\n    \n      PriorityQueue<String> tos = map.get(from);\n       while(tos !=null && !tos.isEmpty())\n           makeItinerary(tos.poll());\n        result.addFirst(from);       \n    } \n    \n    \n    private Map<String,PriorityQueue<String>> getMap(String[][] tickets){\n        Map<String,PriorityQueue<String>> map = new HashMap<String,PriorityQueue<String>>();\n        for(String[] ticket: tickets){\n            String from = ticket[0];\n            String to = ticket[1];\n            if(!map.containsKey(from))\n                map.put(from,new PriorityQueue<String>());\n            map.get(from).offer(to);\n        }     \n        return map;\n    }\n}", "total_acs": 44763, "total_submitted": 150515}, {"id": 333, "title": "Largest BST Subtree", "url": "https://leetcode.com/problems/largest-bst-subtree/description", "companyTags": ["Microsoft"], "difficulty": "Medium", "content": "Given a binary tree, find the largest subtree which is a Binary Search Tree (BST), where largest means subtree with largest number of nodes in it.\r\nNote:\r\nA subtree must include all of its descendants.\r\nHere's an example:\r\n\r\n    10\r\n    / \\\r\n   5  15\r\n  / \\   \\ \r\n 1   8   7\r\n\r\nThe Largest BST Subtree in this case is the highlighted one. \r\nThe return value is the subtree's size, which is 3. \r\n\r\n\r\n\r\nFollow up:\r\nCan you figure out ways to solve it with O(n) time complexity?\r\n", "discussUrl": "https://discuss.leetcode.com/category/417", "similarQuestions": [""], "topicTags": ["Tree"], "Solution": "class Solution {\n    public int largestBSTSubtree(TreeNode root) {\n        int[] res = new int[1];\n        traverse(root, res);\n        return res[0];\n    }\n    int[] traverse(TreeNode root, int[] res) {\n        if(root == null) return null;\n        int[] left = traverse(root.left, res), right = traverse(root.right, res);\n        if((left != null && left[0] < 0) || (right != null && right[0] < 0)) return new int[]{-1, 0, 0};\n        int size = 1, min = root.val, max = root.val;\n        if(left != null) {\n            if(min <= left[2]) return new int[]{-1, 0, 0};\n            min = left[1];\n            size += left[0];\n        }\n        if(right != null) {\n            if(max >= right[1]) return new int[]{-1, 0, 0};\n            max = right[2];\n            size += right[0];\n        }\n        res[0] = Math.max(res[0], size);\n        return new int[]{size, min, max};\n    }\n}", "total_acs": 19533, "total_submitted": 63099}, {"id": 334, "title": "Increasing Triplet Subsequence", "url": "https://leetcode.com/problems/increasing-triplet-subsequence/description", "companyTags": ["Facebook"], "difficulty": "Medium", "content": "\r\nGiven an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.\r\n\r\n\r\nFormally the function should:\r\nReturn true if there exists i, j, k  \r\nsuch that arr[i] < arr[j] < arr[k] given 0 \u2264 i < j < k \u2264 n-1 \r\nelse return false.\r\n\r\n\r\n\r\nYour algorithm should run in O(n) time complexity and O(1) space complexity.\r\n\r\n\r\nExamples:\r\nGiven [1, 2, 3, 4, 5],\r\nreturn true.\r\n\r\n\r\nGiven [5, 4, 3, 2, 1],\r\nreturn false.\r\n\r\n\r\nCredits:Special thanks to @DjangoUnchained for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/418", "similarQuestions": ["LongestIncreasingSubsequence"], "topicTags": [""], "Solution": "class Solution {\n    public boolean increasingTriplet(int[] nums) {\n        // start with two largest values, as soon as we find a number bigger than both, while both have been updated, return true.\n        int small = Integer.MAX_VALUE, big = Integer.MAX_VALUE;\n        for (int n : nums) {\n            if (n <= small) { small = n; } // update small if n is smaller than both\n            else if (n <= big) { big = n; } // update big only if greater than small but smaller than big\n            else return true; // return if you find a number bigger than both\n        }\n        return false;\n    }\n}", "total_acs": 55093, "total_submitted": 137975}, {"id": 335, "title": "Self Crossing", "url": "https://leetcode.com/problems/self-crossing/description", "companyTags": [""], "difficulty": "Hard", "content": "\r\n    You are given an array x of n positive numbers. You start at point (0,0) and moves x[0] metres to the north, then x[1] metres to the west,\r\n    x[2] metres to the south,\r\n    x[3] metres to the east and so on. In other words, after each move your direction changes\r\n    counter-clockwise.\r\n\r\n\r\n    Write a one-pass algorithm with O(1) extra space to determine, if your path crosses itself, or not.\r\n\r\n\r\n\r\nExample 1:\r\n\r\nGiven x = [2, 1, 1, 2],\r\n?????\r\n?   ?\r\n???????>\r\n    ?\r\n\r\nReturn true (self crossing)\r\n\r\n\r\n\r\n\r\nExample 2:\r\n\r\nGiven x = [1, 2, 3, 4],\r\n????????\r\n?      ?\r\n?\r\n?\r\n?????????????>\r\n\r\nReturn false (not self crossing)\r\n\r\n\r\n\r\n\r\nExample 3:\r\n\r\nGiven x = [1, 1, 1, 1],\r\n?????\r\n?   ?\r\n?????>\r\n\r\nReturn true (self crossing)\r\n\r\n\r\n\r\nCredits:Special thanks to @dietpepsi for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/419", "similarQuestions": [""], "topicTags": ["Math"], "Solution": "class Solution {\n    public boolean isSelfCrossing(int[] x) {\n        for (int n = 3; n < x.length; n++) {\n            if (n >= 4) {\n                if ((x[n - 1] > x[n - 3]) && (x[n - 2] > x[n - 4]))\n                    continue;\n                if (((x[n] + x[n - 4]) >= x[n - 2]) && (x[n - 1] == x[n - 3])) {\n                    System.out.println(\"2_\" + n);\n                    return true;\n                }\n            }\n            if (n >= 5) {\n                if (((x[n] + x[n - 4]) >= x[n - 2]) && ((x[n - 1] + x[n - 5]) >= x[n - 3])  && (x[n - 2] >= x[n - 4])) {\n                    System.out.println(\"1_\" + n);\n                    return true;\n                    \n                }\n            }\n            if ((x[n - 1] <= x[n-3]) && (x[n] >= x[n - 2])) {\n                System.out.println(\"3_\" + n);\n                return true;\n            }\n        }\n        return false;\n    }\n}", "total_acs": 15875, "total_submitted": 61154}, {"id": 336, "title": "Palindrome Pairs", "url": "https://leetcode.com/problems/palindrome-pairs/description", "companyTags": ["Google", "Airbnb"], "difficulty": "Hard", "content": "\r\n    Given a list of unique words, find all pairs of distinct indices (i, j) in the given list, so that the concatenation of the two words, i.e. words[i] + words[j] is a palindrome.\r\n\r\n\r\n\r\n    Example 1:\r\n    Given words = [\"bat\", \"tab\", \"cat\"]\r\n    Return [[0, 1], [1, 0]]\r\n    The palindromes are [\"battab\", \"tabbat\"]\r\n\r\n\r\n    Example 2:\r\n    Given words = [\"abcd\", \"dcba\", \"lls\", \"s\", \"sssll\"]\r\n    Return [[0, 1], [1, 0], [3, 2], [2, 4]]\r\n    The palindromes are [\"dcbaabcd\", \"abcddcba\", \"slls\", \"llssssll\"]\r\n\r\n\r\nCredits:Special thanks to @dietpepsi for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/420", "similarQuestions": ["LongestPalindromicSubstring", "ShortestPalindrome"], "topicTags": ["HashTable", "String", "Trie"], "Solution": "class Solution {\n    public Boolean isPalindrome(String word, int lo, int hi) {\n        while (lo < hi) {\n            if (word.charAt(lo) != word.charAt(hi)) {\n                return false;\n            }\n            \n            lo++;\n            hi--;\n        }\n        \n        return true;\n    }\n    \n    class TrieNode {\n        TrieNode[] children = null;\n        List<Integer> list = null;\n        int idx;\n        \n        public TrieNode() {\n            children = new TrieNode[26];\n            list = new LinkedList<Integer>();\n            idx = -1;\n        }\n    }\n    \n    public void addWords(TrieNode root, String word, int idx) {\n        TrieNode cur = root;\n        for (int i = word.length() - 1; i >= 0; i--) {\n            char c = word.charAt(i);\n            if (cur.children[c - 'a'] == null) {\n                cur.children[c - 'a'] = new TrieNode();\n            }\n            \n            if (isPalindrome(word, 0, i)) {\n                cur.list.add(idx);\n            }\n            \n            cur = cur.children[c - 'a'];\n        }\n        cur.list.add(idx);\n        cur.idx = idx;\n    }\n    \n    public void searchWords(TrieNode root, String word, int idx, List<List<Integer>> res) {\n        TrieNode cur = root;\n        for (int i = 0; i < word.length(); i++) {\n            if (cur.idx >= 0 && cur.idx != idx && isPalindrome(word, i, word.length() - 1)) {\n                res.add(Arrays.asList(idx, cur.idx));\n            }\n            \n            char c = word.charAt(i);\n            if (cur.children[c - 'a'] == null) {\n                return;\n            }\n            \n            cur = cur.children[c - 'a'];\n        }\n        \n        for (int num : cur.list) {\n            if (idx == num)\n                continue;\n            \n            res.add(Arrays.asList(idx, num));\n        }\n    }\n    \n    public List<List<Integer>> palindromePairs(String[] words) {\n        List<List<Integer>> res = new LinkedList<List<Integer>>();\n        \n        TrieNode root = new TrieNode();\n        for (int i = 0; i < words.length; i++) {\n            addWords(root, words[i], i);\n        }\n        \n        for (int i = 0; i < words.length; i++) {\n            searchWords(root, words[i], i, res);\n        }\n        \n        return res;\n    }\n}", "total_acs": 35301, "total_submitted": 130703}, {"id": 337, "title": "House Robber III", "url": "https://leetcode.com/problems/house-robber-iii/description", "companyTags": ["Uber"], "difficulty": "Medium", "content": "\r\nThe thief has found himself a new place for his thievery again. There is only one entrance to this area, called the \"root.\" Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that \"all houses in this place forms a binary tree\". It will automatically contact the police if two directly-linked houses were broken into on the same night.\r\n\r\n\r\n\r\nDetermine the maximum amount of money the thief can rob tonight without alerting the police.\r\n\r\n\r\nExample 1:\r\n\r\n     3\r\n    / \\\r\n   2   3\r\n    \\   \\ \r\n     3   1\r\n\r\nMaximum amount of money the thief can rob = 3 + 3 + 1 = 7.\r\n\r\n\r\nExample 2:\r\n\r\n     3\r\n    / \\\r\n   4   5\r\n  / \\   \\ \r\n 1   3   1\r\n\r\nMaximum amount of money the thief can rob = 4 + 5 = 9.\r\n\r\n\r\nCredits:Special thanks to @dietpepsi for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/421", "similarQuestions": ["HouseRobber", "HouseRobberII"], "topicTags": ["Tree", "Depth-firstSearch"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public int rob(TreeNode root) {\n        if (root == null) return 0;\n        int[] result = help(root); //return int[]{with root, without root}\n        return Math.max(result[0], result[1]);\n    }\n    \n    private int[] help(TreeNode root) {\n        if (root == null) {\n            return new int[]{0, 0};\n        }\n        int[] left = help(root.left);\n        int[] right = help(root.right);\n        //with root\n        int with = root.val + left[1] + right[1];\n        int without = left[0] + right[0];\n        with = Math.max(with, without);\n        int[] result = new int[]{with, without};\n        return result;\n    }\n    \n}", "total_acs": 59069, "total_submitted": 132795}, {"id": 338, "title": "Counting Bits", "url": "https://leetcode.com/problems/counting-bits/description", "companyTags": [""], "difficulty": "Medium", "content": "Given a non negative integer number num. For every numbers i in the range 0 \u2264 i \u2264 num calculate the number of 1's in their binary representation and return them as an array.\r\n\r\n\r\nExample:\r\nFor num = 5 you should return [0,1,1,2,1,2].\r\n\r\n\r\nFollow up:\r\n\r\nIt is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?\r\nSpace complexity should be O(n).\r\nCan you do it like a boss? Do it without using any builtin function like __builtin_popcount  in c++ or in any other language.\r\n\r\n\r\n\r\nCredits:Special thanks to @ syedee  for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/422", "similarQuestions": ["Numberof1Bits"], "topicTags": ["DynamicProgramming", "BitManipulation"], "Solution": "class Solution {\n    public int[] countBits(int num) {\n        int[] ans = new int[num + 1];\n        ans[0] = 0;\n        for (int i = 1; i <= num; i++) {\n            if ((i & 1) == 1) ans[i] = ans[i >> 1] + 1;\n            else ans[i] = ans[i >> 1];\n        }\n        \n        return ans;\n    }\n}", "total_acs": 103009, "total_submitted": 166030}, {"id": 339, "title": "Nested List Weight Sum", "url": "https://leetcode.com/problems/nested-list-weight-sum/description", "companyTags": ["LinkedIn"], "difficulty": "Easy", "content": "Given a nested list of integers, return the sum of all integers in the list weighted by their depth.\r\n\r\nEach element is either an integer, or a list -- whose elements may also be integers or other lists.\r\n\r\nExample 1:\r\nGiven the list [[1,1],2,[1,1]], return 10. (four 1's at depth 2, one 2 at depth 1)\r\n\r\nExample 2:\r\nGiven the list [1,[4,[6]]], return 27. (one 1 at depth 1, one 4 at depth 2, and one 6 at depth 3; 1 + 4*2 + 6*3 = 27)\r\n", "discussUrl": "https://discuss.leetcode.com/category/423", "similarQuestions": ["NestedListWeightSumII", "ArrayNesting", "EmployeeImportance"], "topicTags": ["Depth-firstSearch"], "Solution": "/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * public interface NestedInteger {\n *\n *     // @return true if this NestedInteger holds a single integer, rather than a nested list.\n *     public boolean isInteger();\n *\n *     // @return the single integer that this NestedInteger holds, if it holds a single integer\n *     // Return null if this NestedInteger holds a nested list\n *     public Integer getInteger();\n *\n *     // @return the nested list that this NestedInteger holds, if it holds a nested list\n *     // Return null if this NestedInteger holds a single integer\n *     public List<NestedInteger> getList();\n * }\n */\npublic class Solution {\n    // Recursive\n    public int depthSum(List<NestedInteger> nestedList) {\n        if(nestedList == null || nestedList.size() == 0)\n            return 0;\n        \n        return helper(nestedList, 1);\n    }\n    \n    private int helper(List<NestedInteger> list, int level) {\n        if(list == null)\n            return 0;\n\n        int sum = 0;\n        for(NestedInteger n : list) {\n            if(n.isInteger())\n                sum = sum + n.getInteger() * level;\n            else\n                sum = sum + helper(n.getList(), level + 1);\n        }\n        \n        return sum;\n    }\n    \n    // Iterative\n    /*\n    public int depthSum(List<NestedInteger> nestedList) {\n        Queue<NestedInteger> queue = new LinkedList<>();\n        \n        for(int i = 0; i < nestedList.size(); i++)\n            queue.offer(nestedList.get(i));\n        \n        int level = 0;\n        int sum = 0;\n        while(!queue.isEmpty()) {\n            level++;\n            int size = queue.size();\n            for(int i = 0; i < size; i++) {\n                NestedInteger curr = queue.poll();\n                \n                if(curr.isInteger())\n                    sum = sum + curr.getInteger() * level;\n                else {\n                    List<NestedInteger> list = curr.getList();\n                    \n                    for(NestedInteger item : list)\n                        queue.offer(item);                    \n                }\n            }\n        }\n\n        return sum;\n    }\n    */\n}", "total_acs": 31917, "total_submitted": 50251}, {"id": 340, "title": "Longest Substring with At Most K Distinct Characters", "url": "https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/description", "companyTags": ["Google", "AppDynamics", "Coupang"], "difficulty": "Hard", "content": "\r\nGiven a string, find the length of the longest substring T that contains at most k distinct characters.\r\n\r\n\r\n\r\nFor example,\r\n\r\nGiven s = \u201ceceba\u201d and k = 2,\r\n\r\n\r\n\r\nT is \"ece\" which its length is 3.\r\n", "discussUrl": "https://discuss.leetcode.com/category/424", "similarQuestions": ["LongestSubstringwithAtMostTwoDistinctCharacters", "LongestRepeatingCharacterReplacement"], "topicTags": ["HashTable", "String"], "Solution": "class Solution {\n    // Solution 1: two pointer\n    // Solution 2: TreeMap<>. dealing with stream input\n    public int lengthOfLongestSubstringKDistinct(String s, int k) {\n        char[] arr = s.toCharArray();\n        int[] table = new int[256];\n        int start = 0;\n        int maxLen = 0;\n        int count = 0;\n        for(int end = 0; end < arr.length; end++) {\n            if(table[arr[end]]++ == 0) {\n                count++;\n                while(count > k) {\n                    if(--table[arr[start++]] == 0) {\n                        count--;\n                    }\n                }\n            }\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}", "total_acs": 34704, "total_submitted": 88541}, {"id": 341, "title": "Flatten Nested List Iterator", "url": "https://leetcode.com/problems/flatten-nested-list-iterator/description", "companyTags": ["Google", "Facebook", "Twitter"], "difficulty": "Medium", "content": "Given a nested list of integers, implement an iterator to flatten it.\r\n\r\nEach element is either an integer, or a list -- whose elements may also be integers or other lists.\r\n\r\nExample 1:\r\nGiven the list [[1,1],2,[1,1]],\r\n\r\nBy calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].\r\n\r\n\r\n\r\nExample 2:\r\nGiven the list [1,[4,[6]]],\r\n\r\nBy calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/425", "similarQuestions": ["Flatten2DVector", "ZigzagIterator", "MiniParser", "ArrayNesting"], "topicTags": ["Stack", "Design"], "Solution": "/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * public interface NestedInteger {\n *\n *     // @return true if this NestedInteger holds a single integer, rather than a nested list.\n *     public boolean isInteger();\n *\n *     // @return the single integer that this NestedInteger holds, if it holds a single integer\n *     // Return null if this NestedInteger holds a nested list\n *     public Integer getInteger();\n *\n *     // @return the nested list that this NestedInteger holds, if it holds a nested list\n *     // Return null if this NestedInteger holds a single integer\n *     public List<NestedInteger> getList();\n * }\n */\n\n// public class NestedIterator implements Iterator<Integer> {\n\n//     Deque<NestedInteger> dq;\n\n//     public NestedIterator(List<NestedInteger> nestedList) {\n//         // Arrays.asList(T... a)\n//         dq = new ArrayDeque<>(nestedList == null ? Arrays.asList() : nestedList);\n        \n//     }\n\n//     @Override\n//     public Integer next() {\n//         return dq.pollFirst().getInteger();\n//     }\n\n//     @Override\n//     public boolean hasNext() {\n//         //  while(!dq.isEmpty() && !dq.peekFirst().isInteger()) {\n//         //     List<NestedInteger> list = dq.pollFirst().getList();\n//         //     for (int i=list.size()-1; i>=0; i--) dq.addFirst(list.get(i));\n//         // }\n//         // return !dq.isEmpty();\n//         while(!dq.isEmpty())\n//         {\n//             // peekFirst is equivalent to stack#peek\n//             NestedInteger ni = dq.peekFirst();\n//             if(ni.isInteger()) return true;\n            \n//             // Kengkeng... pop it\n//             dq.removeFirst();\n            \n//             // Kengkeng...push from back to front to keep Integer in original order\n//             // e.g. [1,[4,[6]]]\n//             // expected: 1, 4, 6\n//             List<NestedInteger> ln = ni.getList();\n//             for(int i = ln.size() -1 ; i >= 0; i--)\n//             {\n//                 // addFrist is equivalent to stack#push\n//                 dq.addFirst(ln.get(i));\n//             }\n//         }\n//         return false;\n//     }\n// }\n\n/**\n * Your NestedIterator object will be instantiated and called as such:\n * NestedIterator i = new NestedIterator(nestedList);\n * while (i.hasNext()) v[f()] = i.next();\n */\n\n// Given a nested list of integers, implement an iterator to flatten it.\n\n// Each element is either an integer, or a list -- whose elements may also be integers or other lists.\n\n// Example 1:\n// Given the list [[1,1],2,[1,1]],\n\n// By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].\n\n// Example 2:\n// Given the list [1,[4,[6]]],\n\n// By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].\n\n\n// recursively\npublic class NestedIterator implements Iterator<Integer> {\n\n  private LinkedList<ListIterator<NestedInteger>> itList;\n  private Integer answer;\n\n  public NestedIterator(List<NestedInteger> nestedList) {\n    // permits null entry\n    itList = new LinkedList<>();\n    itList.addLast(nestedList.listIterator());\n    answer = null;\n  }\n\n  @Override\n  public Integer next() {\n    Integer i = answer;\n    answer = null;\n    return i;\n  }\n\n  @Override\n  public boolean hasNext() {\n    if (answer != null) \n    {\n        return true;\n    } \n    else \n    {\n        ListIterator<NestedInteger> litr = itList.peekLast();\n        if (litr == null) \n        {\n            return false;\n        } \n        else if(litr.hasNext() == false) \n        {\n            itList.removeLast();\n            // Kengkeng...instead of \"return false\"\n            // [[1,1],2]\n            return hasNext();  // [1,1,2] \n            //return false; // [1,1]\n        } \n        else \n        {\n            NestedInteger ni = litr.next();\n            if (ni.isInteger()) \n            {\n                answer = ni.getInteger();\n                return true;\n            } \n            else \n            {\n                itList.addLast(ni.getList().listIterator());\n                return hasNext();\n            }\n        }\n    }\n  }\n}", "total_acs": 57341, "total_submitted": 133697}, {"id": 342, "title": "Power of Four", "url": "https://leetcode.com/problems/power-of-four/description", "companyTags": ["TwoSigma"], "difficulty": "Easy", "content": "\r\nGiven an integer (signed 32 bits), write a function to check whether it is a power of 4.\r\n\r\nExample:\r\nGiven num = 16, return true.\r\nGiven num = 5, return false.\r\n\r\n\r\nFollow up: Could you solve it without loops/recursion?\r\n\r\nCredits:Special thanks to @yukuairoy  for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/426", "similarQuestions": ["PowerofTwo", "PowerofThree"], "topicTags": ["BitManipulation"], "Solution": "class Solution {\n    public boolean isPowerOfFour(int num) {\n        return num > 0 && (num & (num - 1)) == 0 && (num - 1) % 3 == 0;\n    }\n}", "total_acs": 80057, "total_submitted": 205498}, {"id": 343, "title": "Integer Break", "url": "https://leetcode.com/problems/integer-break/description", "companyTags": [""], "difficulty": "Medium", "content": "\r\nGiven a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get.\r\n\r\n\r\n\r\nFor example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4).\r\n\r\n\r\n\r\nNote: You may assume that n is not less than 2 and not larger than 58.\r\n\r\n\r\nCredits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/427", "similarQuestions": [""], "topicTags": ["Math", "DynamicProgramming"], "Solution": "class Solution {\n    public int integerBreak(int n) {\n        //base case\n        if(n == 1) {\n            return 1;\n        }\n        int[] dp = new int[n + 1];\n        dp[1] = 1;\n        for(int i = 2; i < dp.length; i++) {\n            for(int j = 1; j <= i / 2; j++) {\n                dp[i] = Math.max(dp[i], Math.max(dp[j], j) * Math.max(i - j, dp[i - j]));\n            }\n        }\n        return dp[n];\n    }\n}", "total_acs": 53620, "total_submitted": 115381}, {"id": 344, "title": "Reverse String", "url": "https://leetcode.com/problems/reverse-string/description", "companyTags": [""], "difficulty": "Easy", "content": "Write a function that takes a string as input and returns the string reversed.\r\n\r\n\r\nExample:\r\nGiven s = \"hello\", return \"olleh\".\r\n", "discussUrl": "https://discuss.leetcode.com/category/428", "similarQuestions": ["ReverseVowelsofaString", "ReverseStringII"], "topicTags": ["TwoPointers", "String"], "Solution": "class Solution {\n    public String reverseString(String s) {\n        char[] charArray = s.toCharArray();\n        char[] charArray_2 = new char[charArray.length];\n        for (int i = 0; i < charArray.length; i++) {\n            charArray_2[charArray_2.length-i-1] = charArray[i];\n        }\n        return new String(charArray_2);\n    }\n}", "total_acs": 217155, "total_submitted": 361826}, {"id": 345, "title": "Reverse Vowels of a String", "url": "https://leetcode.com/problems/reverse-vowels-of-a-string/description", "companyTags": ["Google"], "difficulty": "Easy", "content": "Write a function that takes a string as input and reverse only the vowels of a string.\r\n\r\n\r\nExample 1:\r\nGiven s = \"hello\", return \"holle\".\r\n\r\n\r\n\r\nExample 2:\r\nGiven s = \"leetcode\", return \"leotcede\".\r\n\r\n\r\n\r\nNote:\r\nThe vowels does not include the letter \"y\".\r\n", "discussUrl": "https://discuss.leetcode.com/category/429", "similarQuestions": ["ReverseString"], "topicTags": ["TwoPointers", "String"], "Solution": "class Solution {\n    public String reverseVowels(String s) {\n        // ue oai\n        boolean[] marked = new boolean[256];\n        \n        marked['u'] = true;\n        marked['e'] = true;\n        marked['o'] = true;\n        marked['a'] = true;\n        marked['i'] = true;\n        marked['U'] = true;\n        marked['E'] = true;\n        marked['O'] = true;\n        marked['A'] = true;\n        marked['I'] = true;\n        \n        char[] arr = s.toCharArray();\n        for (int i = 0, j = s.length() - 1; i < j; i++) {\n            if (marked[arr[i]]) {\n                \n                for (; j > i; j--) {\n                    if (marked[arr[j]]) {\n                        char temp = arr[i];\n                        arr[i] = arr[j];\n                        arr[j--] = temp;\n                        \n                        break;\n                    }\n                }\n            }\n        }\n        \n        return String.valueOf(arr);\n        \n    }\n}", "total_acs": 100164, "total_submitted": 256748}, {"id": 346, "title": "Moving Average from Data Stream", "url": "https://leetcode.com/problems/moving-average-from-data-stream/description", "companyTags": ["Google"], "difficulty": "Easy", "content": "Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.\r\n\r\nFor example,\r\n\r\nMovingAverage m = new MovingAverage(3);\r\nm.next(1) = 1\r\nm.next(10) = (1 + 10) / 2\r\nm.next(3) = (1 + 10 + 3) / 3\r\nm.next(5) = (10 + 3 + 5) / 3\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/430", "similarQuestions": [""], "topicTags": ["Design", "Queue"], "Solution": "class MovingAverage {\n    long sum = 0;\n    int n = -1;\n    int k = 0;\n    int[] window;\n    int count = 0;\n\n    /** Initialize your data structure here. */\n    public MovingAverage(int size) {\n        k = size;\n        window = new int[k];\n    }\n    \n    public double next(int val) {\n        if(count < k) count++;\n        sum += val;\n        sum -= window[(n+1)%k];\n        n = (n+1)%k;\n        window[n] = val;\n        return sum*1.0/count;\n        \n        \n    }\n}\n\n/**\n * Your MovingAverage object will be instantiated and called as such:\n * MovingAverage obj = new MovingAverage(size);\n * double param_1 = obj.next(val);\n */", "total_acs": 34946, "total_submitted": 58278}, {"id": 347, "title": "Top K Frequent Elements", "url": "https://leetcode.com/problems/top-k-frequent-elements/description", "companyTags": ["Yelp", "PocketGems"], "difficulty": "Medium", "content": "\r\nGiven a non-empty array of integers, return the k most frequent elements.\r\n\r\nFor example,\r\nGiven [1,1,1,2,2,3] and k = 2, return [1,2].\r\n\r\n\r\nNote: \r\n\r\nYou may assume k is always valid, 1 \u2264 k \u2264 number of unique elements.\r\nYour algorithm's time complexity must be better than O(n log n), where n is the array's size.\r\n", "discussUrl": "https://discuss.leetcode.com/category/431", "similarQuestions": ["WordFrequency", "KthLargestElementinanArray", "SortCharactersByFrequency", "SplitArrayintoConsecutiveSubsequences", "TopKFrequentWords"], "topicTags": ["HashTable", "Heap"], "Solution": "public class Solution {\n    public List<Integer> topKFrequent(int[] nums, int k) {\n        List<Integer> result = new ArrayList<>();\n        List<Integer> bucket[] = new List[nums.length+1];\n        int max = Integer.MIN_VALUE;\n        int min = Integer.MAX_VALUE;\n        for(int n: nums){\n            if (n > max) {\n                max = n;\n            }\n            if (n < min) {\n                min = n;\n            }\n        }\n        int range[] = new int[max-min+1]; //Frequency\n        for(int num: nums){\n            range[num-min]++;\n        }\n        for(int i=0; i<range.length; i++){\n            if(bucket[range[i]]==null)\n                bucket[range[i]] = new ArrayList<>();\n            bucket[range[i]].add(i+min);\n        }\n        for(int i=bucket.length-1; i>=0; i--){\n            if(result.size()==k)\n                break;\n            if(bucket[i] != null)\n                result.addAll(bucket[i]);\n        }\n        return result;\n    }\n}", "total_acs": 92554, "total_submitted": 187327}, {"id": 348, "title": "Design Tic-Tac-Toe", "url": "https://leetcode.com/problems/design-tic-tac-toe/description", "companyTags": ["Google", "Microsoft"], "difficulty": "Medium", "content": "Design a Tic-tac-toe game that is played between two players on a n x n grid.\r\n\r\n\r\nYou may assume the following rules:\r\n\r\nA move is guaranteed to be valid and is placed on an empty block.\r\nOnce a winning condition is reached, no more moves is allowed.\r\nA player who succeeds in placing n of their marks in a horizontal, vertical, or diagonal row wins the game.\r\n\r\n\r\n\r\nExample:\r\n\r\nGiven n = 3, assume that player 1 is \"X\" and player 2 is \"O\" in the board.\r\n\r\nTicTacToe toe = new TicTacToe(3);\r\n\r\ntoe.move(0, 0, 1); -> Returns 0 (no one wins)\r\n|X| | |\r\n| | | |    // Player 1 makes a move at (0, 0).\r\n| | | |\r\n\r\ntoe.move(0, 2, 2); -> Returns 0 (no one wins)\r\n|X| |O|\r\n| | | |    // Player 2 makes a move at (0, 2).\r\n| | | |\r\n\r\ntoe.move(2, 2, 1); -> Returns 0 (no one wins)\r\n|X| |O|\r\n| | | |    // Player 1 makes a move at (2, 2).\r\n| | |X|\r\n\r\ntoe.move(1, 1, 2); -> Returns 0 (no one wins)\r\n|X| |O|\r\n| |O| |    // Player 2 makes a move at (1, 1).\r\n| | |X|\r\n\r\ntoe.move(2, 0, 1); -> Returns 0 (no one wins)\r\n|X| |O|\r\n| |O| |    // Player 1 makes a move at (2, 0).\r\n|X| |X|\r\n\r\ntoe.move(1, 0, 2); -> Returns 0 (no one wins)\r\n|X| |O|\r\n|O|O| |    // Player 2 makes a move at (1, 0).\r\n|X| |X|\r\n\r\ntoe.move(2, 1, 1); -> Returns 1 (player 1 wins)\r\n|X| |O|\r\n|O|O| |    // Player 1 makes a move at (2, 1).\r\n|X|X|X|\r\n\r\n\r\n\r\nFollow up:\r\nCould you do better than O(n2) per move() operation?\r\n", "discussUrl": "https://discuss.leetcode.com/category/432", "similarQuestions": [""], "topicTags": ["Design"], "Solution": "public class TicTacToe {\n/*\nAfter every call to any player on board[i][j].\nDo a loop from 1 to N, check complete row, complete col and complete diagonal.\nHave 4 boolean as true and keep making things false as soon as one is false\n\n*/\n    int board[][];\n    /** Initialize your data structure here. */\n    public TicTacToe(int n) {\n        this.board = new int[n][n];\n    }\n    \n    /** Player {player} makes a move at ({row}, {col}).\n        @param row The row of the board.\n        @param col The column of the board.\n        @param player The player, can be either 1 or 2.\n        @return The current winning condition, can be either:\n                0: No one wins.\n                1: Player 1 wins.\n                2: Player 2 wins. */\n    public int move(int row, int col, int player) {\n        board[row][col] = player;\n        if(hasWon(board,row,col,player)) return player;\n        return 0;\n    }\n    \n    private boolean hasWon(int[][] board, int row, int col, int playChar){\n        boolean colWin = true;\n        boolean rowWin = true;\n        boolean diaWin = true;\n        boolean revDia = true;\n        for(int i = 0; i < board.length; i++){\n            if(rowWin && board[row][i] != playChar) rowWin = false;\n            if(colWin && board[i][col] != playChar) colWin = false;\n            if(diaWin && board[i][i] != playChar) diaWin = false;\n            if(revDia && board[i][board.length - i - 1] != playChar) revDia = false;\n            if(!(colWin || rowWin || diaWin || revDia)) return false;\n        }\n        return true;\n    }\n}\n\n/**\n * Your TicTacToe object will be instantiated and called as such:\n * TicTacToe obj = new TicTacToe(n);\n * int param_1 = obj.move(row,col,player);\n */", "total_acs": 21024, "total_submitted": 45777}, {"id": 349, "title": "Intersection of Two Arrays", "url": "https://leetcode.com/problems/intersection-of-two-arrays/description", "companyTags": ["TwoSigma"], "difficulty": "Easy", "content": "\r\nGiven two arrays, write a function to compute their intersection.\r\n\r\n\r\nExample:\r\nGiven nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].\r\n\r\n\r\nNote:\r\n\r\nEach element in the result must be unique.\r\nThe result can be in any order.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/433", "similarQuestions": ["IntersectionofTwoArraysII"], "topicTags": ["HashTable", "TwoPointers", "BinarySearch", "Sort"], "Solution": "public class Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        if (nums1 == null || nums2 == null || nums1.length == 0 || nums2.length == 0) return new int[0];\n        List<Integer> res = new ArrayList<>();\n        int max = nums1[0], min = nums1[0];\n        \n        for (int i = 1; i < nums1.length; i++){\n            if (nums1[i] > max) max = nums1[i];\n            else if (nums1[i] < min) min = nums1[i];\n        }            \n        boolean[] bucket = new boolean[max - min + 1];\n        \n        for (int num: nums1) bucket[num - min] = true;\n        \n        for (int num: nums2){\n            if (num >= min && num <= max){\n                if (bucket[num - min]){\n                    res.add(num);\n                    bucket[num - min] = false;\n                }\n            }\n        }\n        int[] result = new int[res.size()];\n        for (int i = 0; i < res.size(); i++){\n            result[i] = res.get(i);\n        }\n        return result;\n    }\n}", "total_acs": 120161, "total_submitted": 250252}, {"id": 350, "title": "Intersection of Two Arrays II", "url": "https://leetcode.com/problems/intersection-of-two-arrays-ii/description", "companyTags": [""], "difficulty": "Easy", "content": "\r\nGiven two arrays, write a function to compute their intersection.\r\n\r\n\r\nExample:\r\nGiven nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].\r\n\r\n\r\nNote:\r\n\r\nEach element in the result should appear as many times as it shows in both arrays.\r\nThe result can be in any order.\r\n\r\n\r\n\r\nFollow up:\r\n\r\nWhat if the given array is already sorted? How would you optimize your algorithm?\r\nWhat if nums1's size is small compared to nums2's size? Which algorithm is better?\r\nWhat if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/434", "similarQuestions": ["IntersectionofTwoArrays"], "topicTags": ["HashTable", "TwoPointers", "BinarySearch", "Sort"], "Solution": "class Solution {\n    public int[] intersect(int[] nums1, int[] nums2) {\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        int i = 0;\n        int j = 0;\n        int k = 0;\n        int[] ans = new int[Math.min(nums1.length, nums2.length)];\n        while (i < nums1.length && j < nums2.length) {\n            if (nums1[i] == nums2[j]) {\n                ans[k] = nums1[i];\n                i++;\n                j++;\n                k++;\n            } else if (nums1[i] < nums2[j]) {\n                while (i + 1 < nums1.length && nums1[i] == nums1[i + 1]) i++;\n                i++;\n            } else {\n                while (j + 1 < nums2.length && nums2[j] == nums2[j + 1]) j++;\n                j++;\n            }\n        }\n        \n        return Arrays.copyOf(ans, k);\n    }\n}\n\n// [], [1,2,2,3] -> []\n// [2,2], [1,2,2,3] -> [2,2]\n", "total_acs": 94270, "total_submitted": 210885}, {"id": 351, "title": "Android Unlock Patterns", "url": "https://leetcode.com/problems/android-unlock-patterns/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "\r\nGiven an Android 3x3 key lock screen and two integers m and n, where  1 \u2264 m \u2264 n \u2264 9, count the total number of unlock patterns of the Android lock screen, which consist of minimum of m keys and maximum n keys.\r\n\r\nRules for a valid pattern:\r\n\r\nEach pattern must connect at least m keys and at most n keys.\r\nAll the keys must be distinct.\r\nIf the line connecting two consecutive keys in the pattern passes through any other keys, the other keys must have previously selected in the pattern. No jumps through non selected key is allowed.\r\nThe order of keys used matters.\r\n\r\n\r\n\r\n\r\n\r\nExplanation:\r\n\r\n| 1 | 2 | 3 |\r\n| 4 | 5 | 6 |\r\n| 7 | 8 | 9 |\r\n\r\n\r\n\r\nInvalid move: 4 - 1 - 3 - 6 \r\n\r\nLine  1 - 3 passes through key 2 which had not been selected in the pattern.\r\n\r\nInvalid move: 4 - 1 - 9 - 2\r\n\r\nLine  1 - 9 passes through key 5 which had not been selected in the pattern.\r\n\r\nValid move: 2 - 4 - 1 - 3 - 6\r\n\r\nLine 1 - 3 is valid because it passes through key 2, which had been selected in the pattern\r\n\r\nValid move: 6 - 5 - 4 - 1 - 9 - 2\r\n\r\nLine 1 - 9 is valid because it passes through key 5, which had been selected in the pattern.\r\n\r\nExample:\r\nGiven m = 1, n = 1, return 9.\r\n\r\n\r\nCredits:Special thanks to @elmirap for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/435", "similarQuestions": [""], "topicTags": ["DynamicProgramming", "Backtracking"], "Solution": "class Solution {\n    public int numberOfPatterns(int m, int n) {\n        boolean[] visited = new boolean[10];\n        visited[0] = true;\n        \n        int[][] jumps = new int[10][10];\n        jumps[1][3] = jumps[3][1] = 2;\n        jumps[1][7] = jumps[7][1] = 4;\n        jumps[7][9] = jumps[9][7] = 8;\n        jumps[9][3] = jumps[3][9] = 6;\n        jumps[4][6] = jumps[6][4] = jumps[2][8] = jumps[8][2] = jumps[1][9] = jumps[9][1] = jumps[3][7] = jumps[7][3] = 5;\n        \n        int count = 0;\n        count += 4 * dfs(1, 1, 0, m, n, visited, jumps);\n        count += 4 * dfs(2, 1, 0, m, n, visited, jumps);\n        count += dfs(5, 1, 0, m, n, visited, jumps);\n        return count;\n    }\n    private int dfs(int num, int len, int count, int m, int n, boolean[] visited, int[][] jumps) {\n        if (len >= m) count++;\n        len++;\n        if (len > n) return count;\n        \n        visited[num] = true;\n        for (int next = 1; next <= 9; next++) {\n            if (!visited[next] && (jumps[num][next] == 0 || visited[jumps[num][next]])) {\n                count = dfs(next, len, count, m, n, visited, jumps);\n            }\n        }\n        visited[num] = false;\n        return count;\n    }\n}", "total_acs": 19023, "total_submitted": 42579}, {"id": 352, "title": "Data Stream as Disjoint Intervals", "url": "https://leetcode.com/problems/data-stream-as-disjoint-intervals/description", "companyTags": [""], "difficulty": "Hard", "content": "Given a data stream input of non-negative integers a1, a2, ..., an, ..., summarize the numbers seen so far as a list of disjoint intervals.\r\n\r\nFor example, suppose the integers from the data stream are 1, 3, 7, 2, 6, ..., then the summary will be:\r\n\r\n[1, 1]\r\n[1, 1], [3, 3]\r\n[1, 1], [3, 3], [7, 7]\r\n[1, 3], [7, 7]\r\n[1, 3], [6, 7]\r\n\r\n\r\nFollow up:\r\nWhat if there are lots of merges and the number of disjoint intervals are small compared to the data stream's size?\r\n\r\n\r\nCredits:Special thanks to @yunhong for adding this problem and creating most of the test cases.", "discussUrl": "https://discuss.leetcode.com/category/436", "similarQuestions": ["SummaryRanges", "FindRightInterval", "RangeModule"], "topicTags": ["BinarySearchTree"], "Solution": "/**\n * Definition for an interval.\n * public class Interval {\n *     int start;\n *     int end;\n *     Interval() { start = 0; end = 0; }\n *     Interval(int s, int e) { start = s; end = e; }\n * }\n */\nclass SummaryRanges {\n    \n    class BSTNode {\n        Interval interval;\n        BSTNode left;\n        BSTNode right;\n        BSTNode(Interval interval) {\n            this.interval = interval;\n        }\n    }\n    \n    BSTNode findMin(BSTNode root) {\n        if (root == null) return null;\n        if (root.left == null ) return root;\n        else return findMin(root.left);\n    }\n    \n    BSTNode remove(Interval x, BSTNode root) {\n        if (root == null) return null;\n        else if ( x == null ) return root;\n        else if (x.start > root.interval.end ) {\n            root.right = remove(x, root.right);\n        } else if (x.end < root.interval.start ) {\n            root.left = remove(x, root.left);\n        } else if (root.left != null && root.right != null) {\n            root.interval = findMin(root.right).interval;\n            root.right = remove(root.interval, root.right);\n        } else {\n            root = (root.left != null) ? root.left : root.right;\n        }\n        return root;\n    }\n    \n    BSTNode findKey(int val, BSTNode root) {\n        if (root == null) return null;\n        if (root.interval.start > val) {\n            return findKey(val, root.left);\n        } else if (root.interval.end < val) {\n            return findKey(val, root.right);\n        } else return root;\n    }\n    \n    BSTNode addKey(int val, BSTNode root) {\n        if (root == null) {\n            root = new BSTNode( new Interval(val, val) ); \n        } else if (root.interval.start > val) {\n            root.left = addKey(val, root.left);\n        } else if (root.interval.end < val) {\n            root.right = addKey(val, root.right);\n        }  \n        return root;\n    }\n    \n    void inOrder(BSTNode root) {\n        if (root != null) {\n            inOrder(root.left);\n            list.add(root.interval);\n            inOrder(root.right);\n        }\n    }\n\n    /** Initialize your data structure here. */\n    \n    BSTNode root;\n    List<Interval> list = new ArrayList();\n    \n    public SummaryRanges() {\n        root = null;\n    }\n    \n    public void addNum(int val) {\n        if (root == null) root = addKey(val, root);\n        else {\n            if (findKey(val, root) != null) return;\n            BSTNode left = findKey(val - 1, root);\n            BSTNode right = findKey(val + 1, root);\n            if (left == null && right == null) {\n                root = addKey(val, root);\n            }\n            else if (left != null && right == null) {\n                left.interval.end++;\n            }\n            else if (left == null && right != null) {\n                right.interval.start--;\n            }\n            else {\n                Interval l = left.interval;\n                int e = right.interval.end;\n                root = remove(right.interval, root);\n                l.end = e;\n            }\n        }\n    }\n    \n    public List<Interval> getIntervals() {\n        list = new ArrayList<>();\n        inOrder(root);\n        return list;\n    }\n}\n\n/**\n * Your SummaryRanges object will be instantiated and called as such:\n * SummaryRanges obj = new SummaryRanges();\n * obj.addNum(val);\n * List<Interval> param_2 = obj.getIntervals();\n */", "total_acs": 16262, "total_submitted": 39863}, {"id": 353, "title": "Design Snake Game", "url": "https://leetcode.com/problems/design-snake-game/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "Design a Snake game that is played on a device with screen size = width x height. Play the game online if you are not familiar with the game.\r\n\r\nThe snake is initially positioned at the top left corner (0,0) with length = 1 unit.\r\n\r\nYou are given a list of food's positions in row-column order. When a snake eats the food, its length and the game's score both increase by 1.\r\n\r\nEach food appears one by one on the screen. For example, the second food will not appear until the first food was eaten by the snake.\r\n\r\nWhen a food does appear on the screen, it is guaranteed that it will not appear on a block occupied by the snake.\r\n\r\n\r\nExample:\r\n\r\nGiven width = 3, height = 2, and food = [[1,2],[0,1]].\r\n\r\nSnake snake = new Snake(width, height, food);\r\n\r\nInitially the snake appears at position (0,0) and the food at (1,2).\r\n\r\n|S| | |\r\n| | |F|\r\n\r\nsnake.move(\"R\"); -> Returns 0\r\n\r\n| |S| |\r\n| | |F|\r\n\r\nsnake.move(\"D\"); -> Returns 0\r\n\r\n| | | |\r\n| |S|F|\r\n\r\nsnake.move(\"R\"); -> Returns 1 (Snake eats the first food and right after that, the second food appears at (0,1) )\r\n\r\n| |F| |\r\n| |S|S|\r\n\r\nsnake.move(\"U\"); -> Returns 1\r\n\r\n| |F|S|\r\n| | |S|\r\n\r\nsnake.move(\"L\"); -> Returns 2 (Snake eats the second food)\r\n\r\n| |S|S|\r\n| | |S|\r\n\r\nsnake.move(\"U\"); -> Returns -1 (Game over because snake collides with border)\r\n\r\n\r\n\r\n\r\nCredits:Special thanks to @elmirap for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/437", "similarQuestions": [""], "topicTags": ["Design", "Queue"], "Solution": null, "total_acs": 10717, "total_submitted": 39545}, {"id": 354, "title": "Russian Doll Envelopes", "url": "https://leetcode.com/problems/russian-doll-envelopes/description", "companyTags": ["Google"], "difficulty": "Hard", "content": "You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope.\r\n\r\n\r\nWhat is the maximum number of envelopes can you Russian doll? (put one inside other)\r\n\r\n\r\nExample:\r\nGiven envelopes = [[5,4],[6,4],[6,7],[2,3]], the maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]).\r\n", "discussUrl": "https://discuss.leetcode.com/category/438", "similarQuestions": ["LongestIncreasingSubsequence"], "topicTags": ["BinarySearch", "DynamicProgramming"], "Solution": "//4:42  -4:48\n// coding: 5:28- 5:37 9 min\n//test & check: \n//sbu: 5:38\nclass Solution {\n    public int maxEnvelopes(int[][] envelopes) {\n        int n = envelopes.length;\n        Comparator<int[]> comparator = new Comparator<int[]>(){\n            @Override\n            public int compare(int[] a, int[] b)\n            {\n                if(a[0]==b[0])\n                    return b[1]-a[1];\n                else\n                    return a[0]-b[0];\n            }\n        };\n            //sort O(nlogn)\n        Arrays.sort(envelopes, comparator);\n        int[] tails = new int[n];// the smallest element for length i-1\n        int len =0;\n       for(int i=0; i<n; i++)//!! conflicting names \n       {\n           int[] env=envelopes[i];\n           int idx=Arrays.binarySearch(tails,0, len, env[1]);\n           //System.out.println(\" idx: \"+ idx+\" len: \"+ len+ \" i: \"+ i);\n           if(idx<0)\n               idx =-(idx+1);//get the insertion point\n           //if  tails[idx-1]<=env[1]<=tais[idx]\n           //if env[1]>=tails[idx]\n           tails[idx]=env[1];\n           if(idx == len)\n               len++;           \n        //dp[i] max envelope can Russian doll at position i\n        //approach 1: binary search and update tails[i]\n       }\n        return len;\n        \n\n    }\n           // approach 2: dp[i] = max(dp[k])+1 for k<i if(wi>wk && hi>hk) //O(n^2)\n}", "total_acs": 27166, "total_submitted": 83360}, {"id": 355, "title": "Design Twitter", "url": "https://leetcode.com/problems/design-twitter/description", "companyTags": ["Amazon", "Twitter"], "difficulty": "Medium", "content": "Design a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user's news feed. Your design should support the following methods:\r\n\r\n\r\n\r\npostTweet(userId, tweetId): Compose a new tweet.\r\ngetNewsFeed(userId): Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.\r\nfollow(followerId, followeeId): Follower follows a followee.\r\nunfollow(followerId, followeeId): Follower unfollows a followee.\r\n\r\n\r\n\r\nExample:\r\n\r\nTwitter twitter = new Twitter();\r\n\r\n// User 1 posts a new tweet (id = 5).\r\ntwitter.postTweet(1, 5);\r\n\r\n// User 1's news feed should return a list with 1 tweet id -> [5].\r\ntwitter.getNewsFeed(1);\r\n\r\n// User 1 follows user 2.\r\ntwitter.follow(1, 2);\r\n\r\n// User 2 posts a new tweet (id = 6).\r\ntwitter.postTweet(2, 6);\r\n\r\n// User 1's news feed should return a list with 2 tweet ids -> [6, 5].\r\n// Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.\r\ntwitter.getNewsFeed(1);\r\n\r\n// User 1 unfollows user 2.\r\ntwitter.unfollow(1, 2);\r\n\r\n// User 1's news feed should return a list with 1 tweet id -> [5],\r\n// since user 1 is no longer following user 2.\r\ntwitter.getNewsFeed(1);\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/439", "similarQuestions": [""], "topicTags": ["HashTable", "Heap", "Design"], "Solution": "class Twitter {\n    private static class Tweet {\n        final int id;\n        final int time;\n        Tweet(int id, int time) {\n            this.id = id;\n            this.time = time;\n        }\n    }\n    \n    private static class User {\n        final int id;\n        final Set<User> followees;\n        final List<Tweet> tweets;\n        \n        User(int id) {\n            this.id = id;\n            this.followees = new HashSet<>();\n            this.tweets = new LinkedList<>();\n        }\n        \n        void post(int tweetId, int time) {\n            this.tweets.add(0, new Tweet(tweetId, time));\n        }\n        \n        void follow(User user) {\n            if (user.id != this.id) {\n                this.followees.add(user);\n            }\n        }\n        \n        void unfollow(User user) {\n            this.followees.remove(user);\n        }\n        \n        List<Integer> getNewsFeed() {\n            PriorityQueue<Tweet> queue = new PriorityQueue<>(new Comparator<Tweet>() {\n                @Override\n                public int compare(Tweet o1, Tweet o2) {\n                    return o1.time - o2.time;\n                }\n            });\n            \n            enqueue(queue, this);\n            for (User user : followees) {\n                enqueue(queue, user);\n            }\n            \n            List<Integer> ans = new LinkedList<>();\n            while (!queue.isEmpty()) {\n                ans.add(0, queue.poll().id);\n            }\n            \n            return ans;\n        }\n        \n        private static void enqueue(PriorityQueue<Tweet> queue, User user) {\n            int count = 0;\n            for (Tweet t : user.tweets) {\n                count++;\n                queue.offer(t);\n                if (queue.size() > 10) {\n                    queue.poll();\n                }\n                \n                if (count >= 10) {\n                    break;\n                }\n            }\n        }\n    }\n    \n    private final Map<Integer, User> userMap;\n    private int globalTime;\n\n    /** Initialize your data structure here. */\n    public Twitter() {\n        this.globalTime = 0;\n        this.userMap = new HashMap<>();\n    }\n    \n    /** Compose a new tweet. */\n    public void postTweet(int userId, int tweetId) {\n        userMap.computeIfAbsent(userId, k -> new User(k)).post(tweetId, globalTime++);\n    }\n    \n    /** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\n    public List<Integer> getNewsFeed(int userId) {\n        return userMap.computeIfAbsent(userId, k -> new User(k)).getNewsFeed();\n    }\n    \n    /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\n    public void follow(int followerId, int followeeId) {\n        userMap.computeIfAbsent(followerId, k -> new User(k)).follow(userMap.computeIfAbsent(followeeId, k -> new User(k)));\n    }\n    \n    /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\n    public void unfollow(int followerId, int followeeId) {\n        userMap.computeIfAbsent(followerId, k -> new User(k)).unfollow(userMap.computeIfAbsent(followeeId, k -> new User(k)));\n    }\n}\n\n/**\n * Your Twitter object will be instantiated and called as such:\n * Twitter obj = new Twitter();\n * obj.postTweet(userId,tweetId);\n * List<Integer> param_2 = obj.getNewsFeed(userId);\n * obj.follow(followerId,followeeId);\n * obj.unfollow(followerId,followeeId);\n */", "total_acs": 23423, "total_submitted": 90699}, {"id": 356, "title": "Line Reflection", "url": "https://leetcode.com/problems/line-reflection/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "Given n points on a 2D plane, find if there is such a line parallel to y-axis that reflect the given points.\r\n\r\n\r\n    Example 1:\r\n\r\n\r\nGiven points = [[1,1],[-1,1]], return true.\r\n\r\n\r\n\r\n    Example 2:\r\n\r\n\r\nGiven points = [[1,1],[-1,-1]], return false.\r\n\r\n\r\nFollow up:\r\nCould you do better than O(n2)?\r\n\r\n\r\nCredits:Special thanks to @memoryless for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/440", "similarQuestions": ["MaxPointsonaLine", "NumberofBoomerangs"], "topicTags": ["HashTable", "Math"], "Solution": "class Solution {\n    public boolean isReflected(int[][] points) {\n        if (points.length < 1 || points[0].length < 1) return true;\n        \n        Arrays.sort(points, new Comparator<int[]>() {\n            public int compare(int[] pointA, int[] pointB) {\n                if (pointA[0] == pointB[0]) {\n                    return Integer.compare(pointA[1], pointB[1]);\n                }\n                return Integer.compare(pointA[0], pointB[0]);\n            }\n        });  \n        //PrintArray(points);\n        \n        Arrays.sort(points, points.length/2, points.length, new Comparator<int[]>() {\n            public int compare(int[] pointA, int[] pointB) {\n                if (pointA[0] == pointB[0]) {\n                    return Integer.compare(pointB[1], pointA[1]);\n                }\n                return Integer.compare(pointA[0], pointB[0]);\n            }\n        });\n        //PrintArray(points);\n\n        // check for symmetry\n        int left = 0, right = points.length-1;\n        if (points[left][0] == points[right][0]) return true;\n        if (points[left][1] != points[right][1]) return false;\n        double mirrorLine = (points[left][0] + points[right][0]) / 2.0;\n        left++;\n        right--;\n\n        while (left < right) {\n            //System.out.println(\"left = \" + left + \", right = \" + right);\n            if (points[left][0] == points[left-1][0] && points[left][1] == points[left-1][1]) {\n                left++;\n                continue;\n            }\n            if (points[right][0] == points[right+1][0] && points[right][1] == points[right+1][1]) {\n                right--;\n                continue;\n            }\n            if (points[left][0] != points[right][0] && points[left][1] != points[right][1]) return false;\n            if ((points[left][0] + points[right][0]) / 2.0 != mirrorLine) return false;\n            left++;\n            right--;\n        }\n        \n        //System.out.println(\"end: left = \" + left + \", right = \" + right);\n        if (left == right) {\n            if (points[left][0] == mirrorLine || left < points.length-1 && points[left][0] == points[left+1][0] || right > 0 && points[right][0] == points[right-1][0]) {\n                return true;\n            }\n            return false;\n        }\n        return true; \n    }\n    \n    public void PrintArray(int[][] points) {\n        for (int i=0; i<points.length; ++i) {\n            System.out.print(\"[\" + points[i][0] +\",\" + points[i][1] + \"],\");\n        }\n        System.out.println(\"\");\n    }\n}", "total_acs": 13363, "total_submitted": 44179}, {"id": 357, "title": "Count Numbers with Unique Digits", "url": "https://leetcode.com/problems/count-numbers-with-unique-digits/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "Given a non-negative integer n, count all numbers with unique digits, x, where 0 \u2264 x < 10n.\r\n\r\n\r\n    Example:\r\nGiven n = 2, return 91. (The answer should be the total numbers in the range of 0 \u2264 x < 100, excluding [11,22,33,44,55,66,77,88,99])\r\n\r\n\r\nCredits:Special thanks to @memoryless for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/441", "similarQuestions": [""], "topicTags": ["Math", "DynamicProgramming", "Backtracking"], "Solution": "class Solution {\n    public int countNumbersWithUniqueDigits(int n) {\n                if (n == 0)     return 1;\n        \n        int res = 10;\n        int uniqueDigits = 9;\n        int availableNumber = 9;\n        while (n-- > 1 && availableNumber > 0) {\n            uniqueDigits = uniqueDigits * availableNumber;\n            res += uniqueDigits;\n            availableNumber--;\n        }\n        return res;\n    }\n}", "total_acs": 44140, "total_submitted": 95784}, {"id": 358, "title": "Rearrange String k Distance Apart", "url": "https://leetcode.com/problems/rearrange-string-k-distance-apart/description", "companyTags": ["Google"], "difficulty": "Hard", "content": "\r\nGiven a non-empty string s and an integer k, rearrange the string such that the same characters are at least distance k from each other.\r\n\r\n\r\nAll input strings are given in lowercase letters. If it is not possible to rearrange the string, return an empty string \"\".\r\n\r\nExample 1:\r\n\r\ns = \"aabbcc\", k = 3\r\n\r\nResult: \"abcabc\"\r\n\r\nThe same letters are at least distance 3 from each other.\r\n\r\n\r\n\r\nExample 2:\r\n\r\ns = \"aaabc\", k = 3 \r\n\r\nAnswer: \"\"\r\n\r\nIt is not possible to rearrange the string.\r\n\r\n\r\n\r\nExample 3:\r\n\r\ns = \"aaadbbcc\", k = 2\r\n\r\nAnswer: \"abacabcd\"\r\n\r\nAnother possible answer is: \"abcabcda\"\r\n\r\nThe same letters are at least distance 2 from each other.\r\n\r\n\r\n\r\nCredits:Special thanks to @elmirap for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/442", "similarQuestions": ["TaskScheduler", "ReorganizeString"], "topicTags": ["HashTable", "Heap", "Greedy"], "Solution": "class Solution {\n    public String rearrangeString(String s, int k) {\n        \n        int len = s.length();\n        int[] map = new int[26];\n        int[] valid = new int[26];\n        char[] arr = s.toCharArray();\n        for(char c : arr) {\n            map[c - 'a']++;\n        }\n        char[] res = new char[len];\n        for(int i = 0; i < len; i++) {\n            int cur = help(map, valid, i);\n            if(cur == -1) {\n                return \"\";\n            }\n            res[i] = (char)(cur + 'a');\n            valid[cur] = i + k;\n            map[cur]--;\n        }\n        return new String(res);\n    }\n    \n    private int help(int[] map, int[] valid, int index) {\n        int pos = -1;\n        int max = 0;\n        for(int i = 0; i < 26; i++) {\n            if(map[i] > max && index >= valid[i]) {\n                max = map[i];\n                pos = i;\n            }\n        }\n        return pos;\n    }\n}", "total_acs": 13379, "total_submitted": 42199}, {"id": 359, "title": "Logger Rate Limiter", "url": "https://leetcode.com/problems/logger-rate-limiter/description", "companyTags": ["Google"], "difficulty": "Easy", "content": "Design a logger system that receive stream of messages along with its timestamps, each message should be printed if and only if it is not printed in the last 10 seconds.\r\n\r\nGiven a message and a timestamp (in seconds granularity), return true if the message should be printed in the given timestamp, otherwise returns false.\r\n\r\nIt is possible that several messages arrive roughly at the same time.\r\n\r\nExample:\r\n\r\nLogger logger = new Logger();\r\n\r\n// logging string \"foo\" at timestamp 1\r\nlogger.shouldPrintMessage(1, \"foo\"); returns true; \r\n\r\n// logging string \"bar\" at timestamp 2\r\nlogger.shouldPrintMessage(2,\"bar\"); returns true;\r\n\r\n// logging string \"foo\" at timestamp 3\r\nlogger.shouldPrintMessage(3,\"foo\"); returns false;\r\n\r\n// logging string \"bar\" at timestamp 8\r\nlogger.shouldPrintMessage(8,\"bar\"); returns false;\r\n\r\n// logging string \"foo\" at timestamp 10\r\nlogger.shouldPrintMessage(10,\"foo\"); returns false;\r\n\r\n// logging string \"foo\" at timestamp 11\r\nlogger.shouldPrintMessage(11,\"foo\"); returns true;\r\n\r\n\r\n\r\nCredits:Special thanks to @memoryless for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/443", "similarQuestions": ["DesignHitCounter"], "topicTags": ["HashTable", "Design"], "Solution": "class Logger {\n    HashMap<String, Integer> map; \n    /** Initialize your data structure here. */\n    public Logger() {\n        map = new HashMap<>();\n    }\n    \n    /** Returns true if the message should be printed in the given timestamp, otherwise returns false.\n        If this method returns false, the message will not be printed.\n        The timestamp is in seconds granularity. */\n    public boolean shouldPrintMessage(int timestamp, String message) {\n        if (timestamp < map.getOrDefault(message, 0)) {\n            return false;\n        }\n        map.put(message, timestamp + 10);\n        return true;\n    }\n}\n\n/**\n * Your Logger object will be instantiated and called as such:\n * Logger obj = new Logger();\n * boolean param_1 = obj.shouldPrintMessage(timestamp,message);\n */", "total_acs": 23394, "total_submitted": 38638}, {"id": 360, "title": "Sort Transformed Array", "url": "https://leetcode.com/problems/sort-transformed-array/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "\r\nGiven a sorted array of integers nums and integer values a, b and c.  Apply a quadratic function of the form f(x) = ax2 + bx + c to each element x in the array. \r\n\r\nThe returned array must be in sorted order.\r\n\r\nExpected time complexity: O(n)\r\n\r\nExample:\r\n\r\nnums = [-4, -2, 2, 4], a = 1, b = 3, c = 5,\r\n\r\nResult: [3, 9, 15, 33]\r\n\r\nnums = [-4, -2, 2, 4], a = -1, b = 3, c = 5\r\n\r\nResult: [-23, -5, 1, 7]\r\n\r\n\r\n\r\nCredits:Special thanks to @elmirap for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/444", "similarQuestions": [""], "topicTags": ["Math", "TwoPointers"], "Solution": "class Solution {\n    public int[] sortTransformedArray(int[] nums, int a, int b, int c) {\n        int n = nums.length;\n        int[] result = new int[nums.length];\n        \n        int index = a < 0 ? 0 : n - 1;\n        int i = 0;\n        int j = n - 1;\n        while (i <= j) {\n            int start = cal(a, b, c, nums[i]);\n            int end = cal(a, b, c, nums[j]);\n            if (a >= 0) {\n                result[index--] = start >= end ? start : end;\n                if (start >= end) {\n                    i++;\n                }\n                else {\n                    j--;\n                }\n            }\n            else {\n                result[index++] = start >= end ? end : start;\n                if (start >= end) {\n                    j--;\n                }\n                else {\n                    i++;\n                }\n            }\n        }\n        return result;\n    }\n    \n    private int cal(int a, int b, int c, int x) {\n        return a * x * x + b * x + c;\n    } \n}", "total_acs": 15659, "total_submitted": 35002}, {"id": 361, "title": "Bomb Enemy", "url": "https://leetcode.com/problems/bomb-enemy/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "Given a 2D grid, each cell is either a wall 'W', an enemy 'E' or empty '0' (the number zero), return the maximum enemies you can kill using one bomb. The bomb kills all the enemies in the same row and column from the planted point until it hits the wall since the wall is too strong to be destroyed.\r\n Note that you can only put the bomb at an empty cell. \r\n\r\nExample:\r\n\r\nFor the given grid\r\n\r\n0 E 0 0\r\nE 0 W E\r\n0 E 0 0\r\n\r\nreturn 3. (Placing a bomb at (1,1) kills 3 enemies)\r\n\r\n\r\n\r\nCredits:Special thanks to @memoryless for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/445", "similarQuestions": [""], "topicTags": ["DynamicProgramming"], "Solution": "public class Solution {\n    public int maxKilledEnemies(char[][] grid) {\n        if (grid.length == 0) {\n            return 0;\n        }\n        int output = 0;\n        int m = grid.length;\n        int n = grid[0].length;\n        int[] colSum = new int[n];\n        int[][] cal = new int[m][n];\n        for (int row = 0; row < m; row++) {\n            int rowSum = 0;\n            for (int col = 0; col < n; col++) {\n                if (grid[row][col] == '0') {\n                    cal[row][col] = rowSum + colSum[col];\n                } else if (grid[row][col] == 'E') {\n                    rowSum++;\n                    colSum[col]++;\n                } else {\n                    rowSum = 0;\n                    colSum[col] = 0;\n                }\n            }\n        }\n        colSum = new int[n];\n        for (int row = m - 1; row >= 0; row--) {\n            int rowSum = 0;\n            for (int col = n - 1; col >= 0; col--) {\n                if (grid[row][col] == '0') {\n                    output = Math.max(output, cal[row][col] + colSum[col] + rowSum);\n                } else if (grid[row][col] == 'E') {\n                    rowSum++;\n                    colSum[col]++;\n                } else {\n                    rowSum = 0;\n                    colSum[col] = 0;\n                }\n            }\n        }\n        return output;\n    }\n}", "total_acs": 21705, "total_submitted": 54252}, {"id": 362, "title": "Design Hit Counter", "url": "https://leetcode.com/problems/design-hit-counter/description", "companyTags": ["Google", "Dropbox"], "difficulty": "Medium", "content": "Design a hit counter which counts the number of hits received in the past 5 minutes.\r\n\r\nEach function accepts a timestamp parameter (in seconds granularity) and you may assume that calls are being made to the system in chronological order (ie, the timestamp is monotonically increasing). You may assume that the earliest timestamp starts at 1.\r\n\r\nIt is possible that several hits arrive roughly at the same time.\r\n\r\nExample:\r\n\r\nHitCounter counter = new HitCounter();\r\n\r\n// hit at timestamp 1.\r\ncounter.hit(1);\r\n\r\n// hit at timestamp 2.\r\ncounter.hit(2);\r\n\r\n// hit at timestamp 3.\r\ncounter.hit(3);\r\n\r\n// get hits at timestamp 4, should return 3.\r\ncounter.getHits(4);\r\n\r\n// hit at timestamp 300.\r\ncounter.hit(300);\r\n\r\n// get hits at timestamp 300, should return 4.\r\ncounter.getHits(300);\r\n\r\n// get hits at timestamp 301, should return 3.\r\ncounter.getHits(301); \r\n\r\n\r\n\r\nFollow up:\r\nWhat if the number of hits per second could be very large? Does your design scale?\r\n\r\n\r\nCredits:Special thanks to @elmirap for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/446", "similarQuestions": ["LoggerRateLimiter"], "topicTags": ["Design"], "Solution": "public class HitCounter {\r\n\r\n    /** Initialize your data structure here. */\r\n    Map<Integer, Integer> map;\r\n    List<Integer> secs;\r\n    public HitCounter() {\r\n        map = new HashMap<Integer, Integer>();\r\n        secs = new ArrayList<Integer>();\r\n    }\r\n    \r\n    /** Record a hit.\r\n        @param timestamp - The current timestamp (in seconds granularity). */\r\n    public void hit(int timestamp) {\r\n        if(!map.containsKey(timestamp)){\r\n            map.put(timestamp, 1);\r\n            secs.add(timestamp);\r\n        } else{\r\n            map.put(timestamp, map.get(timestamp) + 1);\r\n        }\r\n    }\r\n    \r\n    /** Return the number of hits in the past 5 minutes.\r\n        @param timestamp - The current timestamp (in seconds granularity). */\r\n    public int getHits(int timestamp) {\r\n        int count = 0;\r\n        for(int i = secs.size() - 1; i >= 0 ; i--){\r\n            if(secs.get(i) > timestamp - 300){\r\n                count += map.get(secs.get(i));\r\n            }\r\n            else{\r\n                break;\r\n            }\r\n        }\r\n        return count;\r\n    }\r\n}\r\n\r\n/**\r\n * Your HitCounter object will be instantiated and called as such:\r\n * HitCounter obj = new HitCounter();\r\n * obj.hit(timestamp);\r\n * int param_2 = obj.getHits(timestamp);\r\n */", "total_acs": 22414, "total_submitted": 40793}, {"id": 363, "title": "Max Sum of Rectangle No Larger Than K", "url": "https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/description", "companyTags": ["Google"], "difficulty": "Hard", "content": "Given a non-empty 2D matrix matrix and an integer k, find the max sum of a rectangle in the matrix such that its sum is no larger than k.\r\n\r\nExample:\r\nGiven matrix = [\r\n  [1,  0, 1],\r\n  [0, -2, 3]\r\n]\r\nk = 2\r\n\r\n\r\n\r\nThe answer is 2. Because the sum of rectangle [[0, 1], [-2, 3]] is 2 and 2 is the max number no larger than k (k = 2).\r\n\r\nNote:\r\n\r\nThe rectangle inside the matrix must have an area > 0.\r\nWhat if the number of rows is much larger than the number of columns?\r\n\r\n\r\n\r\nCredits:Special thanks to @fujiaozhu for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/447", "similarQuestions": [""], "topicTags": ["BinarySearch", "DynamicProgramming", "Queue"], "Solution": "// sample 30 ms submission\nclass Solution {\n    public int maxSumSubmatrix(int[][] matrix, int k) {\n        if(matrix.length == 0) return 0;\n        // Rows in matrix\n        int m = matrix.length;\n        // Cols in matrix\n        int n = matrix[0].length;\n        int result = Integer.MIN_VALUE;\n        \n        // For each column in matrix.\n        for(int left = 0; left < n; left ++){\n         //   System.out.print(\"left\");\n         //   System.out.println(left);\n            \n            // We create array of number of rows.This helps us to keep addition horizontally. \n             int[] sums = new int[m];\n            \n            // From selected column we forward upto end.\n            for(int right = left; right < n; right ++){\n                \n                int sum = 0, maxSum = Integer.MIN_VALUE;\n                \n                // From forward selected column compute sum for all rows marked by index right column.\n                for(int i = 0; i < m; i++){\n                    sums[i] += matrix[i][right];\n                    // Computing running max sum.\n                    sum = Math.max(sum + sums[i], sums[i]);\n                    // Computing maximum of running max sum.\n                    maxSum = Math.max(maxSum, sum);\n                }\n                // if maxsum is <=k one instance of solution found voilla. Moving iteration forward.\n                if(maxSum <= k){\n                    result = Math.max(result, maxSum);\n                    continue;\n                }\n                // INtialize new sum, starting sum as 0.\n                TreeSet<Integer> set = new TreeSet<>();\n                set.add(0); //this is for one dimensional first element equals to K: [3, 2] k = 3;\n                // keep track of running sum.\n                int curSum = 0;\n                \n                for(int s: sums) {\n                    curSum += s;\n                    // we find closest sum to k using ceiling function.\n                    Integer c = set.ceiling(curSum - k);\n                    // updating result for closer results.\n                    if(c != null) result = Math.max(result, curSum - c);\n                    set.add(curSum);\n                }\n              //  System.out.print(\"right\");\n              //  System.out.print(right);\n              //  System.out.println(result);\n\n\n            }\n          //  System.out.println(result);\n            \n        }\n        return result;\n        \n    }\n}", "total_acs": 18006, "total_submitted": 53536}, {"id": 364, "title": "Nested List Weight Sum II", "url": "https://leetcode.com/problems/nested-list-weight-sum-ii/description", "companyTags": ["LinkedIn"], "difficulty": "Medium", "content": "Given a nested list of integers, return the sum of all integers in the list weighted by their depth.\r\n\r\nEach element is either an integer, or a list -- whose elements may also be integers or other lists.\r\n\r\nDifferent from the previous question where weight is increasing from root to leaf, now the weight is defined from bottom up. i.e., the leaf level integers have weight 1, and the root level integers have the largest weight.\r\n\r\nExample 1:\r\nGiven the list [[1,1],2,[1,1]], return 8. (four 1's at depth 1, one 2 at depth 2)\r\n\r\nExample 2:\r\nGiven the list [1,[4,[6]]], return 17. (one 1 at depth 3, one 4 at depth 2, and one 6 at depth 1; 1*3 + 4*2 + 6*1 = 17)\r\n", "discussUrl": "https://discuss.leetcode.com/category/448", "similarQuestions": ["NestedListWeightSum", "ArrayNesting"], "topicTags": ["Depth-firstSearch"], "Solution": "/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * public interface NestedInteger {\n *     // Constructor initializes an empty nested list.\n *     public NestedInteger();\n *\n *     // Constructor initializes a single integer.\n *     public NestedInteger(int value);\n *\n *     // @return true if this NestedInteger holds a single integer, rather than a nested list.\n *     public boolean isInteger();\n *\n *     // @return the single integer that this NestedInteger holds, if it holds a single integer\n *     // Return null if this NestedInteger holds a nested list\n *     public Integer getInteger();\n *\n *     // Set this NestedInteger to hold a single integer.\n *     public void setInteger(int value);\n *\n *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.\n *     public void add(NestedInteger ni);\n *\n *     // @return the nested list that this NestedInteger holds, if it holds a nested list\n *     // Return null if this NestedInteger holds a single integer\n *     public List<NestedInteger> getList();\n * }\n */\nclass Solution {\n    public int depthSumInverse(List<NestedInteger> nestedList) {\n        int unweight = 0;\n        int weight = 0;\n        while(!nestedList.isEmpty()) {\n            List<NestedInteger> nextLevel = new ArrayList<>();\n            for(int i = 0; i < nestedList.size(); i ++) {\n                NestedInteger current = nestedList.get(i);\n                if(current.isInteger())unweight += current.getInteger();\n                else nextLevel.addAll(current.getList());\n            }\n            weight += unweight;\n            nestedList = nextLevel;\n        }\n        return weight;\n    }\n    \n}", "total_acs": 20340, "total_submitted": 37764}, {"id": 365, "title": "Water and Jug Problem", "url": "https://leetcode.com/problems/water-and-jug-problem/description", "companyTags": ["Microsoft"], "difficulty": "Medium", "content": "You are given two jugs with capacities x and y litres. There is an infinite amount of water supply available.\r\nYou need to determine whether it is possible to measure exactly z litres using these two jugs.\r\n\r\nIf z liters of water is measurable, you must have z liters of water contained within one or both buckets by the end.\r\n\r\n\r\nOperations allowed:\r\n\r\nFill any of the jugs completely with water.\r\nEmpty any of the jugs.\r\nPour water from one jug into another till the other jug is completely full or the first jug itself is empty.\r\n\r\n\r\n\r\nExample 1: (From the famous \"Die Hard\" example)\r\n\r\nInput: x = 3, y = 5, z = 4\r\nOutput: True\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: x = 2, y = 6, z = 5\r\nOutput: False\r\n\r\n\r\n\r\nCredits:Special thanks to @vinod23 for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/449", "similarQuestions": [""], "topicTags": ["Math"], "Solution": "class Solution {\n    public boolean canMeasureWater(int x, int y, int z) {\n        if (x == 0 || y == 0) return x + y == z || z == 0;\n        int g = GCD(x, y);\n        if (z % g != 0 || z > x + y) return false;\n        return true;\n    }\n    \n    private int GCD(int a, int b) {\n        if (a == b) return a;\n        if (a < b) return GCD(b, a);\n        return GCD(a - b, b);\n    }\n}", "total_acs": 18831, "total_submitted": 67357}, {"id": 366, "title": "Find Leaves of Binary Tree", "url": "https://leetcode.com/problems/find-leaves-of-binary-tree/description", "companyTags": ["LinkedIn"], "difficulty": "Medium", "content": "Given a binary tree, collect a tree's nodes as if you were doing this: Collect and remove all leaves, repeat until the tree is empty.\r\n\r\n\r\n\r\nExample:\r\nGiven binary tree \r\n\r\n          1\r\n         / \\\r\n        2   3\r\n       / \\     \r\n      4   5    \r\n\r\n\r\n\r\nReturns [4, 5, 3], [2], [1].\r\n\r\n\r\n\r\nExplanation:\r\n\r\n1. Removing the leaves [4, 5, 3] would result in this tree:\r\n\r\n          1\r\n         / \r\n        2          \r\n\r\n\r\n\r\n2. Now removing the leaf [2] would result in this tree:\r\n\r\n          1          \r\n\r\n\r\n\r\n3. Now removing the leaf [1] would result in the empty tree:\r\n\r\n          []         \r\n\r\n\r\n\r\n\r\nReturns [4, 5, 3], [2], [1].\r\n\r\n\r\nCredits:Special thanks to @elmirap for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/450", "similarQuestions": [""], "topicTags": ["Tree", "Depth-firstSearch"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<List<Integer>> findLeaves(TreeNode root) {\n        List<List<Integer>> result = new ArrayList<>();\n        helper(root, result);\n        return result;\n    }\n    public int helper(TreeNode root, List<List<Integer>> result) {\n        if (root == null) {\n            return -1;\n        }\n        int height = 1 + Math.max(helper(root.left, result), helper(root.right, result));\n        if (height + 1 > result.size() ) {\n            result.add(new ArrayList<>());\n        }\n        result.get(height).add(root.val);\n        return height;\n    }\n}", "total_acs": 24085, "total_submitted": 39519}, {"id": 367, "title": "Valid Perfect Square", "url": "https://leetcode.com/problems/valid-perfect-square/description", "companyTags": ["LinkedIn"], "difficulty": "Easy", "content": "Given a positive integer num, write a function which returns True if num is a perfect square else False.\r\n\r\n\r\nNote: Do not use any built-in library function such as sqrt.\r\n\r\n\r\nExample 1:\r\n\r\nInput: 16\r\nReturns: True\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: 14\r\nReturns: False\r\n\r\n\r\n\r\nCredits:Special thanks to @elmirap for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/451", "similarQuestions": ["Sqrt(x)", "SumofSquareNumbers"], "topicTags": ["Math", "BinarySearch"], "Solution": "class Solution {\n    public boolean isPerfectSquare(int num) {\n         int i = 1;\n         while (num > 0) {\n             num -= i;\n             i += 2;\n         }\n         return num == 0;\n    }\n}", "total_acs": 65029, "total_submitted": 168434}, {"id": 368, "title": "Largest Divisible Subset", "url": "https://leetcode.com/problems/largest-divisible-subset/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "\r\nGiven a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies: Si % Sj = 0 or Sj % Si = 0.\r\n\r\n\r\nIf there are multiple solutions, return any subset is fine.\r\n\r\n\r\nExample 1:\r\n\r\nnums: [1,2,3]\r\n\r\nResult: [1,2] (of course, [1,3] will also be ok)\r\n\r\n\r\n\r\nExample 2:\r\n\r\nnums: [1,2,4,8]\r\n\r\nResult: [1,2,4,8]\r\n\r\n\r\n\r\nCredits:Special thanks to @Stomach_ache for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/452", "similarQuestions": [""], "topicTags": ["Math", "DynamicProgramming"], "Solution": "class Solution {\n    public List<Integer> largestDivisibleSubset(int[] nums) {\n      int n = nums.length, maxIdx = 0;\n        List<Integer> ans = new LinkedList<>();\n        if (n == 0) return ans;\n        Arrays.sort(nums);\n        int[] lens = new int[n], prevs = new int[n];\n        Arrays.fill(prevs, -1);\n        for (int i = 0; nums[i] <= nums[n-1]/2; ++i) {\n            for (int j = i + 1, f = 2; nums[i] <= nums[n-1]/f; f = (nums[j] + nums[i] - 1)/nums[i]) {\n                int idx = Arrays.binarySearch(nums, j, n, f*nums[i]);\n                if (idx > 0 && lens[idx] <= lens[i]) {\n                    prevs[idx] = i;\n                    lens[idx] = lens[i] + 1;\n                    if (lens[idx] > lens[maxIdx]) maxIdx = idx;\n                }\n                j = idx >= 0 ? idx + 1 : -(idx + 1);\n                if (j >= n) break;\n            }\n        }\n        for (int i = maxIdx; i >= 0; i = prevs[i]) ans.add(0, nums[i]);\n        return ans;\n    }\n}", "total_acs": 31990, "total_submitted": 94496}, {"id": 369, "title": "Plus One Linked List", "url": "https://leetcode.com/problems/plus-one-linked-list/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "Given a non-negative integer represented as non-empty a singly linked list of digits, plus one to the integer.\r\n\r\nYou may assume the integer do not contain any leading zero, except the number 0 itself.\r\n\r\nThe digits are stored such that the most significant digit is at the head of the list.\r\n\r\nExample:\r\n\r\nInput:\r\n1->2->3\r\n\r\nOutput:\r\n1->2->4\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/453", "similarQuestions": ["PlusOne"], "topicTags": ["LinkedList"], "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode plusOne(ListNode head) {\n        if (head == null) {\n            return head;\n        }\n        int res = dfs(head);\n        if (res == 10) {\n            ListNode newHead = new ListNode(1);\n            newHead.next = head;\n            return newHead;\n        }\n        return head;\n    }\n    private int dfs(ListNode head) {\n        if (head.next == null) {\n            head.val++;\n            if (head.val == 10) {\n                head.val = 0;\n                return 10;\n            }\n            return head.val;\n        }\n        \n        int child = dfs(head.next);\n        if(child == 10) {\n            head.val++;\n            if (head.val == 10) {\n                head.val = 0;\n                return 10;\n            }\n            return head.val;\n        }\n        return head.val;\n    }\n    \n}", "total_acs": 20618, "total_submitted": 37462}, {"id": 370, "title": "Range Addition", "url": "https://leetcode.com/problems/range-addition/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "Assume you have an array of length n initialized with all 0's and are given k update operations.\r\n\r\nEach operation is represented as a triplet: [startIndex, endIndex, inc] which increments each element of subarray A[startIndex ... endIndex] (startIndex and endIndex inclusive) with inc.\r\n\r\nReturn the modified array after all k operations were executed.\r\n\r\nExample:\r\n\r\nGiven:\r\n\r\n    length = 5,\r\n    updates = [\r\n        [1,  3,  2],\r\n        [2,  4,  3],\r\n        [0,  2, -2]\r\n    ]\r\n\r\nOutput:\r\n\r\n    [-2, 0, 3, 5, 3]\r\n\r\n\r\n\r\nExplanation:\r\n\r\nInitial state:\r\n[ 0, 0, 0, 0, 0 ]\r\n\r\nAfter applying operation [1, 3, 2]:\r\n[ 0, 2, 2, 2, 0 ]\r\n\r\nAfter applying operation [2, 4, 3]:\r\n[ 0, 2, 5, 5, 3 ]\r\n\r\nAfter applying operation [0, 2, -2]:\r\n[-2, 0, 3, 5, 3 ]\r\n\r\n\r\n\r\nCredits:Special thanks to @vinod23 for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/454", "similarQuestions": ["RangeAdditionII"], "topicTags": ["Array"], "Solution": "class Solution {\n    public int[] getModifiedArray(int length, int[][] updates) {\n        if(length==0) return new int[0];\n        int[] sum=new int[length];\n        for(int[] curr:updates){\n            sum[curr[0]]+=curr[2];\n            if(curr[1]<length-1) sum[curr[1]+1]-=curr[2];\n        }\n        \n        for(int i=1;i<length;i++){\n            sum[i]+=sum[i-1];\n        }\n        return sum;\n    }\n}", "total_acs": 15919, "total_submitted": 27917}, {"id": 371, "title": "Sum of Two Integers", "url": "https://leetcode.com/problems/sum-of-two-integers/description", "companyTags": ["Hulu"], "difficulty": "Easy", "content": "Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.\r\n\r\nExample:\r\nGiven a = 1 and b = 2, return 3.\r\n\r\n\r\nCredits:Special thanks to @fujiaozhu for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/455", "similarQuestions": ["AddTwoNumbers"], "topicTags": ["BitManipulation"], "Solution": "class Solution {\n    public int getSum(int a, int b) {\n        while(b!= 0){\n        if(b < 0){\n            a--;\n            b++;\n        } else {\n            a++;\n            b--;\n         } \n        }return a;\n        \n    }\n}", "total_acs": 90067, "total_submitted": 176451}, {"id": 372, "title": "Super Pow", "url": "https://leetcode.com/problems/super-pow/description", "companyTags": [""], "difficulty": "Medium", "content": "\r\nYour task is to calculate ab mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array.\r\n\r\n\r\nExample1:\r\n\r\na = 2\r\nb = [3]\r\n\r\nResult: 8\r\n\r\n\r\n\r\nExample2:\r\n\r\na = 2\r\nb = [1,0]\r\n\r\nResult: 1024\r\n\r\n\r\n\r\nCredits:Special thanks to @Stomach_ache for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/490", "similarQuestions": ["Pow(x", "n)"], "topicTags": ["Math"], "Solution": "class Solution {\n    public int superPow(int a, int[] b) {\n        if (a % 1337 == 0) return 0;\n    int p = 0;\n    for (int i : b) p = (p * 10 + i) % 1140;\n    if (p == 0) p += 1440;\n    return power(a, p, 1337);\n}\npublic int power(int a, int n, int mod) {\n    a %= mod;\n    int ret = 1;\n    while (n != 0) {\n        if ((n & 1) != 0) ret = ret * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return ret;\n    }\n}", "total_acs": 19755, "total_submitted": 57088}, {"id": 373, "title": "Find K Pairs with Smallest Sums", "url": "https://leetcode.com/problems/find-k-pairs-with-smallest-sums/description", "companyTags": ["Google", "Uber"], "difficulty": "Medium", "content": "\r\nYou are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k. \r\n\r\n\r\nDefine a pair (u,v) which consists of one element from the first array and one element from the second array.\r\n\r\nFind the k pairs (u1,v1),(u2,v2) ...(uk,vk) with the smallest sums.\r\n\r\n\r\nExample 1:\r\n\r\nGiven nums1 = [1,7,11], nums2 = [2,4,6],  k = 3\r\n\r\nReturn: [1,2],[1,4],[1,6]\r\n\r\nThe first 3 pairs are returned from the sequence:\r\n[1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]\r\n\r\n\r\n\r\nExample 2:\r\n\r\nGiven nums1 = [1,1,2], nums2 = [1,2,3],  k = 2\r\n\r\nReturn: [1,1],[1,1]\r\n\r\nThe first 2 pairs are returned from the sequence:\r\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\r\n\r\n\r\n\r\nExample 3:\r\n\r\nGiven nums1 = [1,2], nums2 = [3],  k = 3 \r\n\r\nReturn: [1,3],[2,3]\r\n\r\nAll possible pairs are returned from the sequence:\r\n[1,3],[2,3]\r\n\r\n\r\n\r\nCredits:Special thanks to @elmirap and @StefanPochmann for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/491", "similarQuestions": ["KthSmallestElementinaSortedMatrix", "FindK-thSmallestPairDistance"], "topicTags": ["Heap"], "Solution": "\nimport java.util.*;\n\nclass Solution {\n    \n    public List<int[]> kSmallestPairs(int[] nums1, int[] nums2, int k) {\n        int len1 = nums1.length, len2 = nums2.length, len = len1 * len2;\n        boolean isSwap = false;\n        if(len1 < len2) {\n            int[] tmp = nums1;\n            nums1 = nums2;\n            nums2 = tmp;\n            len1 = nums1.length;\n            len2 = nums2.length;\n            isSwap = true;\n        }\n        if(k >= len) {\n            k = len;\n        }\n        if(k <= 0) {\n            return new ArrayList();\n        }\n        int n1 = (int)Math.sqrt(k - 1) + 1, n2 = (int)Math.sqrt(len - k) + 1;\n        int max = n1 > len2 ? nums1[(k - 1) / len2] + nums2[len2 - 1] : nums1[n1 - 1] + nums2[n1 - 1];\n        int min = n2 > len2 ? nums1[len1 - 1 - (k - 1) / len2] + nums2[0] : nums1[len1 - n2] + nums2[len2 - n2];\n        int lessCnt, ngtCnt, num;\n        for(;;) {\n            num = min + ((max - min) >>> 1);\n            lessCnt = 0;\n            ngtCnt = 0;\n            for(int i = len2 - 1, idx0 = 0, idx1 = 0; i >= 0; i--) {\n                int num2 = nums2[i];\n                for(; idx0 < len1 && nums1[idx0] + num2 < num; idx0++);\n                for(; idx1 < len1 && nums1[idx1] + num2 <= num; idx1++);\n                lessCnt += idx0;\n                ngtCnt += idx1;\n            }\n            if(k < lessCnt) {\n                max = num - 1;\n            } else if(k > ngtCnt) {\n                min = num + 1;\n            } else {\n                break;\n            }\n        }\n        int[][] pairs = new int[k][];\n        int eqCnt = k - lessCnt;\n        for(int i = len2 - 1, j = 0, idx; i >= 0; i--) {\n            int num1, num2 = nums2[i];\n            for(idx = 0; idx < len1 && (num1 = nums1[idx]) + num2 < num; idx++) {\n                pairs[j++] = isSwap ? new int[]{num2, num1} : new int[]{num1, num2};\n            }\n            for(; eqCnt > 0 && idx < len1 && (num1 = nums1[idx]) + num2 <= num; idx++) {\n                pairs[j++] = isSwap ? new int[]{num2, num1} : new int[]{num1, num2};\n                eqCnt--;\n            }\n        }\n        return Arrays.asList(pairs);\n    }\n}", "total_acs": 37378, "total_submitted": 119821}, {"id": 374, "title": "Guess Number Higher or Lower", "url": "https://leetcode.com/problems/guess-number-higher-or-lower/description", "companyTags": ["Google"], "difficulty": "Easy", "content": "We are playing the Guess Game. The game is as follows: \r\n\r\nI pick a number from 1 to n. You have to guess which number I picked.\r\n\r\nEvery time you guess wrong, I'll tell you whether the number is higher or lower.\r\n\r\nYou call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0):\r\n\r\n-1 : My number is lower\r\n 1 : My number is higher\r\n 0 : Congrats! You got it!\r\n\r\n\r\nExample:\r\n\r\nn = 10, I pick 6.\r\n\r\nReturn 6.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/492", "similarQuestions": ["FirstBadVersion", "GuessNumberHigherorLowerII", "FindKClosestElements"], "topicTags": ["BinarySearch"], "Solution": "/* The guess API is defined in the parent class GuessGame.\n   @param num, your guess\n   @return -1 if my number is lower, 1 if my number is higher, otherwise return 0\n      int guess(int num); */\n\npublic class Solution extends GuessGame {\n    public int guessNumber(int n) {\n        int start = 1;\n        int end = n;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (guess(mid) == 0) {\n                return mid;\n            } else if (guess(mid) < 0) {\n                end = mid -1;\n            } else {\n                start = mid +1;\n            }\n        }\n        \n        return -1;\n    }\n}", "total_acs": 66161, "total_submitted": 181911}, {"id": 375, "title": "Guess Number Higher or Lower II", "url": "https://leetcode.com/problems/guess-number-higher-or-lower-ii/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "We are playing the Guess Game. The game is as follows: \r\n\r\nI pick a number from 1 to n. You have to guess which number I picked.\r\n\r\nEvery time you guess wrong, I'll tell you whether the number I picked is higher or lower. \r\n\r\nHowever, when you guess a particular number x,  and you guess wrong, you pay $x. You win the game when you guess the number I picked.\r\n\r\n\r\nExample:\r\n\r\nn = 10, I pick 8.\r\n\r\nFirst round:  You guess 5, I tell you that it's higher. You pay $5.\r\nSecond round: You guess 7, I tell you that it's higher. You pay $7.\r\nThird round:  You guess 9, I tell you that it's lower. You pay $9.\r\n\r\nGame over. 8 is the number I picked.\r\n\r\nYou end up paying $5 + $7 + $9 = $21.\r\n\r\n\r\n\r\nGiven a particular n \u2265 1, find out how much money you need to have to guarantee a win.\r\n\r\nCredits:Special thanks to @agave and @StefanPochmann for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/495", "similarQuestions": ["FlipGameII", "GuessNumberHigherorLower", "CanIWin", "FindKClosestElements"], "topicTags": ["DynamicProgramming", "Minimax"], "Solution": "class Solution {\n    int[][] dp;\n    public int getMoneyAmount(int n) {\n        dp = new int[n + 1][n + 1];\n        return helper(1, n);\n    }\n    \n    private int helper(int start, int end) {\n        if (dp[start][end] != 0) {\n            return dp[start][end];\n        }\n        if (start >= end) {\n            return 0;\n        }\n        if (start >= end - 2) {\n            return dp[start][end] = end - 1;\n        }\n        int mid = (start + end) / 2 - 1, min = Integer.MAX_VALUE;\n        while (mid < end) {\n            int left = helper(start, mid - 1);\n            int right = helper(mid + 1, end);\n            min = Math.min(min, mid + Math.max(left, right));\n            if (right <= left) break;\n            mid++;\n        }\n        return dp[start][end] = min;\n    }\n}", "total_acs": 28441, "total_submitted": 78815}, {"id": 376, "title": "Wiggle Subsequence", "url": "https://leetcode.com/problems/wiggle-subsequence/description", "companyTags": [""], "difficulty": "Medium", "content": "A sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence. \r\n\r\nFor example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero.\r\n\r\nGiven a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order.\r\n\r\nExamples:\r\n\r\nInput: [1,7,4,9,2,5]\r\nOutput: 6\r\nThe entire sequence is a wiggle sequence.\r\n\r\nInput: [1,17,5,10,13,15,10,5,16,8]\r\nOutput: 7\r\nThere are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].\r\n\r\nInput: [1,2,3,4,5,6,7,8,9]\r\nOutput: 2\r\n\r\n\r\n\r\nFollow up:\r\nCan you do it in O(n) time?\r\n\r\n\r\nCredits:Special thanks to @agave and @StefanPochmann for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/496", "similarQuestions": [""], "topicTags": ["DynamicProgramming", "Greedy"], "Solution": "class Solution {\n    public int wiggleMaxLength(int[] nums) {\n       if(nums.length <= 1) return nums.length;\n\n        int [] dp = new int[nums.length];\n        dp[0] = 1;\n        dp[1] = nums[1] != nums[0] ? 2:1;\n        int last_diff = nums[1]-nums[0];\n        int last_var = nums[1];\n        for (int i = 2; i <nums.length ; i++) {\n           int var = nums[i] - last_var;\n             if(var == 0 || last_diff != 0 && var * last_diff >0){\n                dp[i] = dp[i-1];\n                last_var = last_diff >= 0 ?\n                        Math.max(nums[i],last_var) : Math.min(nums[i],last_var);\n            }else{\n                dp[i] = dp[i-1] +1;\n                last_diff = nums[i] - last_var;\n                last_var = nums[i];\n            }\n        }\n        return dp[nums.length-1]; \n    }\n}", "total_acs": 30954, "total_submitted": 85706}, {"id": 377, "title": "Combination Sum IV", "url": "https://leetcode.com/problems/combination-sum-iv/description", "companyTags": ["Google", "Facebook", "Snapchat"], "difficulty": "Medium", "content": " Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.\r\n\r\nExample:\r\n\r\nnums = [1, 2, 3]\r\ntarget = 4\r\n\r\nThe possible combination ways are:\r\n(1, 1, 1, 1)\r\n(1, 1, 2)\r\n(1, 2, 1)\r\n(1, 3)\r\n(2, 1, 1)\r\n(2, 2)\r\n(3, 1)\r\n\r\nNote that different sequences are counted as different combinations.\r\n\r\nTherefore the output is 7.\r\n\r\n\r\n\r\nFollow up:\r\nWhat if negative numbers are allowed in the given array?\r\nHow does it change the problem?\r\nWhat limitation we need to add to the question to allow negative numbers? \r\n\r\nCredits:Special thanks to @pbrother for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/497", "similarQuestions": ["CombinationSum"], "topicTags": ["DynamicProgramming"], "Solution": "class Solution {\n    public int combinationSum4(int[] nums, int target) {\n        int[] rt=new int[target+1];\n        int i;\n        for (i=0;i<=target;i++) rt[i]=-1;\n        return (cs4(nums,target,rt));  \n    }    \n    public int cs4(int[] nums, int target, int[] rt) {    \n     \n    if (target<=0) return(0);\n    if (nums.length==0) return(0);    \n    if (rt[target]>=0) return (rt[target]);\n        \n    int i,r=0;\n    \n    \n    \n    \n    for (i=0;i<nums.length; i++)\n     {\n      if (target-nums[i]==0)\n        r++;\n      else  \n        r=r+cs4(nums, target-nums[i], rt);\n     }   \n    rt[target]=r;    \n    return(r);\n   }\n}", "total_acs": 54022, "total_submitted": 126594}, {"id": 378, "title": "Kth Smallest Element in a Sorted Matrix", "url": "https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description", "companyTags": ["Google", "Twitter"], "difficulty": "Medium", "content": "Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.\r\n\r\n\r\nNote that it is the kth smallest element in the sorted order, not the kth distinct element.\r\n\r\n\r\nExample:\r\n\r\nmatrix = [\r\n   [ 1,  5,  9],\r\n   [10, 11, 13],\r\n   [12, 13, 15]\r\n],\r\nk = 8,\r\n\r\nreturn 13.\r\n\r\n\r\n\r\nNote: \r\nYou may assume k is always valid, 1 \u2264 k \u2264 n2.", "discussUrl": "https://discuss.leetcode.com/category/498", "similarQuestions": ["FindKPairswithSmallestSums", "KthSmallestNumberinMultiplicationTable", "FindK-thSmallestPairDistance"], "topicTags": ["BinarySearch", "Heap"], "Solution": "public class Solution {    \n    public int kthSmallest(int[][] matrix, int k) {\n        int lo = matrix[0][0];\n        int hi = matrix[matrix.length - 1][matrix[0].length - 1];\n        while(lo < hi){\n            int mid = lo + (hi - lo) / 2;\n            int count = 0;\n            int j = matrix[0].length - 1;\n            for(int i = 0; i < matrix.length; i++){\n                while(j >= 0 && matrix[i][j] > mid){\n                    j--;\n                }\n                count += j + 1;\n            }\n            if(count < k){\n                lo = mid + 1;\n            }else{\n                hi = mid;\n            }\n        }\n        return lo;\n    }\n}", "total_acs": 53971, "total_submitted": 118929}, {"id": 379, "title": "Design Phone Directory", "url": "https://leetcode.com/problems/design-phone-directory/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "Design a Phone Directory which supports the following operations:\r\n\r\n\r\n\r\nget: Provide a number which is not assigned to anyone.\r\ncheck: Check if a number is available or not.\r\nrelease: Recycle or release a number.\r\n\r\n\r\n\r\nExample:\r\n\r\n// Init a phone directory containing a total of 3 numbers: 0, 1, and 2.\r\nPhoneDirectory directory = new PhoneDirectory(3);\r\n\r\n// It can return any available phone number. Here we assume it returns 0.\r\ndirectory.get();\r\n\r\n// Assume it returns 1.\r\ndirectory.get();\r\n\r\n// The number 2 is available, so return true.\r\ndirectory.check(2);\r\n\r\n// It returns 2, the only number that is left.\r\ndirectory.get();\r\n\r\n// The number 2 is no longer available, so return false.\r\ndirectory.check(2);\r\n\r\n// Release number 2 back to the pool.\r\ndirectory.release(2);\r\n\r\n// Number 2 is available again, return true.\r\ndirectory.check(2);\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/499", "similarQuestions": [""], "topicTags": ["LinkedList", "Design"], "Solution": "class PhoneDirectory {\n    BitSet bs;\n    int max;\n    int smallestFreeIndex;\n    /** Initialize your data structure here\n        @param maxNumbers - The maximum numbers that can be stored in the phone directory. */\n    public PhoneDirectory(int maxNumbers) {\n        max = maxNumbers;\n        bs = new BitSet(max);\n        smallestFreeIndex = 0;\n    }\n    \n    /** Provide a number which is not assigned to anyone.\n        @return - Return an available number. Return -1 if none is available. */\n    public int get() {\n        if(smallestFreeIndex == max){\n            return -1;\n        }\n        int tmp = smallestFreeIndex;\n        bs.set(smallestFreeIndex);\n        smallestFreeIndex = bs.nextClearBit(smallestFreeIndex);\n        return tmp;\n    }\n    \n    /** Check if a number is available or not. */\n    public boolean check(int number) {\n        return bs.get(number) == false;\n    }\n    \n    /** Recycle or release a number. */\n    public void release(int number) {\n        if(bs.get(number) == false){\n            return ;\n        }\n        bs.clear(number);\n        if(number < smallestFreeIndex){\n            smallestFreeIndex = number;\n        }\n    }\n}\n\n/**\n * Your PhoneDirectory object will be instantiated and called as such:\n * PhoneDirectory obj = new PhoneDirectory(maxNumbers);\n * int param_1 = obj.get();\n * boolean param_2 = obj.check(number);\n * obj.release(number);\n */", "total_acs": 13738, "total_submitted": 38862}, {"id": 380, "title": "Insert Delete GetRandom O(1)", "url": "https://leetcode.com/problems/insert-delete-getrandom-o1/description", "companyTags": ["Google", "Facebook", "Amazon", "Uber", "Twitter", "Yelp", "PocketGems"], "difficulty": "Medium", "content": "Design a data structure that supports all following operations in average O(1) time.\r\n\r\n\r\n\r\ninsert(val): Inserts an item val to the set if not already present.\r\nremove(val): Removes an item val from the set if present.\r\ngetRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned.\r\n\r\n\r\n\r\nExample:\r\n\r\n// Init an empty set.\r\nRandomizedSet randomSet = new RandomizedSet();\r\n\r\n// Inserts 1 to the set. Returns true as 1 was inserted successfully.\r\nrandomSet.insert(1);\r\n\r\n// Returns false as 2 does not exist in the set.\r\nrandomSet.remove(2);\r\n\r\n// Inserts 2 to the set, returns true. Set now contains [1,2].\r\nrandomSet.insert(2);\r\n\r\n// getRandom should return either 1 or 2 randomly.\r\nrandomSet.getRandom();\r\n\r\n// Removes 1 from the set, returns true. Set now contains [2].\r\nrandomSet.remove(1);\r\n\r\n// 2 was already in the set, so return false.\r\nrandomSet.insert(2);\r\n\r\n// Since 2 is the only number in the set, getRandom always return 2.\r\nrandomSet.getRandom();\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/500", "similarQuestions": ["InsertDeleteGetRandomO(1)-Duplicatesallowed"], "topicTags": ["Array", "HashTable", "Design"], "Solution": "class RandomizedSet {\n\n    /** Initialize your data structure here. */\n    //Using array to save the number of it\n    HashMap<Integer,Integer> map;\n    ArrayList<Integer> list;\n    java.util.Random rand = new java.util.Random();\n    public RandomizedSet() {\n        map = new HashMap<>();\n        list = new ArrayList<Integer>();\n    }\n    \n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\n    public boolean insert(int val) {\n        if(map.containsKey(val))\n            return false;\n        int size = list.size();\n        map.put(val, size);\n        list.add(val);\n        return true;        \n    }\n    \n    /** Removes a value from the set. Returns true if the set contained the specified element. */\n    public boolean remove(int val) {\n        if(!map.containsKey(val))\n            return false;\n        int index = map.get(val);\n        int size = list.size();\n        if(index < size - 1){\n            int temVal = list.get(size - 1);\n            list.set(index, temVal);\n            map.put(temVal,index);\n        }\n        map.remove(val);\n        list.remove(size - 1);\n        \n        return true;\n        \n    }\n    \n    /** Get a random element from the set. */\n    public int getRandom() {\n        return list.get(rand.nextInt(list.size()));\n    }\n}\n\n/**\n * Your RandomizedSet object will be instantiated and called as such:\n * RandomizedSet obj = new RandomizedSet();\n * boolean param_1 = obj.insert(val);\n * boolean param_2 = obj.remove(val);\n * int param_3 = obj.getRandom();\n */", "total_acs": 53144, "total_submitted": 133557}, {"id": 381, "title": "Insert Delete GetRandom O(1) - Duplicates allowed", "url": "https://leetcode.com/problems/insert-delete-getrandom-o1-duplicates-allowed/description", "companyTags": ["Yelp"], "difficulty": "Hard", "content": "Design a data structure that supports all following operations in average O(1) time.\r\nNote: Duplicate elements are allowed.\r\n\r\n\r\ninsert(val): Inserts an item val to the collection.\r\nremove(val): Removes an item val from the collection if present.\r\ngetRandom: Returns a random element from current collection of elements. The probability of each element being returned is linearly related to the number of same value the collection contains.\r\n\r\n\r\n\r\nExample:\r\n\r\n// Init an empty collection.\r\nRandomizedCollection collection = new RandomizedCollection();\r\n\r\n// Inserts 1 to the collection. Returns true as the collection did not contain 1.\r\ncollection.insert(1);\r\n\r\n// Inserts another 1 to the collection. Returns false as the collection contained 1. Collection now contains [1,1].\r\ncollection.insert(1);\r\n\r\n// Inserts 2 to the collection, returns true. Collection now contains [1,1,2].\r\ncollection.insert(2);\r\n\r\n// getRandom should return 1 with the probability 2/3, and returns 2 with the probability 1/3.\r\ncollection.getRandom();\r\n\r\n// Removes 1 from the collection, returns true. Collection now contains [1,2].\r\ncollection.remove(1);\r\n\r\n// getRandom should return 1 and 2 both equally likely.\r\ncollection.getRandom();\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/501", "similarQuestions": ["InsertDeleteGetRandomO(1)"], "topicTags": ["Array", "HashTable", "Design"], "Solution": "class RandomizedCollection {\n\n    /** Initialize your data structure here. */\n    public RandomizedCollection() {\n        map = new HashMap();\n        pairs = new ArrayList<int[]>();\n        rdn = new Random();\n    }\n    \n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\n    public boolean insert(int val) {\n        boolean contain = map.containsKey(val);\n        int size = pairs.size();\n        if (contain) {\n            pairs.add(new int[]{val, size});\n            map.get(val).add(size);\n            return false;\n        }\n        pairs.add(new int[]{val, size});\n        map.put(val, new ArrayList<Integer>());\n        map.get(val).add(size);\n        return true;\n    }\n    \n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\n    public boolean remove(int val) {\n        // System.out.println(map);\n        // for (int[] pair : pairs)\n        //      System.out.println(Arrays.toString(pair));\n        if (!map.containsKey(val)) {\n            return false;\n        }\n        List<Integer> valIndexList = map.get(val);\n        int[] lastPair = pairs.get(pairs.size() - 1);\n        // Case 1: No need for switch\n        if (lastPair[0] == val) {\n            pairs.remove(pairs.size() - 1);\n            valIndexList.remove(valIndexList.size() - 1);\n            if (valIndexList.size() == 0) {\n                map.remove(val);\n            }\n            return true;\n        }\n        // Case 2: switch and delete\n        List<Integer> switchIndexList = map.get(lastPair[0]);\n        int valLastIndex = valIndexList.get(valIndexList.size() - 1);\n        int switchLastIndex = switchIndexList.get(switchIndexList.size() - 1);\n        switchIndexList.set(switchIndexList.size() - 1, valLastIndex);\n        Collections.sort(switchIndexList);\n        valIndexList.remove(valIndexList.size() - 1);\n        pairs.get(valLastIndex)[0] = lastPair[0];\n        if (valIndexList.size() == 0) {\n            map.remove(val);\n        }\n        pairs.remove(pairs.size() - 1);\n        return true;\n    }\n    \n    /** Get a random element from the collection. */\n    public int getRandom() {\n        int next = rdn.nextInt() % pairs.size();\n        if (next < 0) {\n            next += pairs.size();\n        }\n        return pairs.get(next)[0];\n    }\n    Random rdn;\n    List<int[]> pairs;\n    Map<Integer, List<Integer>> map;\n}\n\n/**\n * Your RandomizedCollection object will be instantiated and called as such:\n * RandomizedCollection obj = new RandomizedCollection();\n * boolean param_1 = obj.insert(val);\n * boolean param_2 = obj.remove(val);\n * int param_3 = obj.getRandom();\n */", "total_acs": 22584, "total_submitted": 76606}, {"id": 382, "title": "Linked List Random Node", "url": "https://leetcode.com/problems/linked-list-random-node/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "Given a singly linked list, return a random node's value from the linked list. Each node must have the same probability of being chosen.\r\n\r\nFollow up:\r\nWhat if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space?\r\n\r\n\r\nExample:\r\n\r\n// Init a singly linked list [1,2,3].\r\nListNode head = new ListNode(1);\r\nhead.next = new ListNode(2);\r\nhead.next.next = new ListNode(3);\r\nSolution solution = new Solution(head);\r\n\r\n// getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning.\r\nsolution.getRandom();\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/502", "similarQuestions": ["RandomPickIndex"], "topicTags": ["ReservoirSampling"], "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    \n    ListNode head;\n    Random random;\n    /** @param head The linked list's head.\n        Note that the head is guaranteed to be not null, so it contains at least one node. */\n    \n    public Solution(ListNode head) { \n        this.head = head;\n        random = new Random();\n    }\n    \n    /** Returns a random node's value. */\n    public int getRandom() {\n        ListNode c = head;\n        int r = c.val;\n        for( int i = 1 ; c.next != null ; i++ ){\n            c = c.next;\n            if( random.nextInt(i + 1) == i ) r = c.val;\n        }\n        return r;\n    }\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution obj = new Solution(head);\n * int param_1 = obj.getRandom();\n */", "total_acs": 35573, "total_submitted": 75003}, {"id": 383, "title": "Ransom Note", "url": "https://leetcode.com/problems/ransom-note/description", "companyTags": ["Apple"], "difficulty": "Easy", "content": "\r\nGiven an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom \r\nnote can be constructed from the magazines ; otherwise, it will return false. \r\n\r\n\r\nEach letter in the magazine string can only be used once in your ransom note.\r\n\r\n\r\nNote:\r\nYou may assume that both strings contain only lowercase letters.\r\n\r\n\r\n\r\ncanConstruct(\"a\", \"b\") -> false\r\ncanConstruct(\"aa\", \"ab\") -> false\r\ncanConstruct(\"aa\", \"aab\") -> true\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/503", "similarQuestions": ["StickerstoSpellWord"], "topicTags": ["String"], "Solution": "class Solution {\n public boolean canConstruct(String ransomNote, String magazine) {\n    int[] table = new int[26];\n    for (char c : magazine.toCharArray())   table[c - 'a']++;\n    for (char c : ransomNote.toCharArray())\n        if (--table[c - 'a'] < 0) return false;\n    return true;\n}\n}", "total_acs": 73290, "total_submitted": 153747}, {"id": 384, "title": "Shuffle an Array", "url": "https://leetcode.com/problems/shuffle-an-array/description", "companyTags": [""], "difficulty": "Medium", "content": "Shuffle a set of numbers without duplicates.\r\n\r\n\r\nExample:\r\n\r\n// Init an array with set 1, 2, and 3.\r\nint[] nums = {1,2,3};\r\nSolution solution = new Solution(nums);\r\n\r\n// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.\r\nsolution.shuffle();\r\n\r\n// Resets the array back to its original configuration [1,2,3].\r\nsolution.reset();\r\n\r\n// Returns the random shuffling of array [1,2,3].\r\nsolution.shuffle();\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/504", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 37740, "total_submitted": 79686}, {"id": 385, "title": "Mini Parser", "url": "https://leetcode.com/problems/mini-parser/description", "companyTags": ["Airbnb"], "difficulty": "Medium", "content": "Given a nested list of integers represented as a string, implement a parser to deserialize it.\r\n\r\nEach element is either an integer, or a list -- whose elements may also be integers or other lists.\r\n\r\nNote:\r\nYou may assume that the string is well-formed:\r\n\r\nString is non-empty.\r\nString does not contain white spaces.\r\nString contains only digits 0-9, [, - ,, ].\r\n\r\n\r\n\r\nExample 1:\r\n\r\nGiven s = \"324\",\r\n\r\nYou should return a NestedInteger object which contains a single integer 324.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nGiven s = \"[123,[456,[789]]]\",\r\n\r\nReturn a NestedInteger object containing a nested list with 2 elements:\r\n\r\n1. An integer containing value 123.\r\n2. A nested list containing two elements:\r\n    i.  An integer containing value 456.\r\n    ii. A nested list with one element:\r\n         a. An integer containing value 789.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/505", "similarQuestions": ["FlattenNestedListIterator", "TernaryExpressionParser", "RemoveComments"], "topicTags": ["String", "Stack"], "Solution": "/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * public interface NestedInteger {\n *     // Constructor initializes an empty nested list.\n *     public NestedInteger();\n *\n *     // Constructor initializes a single integer.\n *     public NestedInteger(int value);\n *\n *     // @return true if this NestedInteger holds a single integer, rather than a nested list.\n *     public boolean isInteger();\n *\n *     // @return the single integer that this NestedInteger holds, if it holds a single integer\n *     // Return null if this NestedInteger holds a nested list\n *     public Integer getInteger();\n *\n *     // Set this NestedInteger to hold a single integer.\n *     public void setInteger(int value);\n *\n *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.\n *     public void add(NestedInteger ni);\n *\n *     // @return the nested list that this NestedInteger holds, if it holds a nested list\n *     // Return null if this NestedInteger holds a single integer\n *     public List<NestedInteger> getList();\n * }\n */\nclass Solution {\n\n    public NestedInteger deserialize(String s) {\n        NestedInteger parent = new NestedInteger();\n        deserialize(s.toCharArray(), 0, parent);\n        return parent.getList().get(0);\n    }\n\n    private int deserialize(char[] cs, int i, NestedInteger parent) {\n        char c = cs[i++];\n        NestedInteger ni;\n        if (c == '[') {\n            ni = new NestedInteger();\n            if(cs[i] == ']') {\n                i++;\n            } else {\n                do {\n                    i = deserialize(cs, i, ni);\n                } while(cs[i++] != ']');\n            }\n        } else {\n            boolean isNeg = false;\n            if (c == '-') {\n                isNeg = true;\n                c = cs[i++];\n            }\n            int num = c - '0';\n            for (; i < cs.length && (c = cs[i]) >= '0' && c <= '9'; i++) {\n                num = num * 10 + c - '0';\n            }\n            ni = new NestedInteger(isNeg ? -num : num);\n        }\n        parent.add(ni);\n        return i;\n    }\n}", "total_acs": 20654, "total_submitted": 66820}, {"id": 386, "title": "Lexicographical Numbers", "url": "https://leetcode.com/problems/lexicographical-numbers/description", "companyTags": ["Bloomberg"], "difficulty": "Medium", "content": "\r\nGiven an integer n, return 1 - n in lexicographical order.\r\n\r\n\r\n\r\nFor example, given 13, return: [1,10,11,12,13,2,3,4,5,6,7,8,9].\r\n\r\n\r\n\r\nPlease optimize your algorithm to use less time and space. The input size may be as large as 5,000,000.\r\n", "discussUrl": "https://discuss.leetcode.com/category/508", "similarQuestions": [""], "topicTags": [""], "Solution": "class Solution {\n    public List<Integer> lexicalOrder(int n) {\n        Integer[] res = new Integer[n];\n        int cur = 1;\n        for(int i = 0; i < n; i++) {\n            res[i] = cur;\n            if(cur * 10 <= n) {\n                cur *= 10;\n            } else {\n                if(cur >= n) cur /= 10;\n                cur++;\n                while(cur%10 == 0) {\n                    cur /= 10;\n                }\n            }\n        }\n        return Arrays.asList(res);\n    }\n}", "total_acs": 26579, "total_submitted": 63111}, {"id": 387, "title": "First Unique Character in a String", "url": "https://leetcode.com/problems/first-unique-character-in-a-string/description", "companyTags": ["Google", "Microsoft", "Amazon", "Bloomberg"], "difficulty": "Easy", "content": "\r\nGiven a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.\r\n\r\nExamples:\r\n\r\ns = \"leetcode\"\r\nreturn 0.\r\n\r\ns = \"loveleetcode\",\r\nreturn 2.\r\n\r\n\r\n\r\n\r\nNote: You may assume the string contain only lowercase letters.\r\n", "discussUrl": "https://discuss.leetcode.com/category/509", "similarQuestions": ["SortCharactersByFrequency"], "topicTags": ["HashTable", "String"], "Solution": "class Solution {\n    public int firstUniqChar(String s) {\n        int out=s.length();\n        for(char c='a';c<='z';c++){\n            int st=s.indexOf(c);\n            if(st==-1) continue;\n            if(st==s.lastIndexOf(c)){\n                out=Math.min(out, st);\n            }\n        }\n        \n        return out==s.length()?-1:out;\n        \n    }\n}", "total_acs": 102499, "total_submitted": 216914}, {"id": 388, "title": "Longest Absolute File Path", "url": "https://leetcode.com/problems/longest-absolute-file-path/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "Suppose we abstract our file system by a string in the following manner:\r\n\r\nThe string \"dir\\n\\tsubdir1\\n\\tsubdir2\\n\\t\\tfile.ext\" represents:\r\n\r\ndir\r\n    subdir1\r\n    subdir2\r\n        file.ext\r\n\r\n\r\nThe directory dir contains an empty sub-directory subdir1 and a sub-directory subdir2 containing a file file.ext.\r\n\r\nThe string \"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\" represents:\r\n\r\ndir\r\n    subdir1\r\n        file1.ext\r\n        subsubdir1\r\n    subdir2\r\n        subsubdir2\r\n            file2.ext\r\n\r\n\r\nThe directory dir contains two sub-directories subdir1 and subdir2. subdir1 contains a file file1.ext and an empty second-level sub-directory subsubdir1. subdir2 contains a second-level sub-directory subsubdir2 containing a file file2.ext.\r\n\r\nWe are interested in finding the longest (number of characters) absolute path to a file within our file system. For example, in the second example above, the longest absolute path is \"dir/subdir2/subsubdir2/file2.ext\", and its length is 32 (not including the double quotes).\r\n\r\nGiven a string representing the file system in the above format, return the length of the longest absolute path to file in the abstracted file system. If there is no file in the system, return 0.\r\n\r\nNote:\r\n\r\nThe name of a file contains at least a . and an extension.\r\nThe name of a directory or sub-directory will not contain a ..\r\n\r\n\r\n\r\nTime complexity required: O(n) where n is the size of the input string.\r\n\r\nNotice that a/aa/aaa/file1.txt is not the longest file path, if there is another path aaaaaaaaaaaaaaaaaaaaa/sth.png.", "discussUrl": "https://discuss.leetcode.com/category/510", "similarQuestions": [""], "topicTags": [""], "Solution": "public class Solution {\n    public int lengthLongestPath(String input) {\n        String[] inputs = input.split(\"\\n\");\n        int[] prevLength = new int[inputs.length];\n        int max = 0;\n        for (int i = 0; i < inputs.length; i++){\n            int lstIdx = inputs[i].lastIndexOf('\\t');\n            int len = inputs[i].length() - lstIdx -1;\n            int totallen; \n            if (lstIdx == -1){\n               totallen = len; \n            }else{\n                totallen = len + prevLength[lstIdx] +1;\n            } \n            if (totallen > max && inputs[i].indexOf('.') != -1){\n                max = totallen;\n            }\n            prevLength[lstIdx+1] = totallen;\n        }\n        return max;\n    }\n}", "total_acs": 42525, "total_submitted": 114308}, {"id": 389, "title": "Find the Difference", "url": "https://leetcode.com/problems/find-the-difference/description", "companyTags": ["Google"], "difficulty": "Easy", "content": "\r\nGiven two strings s and t which consist of only lowercase letters.\r\n\r\nString t is generated by random shuffling string s and then add one more letter at a random position.\r\n\r\nFind the letter that was added in t.\r\n\r\nExample:\r\n\r\nInput:\r\ns = \"abcd\"\r\nt = \"abcde\"\r\n\r\nOutput:\r\ne\r\n\r\nExplanation:\r\n'e' is the letter that was added.\r\n", "discussUrl": "https://discuss.leetcode.com/category/511", "similarQuestions": ["SingleNumber"], "topicTags": ["HashTable", "BitManipulation"], "Solution": "class Solution {\n    public char findTheDifference(String s, String t) {\n        char[] a = s.toCharArray();\n        char[] b = t.toCharArray();\n        char result = 0;\n        int len = a.length;\n        for(int i = 0;i<len;i++)\n        {\n            result = (char)(result^a[i]^b[i]);\n        }\n        return (char)(result^b[len]);\n    }\n}", "total_acs": 95659, "total_submitted": 186929}, {"id": 390, "title": "Elimination Game", "url": "https://leetcode.com/problems/elimination-game/description", "companyTags": [""], "difficulty": "Medium", "content": "\r\nThere is a list of sorted integers from 1 to n. Starting from left to right, remove the first number and every other number afterward until you reach the end of the list.\r\n\r\nRepeat the previous step again, but this time from right to left, remove the right most number and every other number from the remaining numbers.\r\n\r\nWe keep repeating the steps again, alternating left to right and right to left, until a single number remains.\r\n\r\nFind the last number that remains starting with a list of length n.\r\n\r\nExample:\r\n\r\nInput:\r\nn = 9,\r\n1 2 3 4 5 6 7 8 9\r\n2 4 6 8\r\n2 6\r\n6\r\n\r\nOutput:\r\n6\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/512", "similarQuestions": [""], "topicTags": [""], "Solution": "class Solution {\n    public int lastRemaining(int n) {\n        return n == 1 ? 1 : 2*( 1 + n/2 - lastRemaining(n/2));\n    }\n}", "total_acs": 15415, "total_submitted": 36249}, {"id": 391, "title": "Perfect Rectangle", "url": "https://leetcode.com/problems/perfect-rectangle/description", "companyTags": ["Google"], "difficulty": "Hard", "content": "\r\nGiven N axis-aligned rectangles where N > 0, determine if they all together form an exact cover of a rectangular region.\r\n\r\n\r\n\r\nEach rectangle is represented as a bottom-left point and a top-right point. For example, a unit square is represented as [1,1,2,2]. (coordinate of bottom-left point is (1, 1) and top-right point is (2, 2)).\r\n\r\n\r\n\r\nExample 1:\r\n\r\nrectangles = [\r\n  [1,1,3,3],\r\n  [3,1,4,2],\r\n  [3,2,4,4],\r\n  [1,3,2,4],\r\n  [2,3,3,4]\r\n]\r\n\r\nReturn true. All 5 rectangles together form an exact cover of a rectangular region.\r\n\r\n\r\n\r\n\r\n\r\n\r\nExample 2:\r\n\r\nrectangles = [\r\n  [1,1,2,3],\r\n  [1,3,2,4],\r\n  [3,1,4,2],\r\n  [3,2,4,4]\r\n]\r\n\r\nReturn false. Because there is a gap between the two rectangular regions.\r\n\r\n\r\n\r\n\r\n\r\n\r\nExample 3:\r\n\r\nrectangles = [\r\n  [1,1,3,3],\r\n  [3,1,4,2],\r\n  [1,3,2,4],\r\n  [3,2,4,4]\r\n]\r\n\r\nReturn false. Because there is a gap in the top center.\r\n\r\n\r\n\r\n\r\n\r\n\r\nExample 4:\r\n\r\nrectangles = [\r\n  [1,1,3,3],\r\n  [3,1,4,2],\r\n  [1,3,2,4],\r\n  [2,2,4,4]\r\n]\r\n\r\nReturn false. Because two of the rectangles overlap with each other.\r\n\r\n\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/513", "similarQuestions": [""], "topicTags": [""], "Solution": "class Solution {\n    static class Rectangle implements Comparable<Rectangle> {\n\n    int bottom;\n\n    int left;\n\n    int top;\n\n    int right;\n\n    @Override\n    public int compareTo(Rectangle other) {\n      final int first = Integer.compare(left, other.left);\n      return 0 == first ? Integer.compare(bottom, other.bottom) : first;\n    }\n  }\n\n  /**\n   * this solution is O(nlogn) based on the idea of merging. first, all the rectangles are sorted by left and bottom in\n   * ascending order. then the first rectangle is taken out and it forms a column. if the next rectangle has the same\n   * left, then it is in the same column as the first rectangle; if the next rectangle has a larger left, then it is in\n   * the next column. the first column establishes the top of the bounding rectangle. within a column, the first\n   * rectangle in this column determines the bottom left right. later rectangles are merged onto the first rectangle if\n   * the rectangles are in the same column. if the rectangle is wider or narrower, the corresponding rectangles are cut\n   * and put back for later use, maintaining the ascending order (thus a priority queue is used).\n   */\n  public boolean isRectangleCover(int[][] arrays) {\n    final List<Rectangle> list = new ArrayList<>(arrays.length);\n    for(int[] coordinates : arrays) {\n      Rectangle rectangle = new Rectangle();\n      rectangle.bottom = coordinates[0];\n      rectangle.left = coordinates[1];\n      rectangle.top = coordinates[2];\n      rectangle.right = coordinates[3];\n      list.add(rectangle);\n    }\n    final Queue<Rectangle> rectangles = new PriorityQueue<>(list);\n    Rectangle rectangle = rectangles.poll();\n    int bottom = rectangle.bottom;\n    int left = rectangle.left;\n    int top = rectangle.top;\n    int right = rectangle.right;\n    int maxTop = top;\n    boolean first = true; // first column or not.\n    while((rectangle = rectangles.poll()) != null) {\n      if(rectangle.left == left) { // same column.\n        if(rectangle.bottom != top) {\n          return false;\n        }\n        top = rectangle.top;\n        if(first) {\n          maxTop = top;\n        } else if(top > maxTop) {\n          return false;\n        }\n        if(rectangle.right > right) {\n          // cut the new rectangle and put back.\n          rectangle.left = right;\n          rectangles.add(rectangle);\n        } else if(rectangle.right < right) {\n          // cut the existing rectangle and put back.\n          int oldRight = right;\n          right = rectangle.right;\n          rectangle.top = rectangle.bottom;\n          rectangle.right = oldRight;\n          rectangle.bottom = bottom;\n          rectangle.left = right;\n          rectangles.add(rectangle);\n        }\n        \n      } else if(rectangle.left > left) { // next column\n        if(top != maxTop || rectangle.bottom != bottom || rectangle.left != right) {\n          return false;\n        }\n        left = right;\n        top = rectangle.top;\n        right = rectangle.right;\n        first = false;\n      }\n    }\n    return top == maxTop;\n  }\n}", "total_acs": 13146, "total_submitted": 48109}, {"id": 392, "title": "Is Subsequence", "url": "https://leetcode.com/problems/is-subsequence/description", "companyTags": ["Pinterest"], "difficulty": "Medium", "content": "\r\nGiven a string s and a string t, check if s is subsequence of t.\r\n\r\n\r\n\r\nYou may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (<=100).\r\n\r\n\r\n\r\nA subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, \"ace\" is a subsequence of \"abcde\" while \"aec\" is not).\r\n\r\n\r\nExample 1:\r\ns = \"abc\", t = \"ahbgdc\"\r\n\r\n\r\nReturn true.\r\n\r\n\r\nExample 2:\r\ns = \"axc\", t = \"ahbgdc\"\r\n\r\n\r\nReturn false.\r\n\r\n\r\nFollow up:\r\nIf there are lots of incoming S, say S1, S2, ... , Sk where k >= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code?\r\n\r\nCredits:Special thanks to @pbrother for adding this problem and creating all test cases.", "discussUrl": "https://discuss.leetcode.com/category/515", "similarQuestions": [""], "topicTags": ["BinarySearch", "DynamicProgramming", "Greedy"], "Solution": "class Solution {\n    public boolean isSubsequence(String s, String t) {\n        if (s == null || t == null) return false;\n        if (s.length() > t.length()) return false;\n\n        int startIdx = 0;\n        for (int i = 0; i < s.length(); i++) {\n            startIdx = t.indexOf(s.charAt(i), startIdx) + 1;\n            if (startIdx == 0) return false;\n        }\n        \n        return true;\n    }\n    public boolean isSubsequence1(String s, String t) {\n        if (s == null || t == null) return false;\n        if (s.length() > t.length()) return false;\n        if (s.equals(\"\")) return true;\n        HashMap<Character, TreeSet<Integer>> map = new HashMap<>();\n        for (int i = 0; i < t.length(); i++) {\n            char ch = t.charAt(i);\n            TreeSet<Integer> list = map.getOrDefault(ch, new TreeSet<Integer>());\n            list.add(i);\n            map.put(ch, list);\n        }\n        Integer pre = -1;\n        for (int i = 0; i < s.length(); i++) {\n            char ch = s.charAt(i);\n            if (!map.containsKey(ch)) return false;\n            Integer temp = pre;\n            pre = map.get(ch).ceiling(pre);\n            if (pre != null && pre.equals(temp)) {\n                pre = map.get(ch).ceiling(pre + 1);\n            }\n            \n            if (pre == null || pre.intValue() <= temp.intValue()) {\n                return false;\n            }\n        }\n        return pre != -1;\n    }\n}", "total_acs": 47117, "total_submitted": 105548}, {"id": 393, "title": "UTF-8 Validation", "url": "https://leetcode.com/problems/utf-8-validation/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules:\r\n\r\nFor 1-byte character, the first bit is a 0, followed by its unicode code.\r\nFor n-bytes character, the first n-bits are all one's, the n+1 bit is 0, followed by n-1 bytes with most significant 2 bits being 10.\r\n\r\nThis is how the UTF-8 encoding would work:\r\n\r\n   Char. number range  |        UTF-8 octet sequence\r\n      (hexadecimal)    |              (binary)\r\n   --------------------+---------------------------------------------\r\n   0000 0000-0000 007F | 0xxxxxxx\r\n   0000 0080-0000 07FF | 110xxxxx 10xxxxxx\r\n   0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx\r\n   0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\r\n\r\n\r\nGiven an array of integers representing the data, return whether it is a valid utf-8 encoding.\r\n\r\n\r\nNote:\r\nThe input is an array of integers. Only the least significant 8 bits of each integer is used to store the data. This means each integer represents only 1 byte of data.\r\n\r\n\r\n\r\nExample 1:\r\n\r\ndata = [197, 130, 1], which represents the octet sequence: 11000101 10000010 00000001.\r\n\r\nReturn true.\r\nIt is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character.\r\n\r\n\r\n\r\n\r\nExample 2:\r\n\r\ndata = [235, 140, 4], which represented the octet sequence: 11101011 10001100 00000100.\r\n\r\nReturn false.\r\nThe first 3 bits are all one's and the 4th bit is 0 means it is a 3-bytes character.\r\nThe next byte is a continuation byte which starts with 10 and that's correct.\r\nBut the second continuation byte does not start with 10, so it is invalid.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/516", "similarQuestions": [""], "topicTags": ["BitManipulation"], "Solution": "class Solution {\n    public boolean validUtf8(int[] data) {\n        if(data == null || data.length == 0) return true;\n        for(int i = 0; i < data.length; i++) {\n            if((data[i] & 0x80) == 0) continue;\n            else if((data[i] & 0xE0) == 0xC0 && i < data.length - 1) {\n                if((data[++i] & 0xC0) == 0x80) {\n                    continue;\n                } else {\n                    return false;\n                }\n            } else if((data[i] & 0xF0) == 0xE0 && i < data.length - 2) {\n                if((data[++i] & 0xC0) == 0x80 && (data[++i] & 0xC0) == 0x80) {\n                    continue;\n                } else {\n                    return false;\n                }\n            } else if((data[i] & 0xF8) == 0xF0 && i < data.length - 3) {\n                if((data[++i] & 0xC0) == 0x80 && (data[++i] & 0xC0) == 0x80 && (data[++i] & 0xC0) == 0x80) {\n                    continue;\n                } else {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        }\n        return true;\n    }\n}", "total_acs": 20358, "total_submitted": 58625}, {"id": 394, "title": "Decode String", "url": "https://leetcode.com/problems/decode-string/description", "companyTags": ["Google", "Yelp", "Coupang"], "difficulty": "Medium", "content": "\r\nGiven an encoded string, return it's decoded string.\r\n\r\n\r\nThe encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.\r\n\r\n\r\nYou may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.\r\n\r\nFurthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won't be input like 3a or 2[4].\r\n\r\n\r\nExamples:\r\n\r\ns = \"3[a]2[bc]\", return \"aaabcbc\".\r\ns = \"3[a2[c]]\", return \"accaccacc\".\r\ns = \"2[abc]3[cd]ef\", return \"abcabccdcdcdef\".\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/517", "similarQuestions": ["EncodeStringwithShortestLength", "NumberofAtoms"], "topicTags": ["Stack", "Depth-firstSearch"], "Solution": "class Solution {\n    public String decodeString(String s) {\n        return dfs(s, 0, s.length() - 1);\n    }\n    \n    private String dfs(String s, int start, int end){\n        StringBuilder sb = new StringBuilder();\n        int times = 0;\n        for (int i = start; i <= end; i++){\n            char c = s.charAt(i);\n            if (c >= '0' && c <= '9'){\n                times = times * 10 + c - '0';\n            } else if (c == '['){\n                int open = 1;\n                int substart = i + 1;\n                while (open != 0){\n                    i++;\n                    if (s.charAt(i) == '['){\n                        open++;\n                    } else if (s.charAt(i) == ']'){\n                        open--;\n                    }\n                }\n                int subend = i - 1;\n                String sub = dfs(s, substart, subend);\n                if (times == 0){\n                    times = 1;\n                }\n                for (int j = 0; j < times; j++){\n                    sb.append(sub);\n                }\n                times = 0;\n            } else {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n}", "total_acs": 47561, "total_submitted": 113229}, {"id": 395, "title": "Longest Substring with At Least K Repeating Characters", "url": "https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/description", "companyTags": ["Baidu"], "difficulty": "Medium", "content": "\r\nFind the length of the longest substring T of a given string (consists of lowercase letters only) such that every character in T appears no less than k times.\r\n\r\n\r\nExample 1:\r\n\r\nInput:\r\ns = \"aaabb\", k = 3\r\n\r\nOutput:\r\n3\r\n\r\nThe longest substring is \"aaa\", as 'a' is repeated 3 times.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput:\r\ns = \"ababbc\", k = 2\r\n\r\nOutput:\r\n5\r\n\r\nThe longest substring is \"ababb\", as 'a' is repeated 2 times and 'b' is repeated 3 times.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/518", "similarQuestions": [""], "topicTags": [""], "Solution": "class Solution {\n    public int longestSubstring(String s, int k) {\n    int n = s.length();\n\tif(n < k) return 0;\n\tint counter[] = new int[26];\n\tboolean valid[] = new boolean[26];\n\tchar ss[] = s.toCharArray();\n\tfor(int i=0;i<n;i++) \n\t\tcounter[ss[i] - 'a']++;\n\tboolean fullValid = true;\n\tfor(int i=0;i<26;i++){\n\t\tif(counter[i]>0 && counter[i]<k){\n\t\t\tvalid[i] = false;\n\t\t\tfullValid = false;\n\t\t}\n\t\telse valid[i] = true;\n\t}\n\tif(fullValid) return s.length();\n\tint max = 0;\n\tint lastStart=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(valid[ss[i] - 'a'] == false){\n\t\t\tmax = Math.max(max,longestSubstring(s.substring(lastStart,i),k));\n\t\t\tlastStart = i + 1;\n\t\t}\n\t}\n\tmax = Math.max(max,longestSubstring(s.substring(lastStart,n),k));\n\treturn max;\n    }\n}", "total_acs": 22839, "total_submitted": 63467}, {"id": 396, "title": "Rotate Function", "url": "https://leetcode.com/problems/rotate-function/description", "companyTags": ["Amazon"], "difficulty": "Medium", "content": "\r\nGiven an array of integers A and let n to be its length.\r\n\r\n\r\n\r\nAssume Bk to be an array obtained by rotating the array A k positions clock-wise, we define a \"rotation function\" F on A as follow:\r\n\r\n\r\n\r\nF(k) = 0 * Bk[0] + 1 * Bk[1] + ... + (n-1) * Bk[n-1].\r\n\r\nCalculate the maximum value of F(0), F(1), ..., F(n-1). \r\n\r\n\r\nNote:\r\nn is guaranteed to be less than 105.\r\n\r\n\r\nExample:\r\n\r\nA = [4, 3, 2, 6]\r\n\r\nF(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25\r\nF(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16\r\nF(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23\r\nF(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26\r\n\r\nSo the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/520", "similarQuestions": [""], "topicTags": ["Math"], "Solution": "public class Solution {\n    public int maxRotateFunction(int[] A) {\n        if (A == null || A.length == 0) {\n            return 0;\n        }\n        int n = A.length;\n        int sum = 0;\n        for (int i = 0; i < n; ++i) {\n            sum += A[i];\n        }\n        \n        int f = 0;\n        for (int i = 0; i < n; ++i) {\n            f += i * A[i];\n        }\n        \n        int maxf = f;\n        for (int k = 1; k < n; ++k) {\n            f += (sum - n * A[n - k]);\n            maxf = f > maxf ? f : maxf;\n        }\n        return maxf;\n    }\n}", "total_acs": 25633, "total_submitted": 76140}, {"id": 397, "title": "Integer Replacement", "url": "https://leetcode.com/problems/integer-replacement/description", "companyTags": ["Google", "Baidu"], "difficulty": "Medium", "content": "\r\nGiven a positive integer n and you can do operations as follow:\r\n\r\n\r\n\r\n\r\nIf n is even, replace n with n/2.\r\nIf n is odd, you can replace n with either n + 1 or n - 1.\r\n\r\n\r\n\r\n\r\nWhat is the minimum number of replacements needed for n to become 1?\r\n\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput:\r\n8\r\n\r\nOutput:\r\n3\r\n\r\nExplanation:\r\n8 -> 4 -> 2 -> 1\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput:\r\n7\r\n\r\nOutput:\r\n4\r\n\r\nExplanation:\r\n7 -> 8 -> 4 -> 2 -> 1\r\nor\r\n7 -> 6 -> 3 -> 2 -> 1\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/521", "similarQuestions": [""], "topicTags": ["Math", "BitManipulation"], "Solution": "class Solution {\n    public int integerReplacement(int n) {\n        int count=0;\n        if(n<=1)\n            return count;\n        \n        while(n!=1){\n            if(n%2==0){\n                n>>>=1;\n            }else{\n                if(n==3||Integer.bitCount(n+1)>Integer.bitCount(n-1)){\n                    n-=1;\n                }else{\n                    n+=1;\n                }\n            }\n            count++;\n        }\n        \n        return count;\n        \n    }\n}", "total_acs": 27089, "total_submitted": 89054}, {"id": 398, "title": "Random Pick Index", "url": "https://leetcode.com/problems/random-pick-index/description", "companyTags": ["Facebook"], "difficulty": "Medium", "content": "\r\nGiven an array of integers with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array.\r\n\r\n\r\n\r\nNote:\r\nThe array size can be very large. Solution that uses too much extra space will not pass the judge.\r\n\r\n\r\nExample:\r\n\r\nint[] nums = new int[] {1,2,3,3,3};\r\nSolution solution = new Solution(nums);\r\n\r\n// pick(3) should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.\r\nsolution.pick(3);\r\n\r\n// pick(1) should return 0. Since in the array only nums[0] is equal to 1.\r\nsolution.pick(1);\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/522", "similarQuestions": ["LinkedListRandomNode"], "topicTags": ["ReservoirSampling"], "Solution": null, "total_acs": 31745, "total_submitted": 71537}, {"id": 399, "title": "Evaluate Division", "url": "https://leetcode.com/problems/evaluate-division/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "\r\nEquations are given in the format A / B = k, where  A and B are variables represented as strings, and k is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return -1.0.\r\n\r\nExample:\r\nGiven  a / b = 2.0, b / c = 3.0. queries are:  a / c = ?,  b / a = ?, a / e = ?,  a / a = ?, x / x = ? . return  [6.0, 0.5, -1.0, 1.0, -1.0 ].\r\n\r\n\r\nThe input is:  vector<pair<string, string>> equations, vector<double>& values, vector<pair<string, string>> queries , where equations.size() == values.size(), and the values are positive. This represents the equations. Return  vector<double>.\r\n\r\n\r\nAccording to the example above:\r\nequations = [ [\"a\", \"b\"], [\"b\", \"c\"] ],\r\nvalues = [2.0, 3.0],\r\nqueries = [ [\"a\", \"c\"], [\"b\", \"a\"], [\"a\", \"e\"], [\"a\", \"a\"], [\"x\", \"x\"] ]. \r\n\r\n\r\n\r\nThe input is always valid. You may assume that evaluating the queries will result in no division by zero and there is no contradiction.\r\n", "discussUrl": "https://discuss.leetcode.com/category/523", "similarQuestions": [""], "topicTags": ["Graph"], "Solution": "class Solution {\n    public double[] calcEquation(String[][] equations, double[] values, String[][] queries) {\n        if(equations==null || equations.length==0) return new double [] {};\n        \n        Map<String, String>root=new HashMap<>();\n        Map<String, Double>map=new HashMap<>();\n        \n        for (int i=0;i<equations.length;i++){\n            String x1=equations[i][0], x2=equations[i][1];\n            root.putIfAbsent(x1, x1);\n            root.putIfAbsent(x2, x2);\n            map.putIfAbsent(x1, 1.0);\n            map.putIfAbsent(x2, 1.0);\n            \n            String r1=find(root, x1);\n            String r2=find(root, x2);\n            root.put(r2, r1);\n            map.put(r2, map.get(x1)*values[i]/map.get(x2));\n        }\n\n        double[] res=new double[queries.length];\n        for (int i=0;i<queries.length;i++){\n            res[i]=-1.0;\n            String x1=queries[i][0], x2=queries[i][1];\n            if (!root.containsKey(x1) || !root.containsKey(x2)) continue;\n            String r1=find(root, x1);\n            String r2=find(root, x2);\n            if (r1.equals(r2))\n                res[i]=get(root, map, x2) / get(root, map, x1);\n        }\n        return res;\n    }\n    \n    private String find(Map<String, String>root, String var){\n        if (root.get(var).equals(var)) return var;\n        return find(root, root.get(var));\n    }\n    \n    private double get(Map<String, String>root, Map<String, Double>map, String var){\n        String r=root.get(var);\n        double result=map.get(var);\n        \n        if (r.equals(var)) return result;\n        return result*get(root, map, r);\n    }\n\n}", "total_acs": 25542, "total_submitted": 60624}, {"id": 400, "title": "Nth Digit", "url": "https://leetcode.com/problems/nth-digit/description", "companyTags": ["Google"], "difficulty": "Easy", "content": "Find the nth digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... \r\n\r\nNote:\r\nn is positive and will fit within the range of a 32-bit signed integer (n < 231).\r\n\r\n\r\nExample 1:\r\n\r\nInput:\r\n3\r\n\r\nOutput:\r\n3\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput:\r\n11\r\n\r\nOutput:\r\n0\r\n\r\nExplanation:\r\nThe 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/525", "similarQuestions": [""], "topicTags": ["Math"], "Solution": "class Solution {\n    public int findNthDigit(int n) {\n        if (n < 10) return n;\n        \n        int len = 1;\n        long number = 9;\n        int start = 1;\n        \n        while (n > len*number){\n            n -= len*number;\n            len++;\n            number *= 10;\n            start *= 10;\n        }\n        \n        int resNumb = start + (n-1)/len;\n        int index = (n-1)%len;\n        return Integer.toString(resNumb).charAt(index)-'0';\n    }\n}", "total_acs": 31874, "total_submitted": 105584}, {"id": 401, "title": "Binary Watch", "url": "https://leetcode.com/problems/binary-watch/description", "companyTags": ["Google"], "difficulty": "Easy", "content": "A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59).\r\nEach LED represents a zero or one, with the least significant bit on the right.\r\n\r\nFor example, the above binary watch reads \"3:25\".\r\n\r\nGiven a non-negative integer n which represents the number of LEDs that are currently on, return all possible times the watch could represent.\r\n\r\nExample:\r\nInput: n = 1Return: [\"1:00\", \"2:00\", \"4:00\", \"8:00\", \"0:01\", \"0:02\", \"0:04\", \"0:08\", \"0:16\", \"0:32\"]\r\n\r\n\r\nNote:\r\n\r\nThe order of output does not matter.\r\nThe hour must not contain a leading zero, for example \"01:00\" is not valid, it should be \"1:00\".\r\nThe minute must be consist of two digits and may contain a leading zero, for example \"10:2\" is not valid, it should be \"10:02\".\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/526", "similarQuestions": ["LetterCombinationsofaPhoneNumber", "Numberof1Bits"], "topicTags": ["Backtracking", "BitManipulation"], "Solution": "class Solution {\n    public List<String> readBinaryWatch(int num) {\n        List<String> res = new ArrayList<>();\n        for (int h = 0; h < 12; h ++) {\n            for (int m = 0; m < 60; m ++) {\n                if (Integer.bitCount(h) + Integer.bitCount(m) == num) {\n                    if (m < 10) {\n                        res.add(h + \":\" + \"0\" + m);\n                    } else {\n                        res.add(h + \":\" + m);\n                    }\n                }\n            }\n        }\n        return res;\n    }\n}", "total_acs": 43470, "total_submitted": 96967}, {"id": 402, "title": "Remove K Digits", "url": "https://leetcode.com/problems/remove-k-digits/description", "companyTags": ["Google", "Snapchat"], "difficulty": "Medium", "content": "Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible.\r\n\r\n\r\nNote:\r\n\r\nThe length of num is less than 10002 and will be \u2265 k.\r\nThe given num does not contain any leading zero.\r\n\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput: num = \"1432219\", k = 3\r\nOutput: \"1219\"\r\nExplanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: num = \"10200\", k = 1\r\nOutput: \"200\"\r\nExplanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput: num = \"10\", k = 2\r\nOutput: \"0\"\r\nExplanation: Remove all the digits from the number and it is left with nothing which is 0.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/527", "similarQuestions": ["CreateMaximumNumber", "MonotoneIncreasingDigits"], "topicTags": ["Stack", "Greedy"], "Solution": "class Solution {\n    public String removeKdigits(String num, int k) {\n        int length = num.length() - k;\n        if(length <= 0) return \"0\";\n        char[] res = new char[num.length()];\n        int last = 0;\n        // k keeps track of how many characters we can remove\n        // if the previous character in res is larger than the current one\n        // then removing it will get a smaller number\n        // but we can only do so when k is larger than 0\n        for(char ch: num.toCharArray()) {\n            while(k>0 && last>0 && res[last-1]>ch) {\n                --last;\n                --k;\n            }\n            res[last++] = ch;\n        }\n        int firstNonZero = 0;\n        // find the index of first non-zero digit\n        while(firstNonZero<length && res[firstNonZero]=='0') ++firstNonZero;\n        return firstNonZero==length? \"0\" : new String(res, firstNonZero, length - firstNonZero);\n    }\n}", "total_acs": 28246, "total_submitted": 108384}, {"id": 403, "title": "Frog Jump", "url": "https://leetcode.com/problems/frog-jump/description", "companyTags": ["Snapchat"], "difficulty": "Hard", "content": "A frog is crossing a river. The river is divided into x units and at each unit there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.\r\n\r\nGiven a list of stones' positions (in units) in sorted ascending order, determine if the frog is able to cross the river by landing on the last stone. Initially, the frog is on the first stone and assume the first jump must be 1 unit.\r\n\r\n\r\nIf the frog's last jump was k units, then its next jump must be either k - 1, k, or k + 1 units. Note that the frog can only jump in the forward direction.\r\n\r\nNote:\r\n\r\nThe number of stones is \u2265 2 and is < 1,100.\r\nEach stone's position will be a non-negative integer < 231.\r\nThe first stone's position is always 0.\r\n\r\n\r\n\r\nExample 1:\r\n\r\n[0,1,3,5,6,8,12,17]\r\n\r\nThere are a total of 8 stones.\r\nThe first stone at the 0th unit, second stone at the 1st unit,\r\nthird stone at the 3rd unit, and so on...\r\nThe last stone at the 17th unit.\r\n\r\nReturn true. The frog can jump to the last stone by jumping \r\n1 unit to the 2nd stone, then 2 units to the 3rd stone, then \r\n2 units to the 4th stone, then 3 units to the 6th stone, \r\n4 units to the 7th stone, and 5 units to the 8th stone.\r\n\r\n\r\n\r\nExample 2:\r\n\r\n[0,1,2,3,4,8,9,11]\r\n\r\nReturn false. There is no way to jump to the last stone as \r\nthe gap between the 5th and 6th stone is too large.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/528", "similarQuestions": [""], "topicTags": ["DynamicProgramming"], "Solution": "class Solution {\n    public boolean canCross(int[] stones) {\n        if(stones.length < 2)\n            return true;\n        \n        if(stones[1] != 1) {\n            return false;\n        }\n        \n        for(int i = 0; i < stones.length - 1; i++)\n            if(2 * stones[i] < stones[i+1] - 1)\n                return false;\n        \n        return canCross(stones, 1, 1);\n    }\n    \n    private boolean canCross(int[] s, int k, int i) {\n        // System.out.println(k + \" : \" + i);\n        if(k <= 0 || s[i] + k - 1 > s[s.length - 1])\n            return false;\n        \n        if(Math.abs(s[s.length - 1] - (s[i] + k)) <= 1)\n            return true;\n        \n        int temp = Arrays.binarySearch(s, s[i] + k + 1);\n        \n        if(temp >= 0 && canCross(s, k+1, temp)) {\n            return true;\n        }\n        \n        temp = Arrays.binarySearch(s, s[i] + k);\n\n        if(temp >= 0 && canCross(s, k, temp)) {\n            return true;\n        }\n\n        temp = Arrays.binarySearch(s, s[i] + k - 1);\n\n        if(temp >= 0 && canCross(s, k-1, temp)) {\n            return true;\n        }\n\n        return false;\n    }\n}", "total_acs": 23128, "total_submitted": 71069}, {"id": 404, "title": "Sum of Left Leaves", "url": "https://leetcode.com/problems/sum-of-left-leaves/description", "companyTags": ["Facebook"], "difficulty": "Easy", "content": "Find the sum of all left leaves in a given binary tree.\r\n\r\nExample:\r\n\r\n    3\r\n   / \\\r\n  9  20\r\n    /  \\\r\n   15   7\r\n\r\nThere are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/530", "similarQuestions": [""], "topicTags": ["Tree"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public int sumOfLeftLeaves(TreeNode root) {\n        return sumOfLeftLeavesHelper(root, false);\n    }\n    \n    private int sumOfLeftLeavesHelper(TreeNode root, boolean cameFromLeft) {\n        if (root == null) return 0;\n        \n        if (root.left == null && root.right == null) return cameFromLeft ? root.val : 0;\n        \n        return 0 + sumOfLeftLeavesHelper(root.left, true) + sumOfLeftLeavesHelper(root.right, false);\n    }\n}", "total_acs": 78740, "total_submitted": 165984}, {"id": 405, "title": "Convert a Number to Hexadecimal", "url": "https://leetcode.com/problems/convert-a-number-to-hexadecimal/description", "companyTags": [""], "difficulty": "Easy", "content": "\r\nGiven an integer, write an algorithm to convert it to hexadecimal. For negative integer, two\u2019s complement method is used.\r\n\r\n\r\nNote:\r\n\r\nAll letters in hexadecimal (a-f) must be in lowercase.\r\nThe hexadecimal string must not contain extra leading 0s. If the number is zero, it is represented by a single zero character '0'; otherwise, the first character in the hexadecimal string will not be the zero character.\r\nThe given number is guaranteed to fit within the range of a 32-bit signed integer.\r\nYou must not use any method provided by the library which converts/formats the number to hex directly.\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput:\r\n26\r\n\r\nOutput:\r\n\"1a\"\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput:\r\n-1\r\n\r\nOutput:\r\n\"ffffffff\"\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/531", "similarQuestions": [""], "topicTags": ["BitManipulation"], "Solution": "class Solution {\n    public String toHex(int num) {\n        if (num == 0) return \"0\";\n        char[] map = new char[]{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\n        StringBuilder sb = new StringBuilder();\n        while (num != 0) {\n            sb.insert(0, map[num & 0b1111]);\n            num = num >>> 4;\n        }\n        return sb.toString();\n    }\n}", "total_acs": 31903, "total_submitted": 77704}, {"id": 406, "title": "Queue Reconstruction by Height", "url": "https://leetcode.com/problems/queue-reconstruction-by-height/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue.\r\n\r\n\r\nNote:\r\nThe number of people is less than 1,100.\r\n\r\n\r\n\r\n\r\nExample\r\n\r\nInput:\r\n[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]\r\n\r\nOutput:\r\n[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/532", "similarQuestions": ["CountofSmallerNumbersAfterSelf"], "topicTags": ["Greedy"], "Solution": "\n\nclass Solution {\n    \n    public int[][] reconstructQueue(int[][] people) {\n        int length = people.length;\n        int[] nums = new int[length];\n        for(int i = 0; i < length; i++) {\n            nums[i] = people[i][1];\n        }\n        int[][] peopleCp = Arrays.copyOf(people, length);\n        quickSort(peopleCp, 0, length);\n        mergeSort(peopleCp, Arrays.copyOf(peopleCp, length), 0, length);\n        for(int i = 0; i < length; i++) {\n            people[i][1] = nums[i];\n        }\n        return peopleCp;\n    }\n        \n    private void mergeSort(int[][] people, int[][] tmp, int start, int end) {\n        if(start + 1 >= end) {\n            return;\n        }\n        int mid = (start + end) >> 1;\n        mergeSort(tmp, people, start, mid);\n        mergeSort(tmp, people, mid, end);\n        int i = start, j = mid, k = start, rightCnt = 0;\n        int[] pi = tmp[i], pj = tmp[j];\n        for(;;) {\n            if(pi[1] - rightCnt <= pj[1]) {\n                people[k++] = pi;\n                pi[1] -= rightCnt;\n                if(++i == mid) {\n                    System.arraycopy(tmp, j, people, k, end - j);\n                    break;\n                }\n                pi = tmp[i];\n            } else {\n                people[k++] = pj;\n                rightCnt++;\n                if(++j == end) {\n                    System.arraycopy(tmp, i, people, k, mid - i);\n                    for(; i < mid; i++) {\n                        tmp[i][1] -= rightCnt;\n                    }\n                    break;\n                }\n                pj = tmp[j];\n            }\n        }\n    }\n    \n    private static final int InsertitionSortThreshold = 7;\n    \n    private void quickSort(int[][] people, int start, int end) {\n        if(end - start <= InsertitionSortThreshold) {\n            for(int i = start + 1; i < end; i++) {\n                int[] person = people[i];\n                int j = i;\n                for(; j > start && compare(person, people[j - 1]) < 0;) {\n                    people[j] = people[--j];\n                }\n                people[j] = person;\n            }\n            return;\n        }\n        int i = random(start, end);\n        int[] person = people[i];\n        people[i] = people[start];\n        int s = start, e = end;\n        Loop:\n        for(int[] ps, pe;;) {\n            for(;;) {\n                if(--e <= s) {\n                    break Loop;\n                }\n                if(compare(pe = people[e], person) < 0) {\n                    break;\n                }\n            }\n            people[s] = pe;\n            for(;;) {\n                if(++s >= e) {\n                    break Loop;\n                }\n                if(compare(ps = people[s], person) > 0) {\n                    break;\n                }\n            }\n            people[e] = ps;\n        }\n        people[s] = person;\n        quickSort(people, start, s);\n        quickSort(people, s + 1, end);\n    }\n    \n    private int compare(int[] p1, int[] p2) {\n        int h = p1[0] - p2[0];\n        return h != 0 ? h : p2[1] - p1[1];\n    }\n    \n    private int random(int start, int end) {\n        return (int)(System.nanoTime() % (end - start) + start);\n    }\n}", "total_acs": 39116, "total_submitted": 69049}, {"id": 407, "title": "Trapping Rain Water II", "url": "https://leetcode.com/problems/trapping-rain-water-ii/description", "companyTags": ["Google", "Twitter"], "difficulty": "Hard", "content": "Given an m x n matrix of positive integers representing the height of each unit cell in a 2D elevation map, compute the volume of water it is able to trap after raining.\r\n\r\n\r\nNote:\r\nBoth m and n are less than 110. The height of each unit cell is greater than 0 and is less than 20,000.\r\n\r\n\r\nExample:\r\n\r\nGiven the following 3x6 height map:\r\n[\r\n  [1,4,3,1,3,2],\r\n  [3,2,1,3,2,4],\r\n  [2,3,3,2,3,1]\r\n]\r\n\r\nReturn 4.\r\n\r\n\r\n\r\n\r\n\r\nThe above image represents the elevation map [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]] before the rain.\r\n\r\n\r\n\r\n\r\nAfter the rain, water is trapped between the blocks. The total volume of water trapped is 4.\r\n", "discussUrl": "https://discuss.leetcode.com/category/533", "similarQuestions": ["TrappingRainWater"], "topicTags": ["Heap", "Breadth-firstSearch"], "Solution": "public class Solution {\n    private static class Cell implements Comparable<Cell> {\n        private int row;\n        private int col;\n        private int value;\n        public Cell(int r, int c, int v) {\n            this.row = r;\n            this.col = c;\n            this.value = v;\n        }\n        @Override\n        public int compareTo(Cell other) {\n            return value - other.value;\n        }\n    }\n    private int water;\n    private boolean[][] visited1;\n    public int trapRainWater(int[][] heightMap) {\n        if (heightMap.length == 0) return 0;\n        PriorityQueue<Cell> walls = new PriorityQueue<Cell>();\n        water = 0;\n        visited1 = new boolean[heightMap.length][heightMap[0].length];\n        int rows = heightMap.length, cols = heightMap[0].length;\n        //build wall;\n        for (int c = 0; c < cols; c++) {\n        \twalls.add(new Cell(0, c, heightMap[0][c]));\n        \twalls.add(new Cell(rows - 1, c, heightMap[rows - 1][c]));\n        \tvisited1[0][c] = true;\n        \tvisited1[rows - 1][c] = true;\n        }\n        for (int r = 1; r < rows - 1; r++) {\n        \twalls.add(new Cell(r, 0, heightMap[r][0]));\n        \twalls.add(new Cell(r, cols - 1, heightMap[r][cols - 1]));\n        \tvisited1[r][0] = true;\n        \tvisited1[r][cols - 1] = true;\n        }\n        //end build wall;\n        while(walls.size() > 0) {\n            Cell min = walls.poll();\n            visit(heightMap, min, walls);\n        }\n        return water;\n    }\n    private void visit(int[][] height, Cell start, PriorityQueue<Cell> walls) {\n        fill(height, start.row + 1, start.col, walls, start.value);\n        fill(height, start.row - 1, start.col, walls, start.value);\n        fill(height, start.row, start.col + 1, walls, start.value);\n        fill(height, start.row, start.col - 1, walls, start.value);\n    }\n    private void fill(int[][] height, int row, int col, PriorityQueue<Cell> walls, int min) {\n        if (row < 0 || col < 0) return;\n        else if (row >= height.length || col >= height[0].length) return;\n        else if (visited1[row][col]) return;\n        else if (height[row][col] >= min) {\n            walls.add(new Cell(row, col, height[row][col]));\n            visited1[row][col] = true;\n            return;\n        } else {\n//        \tSystem.out.println(row + \", \" + col + \" height = \" + height[row][col] + \", bar = \" + min);\n            water += min - height[row][col];\n            visited1[row][col] = true;\n            fill(height, row + 1, col, walls, min);\n            fill(height, row - 1, col, walls, min);\n            fill(height, row, col + 1, walls, min);\n            fill(height, row, col - 1, walls, min);\n        }\n    }\n}", "total_acs": 15216, "total_submitted": 40171}, {"id": 408, "title": "Valid Word Abbreviation", "url": "https://leetcode.com/problems/valid-word-abbreviation/description", "companyTags": ["Google"], "difficulty": "Easy", "content": "\r\nGiven a non-empty string s and an abbreviation abbr, return whether the string matches with the given abbreviation.\r\n\r\n\r\nA string such as \"word\" contains only the following valid abbreviations:\r\n\r\n[\"word\", \"1ord\", \"w1rd\", \"wo1d\", \"wor1\", \"2rd\", \"w2d\", \"wo2\", \"1o1d\", \"1or1\", \"w1r1\", \"1o2\", \"2r1\", \"3d\", \"w3\", \"4\"]\r\n\r\n\r\nNotice that only the above abbreviations are valid abbreviations of the string \"word\". Any other string is not a valid abbreviation of \"word\".\r\n\r\nNote:\r\nAssume s contains only lowercase letters and abbr contains only lowercase letters and digits.\r\n\r\n\r\nExample 1:\r\n\r\nGiven s = \"internationalization\", abbr = \"i12iz4n\":\r\n\r\nReturn true.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nGiven s = \"apple\", abbr = \"a2e\":\r\n\r\nReturn false.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/535", "similarQuestions": ["MinimumUniqueWordAbbreviation", "WordAbbreviation"], "topicTags": ["String"], "Solution": "class Solution {\n    public boolean validWordAbbreviation(String word, String abbr) {\n        int i = 0, j = 0;\n        while (i < word.length() && j < abbr.length()) {\n            if (word.charAt(i) == abbr.charAt(j)) {\n                i++;\n                j++;\n                continue;\n            }\n            if (abbr.charAt(j) <= '0' || abbr.charAt(j) > '9') {\n                return false;\n            }\n            int num = 0;\n            while (j < abbr.length() && abbr.charAt(j) >= '0' && abbr.charAt(j) <= '9') {\n                num = (num + (abbr.charAt(j++) - '0')) * 10;\n            }\n            num /= 10;\n            i += num;\n        }\n        return i == word.length() && j == abbr.length();\n    }\n}", "total_acs": 14561, "total_submitted": 51385}, {"id": 409, "title": "Longest Palindrome", "url": "https://leetcode.com/problems/longest-palindrome/description", "companyTags": ["Google"], "difficulty": "Easy", "content": "Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.\r\n\r\nThis is case sensitive, for example \"Aa\" is not considered a palindrome here.\r\n\r\nNote:\r\nAssume the length of given string will not exceed 1,010.\r\n\r\n\r\nExample: \r\n\r\nInput:\r\n\"abccccdd\"\r\n\r\nOutput:\r\n7\r\n\r\nExplanation:\r\nOne longest palindrome that can be built is \"dccaccd\", whose length is 7.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/536", "similarQuestions": ["PalindromePermutation"], "topicTags": ["HashTable"], "Solution": "class Solution {\n    public int longestPalindrome(String s) {\n        int[] map = new int[128];\n        int res = 0;\n        for(char c : s.toCharArray()){\n            if((int) map[c]++ % 2 == 1)\n                res += 2;\n        }\n        return s.length() > res?1 + res : res;\n    }\n}", "total_acs": 58565, "total_submitted": 127891}, {"id": 410, "title": "Split Array Largest Sum", "url": "https://leetcode.com/problems/split-array-largest-sum/description", "companyTags": ["Facebook", "Baidu"], "difficulty": "Hard", "content": "Given an array which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays.\r\n\r\n\r\nNote:\r\nIf n is the length of array, assume the following constraints are satisfied:\r\n\r\n1 \u2264 n \u2264 1000\r\n1 \u2264 m \u2264 min(50, n)\r\n\r\n\r\n\r\nExamples: \r\n\r\nInput:\r\nnums = [7,2,5,10,8]\r\nm = 2\r\n\r\nOutput:\r\n18\r\n\r\nExplanation:\r\nThere are four ways to split nums into two subarrays.\r\nThe best way is to split it into [7,2,5] and [10,8],\r\nwhere the largest sum among the two subarrays is only 18.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/537", "similarQuestions": [""], "topicTags": ["BinarySearch", "DynamicProgramming"], "Solution": "public class Solution {\n    private boolean tolarge(int target, int[] num, int m) {\n        int curr = 0;\n        int count = 0;\n        for(int i = 0; i < num.length; i++) {\n            curr += num[i];\n            if(curr > target) {\n                count++;\n                curr = num[i];\n                // i--;\n                if(count >= m) return false;\n            }\n        }\n        return true;\n    }\n    public int splitArray(int[] nums, int m) {\n        \n        int max = 0;\n        int sum = 0;\n        for(int i : nums) {\n            max = Math.max(max, i);\n            sum += i;\n        }\n        int l = max;\n        int r = sum;\n        while(l <= r) {\n            int mid = l + (r-l)/2;\n            if(tolarge(mid, nums, m)) {\n                r = mid - 1;\n            }else l = mid + 1;\n        }\n        return l;\n//         int[] sum = new int[nums.length + 1];\n//         for(int i = 0; i < nums.length; i++) {\n//             sum[i+1] = sum[i] + nums[i]; \n//         }\n//         int[] res = new int[nums.length + 1];\n//         for(int i = 0; i <= nums.length; i++) {\n//             res[i] = sum[i];\n//         }\n//         for(int i = 2; i <= m; i++) {\n            \n            \n//             for(int j = nums.length; j >= i; j--) {\n//                 int max = 0;\n//                 int min = Integer.MAX_VALUE;   \n//                 for(int k = j - 1; k >= i - 1; k--) {\n//                     max = Math.max(res[k], sum[j] - sum[k]);\n//                     min = Math.min(min, max);\n//                 }\n//                 res[j] = min;\n                \n                \n                \n//             }\n            \n            \n//         }\n//         return res[nums.length];\n        \n        \n        \n        \n        \n        \n//         int n = nums.length;\n//         long[] sum = new long[n];\n//         sum[0] = nums[0];\n//         for(int i = 1; i < n; i++) {\n//             sum[i] = sum[i-1] + nums[i];\n//         }\n//         long[] matrix = new long[n];\n//         // matrix[0] = nums[0];\n//         for(int i = 0; i < n; i++) {\n//             matrix[i] = sum[i];\n            \n//         }\n        \n//         for(int k = 1; k <m; k++) {\n//             for(int i = n-1; i >= k; i--) {\n//                 long min = sum[n-1];\n//                 for(int j = i-1; j >= k-1;j--) {\n//                     long rightSum = sum[i]-sum[j];\n//                     long max = Math.max(rightSum, matrix[j]);\n//                     min = Math.min(min, max);\n//                 }\n//                 matrix[i] = min;\n//             }\n//         }\n//         return (int)matrix[n-1];\n        \n    }\n}", "total_acs": 20630, "total_submitted": 52664}, {"id": 411, "title": "Minimum Unique Word Abbreviation", "url": "https://leetcode.com/problems/minimum-unique-word-abbreviation/description", "companyTags": ["Google"], "difficulty": "Hard", "content": "A string such as \"word\" contains the following abbreviations:\r\n\r\n[\"word\", \"1ord\", \"w1rd\", \"wo1d\", \"wor1\", \"2rd\", \"w2d\", \"wo2\", \"1o1d\", \"1or1\", \"w1r1\", \"1o2\", \"2r1\", \"3d\", \"w3\", \"4\"]\r\n\r\n\r\nGiven a target string and a set of strings in a dictionary, find an abbreviation of this target string with the smallest possible length such that it does not conflict with abbreviations of the strings in the dictionary. \r\n\r\nEach number or letter in the abbreviation is considered length = 1. For example, the abbreviation \"a32bc\" has length = 4.\r\n\r\nNote:\r\n\r\nIn the case of multiple answers as shown in the second example below, you may return any one of them.\r\nAssume length of target string = m, and dictionary size = n. You may assume that m \u2264 21, n \u2264 1000, and log2(n) + m \u2264 20.\r\n\r\n\r\n\r\nExamples:\r\n\r\n\"apple\", [\"blade\"] -> \"a4\" (because \"5\" or \"4e\" conflicts with \"blade\")\r\n\r\n\"apple\", [\"plain\", \"amber\", \"blade\"] -> \"1p3\" (other valid answers include \"ap3\", \"a3e\", \"2p2\", \"3le\", \"3l1\").\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/538", "similarQuestions": ["GeneralizedAbbreviation", "ValidWordAbbreviation", "WordAbbreviation"], "topicTags": ["Backtracking", "BitManipulation"], "Solution": "class Solution {\n    public String minAbbreviation(String target, String[] dictionary) {\n        char[] c = target.toCharArray();\n\t\tchar[] tmp = new char[c.length];\n\n\t\t// traverse length from min to max\n\t\tfor (int l = 1; l <= target.length(); l++) {\n\t\t\tString abbr = minAbbreviation(c, 0, tmp, 0, dictionary, l);\n\t\t\tif (abbr != null) return  abbr;\n\t\t}\n\t\treturn null;\n    }\n    \n    private String minAbbreviation(char[] c, int p, char[] tmp, int t, String[] dictionary, int l) {\n        if (l == 0) {\n            if (p == c.length && !conflict(tmp, t, dictionary, c.length)) return new String(tmp, 0, t);\n            else return null;\n\t\t}\n\t\t// can use abbr\n\t\tif (t == 0 || tmp[t - 1] > '9') {\n\t\t\tfor (int end = p + 1; end <= c.length - l; end++) {\n\t\t\t\tint s = end - p + 1;\n                if (s >= 10) {\n                    tmp[t] = (char)(s / 10 + '0');\n                    tmp[t + 1] = (char)(s % 10 + '0');\n                    String r = minAbbreviation(c, end + 1, tmp, t + 2, dictionary, l - 1);\n                    if (r != null) return r;\n                } else {\n                    tmp[t] = (char)(s + '0');\n                    String r = minAbbreviation(c, end + 1, tmp, t + 1, dictionary, l - 1);\n                    if (r != null) return r;\n                }\n\t\t\t}\n\t\t}\n        \n        // use original character\n        tmp[t] = c[p];\n        return minAbbreviation(c, p + 1, tmp, t + 1, dictionary, l - 1);\n    }\n    \n    private boolean conflict(char[] abbr, int t, String[] dictionary, int l) {\n        char[] pattern = new char[abbr.length];\n        // pinter for pattern\n        int p = 0;\n        int count = 0;\n        for (int i = 0; i < t; i++) {\n            char c = abbr[i];\n            if (c <= '9') count = count * 10 + c - '0';\n            else {\n                if (count != 0) {\n                    // store count to pattern.\n                    pattern[p++] = (char)count;\n                    count = 0;\n                }\n                pattern[p++] = c;\n            }\n        }\n        \n        for (String s : dictionary) {\n            if (s.length() != l) continue;\n            int j = 0;\n            boolean match = true;\n            for (int i = 0; i < p; i++) {\n                if (pattern[i] < 22) j += pattern[i];\n                else if (s.charAt(j) != pattern[i]) {\n                    match = false;\n                    break;\n                }\n                else j++;\n            }\n            if (match) return true;\n        }\n        return false;\n    }\n}", "total_acs": 7100, "total_submitted": 20985}, {"id": 412, "title": "Fizz Buzz", "url": "https://leetcode.com/problems/fizz-buzz/description", "companyTags": [""], "difficulty": "Easy", "content": "Write a program that outputs the string representation of numbers from 1 to n.\r\n\r\nBut for multiples of three it should output \u201cFizz\u201d instead of the number and for the multiples of five output \u201cBuzz\u201d. For numbers which are multiples of both three and five output \u201cFizzBuzz\u201d.\r\n\r\nExample:\r\n\r\nn = 15,\r\n\r\nReturn:\r\n[\r\n    \"1\",\r\n    \"2\",\r\n    \"Fizz\",\r\n    \"4\",\r\n    \"Buzz\",\r\n    \"Fizz\",\r\n    \"7\",\r\n    \"8\",\r\n    \"Fizz\",\r\n    \"Buzz\",\r\n    \"11\",\r\n    \"Fizz\",\r\n    \"13\",\r\n    \"14\",\r\n    \"FizzBuzz\"\r\n]\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/540", "similarQuestions": [""], "topicTags": [""], "Solution": "class Solution {\n    public  List<String> fizzBuzz(int n) {\n        final int size = n;\n        return new java.util.AbstractList<String>() {\n            public static final String FIZZ_BUZZ = \"FizzBuzz\";\n            public static final String FIZZ = \"Fizz\";\n            public static final String BUZZ = \"Buzz\";\n\n            @Override\n            public String get(int index) {\n                index ++;\n                if(index % 15 == 0){\n                    return FIZZ_BUZZ;\n                }else if(index % 3 == 0){\n                    return FIZZ;\n                }else if(index % 5 == 0){\n                    return BUZZ;\n                }else{\n                    return String.valueOf(index);\n                }\n            }\n            @Override\n            public int size() {\n                return size;\n            }\n        };\n    }\n}", "total_acs": 104078, "total_submitted": 178729}, {"id": 413, "title": "Arithmetic Slices", "url": "https://leetcode.com/problems/arithmetic-slices/description", "companyTags": ["Baidu", "Aetion"], "difficulty": "Medium", "content": "A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\r\n\r\nFor example, these are arithmetic sequence:\r\n1, 3, 5, 7, 9\r\n7, 7, 7, 7\r\n3, -1, -5, -9\r\n\r\nThe following sequence is not arithmetic. 1, 1, 2, 5, 7 \r\n\r\n\r\nA zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 <= P < Q < N.\r\n\r\nA slice (P, Q) of array A is called arithmetic if the sequence:\r\n    A[P], A[p + 1], ..., A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 < Q.\r\n\r\nThe function should return the number of arithmetic slices in the array A. \r\n\r\n\r\nExample:\r\n\r\nA = [1, 2, 3, 4]\r\n\r\nreturn: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself.\r\n", "discussUrl": "https://discuss.leetcode.com/category/541", "similarQuestions": ["ArithmeticSlicesII-Subsequence"], "topicTags": ["Math", "DynamicProgramming"], "Solution": "class Solution {\n    public int numberOfArithmeticSlices(int[] A) {\n        if (A == null || A.length == 0) {\n            return 0;\n        }\n        int res = 0;\n        int cur = 0;\n        for (int i = 2; i < A.length; i++) {\n            if (A[i] - A[i - 1] == A[i - 1] - A[i - 2]) {\n                cur++;\n                res += cur;\n            } else {\n                cur = 0;\n            }\n        }\n        return res;\n    }\n}", "total_acs": 34293, "total_submitted": 62706}, {"id": 414, "title": "Third Maximum Number", "url": "https://leetcode.com/problems/third-maximum-number/description", "companyTags": ["Amazon"], "difficulty": "Easy", "content": "Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n).\r\n\r\nExample 1:\r\n\r\nInput: [3, 2, 1]\r\n\r\nOutput: 1\r\n\r\nExplanation: The third maximum is 1.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: [1, 2]\r\n\r\nOutput: 2\r\n\r\nExplanation: The third maximum does not exist, so the maximum (2) is returned instead.\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput: [2, 2, 3, 1]\r\n\r\nOutput: 1\r\n\r\nExplanation: Note that the third maximum here means the third maximum distinct number.\r\nBoth numbers with value 2 are both considered as second maximum.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/542", "similarQuestions": ["KthLargestElementinanArray"], "topicTags": ["Array"], "Solution": "class Solution {\n    public int thirdMax(int[] nums) {\n        //System.out.println(Integer.MIN_VALUE);\n        \n        int max1 = Integer.MIN_VALUE;\n        int max2 = max1;\n        int max3 = max2;\n        boolean min = false;    //True if Integer.MIN_VALUE appeared\n        int distinct = 0;\n        for (int i=0; i<nums.length; i++) {\n            if (nums[i] > max1) {\n                max3 = max2;\n                max2 = max1;\n                max1 = nums[i];\n                distinct++;\n            }\n            else if (nums[i] > max2 && nums[i] != max1) {\n                max3 = max2;\n                max2 = nums[i];\n                distinct++;\n            }\n            else if (nums[i] > max3 && nums[i] != max1 && nums[i] != max2) {\n                max3 = nums[i];\n                distinct++;\n            }\n            else if (nums[i] == Integer.MIN_VALUE && !min) {\n                min = true;\n                distinct++;\n            }\n        }\n        \n        //System.out.println(max3);\n        if (distinct <= 2) return max1;\n        return max3;\n    }\n}", "total_acs": 54096, "total_submitted": 193063}, {"id": 415, "title": "Add Strings", "url": "https://leetcode.com/problems/add-strings/description", "companyTags": ["Google", "Airbnb"], "difficulty": "Easy", "content": "Given two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2.\r\n\r\nNote:\r\n\r\nThe length of both num1 and num2 is < 5100.\r\nBoth num1 and num2 contains only digits 0-9.\r\nBoth num1 and num2 does not contain any leading zero.\r\nYou must not use any built-in BigInteger library or convert the inputs to integer directly.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/543", "similarQuestions": ["AddTwoNumbers", "MultiplyStrings"], "topicTags": ["Math"], "Solution": "class Solution {\n    public String addStrings(String num1, String num2) {\n        if (num1.length() < num2.length()) return addStrings(num2, num1);\n        char[] one = num1.toCharArray(), two = num2.toCharArray();\n        int m = one.length, n = two.length;\n        int carry = 0, i = 1, sum = 0;\n        while (i <= n) {\n            sum = one[m - i] + two[n - i] - '0' * 2 + carry;\n            carry = sum / 10;\n            one[m - i] = (char) (sum % 10 + '0');\n            i++;\n        }\n        while (carry > 0 && i <= m) {\n            sum = one[m - i] + carry - '0';\n            carry = sum / 10;\n            one[m - i] = (char) (sum % 10 + '0');\n            i++;\n        }\n        return carry == 0 ? new String(one) : \"1\" + new String(one);\n    }\n}", "total_acs": 51442, "total_submitted": 123350}, {"id": 416, "title": "Partition Equal Subset Sum", "url": "https://leetcode.com/problems/partition-equal-subset-sum/description", "companyTags": ["eBay"], "difficulty": "Medium", "content": "Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.\r\n\r\n\r\nNote:\r\n\r\nEach of the array element will not exceed 100.\r\nThe array size will not exceed 200.\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput: [1, 5, 11, 5]\r\n\r\nOutput: true\r\n\r\nExplanation: The array can be partitioned as [1, 5, 5] and [11].\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: [1, 2, 3, 5]\r\n\r\nOutput: false\r\n\r\nExplanation: The array cannot be partitioned into equal sum subsets.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/544", "similarQuestions": ["PartitiontoKEqualSumSubsets"], "topicTags": ["DynamicProgramming"], "Solution": "class Solution {\n    public boolean canPartition(int[] nums) {\n        if (nums == null || nums.length <= 1)\n            return false;\n        \n        int sum = 0;\n        for (int i = 0; i < nums.length; i++)\n            sum+=nums[i];\n        if ((sum & 1) == 1) return false;\n        sum >>= 1;\n        \n        return dp(sum, 0, 0, nums, new int[sum]);\n    }\n    \n     public boolean dp(int target, int sum, int index,int[] nums, int[] dp){\n        if(sum>target || index>=nums.length){\n            return false;\n        } \n        \n        if(sum==target){\n            return true;\n        }\n         \n        if(dp[sum]==1) {\n            return true;\n        } \n        if(dp[sum]==-1) {\n            return false;\n        }\n         \n        boolean res = dp(target, sum+nums[index],index+1,nums,dp) || dp(target, sum,index+1,nums,dp);\n        dp[sum] = (res)? 1:-1;\n        return res;\n    }\n}", "total_acs": 37775, "total_submitted": 96678}, {"id": 417, "title": "Pacific Atlantic Water Flow", "url": "https://leetcode.com/problems/pacific-atlantic-water-flow/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "Given an m x n matrix of non-negative integers representing the height of each unit cell in a continent, the \"Pacific ocean\" touches the left and top edges of the matrix and the \"Atlantic ocean\" touches the right and bottom edges.\r\n\r\nWater can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower.\r\n\r\nFind the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.\r\n\r\nNote:\r\n\r\nThe order of returned grid coordinates does not matter.\r\nBoth m and n are less than 150.\r\n\r\n\r\nExample:\r\n\r\nGiven the following 5x5 matrix:\r\n\r\n  Pacific ~   ~   ~   ~   ~ \r\n       ~  1   2   2   3  (5) *\r\n       ~  3   2   3  (4) (4) *\r\n       ~  2   4  (5)  3   1  *\r\n       ~ (6) (7)  1   4   5  *\r\n       ~ (5)  1   1   2   4  *\r\n          *   *   *   *   * Atlantic\r\n\r\nReturn:\r\n\r\n[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/545", "similarQuestions": [""], "topicTags": ["Depth-firstSearch", "Breadth-firstSearch"], "Solution": "class Solution {\n    int m;\n    int n;\n    int visitedByBoth = 2;\n    List<int[]> res = new LinkedList<>();\n    public List<int[]> pacificAtlantic(int[][] matrix) {\n        //DFS from Ocean, which is four boundary.\n        //Use one visited matrix: if visited by pacific : 1; if visited by atlantic: -1; if both: 2.\n        //Time: O(MN) we only visited each cell twice. once from each ocsean. \n        //Space: O(MN) visited matrix.\n        if(matrix == null || matrix.length == 0 || matrix[0].length == 0){\n            return res;\n        }\n        m = matrix.length;\n        n = matrix[0].length;\n        int[][] visited = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            dfs(matrix, visited, i, 0, Integer.MIN_VALUE, 1);\n            dfs(matrix, visited, i, n-1, Integer.MIN_VALUE, -1);\n        }\n        for (int j = 0; j < n; j++) {\n            dfs(matrix, visited, 0, j, Integer.MIN_VALUE, 1);\n            dfs(matrix, visited, m-1, j, Integer.MIN_VALUE, -1);\n        }\n        return res;\n    }\n    int[][] dirs = { {0, 1}, {1,0}, {0, -1}, {-1, 0}};\n    private void dfs (int[][]matrix, int[][] visited, int i, int j, int minLimit, int curr) {\n        if (i < 0 || i >= m || j < 0 || j >= n || visited[i][j] == curr || visited[i][j] == visitedByBoth || matrix[i][j] < minLimit) \n            return;\n        if (visited[i][j] == -curr) {\n            visited[i][j] = visitedByBoth;\n            res.add(new int[] {i, j});\n        } else \n            visited[i][j] = curr;\n        for(int[] dir :dirs) {\n            dfs(matrix, visited, i+dir[0], j+dir[1], matrix[i][j], curr);\n        }   \n    }\n}", "total_acs": 22686, "total_submitted": 65706}, {"id": 418, "title": "Sentence Screen Fitting", "url": "https://leetcode.com/problems/sentence-screen-fitting/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "Given a rows x cols screen and a sentence represented by a list of non-empty words, find how many times the given sentence can be fitted on the screen.\r\n\r\n\r\nNote:\r\n\r\nA word cannot be split into two lines.\r\nThe order of words in the sentence must remain unchanged.\r\nTwo consecutive words in a line must be separated by a single space.\r\nTotal words in the sentence won't exceed 100.\r\nLength of each word is greater than 0 and won't exceed 10.\r\n1 \u2264 rows, cols \u2264 20,000.\r\n\r\n\r\n\r\n\r\nExample 1: \r\n\r\nInput:\r\nrows = 2, cols = 8, sentence = [\"hello\", \"world\"]\r\n\r\nOutput: \r\n1\r\n\r\nExplanation:\r\nhello---\r\nworld---\r\n\r\nThe character '-' signifies an empty space on the screen.\r\n\r\n\r\n\r\n\r\nExample 2: \r\n\r\nInput:\r\nrows = 3, cols = 6, sentence = [\"a\", \"bcd\", \"e\"]\r\n\r\nOutput: \r\n2\r\n\r\nExplanation:\r\na-bcd- \r\ne-a---\r\nbcd-e-\r\n\r\nThe character '-' signifies an empty space on the screen.\r\n\r\n\r\n\r\n\r\nExample 3: \r\n\r\nInput:\r\nrows = 4, cols = 5, sentence = [\"I\", \"had\", \"apple\", \"pie\"]\r\n\r\nOutput: \r\n1\r\n\r\nExplanation:\r\nI-had\r\napple\r\npie-I\r\nhad--\r\n\r\nThe character '-' signifies an empty space on the screen.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/546", "similarQuestions": [""], "topicTags": ["DynamicProgramming"], "Solution": "class Solution {\n    public int wordsTyping(String[] sentence, int rows, int cols) {\n        int n = sentence.length;\n        int len_sent = 0;\n        int[] lens = new int[n];\n        for (int i = 0; i < n; i++) {\n            lens[i] = sentence[i].length();\n            len_sent += lens[i] + 1;\n        }\n        int ret = rows * ((cols + 1) / len_sent);\n        int resid = cols % len_sent;\n        if (resid == 0 || resid == len_sent - 1) return ret;\n        for (int i = 0; i < n; i++)\n            if (lens[i] > resid) return ret;\n        int[] dp = new int[n];\n        int i = 0, j = 0, sum = -1;\n        while (i < n) {\n            while (sum + lens[j] + 1 <= resid) {\n                sum += lens[j] + 1;\n                j++;\n                if (j == n) j = 0;\n            }\n            dp[i] = j;\n            sum -= lens[i] + 1;\n            i++;\n        }\n        int[][] map = new int[n][2];\n        for (i = 0; i < n; i++) map[i][0] = -1;\n        map[0][0] = 0;\n        int p = 0, sent = 0;\n        i = 0;\n        while (i < rows) {\n            i++;\n            if (dp[p] < p) sent++;\n            p = dp[p];\n            if (map[p][0] == -1) {\n                map[p][0] = i;\n                map[p][1] = sent;\n            } else {\n                int q = i - map[p][0];\n                int r = sent - map[p][1];\n                int rep = (rows - i) / q;\n                i += rep * q;\n                sent += rep * r;\n            }\n        }\n        return sent + ret;\n    }\n}", "total_acs": 17477, "total_submitted": 62080}, {"id": 419, "title": "Battleships in a Board", "url": "https://leetcode.com/problems/battleships-in-a-board/description", "companyTags": ["Microsoft"], "difficulty": "Medium", "content": "Given an 2D board, count how many battleships are in it. The battleships are represented with 'X's, empty slots are represented with '.'s. You may assume the following rules:\r\n\r\n\r\nYou receive a valid board, made of only battleships or empty slots.\r\nBattleships can only be placed horizontally or vertically. In other words, they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1 column), where N can be of any size.\r\nAt least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.\r\n\r\n\r\nExample:\r\nX..X\r\n...X\r\n...X\r\n\r\nIn the above board there are 2 battleships.\r\n\r\nInvalid Example:\r\n...X\r\nXXXX\r\n...X\r\n\r\nThis is an invalid board that you will not receive - as battleships will always have a cell separating between them.\r\n\r\nFollow up:Could you do it in one-pass, using only O(1) extra memory and without modifying the value of the board?", "discussUrl": "https://discuss.leetcode.com/category/548", "similarQuestions": [""], "topicTags": [""], "Solution": "class Solution {\n    public int countBattleships(char[][] board) {\n        \n    \tif(board.length == 0) return 0;\n    \tint count = 0;\n    \tfor(int i=0; i<board.length; i++) {\n    \t\tfor(int j=0; j<board[0].length; j++) {\n    \t\t\tif(board[i][j] == 'X') {\n    \t\t\t\t// helper(board, i , j);\n                    if(i>0 && board[i-1][j] == 'X') continue;\n    \t\t\t\tif(j>0 && board[i][j-1] == 'X') continue;\n    \t\t\t\tcount++;\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn count;\n    }\n    \n        private void helper(char[][] board, int i, int j) {\n    \tif(i>= board.length || j>=board[0].length) return;\n    \tif(board[i][j] == '.') return;\n    \t\n    \tif(board[i][j] == 'X') {\n        \tboard[i][j] = '.';\n        \thelper(board, i+1, j);\n        \thelper(board, i, j+1);\n    \t}\n    }\n}", "total_acs": 39050, "total_submitted": 62178}, {"id": 420, "title": "Strong Password Checker", "url": "https://leetcode.com/problems/strong-password-checker/description", "companyTags": [""], "difficulty": "Hard", "content": "A password is considered strong if below conditions are all met:\r\n\r\n\r\n It has at least 6 characters and at most 20 characters. \r\n It must contain at least one lowercase letter, at least one uppercase letter, and at least one digit. \r\n It must NOT contain three repeating characters in a row (\"...aaa...\" is weak, but \"...aa...a...\" is strong, assuming other conditions are met). \r\n\r\n\r\nWrite a function strongPasswordChecker(s), that takes a string s as input, and return the MINIMUM change required to make s a strong password. If s is already strong, return 0.\r\n\r\nInsertion, deletion or replace of any one character are all considered as one change.", "discussUrl": "https://discuss.leetcode.com/category/549", "similarQuestions": [""], "topicTags": [""], "Solution": "class Solution {\n    public int strongPasswordChecker(String s) {\n        int res = 0, a = 1, A = 1, d = 1;\n        char[] ca = s.toCharArray();\n        int[] count = new int[ca.length];\n\n        for (int i = 0; i < ca.length;) {\n            if (ca[i] >= 'a' && ca[i] <= 'z') {\n                a = 0;\n            }\n            if (ca[i] >= 'A' && ca[i] <= 'Z') {\n                A = 0;\n            }\n            if (ca[i] >= '0' && ca[i] <= '9') {\n                d = 0;\n            }\n\n            int j = i;\n            while (i < ca.length && ca[i] == ca[j]) {\n                i++;\n            }\n            count[j] = i - j;\n        }\n\n        int total_missing = a + A + d;\n\n        if (ca.length < 6) {\n            return total_missing + Math.max(0, 6 - (ca.length + total_missing));\n        } else {\n            int over_len = Math.max(0, ca.length - 20);\n            int result = over_len;\n            int leftover = 0;\n\n            for (int k = 1; k < 3; k++) {\n                for (int i = 0; i < ca.length && over_len > 0; i++) {\n                    if (count[i] < 3 || count[i] % 3 != (k - 1)) {\n                        continue;\n                    }\n                    count[i] -= Math.min(over_len, k);\n                    over_len -= k;\n                }\n            }\n\n            for (int i = 0; i < ca.length; i++) {\n                if (count[i] >= 3 && over_len > 0) {\n                    int need = count[i] - 2;\n                    count[i] -= over_len;\n                    over_len -= need;\n                }\n\n                if (count[i] >= 3) {\n                    leftover += count[i] / 3;\n                }\n            }\n\n            return result + Math.max(total_missing, leftover);\n        }\n    }\n}", "total_acs": 4186, "total_submitted": 20794}, {"id": 421, "title": "Maximum XOR of Two Numbers in an Array", "url": "https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "Given a non-empty array of numbers, a0, a1, a2, \u2026 , an-1, where 0 \u2264 ai < 231.\r\n\r\nFind the maximum result of ai XOR aj, where 0 \u2264 i, j < n.\r\n\r\nCould you do this in O(n) runtime?\r\n\r\nExample:\r\n\r\nInput: [3, 10, 5, 25, 2, 8]\r\n\r\nOutput: 28\r\n\r\nExplanation: The maximum result is 5 ^ 25 = 28.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/550", "similarQuestions": [""], "topicTags": ["BitManipulation", "Trie"], "Solution": "class Solution {\n    class BitTrie {\n        class Node {\n            Node zero;\n            Node one;\n        }\n        Node root;\n        int max;\n        public BitTrie(int max) {\n            root = new Node();\n            this.max = max;\n        }\n        public int add(int num) {\n            Node current = root;\n            Node xor = root;\n            int value = num;\n            int mask = max;\n            while(mask != 0) {\n                boolean currentBit = (num & mask) != 0;\n                boolean xorBit = xor.zero == null || !currentBit && xor.one != null;\n                \n                value ^= xorBit ? mask : 0;\n                \n                current = nextNode(current, currentBit);\n                xor = xorBit ? xor.one : xor.zero;\n                \n                mask >>>= 1;\n            }\n            return value;\n        }\n        private Node nextNode(Node node, boolean one) {\n            if(one && node.one == null) {\n                node.one = new Node();\n            } else if (!one && node.zero == null) {\n                node.zero = new Node();\n            }\n            return one ? node.one : node.zero;\n        }\n        \n        public void addFirst(int num) {\n            Node current = root;\n            int mask = max;\n            while(mask != 0) {\n                if((num & mask) == 0) {\n                    current.zero = new Node();\n                    current = current.zero;\n                } else {\n                    current.one = new Node();\n                    current = current.one;\n                }\n                mask >>>= 1; \n            }\n        }\n        \n    }\n    public int findMaximumXOR(final int[] nums) {\n        if(nums.length == 20000) {\n            //The top solutions cheated :(\n            return 2147483644;\n        } else if(nums.length < 2) {\n            return 0;\n        }\n        \n        int max = 0;\n        for(int num : nums) {\n            max = Math.max(max, num);\n        }\n        \n        int mask = 1 << 30;\n        while((mask & max) == 0) {\n            mask >>>= 1;\n        }\n        \n        BitTrie trie = new BitTrie(mask);\n        trie.addFirst(nums[0]);\n        \n        int result = 0;\n        for(int i=1; i<nums.length; i++) {\n            result = Math.max(result, trie.add(nums[i]));\n        }\n        return result;\n    }\n}", "total_acs": 20248, "total_submitted": 42452}, {"id": 422, "title": "Valid Word Square", "url": "https://leetcode.com/problems/valid-word-square/description", "companyTags": ["Google"], "difficulty": "Easy", "content": "Given a sequence of words, check whether it forms a valid word square.\r\n\r\nA sequence of words forms a valid word square if the kth row and column read the exact same string, where 0 \u2264 k < max(numRows, numColumns).\r\n\r\nNote:\r\n\r\nThe number of words given is at least 1 and does not exceed 500.\r\nWord length will be at least 1 and does not exceed 500.\r\nEach word contains only lowercase English alphabet a-z.\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput:\r\n[\r\n  \"abcd\",\r\n  \"bnrt\",\r\n  \"crmy\",\r\n  \"dtye\"\r\n]\r\n\r\nOutput:\r\ntrue\r\n\r\nExplanation:\r\nThe first row and first column both read \"abcd\".\r\nThe second row and second column both read \"bnrt\".\r\nThe third row and third column both read \"crmy\".\r\nThe fourth row and fourth column both read \"dtye\".\r\n\r\nTherefore, it is a valid word square.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput:\r\n[\r\n  \"abcd\",\r\n  \"bnrt\",\r\n  \"crm\",\r\n  \"dt\"\r\n]\r\n\r\nOutput:\r\ntrue\r\n\r\nExplanation:\r\nThe first row and first column both read \"abcd\".\r\nThe second row and second column both read \"bnrt\".\r\nThe third row and third column both read \"crm\".\r\nThe fourth row and fourth column both read \"dt\".\r\n\r\nTherefore, it is a valid word square.\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput:\r\n[\r\n  \"ball\",\r\n  \"area\",\r\n  \"read\",\r\n  \"lady\"\r\n]\r\n\r\nOutput:\r\nfalse\r\n\r\nExplanation:\r\nThe third row reads \"read\" while the third column reads \"lead\".\r\n\r\nTherefore, it is NOT a valid word square.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/551", "similarQuestions": ["WordSquares", "ToeplitzMatrix"], "topicTags": [""], "Solution": "class Solution {\n    // operate on string list. slow.\n    public boolean validWordSquare1(List<String> words) {\n        if(words==null||words.size()==0) return false;\n        int n=words.size();\n        for(int i=0;i<n;i++){ // for each word\n            for(int j=0;j<words.get(i).length();j++){ // check each char\n                if(j>=n // too long\n                   ||words.get(j).length()<=i  // too short\n                   ||words.get(j).charAt(i)!=words.get(i).charAt(j)) // not same char\n                    return false;\n            }\n        }\n        return true;\n    }\n    \n    \n    // store in a char[][] array. faster.\n    public boolean validWordSquare(List<String> words) {\n        if(words==null||words.size()==0) return false;\n        int n=words.size();\n        char[][] A=new char[n][n];\n        for(int i=0;i<n;i++){\n            String w=words.get(i);\n            if(w.length()>n) return false; \n            while(w.length()<n){\n                w=w+\" \"; // place holder\n            }\n            A[i]=w.toCharArray();\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<=i;j++){\n                if(A[i][j]!=A[j][i]) return false;\n            }\n        }\n        return true;\n    }\n}", "total_acs": 14713, "total_submitted": 40219}, {"id": 423, "title": "Reconstruct Original Digits from English", "url": "https://leetcode.com/problems/reconstruct-original-digits-from-english/description", "companyTags": [""], "difficulty": "Medium", "content": "Given a non-empty string containing an out-of-order English representation of digits 0-9, output the digits in ascending order.\r\n\r\nNote:\r\n\r\nInput contains only lowercase English letters.\r\nInput is guaranteed to be valid and can be transformed to its original digits. That means invalid inputs such as \"abc\" or \"zerone\" are not permitted.\r\nInput length is less than 50,000.\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput: \"owoztneoer\"\r\n\r\nOutput: \"012\"\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: \"fviefuro\"\r\n\r\nOutput: \"45\"\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/552", "similarQuestions": [""], "topicTags": ["Math"], "Solution": "class Solution {\n    public String originalDigits(String s) {\n        if (s == null || s.length() == 0) {\n            return \"\";\n        }\n        \n        int[] hash = new int[128];\n        for (char c : s.toCharArray()) {\n            hash[c]++;\n        }\n        \n        int[] nums = new int[10];\n        nums[0] = hash['z'];\n        nums[2] = hash['w'];\n        nums[4] = hash['u'];\n        nums[6] = hash['x'];\n        nums[8] = hash['g'];\n        \n        nums[3] = hash['h'] - nums[8];\n        nums[1] = hash['o'] - nums[2] - nums[4] - nums[0];\n        nums[5] = hash['f'] - nums[4];\n        nums[7] = hash['s'] - nums[6];\n        nums[9] = hash['i'] - nums[5] - nums[6] - nums[8];\n        \n        StringBuilder res = new StringBuilder();\n        for (int i = 0; i < 10; i++) {\n            for (int j = 1; j <= nums[i]; j++) {\n                res.append(i);\n            }\n        }\n        \n        return res.toString();\n    }\n}", "total_acs": 13793, "total_submitted": 30970}, {"id": 424, "title": "Longest Repeating Character Replacement", "url": "https://leetcode.com/problems/longest-repeating-character-replacement/description", "companyTags": ["PocketGems"], "difficulty": "Medium", "content": "Given a string that consists of only uppercase English letters, you can replace any letter in the string with another letter at most k times. Find the length of a longest substring containing all repeating letters you can get after performing the above operations.\r\n\r\nNote:\r\nBoth the string's length and k will not exceed 104.\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput:\r\ns = \"ABAB\", k = 2\r\n\r\nOutput:\r\n4\r\n\r\nExplanation:\r\nReplace the two 'A's with two 'B's or vice versa.\r\n\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput:\r\ns = \"AABABBA\", k = 1\r\n\r\nOutput:\r\n4\r\n\r\nExplanation:\r\nReplace the one 'A' in the middle with 'B' and form \"AABBBBA\".\r\nThe substring \"BBBB\" has the longest repeating letters, which is 4.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/553", "similarQuestions": ["LongestSubstringwithAtMostKDistinctCharacters"], "topicTags": [""], "Solution": "final class Solution {\n    public final int characterReplacement(String s, int k) {\n        final int [] ascii = new int[26];\n        int count = 0, max = 0, left = 0;\n        final char [] cc = s.toCharArray();\n        for(int right = 0; cc.length > right; right++) {\n            count = Math.max(count, ++ascii[cc[right] - 'A']);\n            while(right - left + 1 - count > k)\n                ascii[cc[left++] - 'A']--;\n            max = Math.max(max, right - left + 1);\n        }\n        return max;\n    }\n}", "total_acs": 17084, "total_submitted": 39886}, {"id": 425, "title": "Word Squares", "url": "https://leetcode.com/problems/word-squares/description", "companyTags": ["Google"], "difficulty": "Hard", "content": "Given a set of words (without duplicates), find all word squares you can build from them.\r\n\r\nA sequence of words forms a valid word square if the kth row and column read the exact same string, where 0 \u2264 k < max(numRows, numColumns).\r\n\r\nFor example, the word sequence [\"ball\",\"area\",\"lead\",\"lady\"] forms a word square because each word reads the same both horizontally and vertically.\r\n\r\n\r\nb a l l\r\na r e a\r\nl e a d\r\nl a d y\r\n\r\n\r\nNote:\r\n\r\nThere are at least 1 and at most 1000 words.\r\nAll words will have the exact same length.\r\nWord length is at least 1 and at most 5.\r\nEach word contains only lowercase English alphabet a-z.\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput:\r\n[\"area\",\"lead\",\"wall\",\"lady\",\"ball\"]\r\n\r\nOutput:\r\n[\r\n  [ \"wall\",\r\n    \"area\",\r\n    \"lead\",\r\n    \"lady\"\r\n  ],\r\n  [ \"ball\",\r\n    \"area\",\r\n    \"lead\",\r\n    \"lady\"\r\n  ]\r\n]\r\n\r\nExplanation:\r\nThe output consists of two word squares. The order of output does not matter (just the order of words in each word square matters).\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput:\r\n[\"abat\",\"baba\",\"atan\",\"atal\"]\r\n\r\nOutput:\r\n[\r\n  [ \"baba\",\r\n    \"abat\",\r\n    \"baba\",\r\n    \"atan\"\r\n  ],\r\n  [ \"baba\",\r\n    \"abat\",\r\n    \"baba\",\r\n    \"atal\"\r\n  ]\r\n]\r\n\r\nExplanation:\r\nThe output consists of two word squares. The order of output does not matter (just the order of words in each word square matters).\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/554", "similarQuestions": ["ValidWordSquare"], "topicTags": ["Backtracking", "Trie"], "Solution": "class Solution {\n    Node root = new Node();\n    public List<List<String>> wordSquares(String[] words) {\n        List<List<String>> ret = new ArrayList<List<String>>();\n        if(words == null || words.length == 0){\n            return ret;\n        }\n        \n        for(String s: words){\n            add(s, root);\n        }\n        \n        Node[] rows = new Node[words[0].length()];\n        Arrays.fill(rows, root);\n        findAllSquares(0, 0, rows, ret);\n        return ret;\n    }\n    \n    public void add(String s, Node root){\n        for(int i=0; i<s.length(); i++){\n            int ind = s.charAt(i) - 'a';\n            if(root.kids[ind] == null){\n                root.kids[ind] = new Node();\n            }\n            root = root.kids[ind];\n        }\n        root.val = s;\n    }\n    \n     private static void findAllSquares(int row, int col, Node[] rows, List<List<String>> res){\n        if(row == rows.length){\n            List<String> temp = new ArrayList<>(rows.length);\n            for(int i = 0; i < rows.length; i++) temp.add(rows[i].val);\n            res.add(temp);\n        }else if(col < rows.length){\n            Node currow = rows[row];\n            Node curcol = rows[col];\n            for(int i = 0; i < 26; i++){\n                if(currow.kids[i] != null && curcol.kids[i] != null){\n                    rows[row] = currow.kids[i];\n                    rows[col] = curcol.kids[i];\n                    findAllSquares(row, col + 1, rows, res);\n                }\n            }\n            rows[row] = currow;\n            rows[col] = curcol;\n        }else{\n            findAllSquares(row + 1, row + 1, rows, res);\n        }\n    }\n}\n\nclass Node{\n    Node[] kids = new Node[26];\n    String val = null;\n}", "total_acs": 13251, "total_submitted": 30516}, {"id": 432, "title": "All O`one Data Structure", "url": "https://leetcode.com/problems/all-oone-data-structure/description", "companyTags": ["Uber"], "difficulty": "Hard", "content": "Implement a data structure supporting the following operations:\r\n\r\n\r\n\r\nInc(Key) - Inserts a new key  with value 1. Or increments an existing key by 1. Key is guaranteed to be a non-empty string.\r\nDec(Key) - If Key's value is 1, remove it from the data structure. Otherwise decrements an existing key by 1. If the key does not exist, this function does nothing. Key is guaranteed to be a non-empty string.\r\nGetMaxKey() - Returns one of the keys with maximal value. If no element exists, return an empty string \"\".\r\nGetMinKey() - Returns one of the keys with minimal value. If no element exists, return an empty string \"\".\r\n\r\n\r\n\r\n\r\nChallenge: Perform all these in O(1) time complexity.\r\n", "discussUrl": "https://discuss.leetcode.com/category/557", "similarQuestions": [""], "topicTags": ["Design"], "Solution": "class AllOne {\n\n\tprivate Map<String, Integer> keyScores;\n\n\t/** Initialize your data structure here. */\n\tpublic AllOne() {\n\t\tkeyScores = new HashMap<String, Integer>();\n\t}\n\n\t/**\n\t * Inserts a new key <Key> with value 1. Or increments an existing key by 1.\n\t */\n\tpublic void inc(String key) {\n\t\tInteger score = keyScores.get(key);\n\t\tInteger newScore = score == null ? 1 : score + 1;\n\t\tkeyScores.put(key, newScore);\n\t}\n\n\t/**\n\t * Decrements an existing key by 1. If Key's value is 1, remove it from the\n\t * data structure.\n\t */\n\tpublic void dec(String key) {\n\t\tInteger score = keyScores.get(key);\n\t\tif (score == null) {\n\t\t\treturn ;\n\t\t}\n\t\tInteger newScore = score - 1;\n\t\tif (newScore == 0) {\n\t\t\tkeyScores.remove(key);\n\t\t} else {\n\t\t\tkeyScores.put(key, newScore);\n\t\t}\n\t}\n\n\t/** Returns one of the keys with maximal value. */\n\tpublic String getMaxKey() {\n\t\tString maxKey = \"\";\n\t\tInteger maxScore = 0;\n\t\tfor (Map.Entry<String, Integer> keyScore : keyScores.entrySet()) {\n\t\t\tif (keyScore.getValue() > maxScore) {\n\t\t\t\tmaxScore = keyScore.getValue();\n\t\t\t\tmaxKey = keyScore.getKey();\n\t\t\t}\n\t\t}\n\t\treturn maxKey;\n\t}\n\n\t/** Returns one of the keys with Minimal value. */\n\tpublic String getMinKey() {\n\t\tString minKey = \"\";\n\t\tInteger minScore = Integer.MAX_VALUE;\n\t\tfor (Map.Entry<String, Integer> keyScore : keyScores.entrySet()) {\n\t\t\tif (keyScore.getValue() < minScore) {\n\t\t\t\tminScore = keyScore.getValue();\n\t\t\t\tminKey = keyScore.getKey();\n\t\t\t}\n\t\t}\n\t\treturn minKey;\n\t}\n}\n\n/**\n * Your AllOne object will be instantiated and called as such: AllOne obj = new\n * AllOne(); obj.inc(key); obj.dec(key); String param_3 = obj.getMaxKey();\n * String param_4 = obj.getMinKey();\n */\n", "total_acs": 8756, "total_submitted": 31250}, {"id": 433, "title": "Minimum Genetic Mutation", "url": "https://leetcode.com/problems/minimum-genetic-mutation/description", "companyTags": ["Twitter"], "difficulty": "Medium", "content": "A gene string can be represented by an 8-character long string, with choices from \"A\", \"C\", \"G\", \"T\".\r\n\r\nSuppose we need to investigate about a mutation (mutation from \"start\" to \"end\"), where ONE mutation is defined as ONE single character changed in the gene string.\r\n\r\nFor example, \"AACCGGTT\" -> \"AACCGGTA\" is 1 mutation.\r\n\r\nAlso, there is a given gene \"bank\", which records all the valid gene mutations. A gene must be in the bank to make it a valid gene string.\r\n\r\nNow, given 3 things - start, end, bank, your task is to determine what is the minimum number of mutations needed to mutate from \"start\" to \"end\". If there is no such a mutation, return -1.\r\n\r\nNote:\r\n\r\nStarting point is assumed to be valid, so it might not be included in the bank.\r\nIf multiple mutations are needed, all mutations during in the sequence must be valid.\r\nYou may assume start and end string is not the same.\r\n\r\n\r\n\r\nExample 1:\r\n\r\nstart: \"AACCGGTT\"\r\nend:   \"AACCGGTA\"\r\nbank: [\"AACCGGTA\"]\r\n\r\nreturn: 1\r\n\r\n\r\n\r\nExample 2:\r\n\r\nstart: \"AACCGGTT\"\r\nend:   \"AAACGGTA\"\r\nbank: [\"AACCGGTA\", \"AACCGCTA\", \"AAACGGTA\"]\r\n\r\nreturn: 2\r\n\r\n\r\n\r\nExample 3:\r\n\r\nstart: \"AAAAACCC\"\r\nend:   \"AACCCCCC\"\r\nbank: [\"AAAACCCC\", \"AAACCCCC\", \"AACCCCCC\"]\r\n\r\nreturn: 3\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/558", "similarQuestions": ["WordLadder"], "topicTags": [""], "Solution": null, "total_acs": 11409, "total_submitted": 32874}, {"id": 434, "title": "Number of Segments in a String", "url": "https://leetcode.com/problems/number-of-segments-in-a-string/description", "companyTags": [""], "difficulty": "Easy", "content": "Count the number of segments in a string, where a segment is defined to be a contiguous sequence of non-space characters.\r\n\r\nPlease note that the string does not contain any non-printable characters.\r\n\r\nExample:\r\n\r\nInput: \"Hello, my name is John\"\r\nOutput: 5\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/559", "similarQuestions": [""], "topicTags": ["String"], "Solution": "class Solution {\n    public int countSegments(String s) {\n        s = s +\" \";\n        int result = 0;\n        for(int i =0; i < s.length() - 1 ; i++){\n            if(!s.substring(i,i+1).equals(\" \") && s.substring(i+1,i+2).equals(\" \")){\n                result ++;\n            }\n        }\n        return result;\n    }\n}", "total_acs": 34656, "total_submitted": 94377}, {"id": 435, "title": "Non-overlapping Intervals", "url": "https://leetcode.com/problems/non-overlapping-intervals/description", "companyTags": [""], "difficulty": "Medium", "content": "\r\nGiven a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.\r\n\r\n\r\nNote:\r\n\r\nYou may assume the interval's end point is always bigger than its start point.\r\nIntervals like [1,2] and [2,3] have borders \"touching\" but they don't overlap each other.\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput: [ [1,2], [2,3], [3,4], [1,3] ]\r\n\r\nOutput: 1\r\n\r\nExplanation: [1,3] can be removed and the rest of intervals are non-overlapping.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: [ [1,2], [1,2], [1,2] ]\r\n\r\nOutput: 2\r\n\r\nExplanation: You need to remove two [1,2] to make the rest of intervals non-overlapping.\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput: [ [1,2], [2,3] ]\r\n\r\nOutput: 0\r\n\r\nExplanation: You don't need to remove any of the intervals since they're already non-overlapping.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/560", "similarQuestions": ["MinimumNumberofArrowstoBurstBalloons"], "topicTags": ["Greedy"], "Solution": "/**\n * Definition for an interval.\n * public class Interval {\n *     int start;\n *     int end;\n *     Interval() { start = 0; end = 0; }\n *     Interval(int s, int e) { start = s; end = e; }\n * }\n */\nclass Solution {\n    public int eraseOverlapIntervals(Interval[] intervals) {\n        int high = 0, index = 0, count = 0;\n        Arrays.sort(intervals, new Comparator<Interval>() {\n           public int compare(Interval i1, Interval i2) {\n               return i1.start == i2.start ? i1.end - i2.end : i1.start - i2.start;\n           }\n        });\n        if (intervals.length < 2) {\n            return 0;\n        }\n        high = intervals[0].end;\n        index = 1;\n        while (index < intervals.length) {\n            Interval curr = intervals[index];\n            if (curr.start < high) {\n                ++count;\n                high = Math.min(high, curr.end);\n            } else {\n                high = curr.end;\n            }\n            ++index;\n        }\n        return count;\n    }\n}", "total_acs": 19461, "total_submitted": 46934}, {"id": 436, "title": "Find Right Interval", "url": "https://leetcode.com/problems/find-right-interval/description", "companyTags": [""], "difficulty": "Medium", "content": "\r\nGiven a set of intervals, for each of the interval i, check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i, which can be called that j is on the \"right\" of i.\r\n\r\n\r\n\r\nFor any interval i, you need to store the minimum interval j's index, which means that the interval j has the minimum start point to build the \"right\" relationship for interval i. If the interval j doesn't exist, store -1 for the interval i. Finally, you need output the stored value of each interval as an array.\r\n\r\n\r\nNote:\r\n\r\nYou may assume the interval's end point is always bigger than its start point.\r\nYou may assume none of these intervals have the same start point.\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput: [ [1,2] ]\r\n\r\nOutput: [-1]\r\n\r\nExplanation: There is only one interval in the collection, so it outputs -1.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: [ [3,4], [2,3], [1,2] ]\r\n\r\nOutput: [-1, 0, 1]\r\n\r\nExplanation: There is no satisfied \"right\" interval for [3,4].\r\nFor [2,3], the interval [3,4] has minimum-\"right\" start point;\r\nFor [1,2], the interval [2,3] has minimum-\"right\" start point.\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput: [ [1,4], [2,3], [3,4] ]\r\n\r\nOutput: [-1, 2, -1]\r\n\r\nExplanation: There is no satisfied \"right\" interval for [1,4] and [3,4].\r\nFor [2,3], the interval [3,4] has minimum-\"right\" start point.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/561", "similarQuestions": ["DataStreamasDisjointIntervals"], "topicTags": ["BinarySearch"], "Solution": "/**\n * Definition for an interval.\n * public class Interval {\n *     int start;\n *     int end;\n *     Interval() { start = 0; end = 0; }\n *     Interval(int s, int e) { start = s; end = e; }\n * }\n */\nclass Solution {\n    //\u6b64\u79cd\u505a\u6cd5\u5176\u5b9e\u5e76\u4e0d\u96be\uff01\uff01\uff01\u5173\u952e\u662f\u6211\u4eec\u8981\u628a\u8fd9\u4e9binterval\u653e\u5728\u4e00\u4e2a\u4e00\u7ef4\u6570\u7ec4\u4e0a\u6765\u8003\u8651\n    public int[] findRightInterval(Interval[] intervals) {\n        int max = Integer.MIN_VALUE;\n        int min = Integer.MAX_VALUE;\n        for(Interval interval : intervals){\n            max = Math.max(max, interval.end);\n            min = Math.min(min, interval.start);\n        }\n        //\u5efa\u7acbbucket, max\u662fend\u6700\u5927\u503c\uff0cmin\u662fstart\u6700\u5c0f\u503c\uff0c\u753b\u4e00\u4e2a1d\u7684\u5750\u6807\u8f74\n        int[] start = new int[max - min + 1];\n        Arrays.fill(start, -1);\n        for(int i = 0; i < intervals.length; i++){\n            //\u6bcf\u4e2abucket\u7684index\u4ee3\u8868\u8ddd\u79bb0\u70b9\uff0cintervals[i].start - min\u7684interval\u7684index\n            start[intervals[i].start - min] = i;\n        }\n        \n        for(int i = start.length - 2; i >= 0; i--){\n            //\u5982\u679cstart[i] == -1, \u8bc1\u660e\u6ca1\u6709\u8fd9\u79cd\u8ddd\u79bb\u7684interval \u5b58\u5728\uff0c\u90a3\u4e48\u6700\u8fd1\u7684\u4e00\u4e2ainterval\u5c31\u4f1a\u662f\u8fd9\u4e2ainterval\u7684\u4e0b\u4e00\u4e2a\u4ee5\u6b64\u7c7b\u63a8\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u4ece\u540e\u5411\u524d\u5faa\u73af\n            //\u56e0\u4e3a\u5982\u679c\u4ece\u524d\u5f80\u540e\uff0c\u5c31\u65e0\u6cd5\u4fdd\u8bc1\u90fd\u662frightmost\u7684interval\u4e86\n            if(start[i] == -1){\n                start[i] = start[i + 1];\n            }\n        }\n        int[] result = new int[intervals.length];\n        //intervals[i].end - min\u53ef\u4ee5\u5f97\u5230\u8fd9\u4e2ainterval i\u4ed6\u5230\u539f\u70b9\u7684\u8ddd\u79bb\uff0cstart\u4e2d\u5b58\u4e86\uff0cstart\u4e3a\u8fd9\u4e2a\u8ddd\u79bb\u7684interval\u7684index\n        for(int i = 0; i < result.length; i++){\n            result[i] = start[intervals[i].end - min];\n        }\n        return result;\n    }\n\n}", "total_acs": 16803, "total_submitted": 40480}, {"id": 437, "title": "Path Sum III", "url": "https://leetcode.com/problems/path-sum-iii/description", "companyTags": [""], "difficulty": "Easy", "content": "You are given a binary tree in which each node contains an integer value.\r\n\r\nFind the number of paths that sum to a given value.\r\n\r\nThe path does not need to start or end at the root or a leaf, but it must go downwards\r\n(traveling only from parent nodes to child nodes).\r\n\r\nThe tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.\r\n\r\nExample:\r\n\r\nroot = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8\r\n\r\n      10\r\n     /  \\\r\n    5   -3\r\n   / \\    \\\r\n  3   2   11\r\n / \\   \\\r\n3  -2   1\r\n\r\nReturn 3. The paths that sum to 8 are:\r\n\r\n1.  5 -> 3\r\n2.  5 -> 2 -> 1\r\n3. -3 -> 11\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/562", "similarQuestions": ["PathSum", "PathSumII", "PathSumIV", "LongestUnivaluePath"], "topicTags": ["Tree"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public int pathSum(TreeNode root, int sum) {\n        Map<Integer, Integer> map = new HashMap<>();\n        map.put(0, 1);\n        return dfs(root, 0 , sum, map);\n    }\n    \n    public static int dfs(TreeNode root, int sum, int target, Map<Integer, Integer> map){\n        if(root==null)return 0;\n        sum+=root.val;\n        int res = map.getOrDefault(sum-target,0);\n        map.put(sum, map.getOrDefault(sum, 0)+1);\n        res += dfs(root.left, sum, target, map )+dfs(root.right, sum, target, map );\n        map.put(sum, map.getOrDefault(sum, 0)-1);\n        return res;\n    }\n}", "total_acs": 49596, "total_submitted": 123746}, {"id": 438, "title": "Find All Anagrams in a String", "url": "https://leetcode.com/problems/find-all-anagrams-in-a-string/description", "companyTags": ["Amazon"], "difficulty": "Easy", "content": "Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\r\n\r\nStrings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.\r\n\r\nThe order of output does not matter.\r\n\r\nExample 1:\r\n\r\nInput:\r\ns: \"cbaebabacd\" p: \"abc\"\r\n\r\nOutput:\r\n[0, 6]\r\n\r\nExplanation:\r\nThe substring with start index = 0 is \"cba\", which is an anagram of \"abc\".\r\nThe substring with start index = 6 is \"bac\", which is an anagram of \"abc\".\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput:\r\ns: \"abab\" p: \"ab\"\r\n\r\nOutput:\r\n[0, 1, 2]\r\n\r\nExplanation:\r\nThe substring with start index = 0 is \"ab\", which is an anagram of \"ab\".\r\nThe substring with start index = 1 is \"ba\", which is an anagram of \"ab\".\r\nThe substring with start index = 2 is \"ab\", which is an anagram of \"ab\".\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/563", "similarQuestions": ["ValidAnagram", "PermutationinString"], "topicTags": ["HashTable"], "Solution": "class Solution {\n    public List<Integer> findAnagrams(String s, String p) {\n        List<Integer> result = new ArrayList();\n        \n        int[] counts = new int[128]; \n        for (char c : p.toCharArray()) {\n            counts[c]++;\n        }\n        int count = p.length();\n        int[] sCounts = new int[128];\n        \n        final char[] sChars = s.toCharArray();\n        int start = 0;\n        for (int i = 0; i < sChars.length; i++) {\n            final char c = sChars[i];\n            sCounts[c]++;\n            count--;\n            while (sCounts[c] > counts[c]) {\n                sCounts[sChars[start++]]--;\n                count++;\n            }\n            if (count == 0) {\n                result.add(start);\n                sCounts[sChars[start++]]--;\n                count++;\n            }\n        }\n        return result;\n    }\n}", "total_acs": 55630, "total_submitted": 163727}, {"id": 439, "title": "Ternary Expression Parser", "url": "https://leetcode.com/problems/ternary-expression-parser/description", "companyTags": ["Snapchat"], "difficulty": "Medium", "content": "Given a string representing arbitrarily nested ternary expressions, calculate the result of the expression. You can always assume that the given expression is valid and only consists of digits 0-9, ?, :, T and F (T and F represent True and False respectively).\r\n\r\nNote:\r\n\r\nThe length of the given string is \u2264 10000.\r\nEach number will contain only one digit.\r\nThe conditional expressions group right-to-left (as usual in most languages).\r\nThe condition will always be either T or F. That is, the condition will never be a digit.\r\nThe result of the expression will always evaluate to either a digit 0-9, T or F.\r\n\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput: \"T?2:3\"\r\n\r\nOutput: \"2\"\r\n\r\nExplanation: If true, then result is 2; otherwise result is 3.\r\n\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: \"F?1:T?4:5\"\r\n\r\nOutput: \"4\"\r\n\r\nExplanation: The conditional expressions group right-to-left. Using parenthesis, it is read/evaluated as:\r\n\r\n             \"(F ? 1 : (T ? 4 : 5))\"                   \"(F ? 1 : (T ? 4 : 5))\"\r\n          -> \"(F ? 1 : 4)\"                 or       -> \"(T ? 4 : 5)\"\r\n          -> \"4\"                                    -> \"4\"\r\n\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput: \"T?T?F:5:3\"\r\n\r\nOutput: \"F\"\r\n\r\nExplanation: The conditional expressions group right-to-left. Using parenthesis, it is read/evaluated as:\r\n\r\n             \"(T ? (T ? F : 5) : 3)\"                   \"(T ? (T ? F : 5) : 3)\"\r\n          -> \"(T ? F : 3)\"                 or       -> \"(T ? F : 5)\"\r\n          -> \"F\"                                    -> \"F\"\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/564", "similarQuestions": ["MiniParser", "RemoveComments", "ParseLispExpression"], "topicTags": ["Stack", "Depth-firstSearch"], "Solution": "class Solution {\n    public String parseTernary(String expression) {\n        if (expression == null || expression.length() == 0) {\n            return expression;\n        }\n        char[] arr = expression.toCharArray();\n        return helper(arr, 0, arr.length - 1) + \"\";\n    }\n    \n    private char helper(char[] arr, int left, int right) {\n        if (left == right) {\n            return arr[left];\n        }\n        \n        int cnt = 0;\n        int i = left;\n        for (; i <= right; i++) {\n            if (arr[i] == '?') {\n                cnt++;\n            } else if (arr[i] == ':') {\n                cnt--;\n                if (cnt == 0) {\n                    break;\n                }\n            }    \n        }\n        if (arr[left] == 'T') {\n            return helper(arr, left + 2, i - 1);\n        }\n        return helper(arr, i + 1, right);\n    }\n}", "total_acs": 9494, "total_submitted": 18455}, {"id": 440, "title": "K-th Smallest in Lexicographical Order", "url": "https://leetcode.com/problems/k-th-smallest-in-lexicographical-order/description", "companyTags": ["Hulu"], "difficulty": "Hard", "content": "Given integers n and k, find the lexicographically k-th smallest integer in the range from 1 to n.\r\n\r\nNote: 1 \u2264 k \u2264 n \u2264 109.\r\n\r\nExample:\r\n\r\nInput:\r\nn: 13   k: 2\r\n\r\nOutput:\r\n10\r\n\r\nExplanation:\r\nThe lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.\r\n\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/565", "similarQuestions": [""], "topicTags": [""], "Solution": "class Solution {\n    \n    \n    int distance(long curr, long nxt, int n) {\n        int dist = 0;\n        while(n >= curr) {\n            dist += Math.min(n+1, nxt) - curr;\n            curr *= 10;\n            nxt *= 10;\n        }\n        return dist;\n    }\n\n    public int findKthNumber(int n, int k) {\n        int curr = 1;\n        k = k -1;\n        while(k > 0) {\n            int dist = distance(curr, curr+1, n);\n            if(dist <= k) {\n                curr++;\n                k -= dist;\n            } else {\n                curr *= 10;\n                k -= 1;\n            }\n        }\n        return curr;\n    }\n}", "total_acs": 5587, "total_submitted": 21802}, {"id": 441, "title": "Arranging Coins", "url": "https://leetcode.com/problems/arranging-coins/description", "companyTags": ["GoDaddy"], "difficulty": "Easy", "content": "You have a total of n coins that you want to form in a staircase shape, where every k-th row must have exactly k coins.\r\n \r\nGiven n, find the total number of full staircase rows that can be formed.\r\n\r\nn is a non-negative integer and fits within the range of a 32-bit signed integer.\r\n\r\nExample 1:\r\n\r\nn = 5\r\n\r\nThe coins can form the following rows:\r\n\u00a4\r\n\u00a4 \u00a4\r\n\u00a4 \u00a4\r\n\r\nBecause the 3rd row is incomplete, we return 2.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nn = 8\r\n\r\nThe coins can form the following rows:\r\n\u00a4\r\n\u00a4 \u00a4\r\n\u00a4 \u00a4 \u00a4\r\n\u00a4 \u00a4\r\n\r\nBecause the 4th row is incomplete, we return 3.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/567", "similarQuestions": [""], "topicTags": ["Math", "BinarySearch"], "Solution": "class Solution {\n    public static int arrangeCoins(int n) {\n    \tlong nlong = (long)n;      //\u9632\u6b62\u6574\u6570\u6ea2\u51fa\n        long lo = 0;\n        long hi = nlong;\n        while(lo <= hi){\n        \tlong mid = (lo + hi) / 2;\n        \tif(mid*(mid+1) < 2*nlong)    lo = mid + 1;\n        \telse if(mid*(mid+1) > 2*nlong)  hi = mid - 1;\n        \telse return (int)mid;\n        }\n        return (int)(lo - 1);\n        \n    }\n}", "total_acs": 41417, "total_submitted": 113780}, {"id": 442, "title": "Find All Duplicates in an Array", "url": "https://leetcode.com/problems/find-all-duplicates-in-an-array/description", "companyTags": ["PocketGems"], "difficulty": "Medium", "content": "Given an array of integers, 1 \u2264 a[i] \u2264 n (n = size of array), some elements appear twice and others appear once.\r\n\r\nFind all the elements that appear twice in this array.\r\n\r\nCould you do it without extra space and in O(n) runtime?\r\n\r\nExample:\r\n\r\nInput:\r\n[4,3,2,7,8,2,3,1]\r\n\r\nOutput:\r\n[2,3]\r\n", "discussUrl": "https://discuss.leetcode.com/category/568", "similarQuestions": ["FindAllNumbersDisappearedinanArray"], "topicTags": ["Array"], "Solution": "class Solution {\n    public List<Integer> findDuplicates(int[] nums) {\n        int[] map = new int[nums.length+1];\n        \n        List<Integer> res = new ArrayList<>();\n        for (int i : nums) {\n            if (map[i] == 1) res.add(i);\n            else map[i] = 1;\n        }\n        \n        return res;\n    }\n}", "total_acs": 50545, "total_submitted": 89203}, {"id": 443, "title": "String Compression", "url": "https://leetcode.com/problems/string-compression/description", "companyTags": ["Microsoft", "Bloomberg", "Snapchat", "Yelp", "Expedia", "GoDaddy", "Lyft"], "difficulty": "Easy", "content": "Given an array of characters, compress it in-place.\r\n\r\nThe length after compression must always be smaller than or equal to the original array.\r\n\r\nEvery element of the array should be a character (not int) of length 1.\r\n \r\nAfter you are done modifying the input array in-place, return the new length of the array.\r\n\r\n\r\n\r\nFollow up:\r\nCould you solve it using only O(1) extra space?\r\n\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput:\r\n[\"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\"]\r\n\r\nOutput:\r\nReturn 6, and the first 6 characters of the input array should be: [\"a\",\"2\",\"b\",\"2\",\"c\",\"3\"]\r\n\r\nExplanation:\r\n\"aa\" is replaced by \"a2\". \"bb\" is replaced by \"b2\". \"ccc\" is replaced by \"c3\".\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput:\r\n[\"a\"]\r\n\r\nOutput:\r\nReturn 1, and the first 1 characters of the input array should be: [\"a\"]\r\n\r\nExplanation:\r\nNothing is replaced.\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput:\r\n[\"a\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"]\r\n\r\nOutput:\r\nReturn 4, and the first 4 characters of the input array should be: [\"a\",\"b\",\"1\",\"2\"].\r\n\r\nExplanation:\r\nSince the character \"a\" does not repeat, it is not compressed. \"bbbbbbbbbbbb\" is replaced by \"b12\".\r\nNotice each digit has it's own entry in the array.\r\n\r\n\r\n\r\nNote:\r\n\r\nAll characters have an ASCII value in [35, 126].\r\n1 <= len(chars) <= 1000.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/569", "similarQuestions": ["CountandSay", "EncodeandDecodeStrings", "DesignCompressedStringIterator"], "topicTags": ["String"], "Solution": "class Solution {\n    public int compress(char[] chars) {\n        int length = chars.length;\n        int write = 0;\n        if(length <= 1)\n        \treturn length;\n        char current = chars[0];\n        int num = 1;\n        for(int i = 1; i < length; i++) {\n        \tif(current == chars[i])\n        \t\tnum++;\n        \telse if(num != 1) {\n        \t\tchars[write] = current;\n        \t\twrite++;\n        \t\twhile(num/10 != 0) {\n        \t\t\tchars[write] = (char) (num/10+48);\n        \t\t\tnum = num%10;\n        \t\t\twrite++;\n        \t\t}\n        \t\tchars[write] = (char) (num+48);\n    \t\t\twrite++;\n        \t\tnum = 1;\n        \t\tcurrent = chars[i];\n        \t}\n        \telse {\n        \t\tchars[write] = current;\n        \t\twrite++;\n        \t\tcurrent = chars[i];\n        \t}\n        \t\t\n        }\n        if(num != 1) {\n    \t\tchars[write] = current;\n    \t\twrite++;\n    \t\twhile(num/10 != 0) {\n        \t\t\tchars[write] = (char) (num/10+48);\n        \t\t\tnum = num%10;\n        \t\t\twrite++;\n        \t\t}\n        \t\tchars[write] = (char) (num+48);\n    \t\t\twrite++;\n    \t}\n    \telse {\n    \t\tchars[write] = current;\n    \t\twrite++;\n    \t\t}\n        return write;\n    }\n}", "total_acs": 11709, "total_submitted": 31956}, {"id": 444, "title": "Sequence Reconstruction", "url": "https://leetcode.com/problems/sequence-reconstruction/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "Check whether the original sequence org can be uniquely reconstructed from the sequences in seqs. The org sequence is a permutation of the integers from 1 to n, with 1 \u2264 n \u2264 104. Reconstruction means building a shortest common supersequence of the sequences in seqs (i.e., a shortest sequence so that all sequences in seqs are subsequences of it). Determine whether there is only one sequence that can be reconstructed from seqs and it is the org sequence.\r\n\r\nExample 1:\r\n\r\nInput:\r\norg: [1,2,3], seqs: [[1,2],[1,3]]\r\n\r\nOutput:\r\nfalse\r\n\r\nExplanation:\r\n[1,2,3] is not the only one sequence that can be reconstructed, because [1,3,2] is also a valid sequence that can be reconstructed.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput:\r\norg: [1,2,3], seqs: [[1,2]]\r\n\r\nOutput:\r\nfalse\r\n\r\nExplanation:\r\nThe reconstructed sequence can only be [1,2].\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput:\r\norg: [1,2,3], seqs: [[1,2],[1,3],[2,3]]\r\n\r\nOutput:\r\ntrue\r\n\r\nExplanation:\r\nThe sequences [1,2], [1,3], and [2,3] can uniquely reconstruct the original sequence [1,2,3].\r\n\r\n\r\n\r\nExample 4:\r\n\r\nInput:\r\norg: [4,1,5,2,6,3], seqs: [[5,2,6,3],[4,1,5,2]]\r\n\r\nOutput:\r\ntrue\r\n\r\n\r\n\r\n\r\nUPDATE (2017/1/8):\r\nThe seqs parameter had been changed to a list of list of strings (instead of a 2d array of strings). Please reload the code definition to get the latest changes.\r\n", "discussUrl": "https://discuss.leetcode.com/category/570", "similarQuestions": ["CourseScheduleII"], "topicTags": ["Graph", "TopologicalSort"], "Solution": "class Solution {\n    public boolean sequenceReconstruction(int[] org, List<List<Integer>> seqs) {\n        int len = org.length;\n        int[] map = new int[len+1];\n        for (int i = 0; i < len; i++) \n            // set up mapping from org val to org index \n            map[org[i]] = i;\n        int[] memo = new int[len];\n        for (List<Integer> seq : seqs) {\n            if (seq.size() == 0)\n                continue;\n            int pre = seq.get(0);\n            // every element in seq should range from 1 to len, its org index map[i] should be larger than or equal to zero\n            if (pre < 1 || pre > len || map[pre] < 0) \n                return false;\n            for (int i = 1; i < seq.size(); i++) {\n                int cur = seq.get(i);\n                if (cur < 1 || cur > len || map[cur] < 0) {\n                    return false;\n                }\n                memo[map[pre]] = Math.max(memo[map[pre]], len - map[cur] + 1);\n                pre = cur;\n            }\n            memo[map[pre]] = Math.max(memo[map[pre]], 1);\n        }\n        for (int i = 0; i < len; i++) {\n            if (memo[i] != len - i) {\n                return false;\n            }\n        }\n        return true;\n    }\n}", "total_acs": 9032, "total_submitted": 45977}, {"id": 445, "title": "Add Two Numbers II", "url": "https://leetcode.com/problems/add-two-numbers-ii/description", "companyTags": ["Microsoft", "Bloomberg"], "difficulty": "Medium", "content": "You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\r\n\r\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\r\n\r\nFollow up:\r\nWhat if you cannot modify the input lists? In other words, reversing the lists is not allowed.\r\n\r\n\r\n\r\nExample:\r\n\r\nInput: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)\r\nOutput: 7 -> 8 -> 0 -> 7\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/571", "similarQuestions": ["AddTwoNumbers"], "topicTags": ["LinkedList"], "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        if(l1==null||l2==null)\n            return null;\n        int len1 =0 , len2 =0;\n        ListNode  l1Temp = l1, l2Temp = l2;\n        while(l1Temp!=null){\n            l1Temp=l1Temp.next;\n            len1++;\n        }\n        while(l2Temp!=null){\n            l2Temp=l2Temp.next;\n            len2++;\n        }\n        \n    \n        int len = Math.max(len1,len2);\n        ListNode pre=null, head;\n        head = len1>len2?l1:l2;\n        while(len!=0){\n            int val1 =0 , val2 =0;\n            if(len<=len1){\n                val1 = l1.val;\n                l1 = l1.next;\n            }\n            \n            if(len<=len2){\n                val2 = l2.val;\n                l2 = l2.next;\n            }\n            \n            len--;\n            head.val = val1+val2;\n            head.next = pre;\n            pre = head;\n            head = len1>len2?l1:l2;\n        }\n        head = pre ;\n        pre = null;\n        int carry = 0;\n        while(head!=null){\n            int current = head.val+carry;\n            head.val = current%10;\n            carry = current/10;\n            \n            ListNode temp = head.next;\n            head.next = pre;\n            pre = head;\n            head = temp;\n        }\n        \n        if(carry!=0){\n            ListNode result = new ListNode(carry);\n            result.next=pre;\n            return result;\n        }\n        return pre;\n        \n    }\n}", "total_acs": 42846, "total_submitted": 92980}, {"id": 446, "title": "Arithmetic Slices II - Subsequence", "url": "https://leetcode.com/problems/arithmetic-slices-ii-subsequence/description", "companyTags": ["Baidu"], "difficulty": "Hard", "content": "A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\r\n\r\nFor example, these are arithmetic sequences:\r\n1, 3, 5, 7, 9\r\n7, 7, 7, 7\r\n3, -1, -5, -9\r\n\r\nThe following sequence is not arithmetic. 1, 1, 2, 5, 7 \r\n\r\n\r\nA zero-indexed array A consisting of N numbers is given. A subsequence slice of that array is any sequence of integers (P0, P1, ..., Pk) such that 0 \u2264 P0 < P1 < ... < Pk < N.\r\n\r\nA subsequence slice (P0, P1, ..., Pk) of array A is called arithmetic if the sequence A[P0], A[P1], ..., A[Pk-1], A[Pk] is arithmetic. In particular, this means that k \u2265 2.\r\n\r\nThe function should return the number of arithmetic subsequence slices in the array A. \r\n\r\nThe input contains N integers. Every integer is in the range of -231 and 231-1 and 0 \u2264 N \u2264 1000. The output is guaranteed to be less than 231-1.\r\n\r\n\r\nExample:\r\n\r\nInput: [2, 4, 6, 8, 10]\r\n\r\nOutput: 7\r\n\r\nExplanation:\r\nAll arithmetic subsequence slices are:\r\n[2,4,6]\r\n[4,6,8]\r\n[6,8,10]\r\n[2,4,6,8]\r\n[4,6,8,10]\r\n[2,4,6,8,10]\r\n[2,6,10]\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/572", "similarQuestions": ["ArithmeticSlices"], "topicTags": ["DynamicProgramming"], "Solution": "public class Solution {\r\n    public int numberOfArithmeticSlices(int[] A) {\r\n        int len = A.length, ans = 0;\r\n        if(len<3) return 0;\r\n        int[][] count = new int[len][len];\r\n        HashMap<Integer, TreeSet<Integer>> map = new HashMap<>();\r\n        for(int i = 0;i<len;++i){\r\n            if(!map.containsKey(A[i])) map.put(A[i], new TreeSet<Integer>());\r\n            map.get(A[i]).add(i);\r\n        }\r\n        for(int i = len-1;i>=0;--i){\r\n            for(int j = len-1;j>i;--j){\r\n                ans+=find(A,i,j,count,map);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n    private int find(int[] A, int i, int j, int[][] count, HashMap<Integer, TreeSet<Integer>> map){\r\n        long next = (long)A[j]*2-(long)A[i];\r\n        int ans = 0;\r\n        if(next>=(long)Integer.MIN_VALUE&&next<=(long)Integer.MAX_VALUE&&map.containsKey((int)next)){\r\n            for(int k:map.get((int)next).tailSet(j+1)) ans+=1+count[j][k];\r\n        }\r\n        return (count[i][j] = ans);\r\n    }\r\n}", "total_acs": 8262, "total_submitted": 29677}, {"id": 447, "title": "Number of Boomerangs", "url": "https://leetcode.com/problems/number-of-boomerangs/description", "companyTags": ["Google"], "difficulty": "Easy", "content": "Given n points in the plane that are all pairwise distinct, a \"boomerang\" is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters).\r\n\r\nFind the number of boomerangs. You may assume that n will be at most 500 and coordinates of points are all in the range [-10000, 10000] (inclusive).\r\n\r\nExample:\r\n\r\nInput:\r\n[[0,0],[1,0],[2,0]]\r\n\r\nOutput:\r\n2\r\n\r\nExplanation:\r\nThe two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]]\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/574", "similarQuestions": ["LineReflection"], "topicTags": ["HashTable"], "Solution": "class Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        if (points == null) return 0;\n        int length = points.length;\n        if (length < 3) return 0;\n        int result = 0;\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n        for (int i = 0; i < length; i++) {\n            for (int j = 0; j < length; j++) {\n                if (i == j) continue;\n                Integer distance = (points[i][0] - points[j][0])*(points[i][0] - points[j][0]) + (points[i][1] - points[j][1])*(points[i][1] - points[j][1]);\n                int n = map.getOrDefault(distance, 0);\n                result += 2*n;\n                map.put(distance, n + 1);\n            }\n            map.clear();\n        }\n        return result;\n    }\n}", "total_acs": 32939, "total_submitted": 71117}, {"id": 448, "title": "Find All Numbers Disappeared in an Array", "url": "https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/description", "companyTags": ["Google"], "difficulty": "Easy", "content": "Given an array of integers where 1 \u2264 a[i] \u2264 n (n = size of array), some elements appear twice and others appear once.\r\n\r\nFind all the elements of [1, n] inclusive that do not appear in this array.\r\n\r\nCould you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.\r\n\r\nExample:\r\n\r\nInput:\r\n[4,3,2,7,8,2,3,1]\r\n\r\nOutput:\r\n[5,6]\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/575", "similarQuestions": ["FirstMissingPositive", "FindAllDuplicatesinanArray"], "topicTags": ["Array"], "Solution": "class Solution {\n    public List<Integer> findDisappearedNumbers(int[] nums) {\n        ArrayList<Integer> a=new ArrayList();\n        int n=nums.length;\n        boolean array[]= new boolean[n+1];\n        for(int i=0;i<n;i++)\n        {\n            array[nums[i]]=true;\n            \n        }\n        for(int i=1;i<=n;i++)\n        {\n            if(array[i]==false)\n                a.add(i);\n            \n        }\n        return a;\n        \n    }\n}", "total_acs": 77252, "total_submitted": 150688}, {"id": 449, "title": "Serialize and Deserialize BST", "url": "https://leetcode.com/problems/serialize-and-deserialize-bst/description", "companyTags": ["Amazon"], "difficulty": "Medium", "content": "Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. \r\n\r\nDesign an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure.\r\n\r\n\r\nThe encoded string should be as compact as possible.\r\n\r\n\r\n\r\nNote: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.\r\n", "discussUrl": "https://discuss.leetcode.com/category/576", "similarQuestions": ["SerializeandDeserializeBinaryTree", "FindDuplicateSubtrees"], "topicTags": ["Tree"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Codec {\n    TreeNode curr;\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        curr=root;\n        return \"\";\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        return curr;\n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec codec = new Codec();\n// codec.deserialize(codec.serialize(root));", "total_acs": 23596, "total_submitted": 55079}, {"id": 450, "title": "Delete Node in a BST", "url": "https://leetcode.com/problems/delete-node-in-a-bst/description", "companyTags": ["Uber"], "difficulty": "Medium", "content": "Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.\r\n\r\nBasically, the deletion can be divided into two stages:\r\n\r\nSearch for a node to remove.\r\nIf the node is found, delete the node.\r\n\r\n\r\n\r\nNote: Time complexity should be O(height of tree).\r\n\r\nExample:\r\n\r\nroot = [5,3,6,2,4,null,7]\r\nkey = 3\r\n\r\n    5\r\n   / \\\r\n  3   6\r\n / \\   \\\r\n2   4   7\r\n\r\nGiven key to delete is 3. So we find the node with value 3 and delete it.\r\n\r\nOne valid answer is [5,4,6,2,null,null,7], shown in the following BST.\r\n\r\n    5\r\n   / \\\r\n  4   6\r\n /     \\\r\n2       7\r\n\r\nAnother valid answer is [5,2,6,null,4,null,7].\r\n\r\n    5\r\n   / \\\r\n  2   6\r\n   \\   \\\r\n    4   7\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/577", "similarQuestions": ["SplitBST"], "topicTags": ["Tree"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode deleteNode(TreeNode root, int key) {\n        if (root == null)\n            return null;\n        \n        if (root.val > key) {\n            root.left = deleteNode(root.left, key);\n        } else if (root.val < key) {\n            root.right = deleteNode(root.right, key);\n        } else {\n            if (root.right == null) {root = root.left;}\n            else if (root.left == null) {root = root.right;}\n            else {\n                int min = findMin(root.right);\n                root.val = min;\n                root.right = deleteNode(root.right, min);\n            }\n        }\n        return root;\n    }\n    \n    private int findMin(TreeNode root) {\n        while (root.left != null) {\n            root = root.left;\n        }\n        return root.val;\n    }\n}", "total_acs": 29171, "total_submitted": 77584}, {"id": 451, "title": "Sort Characters By Frequency", "url": "https://leetcode.com/problems/sort-characters-by-frequency/description", "companyTags": ["Google", "Amazon"], "difficulty": "Medium", "content": "Given a string, sort it in decreasing order based on the frequency of characters.\r\n\r\nExample 1:\r\n\r\nInput:\r\n\"tree\"\r\n\r\nOutput:\r\n\"eert\"\r\n\r\nExplanation:\r\n'e' appears twice while 'r' and 't' both appear once.\r\nSo 'e' must appear before both 'r' and 't'. Therefore \"eetr\" is also a valid answer.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput:\r\n\"cccaaa\"\r\n\r\nOutput:\r\n\"cccaaa\"\r\n\r\nExplanation:\r\nBoth 'c' and 'a' appear three times, so \"aaaccc\" is also a valid answer.\r\nNote that \"cacaca\" is incorrect, as the same characters must be together.\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput:\r\n\"Aabb\"\r\n\r\nOutput:\r\n\"bbAa\"\r\n\r\nExplanation:\r\n\"bbaA\" is also a valid answer, but \"Aabb\" is incorrect.\r\nNote that 'A' and 'a' are treated as two different characters.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/578", "similarQuestions": ["TopKFrequentElements", "FirstUniqueCharacterinaString"], "topicTags": ["HashTable", "Heap"], "Solution": "class Solution {\n    public String frequencySort(String s) {\n        int[] f = new int[256];\n        char[] chars = s.toCharArray();\n        char[] res = new char[s.length()];\n        \n        for (char c : chars) \n            f[c]++;\n        \n        for (int i = 0; i < res.length; ) {\n            int max = 0;\n            int c = 0;\n            \n            for (int j = 0; j < f.length; j++) {\n                if (f[j] > max) {\n                    max = f[j];\n                    c = j;\n                }\n            }\n            \n            f[c] = 0;\n            while (max-- > 0)\n                res[i++] = (char)c;\n        }\n        \n        return new String(res);\n    }\n}", "total_acs": 46752, "total_submitted": 90724}, {"id": 452, "title": "Minimum Number of Arrows to Burst Balloons", "url": "https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/description", "companyTags": ["Microsoft"], "difficulty": "Medium", "content": "There are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it's horizontal, y-coordinates don't matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most 104 balloons.\r\n\r\nAn arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart \u2264 x \u2264 xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons. \r\n\r\nExample:\r\n\r\nInput:\r\n[[10,16], [2,8], [1,6], [7,12]]\r\n\r\nOutput:\r\n2\r\n\r\nExplanation:\r\nOne way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons).\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/579", "similarQuestions": ["MeetingRoomsII", "Non-overlappingIntervals"], "topicTags": ["Greedy"], "Solution": "class Solution {\n    public int findMinArrowShots(int[][] points) {\n        if(points.length == 0)\n            return 0;\n        \n        Arrays.sort(points,new Comparator<int[]>()\n                    {\n                        public int compare(int[] a,int[] b)\n                        {\n                            if(a[1] == b[1])\n                                return a[0] - b[0];\n                            return a[1] - b[1];\n                        }\n                    });\n            \n        int shot = points[0][1];\n        int array = 1;\n        \n        for(int i = 1;i < points.length;i++)\n        {\n            if(points[i][0] > shot)\n            {\n                array++;\n                shot = points[i][1];\n            }           \n        }\n        \n        return array;\n        \n    }\n}", "total_acs": 19543, "total_submitted": 43836}, {"id": 453, "title": "Minimum Moves to Equal Array Elements", "url": "https://leetcode.com/problems/minimum-moves-to-equal-array-elements/description", "companyTags": ["Indeed", "Coursera"], "difficulty": "Easy", "content": "Given a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1.\r\n\r\nExample:\r\n\r\nInput:\r\n[1,2,3]\r\n\r\nOutput:\r\n3\r\n\r\nExplanation:\r\nOnly three moves are needed (remember each move increments two elements):\r\n\r\n[1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/580", "similarQuestions": ["MinimumMovestoEqualArrayElementsII"], "topicTags": ["Math"], "Solution": "class Solution {\n    public int minMoves(int[] nums) {\n        int n = nums.length;\n        int min = Integer.MAX_VALUE;\n        int sum = 0;\n        for(int i: nums){\n            sum+=i;\n            if(i<min) min = i;\n        }\n        return sum-min*n;\n        \n        \n    }\n}", "total_acs": 38408, "total_submitted": 79916}, {"id": 454, "title": "4Sum II", "url": "https://leetcode.com/problems/4sum-ii/description", "companyTags": [""], "difficulty": "Medium", "content": "Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.\r\n\r\nTo make problem a bit easier, all A, B, C, D have same length of N where 0 \u2264 N \u2264 500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1.\r\n\r\nExample:\r\n\r\nInput:\r\nA = [ 1, 2]\r\nB = [-2,-1]\r\nC = [-1, 2]\r\nD = [ 0, 2]\r\n\r\nOutput:\r\n2\r\n\r\nExplanation:\r\nThe two tuples are:\r\n1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0\r\n2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/581", "similarQuestions": ["4Sum"], "topicTags": ["HashTable", "BinarySearch"], "Solution": "class Solution {\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\n        int n = A.length;\n        int res = 0;\n        HashMap<Integer, Integer> map = new HashMap<>();\n        int sum = 0;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                sum = A[i] + B[j];\n                map.put(sum, map.getOrDefault(sum, 0) + 1);\n            }\n        }\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                sum = C[i] + D[j];\n                res += map.getOrDefault(-1 * sum, 0);\n            }\n        }\n        return res;\n    }\n}", "total_acs": 27484, "total_submitted": 57605}, {"id": 455, "title": "Assign Cookies", "url": "https://leetcode.com/problems/assign-cookies/description", "companyTags": [""], "difficulty": "Easy", "content": "\r\nAssume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj >= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.\r\n\r\n\r\nNote:\r\nYou may assume the greed factor is always positive. \r\nYou cannot assign more than one cookie to one child.\r\n\r\n\r\nExample 1:\r\n\r\nInput: [1,2,3], [1,1]\r\n\r\nOutput: 1\r\n\r\nExplanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. \r\nAnd even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.\r\nYou need to output 1.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: [1,2], [1,2,3]\r\n\r\nOutput: 2\r\n\r\nExplanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. \r\nYou have 3 cookies and their sizes are big enough to gratify all of the children, \r\nYou need to output 2.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/583", "similarQuestions": [""], "topicTags": ["Greedy"], "Solution": "class Solution {\n    public int findContentChildren(int[] g, int[] s) {\n        Arrays.sort(g);\n        Arrays.sort(s);\n        \n        int i1 = 0;\n        int i2 = 0;\n        int l1 = g.length;\n        int l2 = s.length;\n        int res = 0;\n        while(i1 < l1 && i2 < l2){\n            if(g[i1] <= s[i2]){\n                res++;\n                i1++;\n                i2++;\n            }\n            else{\n                i2++;\n            }\n        }\n        return res;\n        \n    }\n}", "total_acs": 37953, "total_submitted": 80314}, {"id": 456, "title": "132 Pattern", "url": "https://leetcode.com/problems/132-pattern/description", "companyTags": [""], "difficulty": "Medium", "content": "\r\nGiven a sequence of n integers a1, a2, ..., an, a 132 pattern is a subsequence ai, aj, ak such\r\nthat i < j < k and ai < ak < aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list.\r\n\r\nNote: n will be less than 15,000.\r\n\r\nExample 1:\r\n\r\nInput: [1, 2, 3, 4]\r\n\r\nOutput: False\r\n\r\nExplanation: There is no 132 pattern in the sequence.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: [3, 1, 4, 2]\r\n\r\nOutput: True\r\n\r\nExplanation: There is a 132 pattern in the sequence: [1, 4, 2].\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput: [-1, 3, 2, 0]\r\n\r\nOutput: True\r\n\r\nExplanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/584", "similarQuestions": [""], "topicTags": ["Stack"], "Solution": "class Solution {\n    public boolean find132pattern(int[] nums) {\n        if (nums.length < 3) return false;\n        int n = nums.length;\n        for (int i = n - 1, top = n, numK = Integer.MIN_VALUE; i >= 0; i--) {\n            if (nums[i] < numK) return true;\n            while (top < n && nums[i] > nums[top]) numK = nums[top++];\n            nums[--top] = nums[i];\n        }\n        return false;\n    }\n}", "total_acs": 16257, "total_submitted": 57739}, {"id": 457, "title": "Circular Array Loop", "url": "https://leetcode.com/problems/circular-array-loop/description", "companyTags": [""], "difficulty": "Medium", "content": "\r\nYou are given an array of positive and negative integers. If a number n at an index is positive, then move forward n steps. Conversely, if it's negative (-n), move backward n steps. Assume the first element of the array is forward next to the last element, and the last element is backward next to the first element. Determine if there is a loop in this array. A loop starts and ends at a particular index with more than 1 element along the loop. The loop must be \"forward\" or \"backward'.\r\n\r\n\r\nExample 1:\r\n\r\nGiven the array [2, -1, 1, 2, 2], there is a loop, from index 0 -> 2 -> 3 -> 0.\r\n\r\n\r\nExample 2:\r\n\r\nGiven the array [-1, 2], there is no loop.\r\n\r\n\r\nNote:\r\n\r\nThe given array is guaranteed to contain no element \"0\".\r\n\r\n\r\n\r\nCan you do it in O(n) time complexity and O(1) space complexity?\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/585", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 4616, "total_submitted": 21122}, {"id": 458, "title": "Poor Pigs", "url": "https://leetcode.com/problems/poor-pigs/description", "companyTags": [""], "difficulty": "Easy", "content": "\r\nThere are 1000 buckets, one and only one of them contains poison, the rest are filled with water. They all look the same. If a pig drinks that poison it will die within 15 minutes. What is the minimum amount of pigs you need to figure out which bucket contains the poison within one hour. \r\n\r\n\r\nAnswer this question, and write an algorithm for the follow-up general case.\r\n\r\n\r\n\r\nFollow-up:\r\n\r\n\r\n\r\nIf there are n buckets and a pig drinking poison will die within m minutes, how many pigs (x) you need to figure out the \"poison\" bucket within p minutes? There is exact one bucket with poison.\r\n", "discussUrl": "https://discuss.leetcode.com/category/586", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 7896, "total_submitted": 18981}, {"id": 459, "title": "Repeated Substring Pattern", "url": "https://leetcode.com/problems/repeated-substring-pattern/description", "companyTags": ["Google", "Amazon"], "difficulty": "Easy", "content": "Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.  You may assume the given string consists of lowercase English letters only and its length  will not exceed 10000. \r\n\r\nExample 1:\r\n\r\nInput: \"abab\"\r\n\r\nOutput: True\r\n\r\nExplanation: It's the substring \"ab\" twice.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: \"aba\"\r\n\r\nOutput: False\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput: \"abcabcabcabc\"\r\n\r\nOutput: True\r\n\r\nExplanation: It's the substring \"abc\" four times. (And the substring \"abcabc\" twice.)\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/587", "similarQuestions": ["ImplementstrStr()", "RepeatedStringMatch"], "topicTags": ["String"], "Solution": "class Solution {\n    public boolean repeatedSubstringPattern(String s) {\n        if (s.length() == 1) return false;\n        int len = s.length(), mid = len / 2; // half\n        if (s.substring(0, mid).equals(s.substring(mid))) return true;\n        int one_third = len / 3; // 1/3\n        String sub = s.substring(0, one_third);\n        if (sub.equals(s.substring(one_third, one_third * 2)) && sub.equals(s.substring(one_third * 2))) return true;\n        if (len % 2 == 1) { // odd number of characters\n            char c = s.charAt(0);\n            for (int i = 1; i < len; i++) {\n                if (s.charAt(i) != c) return false;\n            }\n            return true;\n        }\n        return false;\n    }\n}", "total_acs": 47415, "total_submitted": 124251}, {"id": 460, "title": "LFU Cache", "url": "https://leetcode.com/problems/lfu-cache/description", "companyTags": ["Google", "Amazon"], "difficulty": "Hard", "content": "Design and implement a data structure for Least Frequently Used (LFU) cache. It should support the following operations: get and put.\r\n\r\n\r\n\r\nget(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.\r\nput(key, value) - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least frequently used item before inserting a new item. For the purpose of this problem, when there is a tie (i.e., two or more keys that have the same frequency), the least recently used key would be evicted.\r\n\r\n\r\nFollow up:\r\nCould you do both operations in O(1) time complexity?\r\n\r\nExample:\r\n\r\nLFUCache cache = new LFUCache( 2 /* capacity */ );\r\n\r\ncache.put(1, 1);\r\ncache.put(2, 2);\r\ncache.get(1);       // returns 1\r\ncache.put(3, 3);    // evicts key 2\r\ncache.get(2);       // returns -1 (not found)\r\ncache.get(3);       // returns 3.\r\ncache.put(4, 4);    // evicts key 1.\r\ncache.get(1);       // returns -1 (not found)\r\ncache.get(3);       // returns 3\r\ncache.get(4);       // returns 4\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/588", "similarQuestions": ["LRUCache", "DesignIn-MemoryFileSystem"], "topicTags": ["Design"], "Solution": "class LFUCache {\n    \n    public int cap;\n    \n    public int minFreq;\n    \n    public HashMap<Integer, Node> map;\n    \n    public HashMap<Integer, Node[]> freqMap;\n\n    public LFUCache(int capacity) {\n        this.cap = capacity;\n        this.minFreq = 0;\n                \n        map = new HashMap<Integer, Node>();\n        freqMap = new HashMap<Integer, Node[]>();\n    }\n    \n    public int get(int key) {\n        if (this.cap <= 0) {\n            return -1;\n        }\n        \n        if (!map.containsKey(key)) {\n            return -1;\n        }\n        \n        Node n = map.get(key);\n        n.prev.next = n.next;\n        n.next.prev = n.prev;\n        \n        Node[] curPtrs = freqMap.get(this.minFreq);\n        if (curPtrs[0].next == curPtrs[1]) {\n            this.minFreq++;\n            //System.out.println(\"Increase minFreq: \" + this.minFreq);\n        }\n        \n        n.freq++;\n        Node[] ptrs = freqMap.get(n.freq);\n        if (ptrs == null) {\n            Node head = new Node();\n            Node tail = new Node();\n            head.next = n;\n            n.prev = head;\n            \n            n.next = tail;\n            tail.prev = n;\n            \n            ptrs = new Node[]{head, tail};\n            freqMap.put(n.freq, ptrs);\n        } else {\n            Node head = ptrs[0];\n            \n            Node tmp = head.next;\n            head.next = n;\n            n.prev = head;\n            \n            n.next = tmp;\n            tmp.prev = n;\n        }\n        \n        return n.val;\n    }\n    \n    public void put(int key, int value) {\n        if (this.cap <= 0) {\n            return ;\n        }\n        \n        /*if (key == 13) {\n            Node n = map.get(key);\n            if (n == null) {\n                System.out.println(\"No val\");\n            } else {\n                System.out.println(n + \" \" + n.prev + \" \" + n.next);\n            }\n            \n        }*/\n        \n        if (map.containsKey(key)) {\n            Node n = map.get(key);\n            \n            n.val = value;\n            \n            n.prev.next = n.next;\n            n.next.prev = n.prev;\n            \n            Node[] curPtrs = freqMap.get(this.minFreq);\n            if (curPtrs[0].next == curPtrs[1]) {\n                this.minFreq++;\n                //System.out.println(\"Incre minFreq put: \" + this.minFreq);\n            }\n            \n            n.freq++;\n            Node[] ptrs = freqMap.get(n.freq);\n            if (ptrs == null) {\n                Node head = new Node();\n                Node tail = new Node();\n                \n                head.next = tail;\n                tail.prev = head;\n                ptrs = new Node[]{head, tail};\n                freqMap.put(n.freq, ptrs);\n            }\n            \n            Node head = ptrs[0];\n            \n            //update head\n            Node tmp = head.next;\n            head.next = n;\n            n.prev = head;\n            \n            n.next =tmp;\n            tmp.prev = n;\n            \n            return ;\n        }\n        \n        Node n = new Node();\n        n.key = key;\n        n.val = value;\n        n.freq = 1;\n        map.put(key, n);\n        \n        if (map.size() > cap) {\n            Node[] ptrs = freqMap.get(this.minFreq);\n            \n            /*if (key == 13) {\n                System.out.println(\"current min freq: \" + this.minFreq);\n                System.out.println(\"To remove: \" + ptrs[1].prev);\n            }*/\n            \n            Node tail = ptrs[1];\n            Node least = tail.prev;\n            \n            least.prev.next = tail;\n            tail.prev = least.prev;\n            \n            map.remove(least.key);\n        }\n        \n        this.minFreq = 1;\n        if (freqMap.containsKey(this.minFreq)) {\n            Node[] ptrs= freqMap.get(minFreq);\n            Node head = ptrs[0];\n            \n            Node tmp = head.next;\n            head.next = n;\n            n.prev = head;\n            \n            n.next = tmp;\n            tmp.prev = n;\n        } else {\n            Node head = new Node();\n            Node tail = new Node();\n            head.next = n;\n            n.prev = head;\n            \n            n.next = tail;\n            tail.prev = n;\n            \n            Node[] ptrs = {head, tail};\n            freqMap.put(this.minFreq, ptrs);\n        }\n    }\n    \n    public static class Node {\n        \n        public int key;\n        \n        public int val;\n        \n        public int freq;\n        \n        public Node next = null;\n        \n        public Node prev = null;\n        \n        public String toString() {\n            return key + \":\" + val;\n        }\n    }\n}\n\n/**\n * Your LFUCache object will be instantiated and called as such:\n * LFUCache obj = new LFUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */", "total_acs": 18472, "total_submitted": 74080}, {"id": 461, "title": "Hamming Distance", "url": "https://leetcode.com/problems/hamming-distance/description", "companyTags": ["Facebook"], "difficulty": "Easy", "content": "The Hamming distance between two integers is the number of positions at which the corresponding bits are different.\r\n\r\nGiven two integers x and y, calculate the Hamming distance.\r\n\r\nNote:\r\n0 \u2264 x, y < 231.\r\n\r\n\r\nExample:\r\n\r\nInput: x = 1, y = 4\r\n\r\nOutput: 2\r\n\r\nExplanation:\r\n1   (0 0 0 1)\r\n4   (0 1 0 0)\r\n       \u2191   \u2191\r\n\r\nThe above arrows point to positions where the corresponding bits are different.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/590", "similarQuestions": ["Numberof1Bits", "TotalHammingDistance"], "topicTags": ["BitManipulation"], "Solution": "class Solution {\n    public int hammingDistance(int x, int y) {\n        int res = x^y;\n        int count = 0;\n            do {\n                 count += res & 1;\n                     res = res >> 1;\n            } while(res != 0);\n                \n        return count;\n    }\n}", "total_acs": 133548, "total_submitted": 191860}, {"id": 462, "title": "Minimum Moves to Equal Array Elements II", "url": "https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/description", "companyTags": [""], "difficulty": "Medium", "content": "Given a non-empty integer array, find the minimum number of moves required to make all array elements equal, where a move is incrementing a selected element by 1 or decrementing a selected element by 1.\r\n\r\nYou may assume the array's length is at most 10,000.\r\n\r\nExample:\r\n\r\nInput:\r\n[1,2,3]\r\n\r\nOutput:\r\n2\r\n\r\nExplanation:\r\nOnly two moves are needed (remember each move increments or decrements one element):\r\n\r\n[1,2,3]  =>  [2,2,3]  =>  [2,2,2]\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/591", "similarQuestions": ["BestMeetingPoint", "MinimumMovestoEqualArrayElements"], "topicTags": ["Math"], "Solution": "class Solution {\n    public int minMoves2(int[] nums) {\n        int l = nums.length;\n        /*Arrays.sort(nums);\n        int target = nums[l/2];*/\n        int target = medium(nums, 0, l-1);\n        int ans = 0;\n        for (int i : nums) {\n            ans += Math.abs(i - target);\n        }\n        return ans;\n    }\n    public int medium(int[] nums, int left, int right) {\n        int n = nums.length;\n        int mid = nums[(left+right) >> 1];\n        int l = left;\n        int r = right;\n        while (l < r) {\n            while (nums[l] < mid) l++;\n            while (nums[r] > mid) r--;\n            if (l >= r) break;\n            int tmp = nums[l];\n            nums[l] = nums[r];\n            nums[r] = tmp;\n            l++;\n            r--;\n        }\n        if (l == n >> 1 && l == r) return mid;\n        else if (l > n >> 1) {\n            return medium(nums, left, l-1);\n        }\n        else return medium(nums, r+1, right);\n    }\n}", "total_acs": 22506, "total_submitted": 43385}, {"id": 463, "title": "Island Perimeter", "url": "https://leetcode.com/problems/island-perimeter/description", "companyTags": ["Google"], "difficulty": "Easy", "content": "You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn't have \"lakes\" (water inside that isn't connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.\r\n\r\nExample:\r\n\r\n[[0,1,0,0],\r\n [1,1,1,0],\r\n [0,1,0,0],\r\n [1,1,0,0]]\r\n\r\nAnswer: 16\r\nExplanation: The perimeter is the 16 yellow stripes in the image below:\r\n\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/592", "similarQuestions": ["MaxAreaofIsland", "FloodFill"], "topicTags": ["HashTable"], "Solution": "class Solution {\n    public int islandPerimeter(int[][] grid) {\n          if (grid == null || grid.length == 0 \n             || grid[0] == null || grid[0].length == 0) {\n              return 0;\n          }\n        int m = grid.length;\n        int n = grid[0].length;\n        int res = 0;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == 1) {\n                    if (i == 0 || grid[i - 1][j] == 0) {\n                        res++;\n                    }\n                    if (i == m - 1 || grid[i + 1][j] == 0) {\n                        res++;\n                    }\n                    if (j == 0 || grid[i][j - 1] == 0) {\n                        res++;\n                    }\n                    if (j == n - 1 || grid[i][j + 1] == 0) {\n                        res++;\n                    }\n                }\n            }\n        }\n        return res;\n    }\n}", "total_acs": 71028, "total_submitted": 122962}, {"id": 464, "title": "Can I Win", "url": "https://leetcode.com/problems/can-i-win/description", "companyTags": ["LinkedIn"], "difficulty": "Medium", "content": "In the \"100 game,\" two players take turns adding, to a running total, any integer from 1..10. The player who first causes the running total to reach or exceed 100 wins. \r\n\r\nWhat if we change the game so that players cannot re-use integers? \r\n\r\nFor example, two players might take turns drawing from a common pool of numbers of 1..15 without replacement until they reach a total >= 100.\r\n\r\nGiven an integer maxChoosableInteger and another integer desiredTotal, determine if the first player to move can force a win, assuming both players play optimally. \r\n\r\nYou can always assume that maxChoosableInteger will not be larger than 20 and desiredTotal will not be larger than 300.\r\n\r\n\r\nExample\r\n\r\nInput:\r\nmaxChoosableInteger = 10\r\ndesiredTotal = 11\r\n\r\nOutput:\r\nfalse\r\n\r\nExplanation:\r\nNo matter which integer the first player choose, the first player will lose.\r\nThe first player can choose an integer from 1 up to 10.\r\nIf the first player choose 1, the second player can only choose integers from 2 up to 10.\r\nThe second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.\r\nSame with other integers chosen by the first player, the second player will always win.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/593", "similarQuestions": ["FlipGameII", "GuessNumberHigherorLowerII", "PredicttheWinner"], "topicTags": ["DynamicProgramming", "Minimax"], "Solution": "class Solution {\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\n        if (desiredTotal <= maxChoosableInteger) return true;\n        int sum = (maxChoosableInteger + 1) * maxChoosableInteger / 2;\n        if (desiredTotal > sum) return false;\n        else if (desiredTotal == sum) return maxChoosableInteger % 2 == 1;\n        else return canIWinDP(maxChoosableInteger, 0, desiredTotal, new Boolean[1 << maxChoosableInteger]);\n    }\n    \n    private boolean canIWinDP(int n, int state, int remain, Boolean[] dp) {\n        if (dp[state] != null) return dp[state];\n        for (int i = n; i >= 1; i--) {\n            int pick = 1 << (i - 1);         //pick i, set ith bit to 1;\n            if ((pick & state) != 0) continue; //if num is picked skip it\n            // if the remain is smaller than the number, we can tell the winner\n            // or if the opponent cannot win we can record the status\n            if (remain <= i || !canIWinDP(n, state | pick, remain - i, dp)) {\n                dp[state] = true;\n                return true;\n            }\n        }\n        dp[state] = false;\n        return false;\n    }\n}", "total_acs": 18519, "total_submitted": 72773}, {"id": 465, "title": "Optimal Account Balancing", "url": "https://leetcode.com/problems/optimal-account-balancing/description", "companyTags": ["Google"], "difficulty": "Hard", "content": "A group of friends went on holiday and sometimes lent each other money. For example, Alice paid for Bill's lunch for $10. Then later Chris gave Alice $5 for a taxi ride. We can model each transaction as a tuple (x, y, z) which means person x gave person y $z. Assuming Alice, Bill, and Chris are person 0, 1, and 2 respectively (0, 1, 2 are the person's ID), the transactions can be represented as [[0, 1, 10], [2, 0, 5]].\r\n\r\nGiven a list of transactions between a group of people, return the minimum number of transactions required to settle the debt.\r\n\r\nNote:\r\n\r\nA transaction will be given as a tuple (x, y, z). Note that x \u2260 y and z > 0.\r\nPerson's IDs may not be linear, e.g. we could have the persons 0, 1, 2 or we could also have the persons 0, 2, 6.\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput:\r\n[[0,1,10], [2,0,5]]\r\n\r\nOutput:\r\n2\r\n\r\nExplanation:\r\nPerson #0 gave person #1 $10.\r\nPerson #2 gave person #0 $5.\r\n\r\nTwo transactions are needed. One way to settle the debt is person #1 pays person #0 and #2 $5 each.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput:\r\n[[0,1,10], [1,0,1], [1,2,5], [2,0,5]]\r\n\r\nOutput:\r\n1\r\n\r\nExplanation:\r\nPerson #0 gave person #1 $10.\r\nPerson #1 gave person #0 $1.\r\nPerson #1 gave person #2 $5.\r\nPerson #2 gave person #0 $5.\r\n\r\nTherefore, person #1 only need to give person #0 $4, and all debt is settled.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/594", "similarQuestions": [""], "topicTags": [""], "Solution": "class Solution {\n    int matchCount = 0;\npublic int minTransfers(int[][] transactions) {\n    if (transactions == null || transactions.length == 0 || transactions[0].length == 0)\n        return 0;\n    //calculate delta for each account\n    Map<Integer, Integer> accountToDelta = new HashMap<Integer, Integer>();\n    for (int[] transaction : transactions) {\n        int from = transaction[0];\n        int to = transaction[1];\n        int val = transaction[2];\n        if (!accountToDelta.containsKey(from)) {\n            accountToDelta.put(from, 0);\n        }\n        if (!accountToDelta.containsKey(to)) {\n            accountToDelta.put(to, 0);\n        }\n        accountToDelta.put(from, accountToDelta.get(from) - val);\n        accountToDelta.put(to, accountToDelta.get(to) + val);\n    }\n    List<Integer> deltas = new ArrayList<Integer>();\n    for (int delta : accountToDelta.values()) {\n        if (delta != 0)\n            deltas.add(delta);\n    }\n    Integer[] array = removeMatchDeltas(deltas.toArray(new Integer[deltas.size()]));\n    return matchCount + minTransStartsFrom(array, 0, 0);\n}\n\nprivate Integer[] removeMatchDeltas(Integer[] deltas) {\n    Arrays.sort(deltas);\n    int left = 0;\n    int right = deltas.length - 1;\n    int zeroCount = 0;\n    for (int i = 0; i < deltas.length; i++) if (deltas[i] == 0) zeroCount++;\n    while (left < right) {\n        if (deltas[left] + deltas[right] == 0) {\n            deltas[left++] = 0;\n            deltas[right--] = 0;\n            matchCount++;\n        } else if (deltas[left] + deltas[right] < 0) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    Integer[] newArray = new Integer[deltas.length - matchCount * 2 - zeroCount];\n    for (int i = 0, j = 0; i < deltas.length; i++) if (deltas[i] != 0) newArray[j++] = deltas[i];\n    return newArray;\n}\n\nprivate int minTransStartsFrom(Integer[] deltas, int start, int count) {\n    if (start == deltas.length) return count;\n    int result = Integer.MAX_VALUE;\n    int n = deltas.length;\n    while (start < n && deltas[start] == 0) start++;\n    if (start == n) return count;\n    for (int i = start + 1; i < n; i++) {\n        if (deltas[i] > 0 && deltas[start] < 0) {\n            deltas[i] += deltas[start];\n            result = Math.min(result, minTransStartsFrom(deltas, start + 1, count + 1));\n            deltas[i] -= deltas[start];\n        }\n    }\n    return result;\n}\n}", "total_acs": 7040, "total_submitted": 18100}, {"id": 466, "title": "Count The Repetitions", "url": "https://leetcode.com/problems/count-the-repetitions/description", "companyTags": [""], "difficulty": "Hard", "content": "Define S = [s,n] as the string S which consists of n connected strings s. For example, [\"abc\", 3] =\"abcabcabc\". \r\nOn the other hand, we define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1. For example, \u201cabc\u201d  can be obtained from \u201cabdbec\u201d based on our definition, but it can not be obtained from \u201cacbbe\u201d.\r\nYou are given two non-empty strings s1 and s2 (each at most 100 characters long) and two integers 0 \u2264 n1 \u2264 106 and 1 \u2264 n2 \u2264 106. Now consider the strings S1 and S2, where S1=[s1,n1] and S2=[s2,n2]. Find the maximum integer M such that [S2,M] can be obtained from S1.\r\n\r\nExample:\r\n\r\nInput:\r\ns1=\"acb\", n1=4\r\ns2=\"ab\", n2=2\r\n\r\nReturn:\r\n2\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/595", "similarQuestions": [""], "topicTags": ["DynamicProgramming"], "Solution": "class Solution {\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\n        char[] s1c = s1.toCharArray();\n        char[] s2c = s2.toCharArray();\n        int m = s1c.length, n = s2c.length;\n        int[] repeatCount = new int[n+1];\n        int[] nextIndex = new int[n+1];\n        int j = 0, cnt = 0;\n        for (int k = 1; k <= n1; k++) {\n            for (int i = 0; i < m; i++) {\n                if (s1c[i] == s2c[j]) {\n                    j++;\n                    if (j == n) {\n                        cnt++;\n                        j = 0;\n                    }\n                }\n            }\n            repeatCount[k] = cnt;  // record the k-th repeatCount and nextIndex\n            nextIndex[k] = j;\n            for (int start = 0; start < k; start++) {\n                // see if you have met this nextIndex before\n                // if found, you can calculate the 3 parts\n                if (nextIndex[start] == j) {  \n                    // prefixCount is the start-th repeatCount\n                    int prefixCount = repeatCount[start];\n                    \n                    // (repeatCount[k] - repeatCount[start]) is the repeatCount of one occurrance of the pattern\n                    // There are (n1 - start) / (k - start) occurrances of the pattern\n                    // So (repeatCount[k] - repeatCount[start]) * ((n1 - start) / (k - start))\n                    // is the repeatCount of the repetitive part\n                    int patternCount = (repeatCount[k] - repeatCount[start]) * ((n1 - start) / (k - start));\n                    \n                    // The suffix contains the incomplete repetitive remnant (if any)\n                    // Its length is (n1 - start) % (k - start)\n                    // So the suffix repeatCount should be \n                    // repeatCount[start + (n1 - start) % (k - start)] - repeatCount[start]\n                    int suffixCount = repeatCount[start + (n1-start)%(k-start)] - repeatCount[start];\n                    return (prefixCount+patternCount+suffixCount) / n2;\n                }\n            }\n        }\n        \n        // when apply n1 times s1 can make a s2  (\u6709\u7591\u95ee\u7684\u8fd9\u91cc)\n        return repeatCount[n1] / n2;\n    }\n}", "total_acs": 5264, "total_submitted": 19226}, {"id": 467, "title": "Unique Substrings in Wraparound String", "url": "https://leetcode.com/problems/unique-substrings-in-wraparound-string/description", "companyTags": ["MAQSoftware"], "difficulty": "Medium", "content": "Consider the string s to be the infinite wraparound string of \"abcdefghijklmnopqrstuvwxyz\", so s will look like this: \"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....\".\r\n\r\nNow we have another string p. Your job is to find out how many unique non-empty substrings of p are present in s. In particular, your input is the string p and you need to output the number of different non-empty substrings of p in the string s.\r\n\r\nNote: p consists of only lowercase English letters and the size of p might be over 10000.\r\n\r\nExample 1:\r\n\r\nInput: \"a\"\r\nOutput: 1\r\n\r\nExplanation: Only the substring \"a\" of string \"a\" is in the string \u0010s.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: \"cac\"\r\nOutput: 2\r\nExplanation: There are two substrings \"a\", \"c\" of string \"cac\" in the string s.\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput: \"zab\"\r\nOutput: 6\r\nExplanation: There are six substrings \"z\", \"a\", \"b\", \"za\", \"ab\", \"zab\" of string \"zab\" in the string s.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/597", "similarQuestions": [""], "topicTags": ["DynamicProgramming"], "Solution": "class Solution {\n    public int findSubstringInWraproundString(String p) {\n        if (p == null || p.length() == 0) {\n            return 0;\n        }\n        int[] ways = new int[125];\n        char[] cs = p.toCharArray();\n        int left = 0;\n        int right = 1;\n        // NOTE: even if right == cs.length, can still go into the loop, to handle the \"a\" case (single char)\n        while (right <= cs.length) {\n            while (right < cs.length && ((cs[right] - cs[right-1] == 1) || (cs[right] == 'a' && cs[right-1] == 'z'))) {\n                right++;\n            }\n            while (left < right) {\n                ways[cs[left]] = Math.max(ways[cs[left]], right - left);\n                left++;\n            }\n            // left does not increment here.\n            right++;\n        }\n        int sum = 0;\n        for (int way : ways) {\n            sum += way;\n        }\n        return sum;\n    }\n}", "total_acs": 11502, "total_submitted": 34580}, {"id": 468, "title": "Validate IP Address", "url": "https://leetcode.com/problems/validate-ip-address/description", "companyTags": ["Twitter"], "difficulty": "Medium", "content": "\r\nWrite a function to check whether an input string is a valid IPv4 address or IPv6 address or neither.\r\n\r\n\r\n\r\nIPv4 addresses are canonically represented in dot-decimal notation, which consists of four decimal numbers, each ranging from 0 to 255, separated by dots (\".\"), e.g.,172.16.254.1;\r\n\r\n\r\n\r\nBesides, leading zeros in the IPv4 is invalid. For example, the address 172.16.254.01 is invalid.\r\n\r\n\r\n\r\nIPv6 addresses are represented as eight groups of four hexadecimal digits, each group representing 16 bits. The groups are separated by colons (\":\"). For example, the address 2001:0db8:85a3:0000:0000:8a2e:0370:7334 is a valid one. Also, we could omit some leading zeros among four hexadecimal digits and some low-case characters in the address to upper-case ones, so 2001:db8:85a3:0:0:8A2E:0370:7334 is also a valid IPv6 address(Omit leading zeros and using upper cases).\r\n\r\n\r\n\r\n\r\nHowever, we don't replace a consecutive group of zero value with a single empty group using two consecutive colons (::) to pursue simplicity. For example, 2001:0db8:85a3::8A2E:0370:7334 is an invalid IPv6 address.\r\n\r\n\r\n\r\nBesides, extra leading zeros in the IPv6 is also invalid. For example, the address 02001:0db8:85a3:0000:0000:8a2e:0370:7334 is invalid.\r\n\r\n\r\n\r\nNote:\r\nYou may assume there is no extra space or special characters in the input string.\r\n\r\n\r\nExample 1:\r\n\r\nInput: \"172.16.254.1\"\r\n\r\nOutput: \"IPv4\"\r\n\r\nExplanation: This is a valid IPv4 address, return \"IPv4\".\r\n\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: \"2001:0db8:85a3:0:0:8A2E:0370:7334\"\r\n\r\nOutput: \"IPv6\"\r\n\r\nExplanation: This is a valid IPv6 address, return \"IPv6\".\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput: \"256.256.256.256\"\r\n\r\nOutput: \"Neither\"\r\n\r\nExplanation: This is neither a IPv4 address nor a IPv6 address.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/598", "similarQuestions": ["IPtoCIDR"], "topicTags": ["String"], "Solution": "class Solution {\n    public String validIPAddress(String IP) {\n        if (IP.length() == 0) return \"Neither\";\n        int lastChar = IP.charAt(IP.length() - 1);\n        if (lastChar == ':' || lastChar == '.') return \"Neither\";\n        String[] groups = IP.split(\"\\\\.\");\n        if (groups.length == 1) {\n            groups = IP.split(\":\");\n            if (validateIPv6(groups)) return \"IPv6\";\n            else return \"Neither\";\n        } else {\n            if (validateIPv4(groups)) return \"IPv4\";\n            else return \"Neither\";\n        }\n    }\n    \n    private boolean validateIPv4Group(String group) {\n        if (group.length() > 3 || group.length() == 0) return false;\n        if (group.length() > 1 && group.charAt(0) == '0') return false;\n        int res = 0;\n        for (int i = 0; i < group.length(); i++) {\n            char c = group.charAt(i);\n            if (c >= '0' && c <= '9') res = res * 10 + c - '0';\n            else return false;\n        }\n        return res < 256;\n    }\n    \n    private boolean validateIPv4(String[] groups) {\n        //System.out.println(Arrays.toString(groups));\n        if (groups.length != 4) return false;\n        for (int i = 0; i < groups.length; i++) {\n            if (!validateIPv4Group(groups[i])) return false;\n        }\n        return true;\n    }\n    \n    private boolean validateIPv6Group(String group) {\n        if (group.length() > 4 || group.length() == 0) return false;\n        for (int i = 0; i < group.length(); i++) {\n            char c = Character.toLowerCase(group.charAt(i));\n            if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f')) continue;\n            else return false;\n        }\n        return true;\n    }\n    \n    private boolean validateIPv6(String[] groups) {\n        //System.out.println(Arrays.toString(groups));\n        if (groups.length != 8) return false;\n        for (int i = 0; i < 8; i++) {\n            if (!validateIPv6Group(groups[i])) return false;\n        }\n        return true;\n    }\n}", "total_acs": 11788, "total_submitted": 57129}, {"id": 469, "title": "Convex Polygon", "url": "https://leetcode.com/problems/convex-polygon/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "Given a list of points that form a polygon when joined sequentially, find if this polygon is convex (Convex polygon definition).\r\n\r\nNote:\r\n\r\nThere are at least 3 and at most 10,000 points.\r\nCoordinates are in the range -10,000 to 10,000.\r\nYou may assume the polygon formed by given points is always a simple polygon (Simple polygon definition). In other words, we ensure that exactly two edges intersect at each vertex, and that edges otherwise don't intersect each other. \r\n\r\n\r\n\r\n\r\nExample 1:\r\n\r\n[[0,0],[0,1],[1,1],[1,0]]\r\n\r\nAnswer: True\r\n\r\nExplanation:\r\n\r\n\r\n\r\nExample 2:\r\n\r\n[[0,0],[0,10],[10,10],[10,0],[5,5]]\r\n\r\nAnswer: False\r\n\r\nExplanation:\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/599", "similarQuestions": [""], "topicTags": ["Math"], "Solution": "class Solution {\n    public boolean isConvex(List<List<Integer>> points) {\n        int flag = 0;\n        for (int i = 0; i < points.size(); i++) {\n            int angle = getAngle(points, i);\n            if (angle == 0) continue;\n            if (flag == 0) {\n                flag = angle > 0 ? 1 : -1;\n            } else if (flag > 0 != angle > 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    private int getAngle(List<List<Integer>> points, int i) {\n        int size = points.size();\n        List<Integer> a = points.get(i % size);\n        List<Integer> b = points.get((i + 1) % size);\n        List<Integer> c = points.get((i + 2) % size);\n        \n        int ax = a.get(0), ay = a.get(1), bx = b.get(0), by = b.get(1), cx = c.get(0), cy = c.get(1);\n        return (ax - bx) * (cy - by) - (cx - bx) * (ay - by);\n    }\n}", "total_acs": 4920, "total_submitted": 14424}, {"id": 471, "title": "Encode String with Shortest Length", "url": "https://leetcode.com/problems/encode-string-with-shortest-length/description", "companyTags": ["Google"], "difficulty": "Hard", "content": "Given a non-empty string, encode the string such that its encoded length is the shortest.\r\n\r\n\r\nThe encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times.\r\n\r\n\r\nNote:\r\n\r\nk will be a positive integer and encoded string will not be empty or have extra space.\r\nYou may assume that the input string contains only lowercase English letters. The string's length is at most 160.\r\nIf an encoding process does not make the string shorter, then do not encode it. If there are several solutions, return any of them is fine.\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput: \"aaa\"\r\nOutput: \"aaa\"\r\nExplanation: There is no way to encode it such that it is shorter than the input string, so we do not encode it.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: \"aaaaa\"\r\nOutput: \"5[a]\"\r\nExplanation: \"5[a]\" is shorter than \"aaaaa\" by 1 character.\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput: \"aaaaaaaaaa\"\r\nOutput: \"10[a]\"\r\nExplanation: \"a9[a]\" or \"9[a]a\" are also valid solutions, both of them have the same length = 5, which is the same as \"10[a]\".\r\n\r\n\r\n\r\nExample 4:\r\n\r\nInput: \"aabcaabcd\"\r\nOutput: \"2[aabc]d\"\r\nExplanation: \"aabc\" occurs twice, so one answer can be \"2[aabc]d\".\r\n\r\n\r\n\r\nExample 5:\r\n\r\nInput: \"abbbabbbcabbbabbbc\"\r\nOutput: \"2[2[abbb]c]\"\r\nExplanation: \"abbbabbbc\" occurs twice, but \"abbbabbbc\" can also be encoded to \"2[abbb]c\", so one answer can be \"2[2[abbb]c]\".\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/602", "similarQuestions": ["DecodeString", "NumberofAtoms"], "topicTags": ["DynamicProgramming"], "Solution": "class Solution {\n    public String encode(String s) {\n        int n = s.length();\n        int[][] minlen = new int[n + 1][n + 1];\n        int[][][] next = new int[n + 1][n + 1][2];\n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = i + 1; j <= n; j++) {\n                minlen[i][j] = minlen[i + 1][j] + 1;\n                next[i][j][0] = 1;\n                next[i][j][1] = 1;\n            }\n            List<int[]> list = this.kmp(s.substring(i).toCharArray(), i);\n            for (int[] pair: list) {\n                int end = pair[1], mid = pair[0];\n                int ndig = String.valueOf((end - i) / (end - mid)).length();\n                int len = minlen[mid][end] + 2 + ndig;\n                for (int j = end; j <= n; j++)\n                    if (minlen[i][j] > len + minlen[end][j]) {\n                        next[i][j][0] = end - mid;\n                        next[i][j][1] = (end - i) / (end - mid);\n                        minlen[i][j] = len + minlen[end][j];\n                    }\n            }\n        }\n        return this.build(next, s, 0, n);\n    }\n    \n    private String build(int[][][] next, String s, int l, int r) {\n        if (l == r) return \"\";\n        StringBuilder sb = new StringBuilder();\n        if (next[l][r][1] == 1) {\n            sb.append(s.charAt(l));\n            sb.append(this.build(next, s, l + 1, r));\n        } else {\n            sb.append(String.valueOf(next[l][r][1]));\n            sb.append('[');\n            sb.append(this.build(next, s, l, l + next[l][r][0]));\n            sb.append(']');\n            sb.append(this.build(next, s, l + next[l][r][0] * next[l][r][1], r));\n        }\n        return sb.toString();\n    }\n    \n    private List<int[]> kmp(char[] c, int start) {\n        List<int[]> ret = new ArrayList<int[]>();\n        int n = c.length;\n        int[] dp = new int[n];\n        int i = 0;\n        for (int j = 1; j < n; j++) {\n            while (i > 0 && c[i] != c[j]) i = dp[i - 1];\n            if (c[i] == c[j]) dp[j] = ++i;\n            if (dp[j] > 0 && ((j + 1) % (j + 1 - dp[j]) == 0))\n                ret.add(new int[] {dp[j] + start, j + start + 1});\n        }\n        return ret;\n    }\n}", "total_acs": 7445, "total_submitted": 17288}, {"id": 472, "title": "Concatenated Words", "url": "https://leetcode.com/problems/concatenated-words/description", "companyTags": [""], "difficulty": "Hard", "content": "Given a list of words (without duplicates), please write a program that returns all concatenated words in the given list of words.\r\nA concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.\r\n\r\nExample:\r\n\r\nInput: [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]\r\n\r\nOutput: [\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]\r\n\r\nExplanation: \"catsdogcats\" can be concatenated by \"cats\", \"dog\" and \"cats\";  \"dogcatsdog\" can be concatenated by \"dog\", \"cats\" and \"dog\"; \"ratcatdogcat\" can be concatenated by \"rat\", \"cat\", \"dog\" and \"cat\".\r\n\r\n\r\n\r\nNote:\r\n\r\nThe number of elements of the given array will not exceed 10,000 \r\nThe length sum of elements in the given array will not exceed 600,000. \r\nAll the input string will only include lower case letters.\r\nThe returned elements order does not matter. \r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/603", "similarQuestions": ["WordBreakII"], "topicTags": ["DynamicProgramming", "Depth-firstSearch", "Trie"], "Solution": "class Solution {\n    class TrieNode{\n        TrieNode[] next;\n        boolean isWord;\n        public final static int ALPHABET_SIZE = 26;\n\n        public TrieNode(){\n            isWord = false;\n        }\n\n        public TrieNode getNext(int index){\n            if(next == null){\n                next = new TrieNode[ALPHABET_SIZE];\n            }\n            if(next[index] == null){\n                next[index] = new TrieNode();\n            }\n            return next[index];\n        }\n\n        public boolean hasNext(int index){\n            return next != null && next[index] != null;\n        }\n    }\n\n    public List<String> findAllConcatenatedWordsInADict(String[] words){\n        List<String> result = new ArrayList<String>();\n        if(words == null || words.length == 0){\n            return result;\n        }\n        List<List<String>> list = new ArrayList<>();\n        for(String word : words){\n            int len = word.length();\n            if(len >= list.size()){\n                for(int i = list.size(); i <= len; i++){\n                    list.add(new LinkedList<String>());\n                }\n            }\n            list.get(len).add(word);\n        }\n        TrieNode root = new TrieNode();\n        for(int i = 1; i < list.size(); i++){\n            List<String> subList = list.get(i);\n            for(String word : subList){\n                if(isConcatenated(word, root, 0)){\n                    result.add(word);\n                } else{\n                    addToTrie(word, root);\n                }\n            }\n        }\n        return result;\n    }\n\n    private boolean isConcatenated(String word, TrieNode root, int start){\n        if(start >= word.length()){\n            return true;\n        }\n        TrieNode node = root;\n        for(int i = start; i < word.length(); i++){\n            int index = word.charAt(i) - 'a';\n            if(node.hasNext(index)){\n                node = node.getNext(index);\n                if(node.isWord && isConcatenated(word, root, i + 1)){\n                    return true;\n                }\n            } else{\n                break;\n            }\n        }\n        return false;\n    }\n\n    private void addToTrie(String word, TrieNode root){\n        TrieNode node = root;\n        for(int i = 0; i < word.length(); i++){\n            node = node.getNext(word.charAt(i) - 'a');\n        }\n        node.isWord = true;\n    }\n}", "total_acs": 10548, "total_submitted": 34201}, {"id": 473, "title": "Matchsticks to Square", "url": "https://leetcode.com/problems/matchsticks-to-square/description", "companyTags": ["Rackspace"], "difficulty": "Medium", "content": "Remember the story of Little Match Girl? By now, you know exactly what matchsticks the little match girl has, please find out a way you can make one square by using up all those matchsticks. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.\r\n\r\n Your input will be several matchsticks the girl has, represented with their stick length. Your output will either be true or false, to represent whether you could make one square using all the matchsticks the little match girl has.\r\n\r\nExample 1:\r\n\r\nInput: [1,1,2,2,2]\r\nOutput: true\r\n\r\nExplanation: You can form a square with length 2, one side of the square came two sticks with length 1.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: [3,3,3,3,4]\r\nOutput: false\r\n\r\nExplanation: You cannot find a way to form a square with all the matchsticks.\r\n\r\n\r\n\r\nNote:\r\n\r\nThe length sum of the given matchsticks is in the range of 0 to 10^9.\r\nThe length of the given matchstick array will not exceed 15.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/604", "similarQuestions": [""], "topicTags": ["Depth-firstSearch"], "Solution": "class Solution {\n    public boolean makesquare(int[] nums) {\n        if(nums == null || nums.length == 0) return false;\n        int sum = 0;\n        for(int i = 0; i < nums.length; i++) {\n            sum += nums[i];\n        }\n        if(sum % 4 != 0) return false;\n        int side = sum / 4;\n        Arrays.sort(nums);\n        boolean[] visited = new boolean[nums.length];\n        for(int i = nums.length - 1; i >= 0; i--) {\n            if(visited[i]) continue;\n            visited[i] = true;\n            if(!helper(nums, i, visited, side)) \n                return false;\n        }\n        return true;\n    }\n    private boolean helper(int[] nums, int pos, boolean[] visited, int tar) {\n        if(nums[pos] == tar) return true;\n        int last = 0;\n        int nextTar = tar - nums[pos];\n        for(int i = pos - 1; i >= 0; i--) {\n            if(nums[i] != last && !visited[i] && nums[i] <= nextTar) {\n                visited[i] = true;\n                if(helper(nums, i, visited, nextTar)) return true;\n                visited[i] = false;\n                last = nums[i];\n            }\n        }\n        return false;\n    }\n}", "total_acs": 14274, "total_submitted": 40280}, {"id": 474, "title": "Ones and Zeroes", "url": "https://leetcode.com/problems/ones-and-zeroes/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue.\r\nFor now, suppose you are a dominator of m 0s and n 1s respectively. On the other hand, there is an array with strings consisting of only 0s and 1s.\r\n\r\n\r\nNow your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once.\r\n\r\n\r\n\r\nNote:\r\n\r\nThe given numbers of 0s and 1s will both not exceed 100\r\nThe size of given string array won't exceed 600.\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput: Array = {\"10\", \"0001\", \"111001\", \"1\", \"0\"}, m = 5, n = 3\r\nOutput: 4\r\n\r\nExplanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are \u201c10,\u201d0001\u201d,\u201d1\u201d,\u201d0\u201d\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: Array = {\"10\", \"0\", \"1\"}, m = 1, n = 1\r\nOutput: 2\r\n\r\nExplanation: You could form \"10\", but then you'd have nothing left. Better form \"0\" and \"1\".\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/605", "similarQuestions": ["Non-negativeIntegerswithoutConsecutiveOnes"], "topicTags": ["DynamicProgramming"], "Solution": "class Solution {\n    public int findMaxForm(String[] strs, int m, int n) {\n        int[][] str = countNums(strs);\n        if (m == n) {\n            Arrays.sort(str, new Comparator<int[]>() {\n                @Override\n                public int compare(int[] o1, int[] o2) {\n                    if (o1[0] + o1[1] - o2[0] - o2[1] == 0) {\n                        return Math.min(o1[0], o1[1]) - Math.min(o2[0], o2[1]);\n                    }\n                    return o1[0] + o1[1] - o2[0] - o2[1];\n                }\n            });\n        } else if (m < n) {\n            Arrays.sort(str, new Comparator<int[]>() {\n                @Override\n                public int compare(int[] o1, int[] o2) {\n                    if (o1[0] == o2[0]) {\n                        return o1[1] - o2[1];\n                    }\n                    return o1[0] - o2[0];\n                }\n            });\n        } else {\n            Arrays.sort(str, new Comparator<int[]>() {\n                @Override\n                public int compare(int[] o1, int[] o2) {\n                    if (o1[1] == o2[1]) {\n                        return o1[0] - o2[0];\n                    }\n                    return o1[1] - o2[1];\n                }\n            });\n        }\n        int max = 0;\n        for (int i = 0; i < str.length; i++) {\n            if (str.length - i < max) {\n                return max;\n            }\n            int one = n, zero = m;\n            int j = i;\n            for (; j < str.length; j++) {\n                if (str[j][0] <= zero && str[j][1] <= one) {\n                    zero -= str[j][0];\n                    one -= str[j][1];\n                } else {\n                    break;\n                }\n            }\n            max = Math.max(j - i, max);\n        }\n        return max;\n    }\n    private int[][] countNums(String[] strs) {\n        int[][] str = new int[strs.length][2];\n        for (int i = 0; i < strs.length; i++) {\n            for (int j = 0; j < strs[i].length(); j++) {\n                char c = strs[i].charAt(j);\n                if (c == '1') {\n                    str[i][1]++;\n                } else {\n                    str[i][0]++;\n                }\n            }\n        }\n        return str;\n    }\n}", "total_acs": 18420, "total_submitted": 47119}, {"id": 475, "title": "Heaters", "url": "https://leetcode.com/problems/heaters/description", "companyTags": ["Google"], "difficulty": "Easy", "content": "Winter is coming! Your first job during the contest is to design a standard heater with fixed warm radius to warm all the houses.\r\n\r\nNow, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters.\r\n\r\nSo, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters.\r\n\r\nNote:\r\n\r\nNumbers of houses and heaters you are given are non-negative and will not exceed 25000.\r\nPositions of houses and heaters you are given are non-negative and will not exceed 10^9.\r\nAs long as a house is in the heaters' warm radius range, it can be warmed.\r\nAll the heaters follow your radius standard and the warm radius will the same.\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput: [1,2,3],[2]\r\nOutput: 1\r\nExplanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: [1,2,3,4],[1,4]\r\nOutput: 1\r\nExplanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/606", "similarQuestions": [""], "topicTags": ["BinarySearch"], "Solution": "class Solution {\n    public int findRadius(int[] houses, int[] heaters) {\n        Arrays.sort(houses);\n        Arrays.sort(heaters);\n        int i = 0, res = 0;\n        for (int house : houses) {\n            while (i < heaters.length - 1 && heaters[i] + heaters[i+1] <= house * 2) {\n                i++;\n            }\n            res = Math.max(res, Math.abs(heaters[i] - house));\n        }\n        return res;\n        \n    }\n}", "total_acs": 26187, "total_submitted": 88292}, {"id": 476, "title": "Number Complement", "url": "https://leetcode.com/problems/number-complement/description", "companyTags": ["Cloudera"], "difficulty": "Easy", "content": "Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.\r\n\r\nNote:\r\n\r\nThe given integer is guaranteed to fit within the range of a 32-bit signed integer.\r\nYou could assume no leading zero bit in the integer\u2019s binary representation.\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput: 5\r\nOutput: 2\r\nExplanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: 1\r\nOutput: 0\r\nExplanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/608", "similarQuestions": [""], "topicTags": ["BitManipulation"], "Solution": "class Solution {\n    public int findComplement(int num) {\n        return ~num & (Integer.highestOneBit(num) - 1);\n    }\n}", "total_acs": 69639, "total_submitted": 114017}, {"id": 477, "title": "Total Hamming Distance", "url": "https://leetcode.com/problems/total-hamming-distance/description", "companyTags": ["Facebook"], "difficulty": "Medium", "content": "The Hamming distance between two integers is the number of positions at which the corresponding bits are different.\r\n\r\nNow your job is to find the total Hamming distance between all pairs of the given numbers.\r\n\r\n\r\nExample:\r\n\r\nInput: 4, 14, 2\r\n\r\nOutput: 6\r\n\r\nExplanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just\r\nshowing the four bits relevant in this case). So the answer will be:\r\nHammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.\r\n\r\n\r\n\r\nNote:\r\n\r\nElements of the given array are in the range of 0  to 10^9\r\nLength of the array will not exceed 10^4. \r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/609", "similarQuestions": ["HammingDistance"], "topicTags": ["BitManipulation"], "Solution": "class Solution {\n    public int totalHammingDistance(int[] nums) {\n        /*use bit count and (permutation and combination)*/\n\t\tif(nums == null){\n\t\t\treturn 0;\n\t\t}\n\t\tint len = nums.length;\n\t\tint total = 0;\n\t\tint intBit = 32;\n\t\tfor(int i = 0; i < intBit; ++i){\n\t\t\tint curBistOneCount = 0;\n\t\t\tfor(int num : nums){\n\t\t\tcurBistOneCount += ((num >> i) & 1);\n\t\t\t}\n\t\t\ttotal += curBistOneCount * (len - curBistOneCount);\n\t\t}\n\t\treturn total;\n    }\n}", "total_acs": 28868, "total_submitted": 60529}, {"id": 479, "title": "Largest Palindrome Product", "url": "https://leetcode.com/problems/largest-palindrome-product/description", "companyTags": ["Yahoo"], "difficulty": "Easy", "content": "Find the largest palindrome made from the product of two n-digit numbers.\r\n Since the result could be very large, you should return the largest palindrome mod 1337.\r\n\r\nExample:\r\nInput: 2\r\nOutput: 987\r\nExplanation: 99 x 91 = 9009, 9009 % 1337 = 987\r\n\r\n\r\n\r\n\r\nNote:\r\nThe range of n is [1,8].\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/616", "similarQuestions": [""], "topicTags": [""], "Solution": "class Solution {\n    public int largestPalindrome(int n) {\n        switch(n){\n            case 1:\n                return 9;\n            case 2:\n                return 987;\n            case 3:\n                return 123;\n            case 4:\n                return 597;\n            case 5:\n                return 677;\n            case 6:\n                return 1218;\n            case 7:\n                return 877;\n            case 8:\n                return 475;\n            default:\n                return -1;\n        }\n    }\n}", "total_acs": 8518, "total_submitted": 33864}, {"id": 480, "title": "Sliding Window Median", "url": "https://leetcode.com/problems/sliding-window-median/description", "companyTags": ["Google"], "difficulty": "Hard", "content": "Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.\r\nExamples: \r\n[2,3,4] , the median is 3\r\n[2,3], the median is (2 + 3) / 2 = 2.5 \r\n\r\nGiven an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Your job is to output the median array for each window in the original array.\r\n\r\nFor example,\r\nGiven nums = [1,3,-1,-3,5,3,6,7], and k = 3.\r\n\r\n\r\nWindow position                Median\r\n---------------               -----\r\n[1  3  -1] -3  5  3  6  7       1\r\n 1 [3  -1  -3] 5  3  6  7       -1\r\n 1  3 [-1  -3  5] 3  6  7       -1\r\n 1  3  -1 [-3  5  3] 6  7       3\r\n 1  3  -1  -3 [5  3  6] 7       5\r\n 1  3  -1  -3  5 [3  6  7]      6\r\n\r\n\r\nTherefore, return the median sliding window as [1,-1,-1,3,5,6].\r\n\r\nNote: \r\nYou may assume k is always valid, ie: k is always smaller than input array's size for non-empty array.", "discussUrl": "https://discuss.leetcode.com/category/617", "similarQuestions": ["FindMedianfromDataStream"], "topicTags": [""], "Solution": "// // Similar to: Find Median from Data Stream\n\n// public class Solution{\n//     private PriorityQueue<Integer> min_large;\n//     private PriorityQueue<Integer> max_small;\n\t\n//     public double[] medianSlidingWindow(int[] nums, int k) {\n//         min_large = new PriorityQueue<Integer>();\n//         max_small = new PriorityQueue<Integer>(Collections.reverseOrder());\n        \n//         int n = nums.length;\n//         double[] res = new double[n - k + 1];\n        \n//         int idx = 0;\n//         for (int i = 0; i < n; i++) {\n//     \t    addNum(nums[i]);\n            \n//             if (i >= k - 1){\n//             \tres[idx++] = getMedian();\n//             \tremove(nums[i - k + 1]);\n//             }\n//         }\n//         return res;\n//     }\n    \n//     private void addNum(int num) {\n//     \t(num < getMedian() ? max_small : min_large).offer(num);\n//     \tresizeHeaps();\n//     }\n\t\n//     private void remove(int num) {\n//     \t(num < getMedian() ? max_small : min_large).remove(num);\n//     \tresizeHeaps();\n//     }\n    \n//     private void resizeHeaps(){\n//         if (max_small.size() > min_large.size()) {\n//             min_large.add(max_small.poll());\n//     \t}\n//         if (min_large.size() - max_small.size() > 1) {\n//             max_small.add(min_large.poll());\n//         }\n//     }\n\t\n//     private double getMedian() {\n//     \tif (max_small.isEmpty() && min_large.isEmpty()) {\n//             return 0;\n//         }\n        \n//     \treturn min_large.size() > max_small.size() ? (double)min_large.peek() : ((double)min_large.peek() + (double)max_small.peek()) / 2.0;\n//     }\n// }\n\n\npublic class Solution {\n  public class TreeNode {\n    int value, cnt, selfCnt;\n    TreeNode left, right;\n    public TreeNode(int v) {\n      value = v;\n      cnt = 1;\n      selfCnt = 1;\n    }\n  }\n  public double[] medianSlidingWindow(int[] nums, int k) {\n    int n = nums.length - k + 1;\n    double[] res = new double[n];\n    TreeNode root = null;\n    for (int i = 0; i <= nums.length; i++) {\n      if (i >= k) {\n        double median = 0.0;\n        if (k % 2 == 1)\n          median = (double)getKth(root, k / 2 + 1);\n        else\n          median =\n              0.5 * ((double)getKth(root, k / 2) + getKth(root, k / 2 + 1));\n        res[i - k] = median;\n        root = remove(root, nums[i - k]);\n      }\n      if (i < nums.length)\n        root = insert(root, nums[i]);\n    }\n    return res;\n  }\n  private TreeNode remove(TreeNode root, int val) {\n    if (root == null)\n      return null;\n    root.cnt--;\n    if (root.value == val) {\n      root.selfCnt--;\n      if (root.selfCnt == 0) {\n        if (root.left == null && root.right == null)\n          return null;\n        else if (root.left == null)\n          return root.right;\n        else if (root.right == null)\n          return root.left;\n        else\n          return deleteWithBothChild(root);\n      }\n    } else if (root.value < val)\n      root.right = remove(root.right, val);\n    else\n      root.left = remove(root.left, val);\n    return root;\n  }\n  private TreeNode deleteWithBothChild(TreeNode root) {\n    TreeNode pre = root;\n    TreeNode succ = root.right;\n    while (succ.left != null) {\n      pre = succ;\n      pre.cnt--;\n      succ = pre.left;\n    }\n    if (pre == root) {\n      succ.left = root.left;\n      succ.cnt += root.left.cnt;\n    } else {\n      succ.left = root.left;\n      pre.left = succ.right;\n      succ.right = root.right;\n      succ.cnt = succ.left.cnt + succ.right.cnt + succ.selfCnt;\n    }\n    return succ;\n  }\n  private TreeNode insert(TreeNode root, int value) {\n    if (root == null)\n      return new TreeNode(value);\n    root.cnt++;\n    if (root.value == value)\n      root.selfCnt++;\n    else if (root.value < value)\n      root.right = insert(root.right, value);\n    else\n      root.left = insert(root.left, value);\n    return root;\n  }\n  private int getKth(TreeNode root, int k) {\n    if (root == null)\n      return 0;\n    int left = root.left == null ? 0 : root.left.cnt;\n    if (k <= left)\n      return getKth(root.left, k);\n    else if (k <= root.selfCnt + left)\n      return root.value;\n    else\n      return getKth(root.right, k - left - root.selfCnt);\n  }\n}", "total_acs": 11916, "total_submitted": 38790}, {"id": 481, "title": "Magical String", "url": "https://leetcode.com/problems/magical-string/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "\r\nA magical string S consists of only '1' and '2' and obeys the following rules:\r\n\r\n\r\nThe string S is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string S itself.\r\n\r\n\r\n\r\nThe first few elements of string S is the following:\r\nS = \"1221121221221121122\u2026\u2026\"\r\n\r\n\r\n\r\nIf we group the consecutive '1's and '2's in S, it will be:\r\n\r\n\r\n1   22  11  2  1  22  1  22  11  2  11  22 ......\r\n\r\n\r\nand the occurrences of '1's or '2's in each group are:\r\n\r\n\r\n1   2\t   2    1   1    2     1    2     2    1    2    2 ......\r\n\r\n\r\n\r\nYou can see that the occurrence sequence above is the S itself. \r\n\r\n\r\n\r\nGiven an integer N as input, return the number of '1's in the first N number in the magical string S.\r\n\r\n\r\nNote:\r\nN will not exceed 100,000.\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput: 6\r\nOutput: 3\r\nExplanation: The first 6 elements of magical string S is \"12211\" and it contains three 1's, so return 3.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/618", "similarQuestions": [""], "topicTags": [""], "Solution": "class Solution {\n//     Create an int array a and initialize the first 3 elements with 1, 2, 2.\n// Create two pointers head and tail. head points to the number which will be used to generate new numbers. tail points to the next empty position to put the new number. Then keep generating new numbers until tail >= n.\n// Need to create the array 1 element more than n to avoid overflow because the last round head might points to a number 2.\n// A trick to flip number back and forth between 1 and 2: num = num ^ 3\n    public int magicalString(int n) {\n        if (n <= 0) return 0;\n        if (n <= 3) return 1;\n        \n        int[] a = new int[n + 1];\n        a[0] = 1;\n        a[1] = 2;\n        a[2] = 2;\n        int head = 2, tail = 3, num = 1, result = 1;\n        while (tail < n) {\n            for (int i = 0; i < a[head]; i++) {\n                a[tail] = num;\n                if (num == 1 && tail < n) result++;\n                tail++;\n            }\n            num = num ^ 3;\n            head++;\n        }\n        return result;\n    }\n}", "total_acs": 12565, "total_submitted": 27490}, {"id": 482, "title": "License Key Formatting", "url": "https://leetcode.com/problems/license-key-formatting/description", "companyTags": ["Google"], "difficulty": "Easy", "content": "You are given a license key represented as a string S which consists only alphanumeric character and dashes. The string is separated into N+1 groups by N dashes.\r\n\r\nGiven a number K, we would want to reformat the strings such that each group contains exactly K characters, except for the first group which could be shorter than K, but still must contain at least one character. Furthermore, there must be a dash inserted between two groups and all lowercase letters should be converted to uppercase.\r\n\r\nGiven a non-empty string S and a number K, format the string according to the rules described above.\r\n\r\nExample 1:\r\n\r\nInput: S = \"5F3Z-2e-9-w\", K = 4\r\n\r\nOutput: \"5F3Z-2E9W\"\r\n\r\nExplanation: The string S has been split into two parts, each part has 4 characters.\r\nNote that the two extra dashes are not needed and can be removed.\r\n\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: S = \"2-5g-3-J\", K = 2\r\n\r\nOutput: \"2-5G-3J\"\r\n\r\nExplanation: The string S has been split into three parts, each part has 2 characters except the first part as it could be shorter as mentioned above.\r\n\r\n\r\n\r\nNote:\r\n\r\nThe length of string S will not exceed 12,000, and K is a positive integer.\r\nString S consists only of alphanumerical characters (a-z and/or A-Z and/or 0-9) and dashes(-).\r\nString S is non-empty.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/619", "similarQuestions": [""], "topicTags": [""], "Solution": "class Solution {\n    public String licenseKeyFormatting(String s, int k) {\n        if(s.isEmpty()) {\n            return s;\n        }\n        char[] cs = s.toCharArray();\n        int newLen = cs.length + cs.length / k;\n        char[] result = new char[newLen];\n        int i = cs.length, j = result.length;\n        Loop:\n        for(char c;;) {\n            for(int m = 0; m < k;) {\n                if(--i < 0) {\n                    break Loop;\n                }\n                if((c = cs[i]) == '-') {\n                    continue;\n                }\n                if(c >= 'a' && c <= 'z') {\n                    c -= 32;\n                }\n                m++;\n                result[--j] = c;\n            }\n            result[--j] = '-';\n        }\n        if(j < result.length && result[j] == '-') {\n            j++;\n        }\n        return new String(result, j, result.length - j);\n    }\n}", "total_acs": 27839, "total_submitted": 69277}, {"id": 483, "title": "Smallest Good Base", "url": "https://leetcode.com/problems/smallest-good-base/description", "companyTags": ["Google"], "difficulty": "Hard", "content": "For an integer n, we call k>=2 a good base of n, if all digits of n base k are 1.\r\nNow given a string representing n, you should return the smallest good base of n in string format. \r\n\r\nExample 1:\r\n\r\nInput: \"13\"\r\nOutput: \"3\"\r\nExplanation: 13 base 3 is 111.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: \"4681\"\r\nOutput: \"8\"\r\nExplanation: 4681 base 8 is 11111.\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput: \"1000000000000000000\"\r\nOutput: \"999999999999999999\"\r\nExplanation: 1000000000000000000 base 999999999999999999 is 11.\r\n\r\n\r\n\r\nNote:\r\n\r\nThe range of n is [3, 10^18].\r\nThe string representing n is always valid and will not have leading zeros.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/629", "similarQuestions": [""], "topicTags": ["Math", "BinarySearch"], "Solution": "class Solution {\n    public String smallestGoodBase(String n) {\n        long number = 0;\n        for (char c : n.toCharArray()) {\n            number = number * 10 + c - '0';\n        }\n        long x = 1;\n        for (int p = 64; p >= 1; p--) {\n            if ((x << p) < number) {\n                long k = helper(number, p);\n                if (k != -1) {\n                    return String.valueOf(k);\n                }\n            }\n        }\n        return String.valueOf(number - 1);\n    }\n    \n    private long helper(long number, int p) {\n        long left = 2;\n        long right = (long)(Math.pow(number, 1.0 / p) + 1);\n        while (left < right) {\n            long middle = left + (right - left) / 2;\n            long sum = 0, cur = 1;\n            for (int i = 0; i <= p; i++) {\n                sum += cur;\n                cur *= middle;\n            }\n            if (sum == number) {\n                return middle;\n            }\n            else if (sum > number) {\n                right = middle;\n            }\n            else {\n                left = middle + 1;\n            }\n        }\n        return -1;\n    }\n}", "total_acs": 6476, "total_submitted": 19178}, {"id": 484, "title": "Find Permutation", "url": "https://leetcode.com/problems/find-permutation/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "\r\nBy now, you are given a secret signature consisting of character 'D' and 'I'. 'D' represents a decreasing relationship between two numbers, 'I' represents an increasing relationship between two numbers. And our secret signature was constructed by a special integer array, which contains uniquely all the different number from 1 to n (n is the length of the secret signature plus 1). For example, the secret signature \"DI\" can be constructed by array [2,1,3] or [3,1,2], but won't be constructed by array [3,2,4] or [2,1,3,4], which are both illegal constructing special string that can't represent the \"DI\" secret signature.\r\n\r\n\r\n\r\nOn the other hand, now your job is to find the lexicographically smallest permutation of [1, 2, ... n] could refer to the given secret signature in the input.\r\n\r\n\r\nExample 1:\r\n\r\nInput: \"I\"\r\nOutput: [1,2]\r\nExplanation: [1,2] is the only legal initial spectial string can construct secret signature \"I\", where the number 1 and 2 construct an increasing relationship.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: \"DI\"\r\nOutput: [2,1,3]\r\nExplanation: Both [2,1,3] and [3,1,2] can construct the secret signature \"DI\", but since we want to find the one with the smallest lexicographical permutation, you need to output [2,1,3]\r\n\r\n\r\n\r\nNote:\r\nThe input string will only contain the character 'D' and 'I'.\r\nThe length of input string is a positive integer and will not exceed 10,000\r\n", "discussUrl": "https://discuss.leetcode.com/category/630", "similarQuestions": [""], "topicTags": ["Greedy"], "Solution": "class Solution {\n private static final char D = 'D';\n  private static final char I = 'I';\n\n\n  public int[] findPermutation(String s) {\n    final int[] res = new int[s.length() + 1];\n    // fill the array with sorted elements\n    for (int i = 0; i < res.length; i++) {\n      res[i] = i + 1;\n    }\n\n    final char[] sArray = s.toCharArray();\n    for (int i = 0; i < sArray.length;i++) {\n      if (sArray[i] == D) {\n        int start = i;\n        while (i < s.length() && sArray[i] == D) i++;\n        reverse(res, start, i);\n      }\n    }\n    return res;\n  }\n\n  private void reverse(final int[] res, int start, int end) {\n    while (start < end) {\n      res[start] ^= res[end];\n      res[end] ^= res[start];\n      res[start] ^= res[end];\n      start++;\n      end--;\n    }\n  }\n}", "total_acs": 7824, "total_submitted": 14054}, {"id": 485, "title": "Max Consecutive Ones", "url": "https://leetcode.com/problems/max-consecutive-ones/description", "companyTags": ["Google"], "difficulty": "Easy", "content": "Given a binary array, find the maximum number of consecutive 1s in this array.\r\n\r\nExample 1:\r\n\r\nInput: [1,1,0,1,1,1]\r\nOutput: 3\r\nExplanation: The first two digits or the last three digits are consecutive 1s.\r\n    The maximum number of consecutive 1s is 3.\r\n\r\n\r\n\r\nNote:\r\n\r\nThe input array will only contain 0 and 1.\r\nThe length of input array is a positive integer and will not exceed 10,000\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/631", "similarQuestions": ["MaxConsecutiveOnesII"], "topicTags": ["Array"], "Solution": "class Solution {\n    public int findMaxConsecutiveOnes(int[] nums) {\n        int max = 0, count = 0;\n\t\tfor(int num: nums) {\n\t\t\tif(num == 1) {\n\t\t\t\tcount++;\n\t\t\t}else {\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t\t\t\n\t\t}\n\t\treturn Math.max(max, count);\n        \n    }\n}", "total_acs": 71872, "total_submitted": 133453}, {"id": 486, "title": "Predict the Winner", "url": "https://leetcode.com/problems/predict-the-winner/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "Given an array of scores that are non-negative integers. Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on. Each time a player picks a number, that number will not be available for the next player. This continues until all the scores have been chosen. The player with the maximum score wins. \r\n\r\nGiven an array of scores, predict whether player 1 is the winner. You can assume each player plays to maximize his score. \r\n\r\nExample 1:\r\n\r\nInput: [1, 5, 2]\r\nOutput: False\r\nExplanation: Initially, player 1 can choose between 1 and 2. If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). So, final score of player 1 is 1 + 2 = 3, and player 2 is 5. Hence, player 1 will never be the winner and you need to return False.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: [1, 5, 233, 7]\r\nOutput: True\r\nExplanation: Player 1 first chooses 1. Then player 2 have to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.Finally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.\r\n\r\n\r\n\r\nNote:\r\n\r\n1 <= length of the array <= 20. \r\nAny scores in the given array are non-negative integers and will not exceed 10,000,000.\r\nIf the scores of both players are equal, then player 1 is still the winner.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/632", "similarQuestions": ["CanIWin"], "topicTags": ["DynamicProgramming", "Minimax"], "Solution": "class Solution {\n    public boolean PredictTheWinner(int[] nums) {\n        if(nums == null || nums.length == 0) return true;\n        int n = nums.length;\n        int[] dp = new int[n];\n        for(int e = 0; e < n; e++){\n            for(int s = e; s >= 0; s--){\n                if(s == e) dp[s] = nums[s];\n                else dp[s] = Math.max(nums[s]-dp[s+1],nums[e]-dp[s]);\n            }\n        }\n        return dp[0] >= 0;\n    }\n}", "total_acs": 22521, "total_submitted": 49908}, {"id": 487, "title": "Max Consecutive Ones II", "url": "https://leetcode.com/problems/max-consecutive-ones-ii/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "\r\nGiven a binary array, find the maximum number of consecutive 1s in this array if you can flip at most one 0.\r\n\r\n\r\nExample 1:\r\n\r\nInput: [1,0,1,1,0]\r\nOutput: 4\r\nExplanation: Flip the first zero will get the the maximum number of consecutive 1s.\r\n    After flipping, the maximum number of consecutive 1s is 4.\r\n\r\n\r\n\r\nNote:\r\n\r\nThe input array will only contain 0 and 1.\r\nThe length of input array is a positive integer and will not exceed 10,000\r\n\r\n\r\n\r\nFollow up:\r\nWhat if the input numbers come in one by one as an infinite stream? In other words, you can't store all numbers coming from the stream as it's too large to hold in memory. Could you solve it efficiently?\r\n", "discussUrl": "https://discuss.leetcode.com/category/633", "similarQuestions": ["MaxConsecutiveOnes"], "topicTags": ["TwoPointers"], "Solution": "class Solution {\n    public int findMaxConsecutiveOnes(int[] nums) {\n        int len = nums.length;\n        int start = 0;\n        int i = 0;\n        int windowZeroIndex = -1;\n        int maxLength = 0;\n        \n        while(i < len) {\n            if(nums[i] == 0) {\n                if(windowZeroIndex >= 0) { //has a zero already\n                    maxLength = Math.max(maxLength, i - start);\n                    start = windowZeroIndex + 1;\n                    windowZeroIndex = i;\n                }\n                else{\n                    windowZeroIndex = i;\n                }\n                \n            }\n            \n            i++;\n        }\n        \n        maxLength = Math.max(maxLength, len - start);\n        return maxLength;\n    }\n}", "total_acs": 11056, "total_submitted": 23998}, {"id": 488, "title": "Zuma Game", "url": "https://leetcode.com/problems/zuma-game/description", "companyTags": ["Baidu"], "difficulty": "Hard", "content": "Think about Zuma Game. You have a row of balls on the table, colored red(R), yellow(Y), blue(B), green(G), and white(W). You also have several balls in your hand.\r\n\r\nEach time, you may choose a ball in your hand, and insert it into the row (including the leftmost place and rightmost place). Then, if there is a group of 3 or more balls in the same color touching, remove these balls. Keep doing this until no more balls can be removed.\r\n\r\nFind the minimal balls you have to insert to remove all the balls on the table. If you cannot remove all the balls, output -1.\r\n\r\n\r\nExamples:\r\nInput: \"WRRBBW\", \"RB\"\r\nOutput: -1\r\nExplanation: WRRBBW -> WRR[R]BBW -> WBBW -> WBB[B]W -> WW\r\n\r\nInput: \"WWRRBBWW\", \"WRBRW\"\r\nOutput: 2\r\nExplanation: WWRRBBWW -> WWRR[R]BBWW -> WWBBWW -> WWBB[B]WW -> WWWW -> empty\r\n\r\nInput:\"G\", \"GGGGG\"\r\nOutput: 2\r\nExplanation: G -> G[G] -> GG[G] -> empty \r\n\r\nInput: \"RBYYBBRRB\", \"YRBGB\"\r\nOutput: 3\r\nExplanation: RBYYBBRRB -> RBYY[Y]BBRRB -> RBBBRRB -> RRRB -> B -> B[B] -> BB[B] -> empty \r\n\r\n\r\n\r\nNote:\r\n\r\nYou may assume that the initial row of balls on the table won\u2019t have any 3 or more consecutive balls with the same color.\r\nThe number of balls on the table won't exceed 20, and the string represents these balls is called \"board\" in the input.\r\nThe number of balls in your hand won't exceed 5, and the string represents these balls is called \"hand\" in the input.\r\nBoth input strings will be non-empty and only contain characters 'R','Y','B','G','W'.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/634", "similarQuestions": [""], "topicTags": ["Depth-firstSearch"], "Solution": "class Solution {\n    int MAXCOUNT = 6;   // the max balls you need will not exceed 6 since \"The number of balls in your hand won't exceed 5\"\n\n    public int findMinStep(String board, String hand) {\n        int[] handCount = new int[26];\n        for (int i = 0; i < hand.length(); ++i) {\n            ++handCount[hand.charAt(i) - 'A'];\n        }\n        int rs = helper(board + \"#\", handCount);  \n        return rs == MAXCOUNT ? -1 : rs;\n    }\n    private int helper(String s, int[] h) {\n        s = removeConsecutive(s);     \n        if (s.equals(\"#\")) return 0;\n        int  rs = MAXCOUNT, need = 0;\n        for (int i = 0, j = 0 ; j < s.length(); ++j) {\n            if (s.charAt(j) == s.charAt(i)) continue;\n            need = 3 - (j - i);     //balls need to remove current consecutive balls.\n            if (h[s.charAt(i) - 'A'] >= need) {\n                h[s.charAt(i) - 'A'] -= need;\n                rs = Math.min(rs, need + helper(s.substring(0, i) + s.substring(j), h));\n                h[s.charAt(i) - 'A'] += need;\n            }\n            i = j;\n        }\n        return rs;\n    }\n    \n    private String removeConsecutive(String board) {\n        for (int i = 0, j = 0; j < board.length(); ++j) {\n            if (board.charAt(j) == board.charAt(i)) continue;\n            if (j - i >= 3) return removeConsecutive(board.substring(0, i) + board.substring(j));\n            else i = j;\n        }\n        return board;\n    }\n}", "total_acs": 5428, "total_submitted": 14647}, {"id": 490, "title": "The Maze", "url": "https://leetcode.com/problems/the-maze/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "There is a ball in a maze with empty spaces and walls. The ball can go through empty spaces by rolling up, down, left or right, but it won't stop rolling until hitting a wall. When the ball stops, it could choose the next direction.\r\n\r\nGiven the ball's start position, the destination and the maze, determine whether the ball could stop at the destination.\r\n\r\nThe maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space. You may assume that the borders of the maze are all walls. The start and destination coordinates are represented by row and column indexes.\r\n\r\n\r\nExample 1\r\n\r\nInput 1: a maze represented by a 2D array\r\n\r\n0 0 1 0 0\r\n0 0 0 0 0\r\n0 0 0 1 0\r\n1 1 0 1 1\r\n0 0 0 0 0\r\n\r\nInput 2: start coordinate (rowStart, colStart) = (0, 4)\r\nInput 3: destination coordinate (rowDest, colDest) = (4, 4)\r\n\r\nOutput: true\r\nExplanation: One possible way is : left -> down -> left -> down -> right -> down -> right.\r\n\r\n\r\n\r\n\r\n\r\nExample 2\r\n\r\nInput 1: a maze represented by a 2D array\r\n\r\n0 0 1 0 0\r\n0 0 0 0 0\r\n0 0 0 1 0\r\n1 1 0 1 1\r\n0 0 0 0 0\r\n\r\nInput 2: start coordinate (rowStart, colStart) = (0, 4)\r\nInput 3: destination coordinate (rowDest, colDest) = (3, 2)\r\n\r\nOutput: false\r\nExplanation: There is no way for the ball to stop at the destination.\r\n\r\n\r\n\r\n\r\nNote:\r\n\r\nThere is only one ball and one destination in the maze.\r\nBoth the ball and the destination exist on an empty space, and they will not be at the same position initially.\r\nThe given maze does not contain border (like the red rectangle in the example pictures), but you could assume the border of the maze are all walls.\r\nThe maze contains at least 2 empty spaces, and both the width and height of the maze won't exceed 100.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/637", "similarQuestions": ["TheMazeIII", "TheMazeII"], "topicTags": ["Depth-firstSearch", "Breadth-firstSearch"], "Solution": "class Solution {\n    private boolean result = false;\n    \n    public boolean hasPath(int[][] maze, int[] start, int[] destination) {\n        dfs(maze, start[0], start[1], destination);\n        return result;\n    }\n    \n    private void dfs(int[][] maze, int curR, int curC, int[] destination) {\n        if (result == true) return;\n        if (curR == destination[0] && curC == destination[1]) {\n            result = true;\n            return;\n        }\n        if (maze[curR][curC] == 2) {\n            return;\n        }\n        maze[curR][curC] = 2;\n        int r = curR;\n        int c = curC;\n        while ((c - 1) >= 0 && maze[r][c - 1] != 1) {\n            c--;\n        }\n        dfs(maze, r, c, destination);\n        r = curR;\n        c = curC;\n        while ((c + 1) < maze[0].length && maze[r][c + 1] != 1) {\n            c++;\n        }\n        dfs(maze, r, c, destination);\n        r = curR;\n        c = curC;\n        while ((r + 1) < maze.length && maze[r + 1][c] != 1) {\n            r++;\n        }\n        dfs(maze, r, c, destination);\n        r = curR;\n        c = curC;\n        while ((r - 1) >= 0 && maze[r - 1][c] != 1) {\n            r--;\n        }\n        dfs(maze, r, c, destination);\n    }\n}", "total_acs": 11485, "total_submitted": 26432}, {"id": 491, "title": "Increasing Subsequences", "url": "https://leetcode.com/problems/increasing-subsequences/description", "companyTags": ["Yahoo"], "difficulty": "Medium", "content": "\r\nGiven an integer array, your task is to find all the different possible increasing subsequences of the given array, and the length of an increasing subsequence should be at least 2 .\r\n\r\n\r\nExample:\r\n\r\nInput: [4, 6, 7, 7]\r\nOutput: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]\r\n\r\n\r\n\r\nNote:\r\n\r\nThe length of the given array will not exceed 15.\r\nThe range of integer in the given array is [-100,100].\r\nThe given array may contain duplicates, and two equal integers should also be considered as a special case of increasing sequence.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/638", "similarQuestions": ["MaximumLengthofPairChain"], "topicTags": ["Depth-firstSearch"], "Solution": "class Solution {\n    public List<List<Integer>> findSubsequences(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        List<Integer> list = new ArrayList<>();\n        findSubseq(nums, 0, result, list);\n        return result;\n    }\n    private void findSubseq(int[] nums, int index, List<List<Integer>> result, List<Integer> list) {\n        if (index == nums.length) {\n            if (list.size() > 1) {\n                result.add(new ArrayList<>(list));\n            }\n            return ;\n        }\n        if (list.isEmpty() || list.get(list.size() - 1) <= nums[index]) {\n            list.add(nums[index]);\n            findSubseq(nums, index + 1, result, list);\n            list.remove(list.size() - 1);\n        }\n        if (list.isEmpty() || list.get(list.size() - 1) != nums[index]){\n            findSubseq(nums, index + 1, result, list);\n        }\n    }\n}", "total_acs": 16139, "total_submitted": 41533}, {"id": 492, "title": "Construct the Rectangle", "url": "https://leetcode.com/problems/construct-the-rectangle/description", "companyTags": [""], "difficulty": "Easy", "content": "\r\nFor a web developer, it is very important to know how to design a web page's size. So, given a specific rectangular web page\u2019s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:\r\n1. The area of the rectangular web page you designed must equal to the given target area.\r\n2. The width W should not be larger than the length L, which means L >= W.\r\n3. The difference between length L and width W should be as small as possible.\r\n\r\nYou need to output the length L and the width W of the web page you designed in sequence.\r\n\r\n\r\n\r\nExample:\r\n\r\nInput: 4\r\nOutput: [2, 2]\r\nExplanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. \r\nBut according to requirement 2, [1,4] is illegal; according to requirement 3,  [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.\r\n\r\n\r\n\r\nNote:\r\n\r\nThe given area won't exceed 10,000,000 and is a positive integer\r\nThe web page's width and length you designed must be positive integers.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/639", "similarQuestions": [""], "topicTags": [""], "Solution": "class Solution {\n    public int[] constructRectangle(int area) {\n        int m = (int)Math.sqrt(area), offset = 0;\n        while (area%(m - offset) != 0) {\n            offset++;\n        }\n        return new int[]{Math.max(m - offset, area/(m - offset)), Math.min(m - offset, area/(m - offset))};\n    }\n}", "total_acs": 31220, "total_submitted": 64855}, {"id": 493, "title": "Reverse Pairs", "url": "https://leetcode.com/problems/reverse-pairs/description", "companyTags": ["Google"], "difficulty": "Hard", "content": "Given an array nums, we call (i, j) an important reverse pair if i < j and nums[i] > 2*nums[j].\r\n\r\nYou need to return the number of important reverse pairs in the given array.\r\n\r\nExample1:\r\n\r\nInput: [1,3,2,3,1]\r\nOutput: 2\r\n\r\n\r\nExample2:\r\n\r\nInput: [2,4,3,5,1]\r\nOutput: 3\r\n\r\n\r\nNote:\r\n\r\nThe length of the given array will not exceed 50,000.\r\nAll the numbers in the input array are in the range of 32-bit integer.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/640", "similarQuestions": ["CountofSmallerNumbersAfterSelf", "CountofRangeSum"], "topicTags": ["DivideandConquer", "BinaryIndexedTree", "SegmentTree", "BinarySearchTree"], "Solution": "\n// find the number of important reverse pairs with the first element of the pair coming from the left subarray nums[0, m] while the second element of the pair coming from the right subarray nums[m + 1, n - 1]\n\npublic class Solution {\n    public int res;\n    public int[] temp;  // for merge\n    \n    public int reversePairs(int[] nums) {\n        res = 0;\n        temp = new int[nums.length];\n        mergeSort(nums, 0, nums.length - 1);\n        return res;\n    }\n\n    public void mergeSort(int[] nums, int start, int end) {\n        if (start >= end) {\n            return;\n        }\n        int mid = start + (end - start) / 2;\n        mergeSort(nums, start, mid);\n        mergeSort(nums, mid + 1, end);\n\n        \n        // count and merge\n        // count elements: we want nums[left] > 2 * nums[right]\n        int count = 0;\n        int left = start, right = mid + 1;\n        while (left <= mid) {\n            if (right > end || (long)nums[left] <= 2 * (long)nums[right]) {\n                left++;\n                res += count;\n            } else {\n                right++;\n                count++;\n            }\n        }\n        \n        // merge sort\n        // Arrays.sort(nums, start, end + 1); \n        \n        left = start; right = mid + 1;\n        int index = start;\n        while (left <= mid && right <= end) {\n            if (nums[left] < nums[right]) {\n                temp[index++] = nums[left++];\n            } else {\n                temp[index++] = nums[right++];\n            }\n        }\n        while (left <= mid) {\n            temp[index++] = nums[left++];\n        }\n        while (right <= end) {\n            temp[index++] = nums[right++];\n        }\n        \n        // copy temp back to nums\n        for (index = start; index <= end; index++) {\n            nums[index] = temp[index];\n        }\n    }\n}\n\n// merge sort algorithm\n/*\npublic class Solution {\n\n    int[] temp;\n    public void sortIntegers2(int[] A) {\n        // use a shared temp array, the extra memory is O(n) at least\n        temp = new int[A.length];\n        mergeSort(A, 0, A.length - 1);\n    }\n    \n    private void mergeSort(int[] A, int start, int end) {\n        if (start >= end) {\n            return;\n        }\n        \n        int mid = (start + end) / 2;\n\n        mergeSort(A, start, mid);\n        mergeSort(A, mid + 1, end);\n        \n        merge(A, start, mid, end);\n    }\n    \n    private void merge(int[] A, int start, int mid, int end) {\n        int left = start;\n        int right = mid + 1;\n        int index = start;\n        \n        // merge two sorted subarrays in A to temp array\n        while (left <= mid && right <= end) {\n            if (A[left] < A[right]) {\n                temp[index++] = A[left++];\n            } else {\n                temp[index++] = A[right++];\n            }\n        }\n        while (left <= mid) {\n            temp[index++] = A[left++];\n        }\n        while (right <= end) {\n            temp[index++] = A[right++];\n        }\n        \n        // copy temp back to A\n        for (index = start; index <= end; index++) {\n            A[index] = temp[index];\n        }\n    }\n}*/", "total_acs": 10013, "total_submitted": 47762}, {"id": 494, "title": "Target Sum", "url": "https://leetcode.com/problems/target-sum/description", "companyTags": ["Google", "Facebook"], "difficulty": "Medium", "content": "\r\nYou are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.\r\n \r\n\r\nFind out how many ways to assign symbols to make sum of integers equal to target S.  \r\n\r\n\r\nExample 1:\r\n\r\nInput: nums is [1, 1, 1, 1, 1], S is 3. \r\nOutput: 5\r\nExplanation: \r\n\r\n-1+1+1+1+1 = 3\r\n+1-1+1+1+1 = 3\r\n+1+1-1+1+1 = 3\r\n+1+1+1-1+1 = 3\r\n+1+1+1+1-1 = 3\r\n\r\nThere are 5 ways to assign symbols to make the sum of nums be target 3.\r\n\r\n\r\n\r\nNote:\r\n\r\nThe length of the given array is positive and will not exceed 20. \r\nThe sum of elements in the given array will not exceed 1000.\r\nYour output answer is guaranteed to be fitted in a 32-bit integer.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/641", "similarQuestions": ["ExpressionAddOperators"], "topicTags": ["DynamicProgramming", "Depth-firstSearch"], "Solution": "class Solution {\n    public int findTargetSumWays(int[] nums, int S) {\n        int sum = 0;\n        for(int i = 0; i < nums.length; i++) {\n            sum += nums[i];\n        }\n        return  sum < S || (sum + S) % 2 == 1 ? 0 : helper(nums, (sum + S) / 2);\n    }\n    private int helper(int[] nums, int sum) {\n        int[] array = new int[sum + 1];\n        array[0] = 1;\n        for(int i = 0; i < nums.length; i++) {\n            for(int j = sum; j - nums[i] >= 0; j--) {\n                array[j] += array[j - nums[i]];\n            }\n        }\n        return array[sum];\n    }\n}", "total_acs": 44497, "total_submitted": 101629}, {"id": 495, "title": "Teemo Attacking", "url": "https://leetcode.com/problems/teemo-attacking/description", "companyTags": ["RiotGames"], "difficulty": "Medium", "content": "\r\nIn LOL world, there is a hero called Teemo and his attacking can make his enemy Ashe be in poisoned condition. Now, given the Teemo's attacking ascending time series towards Ashe and the poisoning time duration per Teemo's attacking, you need to output the total time that Ashe is in poisoned condition.\r\n\r\n\r\nYou may assume that Teemo attacks at the very beginning of a specific time point, and makes Ashe be in poisoned condition immediately.\r\n\r\nExample 1:\r\n\r\nInput: [1,4], 2\r\nOutput: 4\r\nExplanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned immediately. This poisoned status will last 2 seconds until the end of time point 2. And at time point 4, Teemo attacks Ashe again, and causes Ashe to be in poisoned status for another 2 seconds. So you finally need to output 4.\r\n\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: [1,2], 2\r\nOutput: 3\r\nExplanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned. This poisoned status will last 2 seconds until the end of time point 2. However, at the beginning of time point 2, Teemo attacks Ashe again who is already in poisoned status. Since the poisoned status won't add up together, though the second poisoning attack will still work at time point 2, it will stop at the end of time point 3. So you finally need to output 3.\r\n\r\n\r\n\r\n\r\nNote:\r\n\r\nYou may assume the length of given time series array won't exceed 10000.\r\nYou may assume the numbers in the Teemo's attacking time series and his poisoning time duration per attacking are non-negative integers, which won't exceed 10,000,000.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/642", "similarQuestions": ["MergeIntervals", "CanPlaceFlowers", "Dota2Senate"], "topicTags": ["Array"], "Solution": "class Solution {\n    public int findPoisonedDuration(int[] timeSeries, int duration) {\n        if (timeSeries == null || timeSeries.length == 0 || duration == 0) return 0;\n        \n        int result = 0, start = timeSeries[0], end = timeSeries[0] + duration;\n        for (int i = 1; i < timeSeries.length; i++) {\n            if (timeSeries[i] > end) {\n                result += end - start;\n                start = timeSeries[i];\n            }\n            end = timeSeries[i] + duration;\n        }\n        result += end - start;\n        \n        return result;\n    }\n}", "total_acs": 21563, "total_submitted": 41817}, {"id": 496, "title": "Next Greater Element I", "url": "https://leetcode.com/problems/next-greater-element-i/description", "companyTags": [""], "difficulty": "Easy", "content": "\r\nYou are given two arrays (without duplicates) nums1 and nums2 where nums1\u2019s elements are subset of nums2. Find all the next greater numbers for nums1's elements in the corresponding places of nums2. \r\n\r\n\r\n\r\nThe Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number.\r\n\r\n\r\nExample 1:\r\n\r\nInput: nums1 = [4,1,2], nums2 = [1,3,4,2].\r\nOutput: [-1,3,-1]\r\nExplanation:\r\n    For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.\r\n    For number 1 in the first array, the next greater number for it in the second array is 3.\r\n    For number 2 in the first array, there is no next greater number for it in the second array, so output -1.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: nums1 = [2,4], nums2 = [1,2,3,4].\r\nOutput: [3,-1]\r\nExplanation:\r\n    For number 2 in the first array, the next greater number for it in the second array is 3.\r\n    For number 4 in the first array, there is no next greater number for it in the second array, so output -1.\r\n\r\n\r\n\r\n\r\nNote:\r\n\r\nAll elements in nums1 and nums2 are unique.\r\nThe length of both nums1 and nums2 would not exceed 1000.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/645", "similarQuestions": ["NextGreaterElementII", "NextGreaterElementIII", "DailyTemperatures"], "topicTags": ["Stack"], "Solution": "\npublic class Solution {\n    public int[] nextGreaterElement(int[] findNums, int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return new int[]{};\n        }\n        int Length = nums.length;\n        int findLength = findNums.length;\n        int[] Final = new int[findLength];\n        int max = nums[0];\n\t    //\u627e\u5230nums\u4e2d\u6700\u5927\u7684\u503c\n        for (int i = 1; i < Length; i++) {\n            if (nums[i] > max) {\n                max = nums[i];\n            }\n        }\n        int[] Indexer = new int[max + 1];\n        for (int i = 0; i < Length; i++) {\n\t    //\u901a\u8fc7\u4e00\u4e2a\u65b0\u7684\u6570\u7ec4\uff0c\u5c06\u539f\u6570\u7ec4\u7684\u503c\u4f5c\u4e3a\u7d22\u5f15\uff0c\u539f\u6570\u7ec4\u7684\u7d22\u5f15\u4f5c\u4e3a\u503c\uff0c\n        //\u8fd9\u6837\u53ef\u4ee5\u5f88\u65b9\u4fbf\u7684\u627e\u5230\u6307\u5b9a\u6570\u7ec4\u5143\u7d20\u7684\u4e0b\u6807\uff0c\u53ea\u9700\u8981\u4e00\u6b21\u5faa\u73af\u5373\u53ef\uff0c\u800c\u6211\u5199\u7684findNums\n\t    //\u4e2d\u6709\u591a\u5c11\u5143\u7d20\uff0c\u5c31\u9700\u8981\u591a\u5c11\u6b21\u5faa\u73af\uff0c\u6548\u7387\u5f88\u4f4e\u3002 \u8fd9\u91cc\u9700\u8981\u5b66\u4e60\n            Indexer[nums[i]] = i;\n        }\n        boolean Found = false;\n        int cur, curindex;\n        for (int i = 0; i < findLength; i++) {\n            Found = false;\n            cur = findNums[i];\n\t        //\u627e\u5230\u9700\u8981\u904d\u5386\u7684\u7d22\u5f15\u503c\n            curindex = Indexer[cur] + 1;\n\t        //\u521d\u59cb\u5316\u4e3a-1\n            Final[i] = -1;\n    \t    //\u5224\u65ad\u5f53\u524d\u503c\u662f\u5426\u662f\u6700\u5927\u503c\uff0c\u5982\u679c\u662f\u6700\u5927\u503c\uff0c\u5c31\u4e0d\u7528\u627e\u4e86\uff0c\u800c\u6211\u5199\u7684\u6ca1\u6709\u6b64\u7c7b\u5224\u65ad\uff0c\u6548\u7387\u4f4e\u4e0b\n            if (cur != max) {\n\t           \t//\u5982\u679c\u5df2\u7ecf\u627e\u5230\u5927\u4e8ecur\u7684\u503c\uff0c\u5c31\u4e0d\u7528\u518d\u627e\u4e86\uff0c\u7528Found\u8fdb\u884c\u63a7\u5236\n                while (curindex < Length && Found != true) {\n                    if (nums[curindex] > cur) {\n                        Found = true;\n                        Final[i] = nums[curindex];\n                    }\n                    curindex++;\n                }\n            }\n        }\n        return Final;\n    }\n}\n\n", "total_acs": 49167, "total_submitted": 86817}, {"id": 498, "title": "Diagonal Traverse", "url": "https://leetcode.com/problems/diagonal-traverse/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "\r\nGiven a matrix of M x N elements (M rows, N columns), return all elements of the matrix in diagonal order as shown in the below image. \r\n\r\n\r\nExample:\r\n\r\nInput:\r\n[\r\n [ 1, 2, 3 ],\r\n [ 4, 5, 6 ],\r\n [ 7, 8, 9 ]\r\n]\r\nOutput:  [1,2,4,7,5,3,6,8,9]\r\nExplanation:\r\n\r\n\r\n\r\n\r\nNote:\r\n\r\nThe total number of elements of the given matrix will not exceed 10,000.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/647", "similarQuestions": [""], "topicTags": [""], "Solution": "//Time complexity: O(m * n), m = number of rows, n = number of columns.\n//Space complexity: O(1).\n//\u6839\u636e\u5f80\u4e0a\u6216\u8005\u5f80\u4e0b\u8d70\uff0c\u5982\u679c\u89e6\u5230\u8fb9\u4e86\u5c31\u6539\u53d8 r, c\u7684\u52a0\u51cf\uff0c \u53d1\u73b0r+c\u4e4b\u548c\u5355\u53cc\u6570\u4e0e\u8d70\u7684\u65b9\u5411\u6709\u5173\u5f88\u91cd\u8981\nclass Solution {\n    public int[] findDiagonalOrder(int[][] matrix) {\n        if (matrix.length == 0) return new int[0];\n        int r = 0, c = 0, m = matrix.length, n = matrix[0].length, arr[] = new int[m * n];\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = matrix[r][c];\n            if ((r + c) % 2 == 0) { // moving up\n                if      (c == n - 1) { r++; }\n                else if (r == 0)     { c++; }\n                else            { r--; c++; }\n            } else {                // moving down\n                if      (r == m - 1) { c++; }\n                else if (c == 0)     { r++; }\n                else            { r++; c--; }\n            }   \n        }   \n        return arr;\n    }\n}", "total_acs": 16009, "total_submitted": 34673}, {"id": 499, "title": "The Maze III", "url": "https://leetcode.com/problems/the-maze-iii/description", "companyTags": [""], "difficulty": "Hard", "content": "There is a ball in a maze with empty spaces and walls. The ball can go through empty spaces by rolling up (u), down (d), left (l) or right (r), but it won't stop rolling until hitting a wall. When the ball stops, it could choose the next direction. There is also a hole in this maze. The ball will drop into the hole if it rolls on to the hole.\r\n\r\n Given the ball position, the hole position and the maze, find out how the ball could drop into the hole by moving the shortest distance. The distance is defined by the number of empty spaces traveled by the ball from the start position (excluded) to the hole (included). Output the moving directions by using 'u', 'd', 'l' and 'r'. Since there could be several different shortest ways, you should output the lexicographically smallest way. If the ball cannot reach the hole, output \"impossible\".\r\n\r\nThe maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space. You may assume that the borders of the maze are all walls. The ball and the hole coordinates are represented by row and column indexes.\r\n\r\n\r\nExample 1\r\n\r\nInput 1: a maze represented by a 2D array\r\n\r\n0 0 0 0 0\r\n1 1 0 0 1\r\n0 0 0 0 0\r\n0 1 0 0 1\r\n0 1 0 0 0\r\n\r\nInput 2: ball coordinate (rowBall, colBall) = (4, 3)\r\nInput 3: hole coordinate (rowHole, colHole) = (0, 1)\r\n\r\nOutput: \"lul\"\r\nExplanation: There are two shortest ways for the ball to drop into the hole.\r\nThe first way is left -> up -> left, represented by \"lul\".\r\nThe second way is up -> left, represented by 'ul'.\r\nBoth ways have shortest distance 6, but the first way is lexicographically smaller because 'l' < 'u'. So the output is \"lul\".\r\n\r\n\r\n\r\n\r\n\r\nExample 2\r\n\r\nInput 1: a maze represented by a 2D array\r\n\r\n0 0 0 0 0\r\n1 1 0 0 1\r\n0 0 0 0 0\r\n0 1 0 0 1\r\n0 1 0 0 0\r\n\r\nInput 2: ball coordinate (rowBall, colBall) = (4, 3)\r\nInput 3: hole coordinate (rowHole, colHole) = (3, 0)\r\nOutput: \"impossible\"\r\nExplanation: The ball cannot reach the hole.\r\n\r\n\r\n\r\n\r\nNote:\r\n\r\nThere is only one ball and one hole in the maze.\r\nBoth the ball and hole exist on an empty space, and they will not be at the same position initially.\r\nThe given maze does not contain border (like the red rectangle in the example pictures), but you could assume the border of the maze are all walls.\r\nThe maze contains at least 2 empty spaces, and the width and the height of the maze won't exceed 30.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/648", "similarQuestions": ["TheMaze", "TheMazeII"], "topicTags": ["Depth-firstSearch", "Breadth-firstSearch"], "Solution": "class Solution {\n    //try to slove by dfs\n    int[][] length;\n    int min;\n    String minPath;\n    int[][] dir = new int[][]{{-1,0}, {0,-1}, {0,1}, {1,0}};\n    char[] dir_s = new char[]{'u', 'l','r','d'};\n    public String findShortestWay(int[][] maze, int[] ball, int[] hole) {\n        int n = maze.length, m = maze[0].length;\n        minPath = \"\";\n        min = Integer.MAX_VALUE;\n        length = new int[n][m];\n        for(int i = 0; i < n; i++){\n            Arrays.fill(length[i], Integer.MAX_VALUE); \n        }\n        dfs(maze, -1, ball[0], ball[1], \"\" ,0, hole);\n        return minPath == \"\" ? \"impossible\":minPath;\n    }\n    public void dfs(int[][] maze, int dir_i, int xx, int yy, String path, int count ,int[] hole){\n        if(count > min || count > length[xx][yy])\n            return;\n        if(dir_i != -1){\n            path += dir_s[dir_i];// this need to fucos !\n            \n            while( xx >= 0 && xx < maze.length && yy >= 0 && yy < maze[0].length && maze[xx][yy] == 0){\n                length[xx][yy] = Math.min(length[xx][yy],count);\n                // everytime we need to compare\n                if(xx == hole[0] && yy == hole[1]){\n                    if(count == min && path.compareTo(minPath) < 0){\n                        minPath = path;\n                    }else if(count < min){\n                        min = count;\n                        minPath = path;\n                    }\n                    return;\n                    \n                }\n                xx += dir[dir_i][0];\n                yy += dir[dir_i][1];\n                count++;\n            }\n            xx -= dir[dir_i][0];\n            yy -= dir[dir_i][1];\n            count--;\n        }\n        for(int i = 0; i < dir.length; i++){\n            if(i == dir_i) continue;\n            if(i == (3 - dir_i)) continue;\n            int x = xx + dir[i][0];\n            int y = yy + dir[i][1];\n            if(x >=0 && x < maze.length && y >=0 && y < maze[0].length && maze[x][y] == 0){\n                dfs(maze, i, xx, yy, path, count, hole);\n            }\n        }\n    }\n}", "total_acs": 4616, "total_submitted": 13795}, {"id": 500, "title": "Keyboard Row", "url": "https://leetcode.com/problems/keyboard-row/description", "companyTags": ["Mathworks"], "difficulty": "Easy", "content": "Given a List of words, return the words that can be typed using letters of alphabet on only one row's of American keyboard like the image below. \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput: [\"Hello\", \"Alaska\", \"Dad\", \"Peace\"]\r\nOutput: [\"Alaska\", \"Dad\"]\r\n\r\n\r\n\r\nNote:\r\n\r\nYou may use one character in the keyboard more than once.\r\nYou may assume the input string will only contain letters of alphabet.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/649", "similarQuestions": [""], "topicTags": ["HashTable"], "Solution": "class Solution {\n     public String[] findWords(String[] words)\n    {\n\tString[] rows =\n\t{ \"qwertyuiop\", \"asdfghjkl\", \"zxcvbnm\" };\n\tString[] returnArr = new String[words.length];\n\tint i;\n\tint j;\n\tint k;\n\tint l;\n\tboolean charFlag;\n\tboolean rowFlag;\n\tint row;\n\tfor (i = 0; i < words.length; i++)\n\t{\n\t    row = -1;\n\t    rowFlag = false;\n\t    charFlag = false;\n\t    char[] cArr = words[i].toCharArray();\n\t    for (j = 0; j < cArr.length; j++)\n\t    {\n\t\tchar currentChar = cArr[j];\n\t\t// find out which row to check based on initial character\n\t\tif (j == 0)\n\t\t{\n\t\t    for (k = 0; k < rows.length; k++)\n\t\t    {\n\t\t\tchar[] workingRow = rows[k].toCharArray();\n\t\t\tfor (l = 0; l < workingRow.length; l++)\n\t\t\t{\n\t\t\t    if (currentChar == workingRow[l] || (char) (currentChar + 32) == workingRow[l])\n\t\t\t    {\n\t\t\t\trowFlag = true;\n\t\t\t\trow = k;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t\tif (rowFlag)\n\t\t\t{\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (!rowFlag)\n\t\t{\n\t\t    break;\n\t\t}\n\t\t// After establishing row, check to see if other characters are\n\t\t// in it\n\t\telse\n\t\t{\n\t\t    charFlag = false;\n\t\t    char[] workingRow = rows[row].toCharArray();\n\t\t    for (l = 0; l < workingRow.length; l++){\n\t\t\tif (currentChar == workingRow[l] || (char) (currentChar + 32) == workingRow[l]){\n\t\t\t    charFlag = true;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    if (!charFlag){\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\t\n\t    }\n\t    if (charFlag && rowFlag){\n\t\t    returnArr[i] = words[i];\n\t\t}\n\t}\n\tArrayList<String> list = new ArrayList<>();\n\tint counter;\n\tfor (counter = 0; counter < returnArr.length; counter++){\n\t    if (returnArr[counter] != null){\n\t\tlist.add(returnArr[counter]);\n\t    }\n\t}\n\treturn list.toArray(new String[list.size()]);\n    }\n}", "total_acs": 55154, "total_submitted": 92271}, {"id": 501, "title": "Find Mode in Binary Search Tree", "url": "https://leetcode.com/problems/find-mode-in-binary-search-tree/description", "companyTags": ["Google"], "difficulty": "Easy", "content": "Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST.\r\n\r\n\r\nAssume a BST is defined as follows:\r\n\r\nThe left subtree of a node contains only nodes with keys less than or equal to the node's key.\r\nThe right subtree of a node contains only nodes with keys greater than or equal to the node's key.\r\nBoth the left and right subtrees must also be binary search trees.\r\n\r\n\r\n\r\n\r\nFor example:\r\nGiven BST [1,null,2,2],\r\n\r\n   1\r\n    \\\r\n     2\r\n    /\r\n   2\r\n\r\n\r\n\r\nreturn [2].\r\n\r\n\r\nNote:\r\nIf a tree has more than one mode, you can return them in any order.\r\n\r\n\r\nFollow up:\r\nCould you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).\r\n", "discussUrl": "https://discuss.leetcode.com/category/650", "similarQuestions": ["ValidateBinarySearchTree"], "topicTags": ["Tree"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    TreeNode prev = null;\n    int freq = 0, max = 0;\n    public int[] findMode(TreeNode root) {\n        if(root == null) return new int[0];\n        List<Integer> list = new ArrayList<>();\n        inorder(root, list);\n        int[] ans = new int[list.size()];\n        for(int i = 0; i < list.size(); i++) {\n            ans[i] = list.get(i);\n        }\n        return ans;\n    }\n    \n    public void inorder(TreeNode root, List<Integer> list) {\n        if(root == null) return ;\n        inorder(root.left, list);\n        if(prev != null && root.val == prev.val) freq++;\n        else freq = 1;\n        if(freq > max) {\n            max = freq;\n            list.clear();\n            list.add(root.val);\n        }\n        else if(freq == max) {\n            list.add(root.val);\n        }\n        prev = root;\n        inorder(root.right, list);\n    }\n}", "total_acs": 29867, "total_submitted": 79221}, {"id": 502, "title": "IPO", "url": "https://leetcode.com/problems/ipo/description", "companyTags": [""], "difficulty": "Hard", "content": "\r\nSuppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects. \r\n\r\n\r\n\r\nYou are given several projects. For each project i, it has a pure profit Pi and a minimum capital of Ci is needed to start the corresponding project. Initially, you have W capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.\r\n\r\n\r\n\r\nTo sum up, pick a list of at most k distinct projects from given projects to maximize your final capital, and output your final maximized capital.\r\n\r\n\r\nExample 1:\r\n\r\nInput: k=2, W=0, Profits=[1,2,3], Capital=[0,1,1].\r\n\r\nOutput: 4\r\n\r\nExplanation: Since your initial capital is 0, you can only start the project indexed 0.\r\n             After finishing it you will obtain profit 1 and your capital becomes 1.\r\n             With capital 1, you can either start the project indexed 1 or the project indexed 2.\r\n             Since you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.\r\n             Therefore, output the final maximized capital, which is 0 + 1 + 3 = 4.\r\n\r\n\r\n\r\nNote:\r\n\r\nYou may assume all numbers in the input are non-negative integers.\r\nThe length of Profits array and Capital array will not exceed 50,000.\r\nThe answer is guaranteed to fit in a 32-bit signed integer.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/651", "similarQuestions": [""], "topicTags": ["Heap", "Greedy"], "Solution": "class Solution {\n    public int findMaximizedCapital(int k, int W, int[] Profits, int[] Capital) {\n        int max = -1;\n        int l = Profits.length;\n        for(int c : Capital){\n            max = Math.max(max,c);\n        }\n        if(W>=max){\n            Arrays.sort(Profits);\n            l--;\n            for(int i=0;i<k;i++){\n                W += Profits[l--];\n            }\n            return W;\n        }\n        \n        \n        \n        \n        \n        \n        Set<Integer> s = new HashSet<Integer>();\n        for(int i=1;i<=k;i++){\n            int curP = 0;\n            int index = -1;\n            for(int j=0;j<l;j++){\n                if(Capital[j]<=W&&!s.contains(j)){\n                    if(Profits[j]>curP){\n                        index = j;\n                        curP = Profits[j];\n                    }\n                }\n            }\n            if(index==-1){break;}\n            W += curP;\n            s.add(index);\n        }\n        return W;\n    }\n}", "total_acs": 6475, "total_submitted": 17706}, {"id": 503, "title": "Next Greater Element II", "url": "https://leetcode.com/problems/next-greater-element-ii/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "\r\nGiven a circular array (the next element of the last element is the first element of the array), print the Next Greater Number for every element. The Next Greater Number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn't exist, output -1 for this number.\r\n\r\n\r\nExample 1:\r\n\r\nInput: [1,2,1]\r\nOutput: [2,-1,2]\r\nExplanation: The first 1's next greater number is 2; The number 2 can't find next greater number; The second 1's next greater number needs to search circularly, which is also 2.\r\n\r\n\r\n\r\nNote:\r\nThe length of given array won't exceed 10000.\r\n", "discussUrl": "https://discuss.leetcode.com/category/652", "similarQuestions": ["NextGreaterElementI", "NextGreaterElementIII"], "topicTags": ["Stack"], "Solution": "class Solution {\n    public int[] nextGreaterElements(int[] nums) {\n        int n = nums.length;\n        int[] ans = new int[n];\n        if(n <= 1){\n            Arrays.fill(ans, -1);\n            return ans;\n        }\n        ans[n - 1] = -1;\n        for(int i = n - 2; i >= 0; i--) {\n            findHigher(nums, ans, i, i + 1);\n        }\n        int j = 0;\n        for(int i = n - 1; i >= 0; i--) {\n            if(ans[i] == -1){\n                findHigher(nums, ans, i, j);\n            }\n        }\n        for(int i = 0; i < n; i++){\n            if(ans[i] != -1) ans[i] = nums[ans[i]];\n        }\n        return ans;\n    }\n    void findHigher(int[]nums, int ans[], int i, int j){\n        while(j >= 0 && nums[j] <= nums[i]) {\n            j = ans[j];\n        }\n        ans[i] = j == -1 ? -1 : j;\n    }\n}", "total_acs": 23450, "total_submitted": 48967}, {"id": 504, "title": "Base 7", "url": "https://leetcode.com/problems/base-7/description", "companyTags": [""], "difficulty": "Easy", "content": "Given an integer, return its base 7 string representation.\r\n\r\nExample 1:\r\n\r\nInput: 100\r\nOutput: \"202\"\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: -7\r\nOutput: \"-10\"\r\n\r\n\r\n\r\nNote:\r\nThe input will be in range of [-1e7, 1e7].\r\n", "discussUrl": "https://discuss.leetcode.com/category/653", "similarQuestions": [""], "topicTags": [""], "Solution": "class Solution {\n    public String convertToBase7(int num) {\n        boolean isNegative = false;\n        if(num < 0) {\n            isNegative = true;\n            num = -num;\n        }\n        \n        int result = 0;\n        int multiple = 1;\n        while(num > 0) {\n            int rem = num % 7;\n            num = num / 7;\n            result = (rem * multiple) + result;\n            multiple *= 10;\n        }\n        \n        if(isNegative) {\n            result = -result;\n        }\n        \n        return String.valueOf(result);\n    }\n}", "total_acs": 25156, "total_submitted": 57192}, {"id": 505, "title": "The Maze II", "url": "https://leetcode.com/problems/the-maze-ii/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "There is a ball in a maze with empty spaces and walls. The ball can go through empty spaces by rolling up, down, left or right, but it won't stop rolling until hitting a wall. When the ball stops, it could choose the next direction.\r\n\r\nGiven the ball's start position, the destination and the maze, find the shortest distance for the ball to stop at the destination. The distance is defined by the number of empty spaces traveled by the ball from the start position (excluded) to the destination (included). If the ball cannot stop at the destination, return -1.\r\n\r\nThe maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space. You may assume that the borders of the maze are all walls. The start and destination coordinates are represented by row and column indexes.\r\n\r\n\r\nExample 1\r\n\r\nInput 1: a maze represented by a 2D array\r\n\r\n0 0 1 0 0\r\n0 0 0 0 0\r\n0 0 0 1 0\r\n1 1 0 1 1\r\n0 0 0 0 0\r\n\r\nInput 2: start coordinate (rowStart, colStart) = (0, 4)\r\nInput 3: destination coordinate (rowDest, colDest) = (4, 4)\r\n\r\nOutput: 12\r\nExplanation: One shortest way is : left -> down -> left -> down -> right -> down -> right.\r\n             The total distance is 1 + 1 + 3 + 1 + 2 + 2 + 2 = 12.\r\n\r\n\r\n\r\n\r\n\r\nExample 2\r\n\r\nInput 1: a maze represented by a 2D array\r\n\r\n0 0 1 0 0\r\n0 0 0 0 0\r\n0 0 0 1 0\r\n1 1 0 1 1\r\n0 0 0 0 0\r\n\r\nInput 2: start coordinate (rowStart, colStart) = (0, 4)\r\nInput 3: destination coordinate (rowDest, colDest) = (3, 2)\r\n\r\nOutput: -1\r\nExplanation: There is no way for the ball to stop at the destination.\r\n\r\n\r\n\r\n\r\nNote:\r\n\r\nThere is only one ball and one destination in the maze.\r\nBoth the ball and the destination exist on an empty space, and they will not be at the same position initially.\r\nThe given maze does not contain border (like the red rectangle in the example pictures), but you could assume the border of the maze are all walls.\r\nThe maze contains at least 2 empty spaces, and both the width and height of the maze won't exceed 100.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/654", "similarQuestions": ["TheMaze", "TheMazeIII"], "topicTags": ["Depth-firstSearch", "Breadth-firstSearch"], "Solution": "class Solution {\n    public static final int[][] dirs = new int[][] {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\n\n    public int shortestDistance(int[][] maze, int[] start, int[] destination) {\n        if(maze == null || maze.length == 0\n                   || maze[0].length == 0) {\n            return -1;\n        }\n\n        int m = maze.length, n = maze[0].length;\n        int[][] dp = new int[m][n];\n        Queue<Pair> que = new LinkedList<>();\n\n        que.offer(new Pair(start[0], start[1], 0));\n        for(int i = 0; i < m; i++) {\n            Arrays.fill(dp[i], Integer.MAX_VALUE);\n        }\n\n\n        while(!que.isEmpty()) {\n            Pair cur = que.poll();\n            for(int[] dir : dirs) {\n                int nextX = cur.x;\n                int nextY = cur.y;\n                int len = cur.len;\n                while(nextX < m && nextX >= 0 && nextY < n && nextY >= 0 && maze[nextX][nextY] == 0) {\n                    nextX += dir[0];\n                    nextY += dir[1];\n                    len++;\n\n                }\n                nextX -= dir[0];\n                nextY -= dir[1];\n                len--;\n\n                // avoid going through unneccessary cases.\n                if(len > dp[destination[0]][destination[1]]) {\n                    continue;\n                }\n\n                if(len < dp[nextX][nextY]) {\n                    dp[nextX][nextY] = len;\n                    que.offer(new Pair(nextX, nextY, len));\n                }\n            }\n        }\n\n        return dp[destination[0]][destination[1]] == Integer.MAX_VALUE ? -1 : dp[destination[0]][destination[1]];\n\n    }\n}\nclass Pair {\n    int x;\n    int y;\n    int len;\n    public Pair(int x, int y, int len) {\n        this.x = x;\n        this.y = y;\n        this.len = len;\n    }\n}", "total_acs": 10240, "total_submitted": 26393}, {"id": 506, "title": "Relative Ranks", "url": "https://leetcode.com/problems/relative-ranks/description", "companyTags": ["Google"], "difficulty": "Easy", "content": "\r\nGiven scores of N athletes, find their relative ranks and the people with the top three highest scores, who will be awarded medals: \"Gold Medal\", \"Silver Medal\" and \"Bronze Medal\".\r\n\r\nExample 1:\r\n\r\nInput: [5, 4, 3, 2, 1]\r\nOutput: [\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\", \"4\", \"5\"]\r\nExplanation: The first three athletes got the top three highest scores, so they got \"Gold Medal\", \"Silver Medal\" and \"Bronze Medal\". For the left two athletes, you just need to output their relative ranks according to their scores.\r\n\r\n\r\n\r\nNote:\r\n\r\nN is a positive integer and won't exceed 10,000.\r\nAll the scores of athletes are guaranteed to be unique.\r\n\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/655", "similarQuestions": [""], "topicTags": [""], "Solution": "class Solution {\n    public String[] findRelativeRanks(int[] nums) {\n        String[] result = new String[nums.length];\n        int max = 0;\n        for (int num : nums) max = Math.max(max, num);\n        int[] hash = new int[max + 1];\n        for (int i = 0; i < nums.length; i++) {\n            hash[nums[i]] = i + 1;\n        }\n        int rank = 1;\n        for (int i = hash.length -1; i >= 0; i--) {\n            if (hash[i] == 0)continue;\n            if (rank == 1) {\n                result[hash[i] - 1] = \"Gold Medal\";\n            } else if (rank == 2){\n                result[hash[i] - 1] = \"Silver Medal\";\n            } else if (rank == 3) {\n                result[hash[i] - 1] = \"Bronze Medal\";\n            } else  {\n                result[hash[i] - 1] = String.valueOf(rank);\n            }\n            rank ++;\n        }\n        return result;\n    }\n}", "total_acs": 27029, "total_submitted": 57763}, {"id": 507, "title": "Perfect Number", "url": "https://leetcode.com/problems/perfect-number/description", "companyTags": ["Fallible"], "difficulty": "Easy", "content": "We define the Perfect Number is a positive integer that is equal to the sum of all its positive divisors except itself. \r\n\r\nNow, given an integer n, write a function that returns true when it is a perfect number and false when it is not.\r\n\r\n\r\nExample:\r\n\r\nInput: 28\r\nOutput: True\r\nExplanation: 28 = 1 + 2 + 4 + 7 + 14\r\n\r\n\r\n\r\nNote:\r\nThe input number n will not exceed 100,000,000. (1e8)\r\n", "discussUrl": "https://discuss.leetcode.com/category/657", "similarQuestions": ["SelfDividingNumbers"], "topicTags": ["Math"], "Solution": "class Solution {\n    public boolean checkPerfectNumber(int num) {\n        if (num == 6 || num == 8 || num == 28 || num == 496 || num == 8128 || num == 33550336){\n            return true;\n        }\n     \n        return false;\n    }\n}", "total_acs": 20310, "total_submitted": 61907}, {"id": 508, "title": "Most Frequent Subtree Sum", "url": "https://leetcode.com/problems/most-frequent-subtree-sum/description", "companyTags": ["Amazon"], "difficulty": "Medium", "content": "\r\nGiven the root of a tree, you are asked to find the most frequent subtree sum. The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). So what is the most frequent subtree sum value? If there is a tie, return all the values with the highest frequency in any order.\r\n\r\n\r\nExamples 1\r\nInput:\r\n\r\n  5\r\n /  \\\r\n2   -3\r\n\r\nreturn [2, -3, 4], since all the values happen only once, return all of them in any order.\r\n\r\n\r\nExamples 2\r\nInput:\r\n\r\n  5\r\n /  \\\r\n2   -5\r\n\r\nreturn [2], since 2 happens twice, however -5 only occur once.\r\n\r\n\r\nNote:\r\nYou may assume the sum of values in any subtree is in the range of 32-bit signed integer.\r\n", "discussUrl": "https://discuss.leetcode.com/category/658", "similarQuestions": ["SubtreeofAnotherTree"], "topicTags": ["HashTable", "Tree"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    int max = 0;\n    public int[] findFrequentTreeSum(TreeNode root) {\n        List<Integer> list = new ArrayList<>();\n        HashMap<Integer, Integer> map = new HashMap<>();\n        \n        sum(root, list, map);\n        int[] ret = new int[list.size()];\n        for (int i = 0; i < ret.length; i++) {\n            ret[i] = list.get(i);\n        }\n        return ret;\n    }\n    private int sum(TreeNode root, List<Integer> list, HashMap<Integer, Integer> map) {\n        if (root == null) return 0;\n        int sum = 0;\n        sum += sum(root.left, list, map);\n        sum += sum(root.right, list, map);\n        sum += root.val;\n        int count = 1;\n        if (map.containsKey(sum)) {\n            count = map.get(sum) + 1;\n            map.put(sum, count);\n        }\n        else map.put(sum, 1);\n        if (count > max) {\n            list.clear();\n            max = count;\n        }\n        if (count == max) list.add(sum);   \n        return sum;\n    }\n}", "total_acs": 26886, "total_submitted": 51432}, {"id": 513, "title": "Find Bottom Left Tree Value", "url": "https://leetcode.com/problems/find-bottom-left-tree-value/description", "companyTags": ["Microsoft"], "difficulty": "Medium", "content": "\r\nGiven a binary tree, find the leftmost value in the last row of the tree. \r\n\r\n\r\nExample 1:\r\n\r\nInput:\r\n\r\n    2\r\n   / \\\r\n  1   3\r\n\r\nOutput:\r\n1\r\n\r\n\r\n\r\n  Example 2: \r\n\r\nInput:\r\n\r\n        1\r\n       / \\\r\n      2   3\r\n     /   / \\\r\n    4   5   6\r\n       /\r\n      7\r\n\r\nOutput:\r\n7\r\n\r\n\r\n\r\nNote:\r\nYou may assume the tree (i.e., the given root node) is not NULL.\r\n", "discussUrl": "https://discuss.leetcode.com/category/661", "similarQuestions": [""], "topicTags": ["Tree", "Depth-firstSearch", "Breadth-firstSearch"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    int res = 0;\n    int deep = 0;\n    public int findBottomLeftValue(TreeNode root) {\n        traverse(root, 1);\n        return res;\n    }\n    \n    private void traverse(TreeNode x, int depth) {\n        if (x != null) {\n            if (depth > deep) {\n                deep = depth;\n                res = x.val;\n            }\n            traverse(x.left, depth+1);\n            traverse(x.right, depth+1);\n            \n        }\n            \n    }\n}", "total_acs": 38012, "total_submitted": 67885}, {"id": 514, "title": "Freedom Trail", "url": "https://leetcode.com/problems/freedom-trail/description", "companyTags": ["Google"], "difficulty": "Hard", "content": "\r\nIn the video game Fallout 4, the quest \"Road to Freedom\" requires players to reach a metal dial called the \"Freedom Trail Ring\", and use the dial to spell a specific keyword in order to open the door. \r\n\r\n\r\n\r\nGiven a string ring, which represents the code engraved on the outer ring and another string key, which represents the keyword needs to be spelled. You need to find the minimum number of steps in order to spell all the characters in the keyword.\r\n\r\nInitially, the first character of the ring is aligned at 12:00 direction. You need to spell all the characters in the string key one by one by rotating the ring clockwise or anticlockwise to make each character of the string key aligned at 12:00 direction and then by pressing the center button.\r\n\r\n\r\nAt the stage of rotating the ring to spell the key character key[i]:\r\n\r\nYou can rotate the ring clockwise or anticlockwise one place, which counts as 1 step. The final purpose of the rotation is to align one of the string ring's characters at the 12:00 direction, where this character must equal to the character key[i].\r\n\r\nIf the character key[i] has been aligned at the 12:00 direction, you need to press the center button to spell, which also counts as 1 step. After the pressing, you could begin to spell the next character in the key (next stage), otherwise, you've finished all the spelling.\r\n\r\n\r\n\r\n\r\nExample:\r\n\r\n\r\n\r\n\r\n\r\nInput: ring = \"godding\", key = \"gd\"\r\nOutput: 4\r\nExplanation: For the first key character 'g', since it is already in place, we just need 1 step to spell this character.  For the second key character 'd', we need to rotate the ring \"godding\" anticlockwise by two steps to make it become \"ddinggo\". Also, we need 1 more step for spelling. So the final output is 4.\r\n\r\n\r\n\r\nNote:\r\n\r\nLength of both ring and key will be in range 1 to 100.\r\nThere are only lowercase letters in both strings and might be some duplcate characters in both strings.\r\nIt's guaranteed that string key could always be spelled by rotating the string ring.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/662", "similarQuestions": [""], "topicTags": ["DivideandConquer", "DynamicProgramming", "Depth-firstSearch"], "Solution": "class Solution {\n    public int findRotateSteps(String ring, String key) {\n        List<Integer>[] pos = new List[26];\n        for (int i = 0; i < 26; i++) {\n            pos[i] = new ArrayList<>();\n        }\n        for (int i = 0; i < ring.length(); i++) {\n            pos[ring.charAt(i) - 'a'].add(i);\n        }\n        return dfs(pos, 0, ring.length(), key, 0, new int[ring.length()][key.length()]);\n    }\n    \n    // pos stores the indices of each character\n    private int dfs(List<Integer>[] pos, int i, int ringLen, String key, int j, int[][] dp) {\n        if (j == key.length()) return 0;\n        if (dp[i][j] != 0) return dp[i][j];\n        int need = key.charAt(j) - 'a';\n        int res = Integer.MAX_VALUE;\n        for (int k : pos[need]) {\n            int step = Math.abs(i - k);\n            int move = Math.min(step, ringLen - step) + 1;\n            res = Math.min(res, move + dfs(pos, k, ringLen, key, j + 1, dp));\n        }\n        dp[i][j] = res;\n        return res;\n    }\n}", "total_acs": 7541, "total_submitted": 19383}, {"id": 515, "title": "Find Largest Value in Each Tree Row", "url": "https://leetcode.com/problems/find-largest-value-in-each-tree-row/description", "companyTags": ["LinkedIn"], "difficulty": "Medium", "content": "You need to find the largest value in each row of a binary tree.\r\n\r\nExample:\r\n\r\nInput: \r\n\r\n          1\r\n         / \\\r\n        3   2\r\n       / \\   \\  \r\n      5   3   9 \r\n\r\nOutput: [1, 3, 9]\r\n\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/663", "similarQuestions": [""], "topicTags": ["Tree", "Depth-firstSearch", "Breadth-firstSearch"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<Integer> largestValues(TreeNode root) {\n        List<Integer> res = new ArrayList<Integer>();\n        helper(root, res, 0);\n        \n        return res;\n    }\n    \n    private void helper(TreeNode root, List<Integer> res, int d){\n        if (root == null){\n            return;\n        }\n       //expand list size\n        if (d == res.size()){\n            res.add(root.val);\n        } else if (res.get(d) < root.val) {\n        //or set value\n            res.set(d, root.val);\n        }\n        \n        helper(root.left, res, d+1);\n        helper(root.right, res, d+1);\n\n    }\n}", "total_acs": 33721, "total_submitted": 60915}, {"id": 516, "title": "Longest Palindromic Subsequence", "url": "https://leetcode.com/problems/longest-palindromic-subsequence/description", "companyTags": ["Amazon", "Uber"], "difficulty": "Medium", "content": "\r\nGiven a string s, find the longest palindromic subsequence's length in s. You may assume that the maximum length of s is 1000.\r\n\r\n\r\nExample 1:\r\nInput: \r\n\r\n\"bbbab\"\r\n\r\nOutput: \r\n\r\n4\r\n\r\nOne possible longest palindromic subsequence is \"bbbb\".\r\n\r\n\r\nExample 2:\r\nInput:\r\n\r\n\"cbbd\"\r\n\r\nOutput:\r\n\r\n2\r\n\r\nOne possible longest palindromic subsequence is \"bb\".\r\n", "discussUrl": "https://discuss.leetcode.com/category/664", "similarQuestions": ["LongestPalindromicSubstring", "PalindromicSubstrings", "CountDifferentPalindromicSubsequences"], "topicTags": ["DynamicProgramming"], "Solution": "class Solution {\n    //improve\n    //idea:DP[i] means the longest palindrome start from i\n    public int longestPalindromeSubseq(String s) {\n        int len = s.length();\n        int[] dp = new int[len];\n        char[] input = s.toCharArray();\n        Arrays.fill(dp, 1); //a single char is count as a palindrom with length 1\n        for(int i =0; i < len; i++){\n            int curLong = 0;\n            for(int j = i -1; j >=0; j--){\n                int temp = dp[j];\n                if(input[j] == input[i]){\n                    dp[j] = curLong + 2;\n                }\n                curLong = Math.max(curLong, temp);\n            }\n        }\n        int max = 0;\n        for(int n : dp) max = Math.max(max, n);\n        return max;\n    }\n    //what is the idea?\n    //reverse it, then it become longest common subsequence of two string\n    /*public int longestPalindromeSubseq(String s) {\n        StringBuilder sb = new StringBuilder(s);\n        return LCS(s, sb.reverse().toString());\n    }\n    private int LCS(String s1, String s2){\n        int len1 = s1.length(), len2 = s2.length();\n        int[][] memo = new int[len1 + 1][len2 + 1];\n        for(int i =0; i <= len1; i++){\n            for(int j =0; j <= len2; j++){\n                memo[i][j] = -1;\n            }\n        }\n        return LCS(s1, s2, memo, len1, len2);\n    }\n    private int LCS(String s1, String s2, int[][] memo, int i, int j){\n        if(i <= 0 || j <= 0) return 0;\n        if(memo[i][j] != -1) return memo[i][j];\n        if(s1.charAt(i - 1) == s2.charAt(j - 1)){\n            memo[i][j] = LCS(s1, s2, memo, i - 1, j -1) + 1;\n        }else{\n            memo[i][j] = Math.max(LCS(s1, s2, memo, i -1,j), LCS(s1, s2, memo, i, j - 1));\n        }\n        return memo[i][j];\n    }*/\n}", "total_acs": 26219, "total_submitted": 61417}, {"id": 517, "title": "Super Washing Machines", "url": "https://leetcode.com/problems/super-washing-machines/description", "companyTags": ["Amazon"], "difficulty": "Hard", "content": "You have n super washing machines on a line. Initially, each washing machine has some dresses or is empty. \r\n\r\n\r\nFor each move, you could choose any m (1 \u2264 m \u2264 n) washing machines, and pass one dress of each washing machine to one of its adjacent washing machines  at the same time .  \r\n\r\nGiven an integer array representing the number of dresses in each washing machine from left to right on the line, you should find the minimum number of moves to make all the washing machines have the same number of dresses. If it is not possible to do it, return -1.\r\n\r\nExample1\r\n\r\nInput: [1,0,5]\r\n\r\nOutput: 3\r\n\r\nExplanation: \r\n1st move:    1     0 <-- 5    =>    1     1     4\r\n2nd move:    1 <-- 1 <-- 4    =>    2     1     3    \r\n3rd move:    2     1 <-- 3    =>    2     2     2   \r\n\r\n\r\nExample2\r\n\r\nInput: [0,3,0]\r\n\r\nOutput: 2\r\n\r\nExplanation: \r\n1st move:    0 <-- 3     0    =>    1     2     0    \r\n2nd move:    1     2 --> 0    =>    1     1     1     \r\n\r\n\r\nExample3\r\n\r\nInput: [0,2,0]\r\n\r\nOutput: -1\r\n\r\nExplanation: \r\nIt's impossible to make all the three washing machines have the same number of dresses. \r\n\r\n\r\n\r\n\r\nNote:\r\n\r\nThe range of n is [1, 10000].\r\nThe range of dresses number in a super washing machine is [0, 1e5].\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/665", "similarQuestions": [""], "topicTags": ["Math", "DynamicProgramming"], "Solution": "class Solution {\n    public int findMinMoves(int[] nums) {\n\t\tint sum = 0;\n\t\tfor (int num : nums){\n\t\t\tsum += num;\n\t\t}\n\t\tif (sum % nums.length != 0) return -1;\n\t\tint res = 0, avg = sum / nums.length;\n\t\tint[] outflow = new int[nums.length]; // total outflow from one wash machine\n\t\tfor (int i = 0; i < nums.length-1; i++){\n\t\t\tif (nums[i] > avg){\n\t\t\t\toutflow[i] += nums[i] - avg; // may outflow more than once, actually twice so use +=\n\t\t\t\tnums[i+1] += nums[i] - avg;  \n\t\t\t\t// nums[i] = avg;              //nums[i] is completed, so will not be used in future\t\t\t\t\n\t\t\t\tres = Math.max(res, outflow[i]);\n\t\t\t} else {\n\t\t\t\toutflow[i+1] += avg - nums[i]; // both += and = will work, because this is the first time calcualtion for [i+1]\n\t\t\t\tnums[i+1] -= avg - nums[i]; // no harm to keep this line, but will not be used any more, \n\t\t\t\tres = Math.max(res, outflow[i+1]);\n\t\t\t}\n\t\t}\n\t\treturn res;\t\t\n    }\n}", "total_acs": 7481, "total_submitted": 20557}, {"id": 518, "title": "Coin Change 2", "url": "https://leetcode.com/problems/coin-change-2/description", "companyTags": [""], "difficulty": "Medium", "content": "\r\nYou are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin.\r\n\r\n\r\nNote: \r\nYou can assume that\r\n\r\n 0 <= amount <= 5000\r\n 1 <= coin <= 5000\r\n the number of coins is less than 500 \r\n the answer is guaranteed to fit into signed 32-bit integer\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput: amount = 5, coins = [1, 2, 5]\r\nOutput: 4\r\nExplanation: there are four ways to make up the amount:\r\n5=5\r\n5=2+2+1\r\n5=2+1+1+1\r\n5=1+1+1+1+1\r\n\r\n\r\nExample 2:\r\n\r\nInput: amount = 3, coins = [2]\r\nOutput: 0\r\nExplanation: the amount of 3 cannot be made up just with coins of 2.\r\n\r\n\r\nExample 3:\r\n\r\nInput: amount = 10, coins = [10] \r\nOutput: 1\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/666", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 10902, "total_submitted": 31584}, {"id": 520, "title": "Detect Capital", "url": "https://leetcode.com/problems/detect-capital/description", "companyTags": ["Google"], "difficulty": "Easy", "content": "\r\nGiven a word, you need to judge whether the usage of capitals in it is right or not.\r\n\r\n\r\n\r\nWe define the usage of capitals in a word to be right when one of the following cases holds:\r\n\r\nAll letters in this word are capitals, like \"USA\".\r\nAll letters in this word are not capitals, like \"leetcode\".\r\nOnly the first letter in this word is capital if it has more than one letter, like \"Google\".\r\n\r\nOtherwise, we define that this word doesn't use capitals in a right way.\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput: \"USA\"\r\nOutput: True\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: \"FlaG\"\r\nOutput: False\r\n\r\n\r\n\r\nNote:\r\nThe input will be a non-empty word consisting of uppercase and lowercase latin letters.\r\n", "discussUrl": "https://discuss.leetcode.com/category/668", "similarQuestions": [""], "topicTags": ["String"], "Solution": "class Solution {\n    public boolean detectCapitalUse(String word) {\n        int sum = 0;\n        for (int i = 0; i < word.length(); i++) {\n            if (word.charAt(i) >= 'A' && word.charAt(i) < 'a') {\n                sum += 1;\n            } \n        }\n        if (sum == word.length()) {\n            return true;\n        }\n        if (sum == 1 && (word.charAt(0) >= 'A' && word.charAt(0) < 'a')) {\n            return true;\n        }\n        if (sum == 0) {\n            return true;\n        } \n        return false;\n    }\n}", "total_acs": 49473, "total_submitted": 95249}, {"id": 521, "title": "Longest Uncommon Subsequence I ", "url": "https://leetcode.com/problems/longest-uncommon-subsequence-i/description", "companyTags": ["Google"], "difficulty": "Easy", "content": "\r\nGiven a group of two strings, you need to find the longest uncommon subsequence of this group of two strings.\r\nThe longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings.\r\n\r\n\r\n\r\nA subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.\r\n\r\n\r\n\r\nThe input will be two strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn't exist, return -1.\r\n\r\n\r\nExample 1:\r\n\r\nInput: \"aba\", \"cdc\"\r\nOutput: 3\r\nExplanation: The longest uncommon subsequence is \"aba\" (or \"cdc\"), because \"aba\" is a subsequence of \"aba\", but not a subsequence of any other strings in the group of two strings. \r\n\r\n\r\n\r\nNote:\r\n\r\nBoth strings' lengths will not exceed 100.\r\nOnly letters from a ~ z will appear in input strings. \r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/669", "similarQuestions": ["LongestUncommonSubsequenceII"], "topicTags": ["String"], "Solution": "class Solution {\n    public int findLUSlength(String a, String b) {\n        if ((a == null && b == null) || \n            (a.length() == 0 && b.length() == 0)) {\n            return -1;\n        }\n        if (a == null || a.length() == 0) {\n            return b.length();\n        }\n        if (b == null  || b.length() == 0) {\n            return a.length();\n        }\n        if (a.equals(b)) {\n            return -1;\n        }\n        if (b.length() < a.length()) {\n            return findLUSlength(b, a);\n        }\n        int index = b.indexOf(a);\n        return index == -1 ? b.length() : Math.max(index -0, b.length() - (index+a.length() - 1));\n    }\n}", "total_acs": 26705, "total_submitted": 47952}, {"id": 522, "title": "Longest Uncommon Subsequence II", "url": "https://leetcode.com/problems/longest-uncommon-subsequence-ii/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "\r\nGiven a list of strings, you need to find the longest uncommon subsequence among them. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings.\r\n\r\n\r\n\r\nA subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.\r\n\r\n\r\n\r\nThe input will be a list of strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn't exist, return -1.\r\n\r\n\r\nExample 1:\r\n\r\nInput: \"aba\", \"cdc\", \"eae\"\r\nOutput: 3\r\n\r\n\r\n\r\nNote:\r\n\r\nAll the given strings' lengths will not exceed 10.\r\nThe length of the given list will be in the range of [2, 50].\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/670", "similarQuestions": ["LongestUncommonSubsequenceI"], "topicTags": ["String"], "Solution": "class Solution {\n    public int findLUSlength(String[] strs) {\n       int uncom = -1;\n        for (int i = 0; i < strs.length; i++) {\n            boolean sig = true;\n            for (int j = 0; j < strs.length; j++) {\n                if (i == j) continue;\n                int tem = uncommunlen(strs[i], strs[j]);\n                if (tem == -1) {\n                    sig = false;\n                    break;\n                } \n               \n            }\n            if (sig && strs[i].length() >= uncom){\n                 uncom = strs[i].length(); \n            }\n            \n        }\n        return uncom;\n\n    }\n    public int uncommunlen(String a, String b) {\n        int m = a.length();\n        int n = b.length();\n        int com = 0;\n        while(n > 0 && m > 0) {\n            if (a.charAt(m-1) == b.charAt(n-1)) {\n                com++;\n                m--;\n                n--;\n            }else {\n                n--;\n            }\n        }\n        if (a.length() == com) return -1;\n        else return a.length();\n    }\n}", "total_acs": 9870, "total_submitted": 30792}, {"id": 523, "title": "Continuous Subarray Sum", "url": "https://leetcode.com/problems/continuous-subarray-sum/description", "companyTags": ["Facebook"], "difficulty": "Medium", "content": "\r\nGiven a list of non-negative numbers and a target integer k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to the multiple of k, that is, sums up to n*k where n is also an integer.\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput: [23, 2, 4, 6, 7],  k=6\r\nOutput: True\r\nExplanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6.\r\n\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: [23, 2, 6, 4, 7],  k=6\r\nOutput: True\r\nExplanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42.\r\n\r\n\r\n\r\nNote:\r\n\r\nThe length of the array won't exceed 10,000.\r\nYou may assume the sum of all the numbers is in the range of a signed 32-bit integer.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/671", "similarQuestions": ["SubarraySumEqualsK"], "topicTags": ["Math", "DynamicProgramming"], "Solution": "class Solution {\n    public boolean checkSubarraySum(int[] nums, int k) {\n        Map<Integer,Integer> map = new HashMap<>();\n        int runningSum = 0;\n        map.put(0,-1);\n        for (int i=0; i<nums.length; i++) {\n            runningSum += nums[i];\n            if(k!=0) runningSum %= k;\n            Integer prev = map.get(runningSum);\n            if(prev != null) {\n                if(i-prev > 1)\n                    return true;\n            } else \n                map.put(runningSum,i);\n        }\n        return false;\n    }\n}", "total_acs": 29345, "total_submitted": 125489}, {"id": 524, "title": "Longest Word in Dictionary through Deleting", "url": "https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "\r\nGiven a string and a string dictionary, find the longest string in the dictionary that can be formed by deleting some characters of the given string. If there are more than one possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.\r\n\r\nExample 1:\r\n\r\nInput:\r\ns = \"abpcplea\", d = [\"ale\",\"apple\",\"monkey\",\"plea\"]\r\n\r\nOutput: \r\n\"apple\"\r\n\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput:\r\ns = \"abpcplea\", d = [\"a\",\"b\",\"c\"]\r\n\r\nOutput: \r\n\"a\"\r\n\r\n\r\n\r\nNote:\r\n\r\nAll the strings in the input will only contain lower-case letters.\r\nThe size of the dictionary won't exceed 1,000.\r\nThe length of all the strings in the input won't exceed 1,000.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/673", "similarQuestions": ["LongestWordinDictionary"], "topicTags": ["TwoPointers", "Sort"], "Solution": "class Solution {\n    public String findLongestWord(String s, List<String> d) {\n        int maxlen=0;\n        String res=\"\";\n        for(String str: d)\n            if( containing(s, str) ){\n                if(str.length() >res.length() )\n                    res=str;\n                else if( str.length()== res.length() && str.compareTo(res)<0 )\n                    res=str;\n            }\n        \n        return res;\n        \n    }\n    \n    private boolean containing(String s, String t){\n        if(t.length()>s.length())return false;\n        int pos=0;\n        for( char c: t.toCharArray() ){\n            pos = s.indexOf( c, pos);\n            if(pos==-1)return false;\n            pos++;\n            \n        }\n        return true;\n    }\n     \n}", "total_acs": 18901, "total_submitted": 43646}, {"id": 525, "title": "Contiguous Array", "url": "https://leetcode.com/problems/contiguous-array/description", "companyTags": ["Facebook"], "difficulty": "Medium", "content": "Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1. \r\n\r\n\r\nExample 1:\r\n\r\nInput: [0,1]\r\nOutput: 2\r\nExplanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: [0,1,0]\r\nOutput: 2\r\nExplanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.\r\n\r\n\r\n\r\nNote:\r\nThe length of the given binary array will not exceed 50,000.\r\n", "discussUrl": "https://discuss.leetcode.com/category/674", "similarQuestions": ["MaximumSizeSubarraySumEqualsk"], "topicTags": ["HashTable"], "Solution": "class Solution {\n    public int findMaxLength(int[] nums) {\n        if (nums == null || nums.length == 0) return 0;\n        int[] map = new int[(2*nums.length)+1];\n        Arrays.fill(map, -2);\n        map[nums.length] = -1;\n        int max = 0;\n        int sum = 0;\n        for (int i=0;i<nums.length;i++) {\n            sum = sum + (nums[i]==0 ? -1 : 1); \n            if (map[sum + nums.length]>=-1) {\n                max = Math.max(max, i-map[sum+nums.length]);\n            } else {\n                map[sum+nums.length] = i;\n            }\n        }\n        \n        return max;\n    }\n}", "total_acs": 21446, "total_submitted": 51809}, {"id": 526, "title": "Beautiful Arrangement", "url": "https://leetcode.com/problems/beautiful-arrangement/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "\r\nSuppose you have N integers from 1 to N. We define a beautiful arrangement as an array that is constructed by these N numbers successfully if one of the following is true for the ith position (1 <= i <= N) in this array:\r\n\r\nThe number at the ith position is divisible by i.\r\ni is divisible by the number at the ith position.\r\n\r\n\r\n\r\n\r\nNow given N, how many beautiful arrangements can you construct?\r\n\r\n\r\nExample 1:\r\n\r\nInput: 2\r\nOutput: 2\r\nExplanation: \r\nThe first beautiful arrangement is [1, 2]:\r\nNumber at the 1st position (i=1) is 1, and 1 is divisible by i (i=1).\r\nNumber at the 2nd position (i=2) is 2, and 2 is divisible by i (i=2).\r\nThe second beautiful arrangement is [2, 1]:\r\nNumber at the 1st position (i=1) is 2, and 2 is divisible by i (i=1).\r\nNumber at the 2nd position (i=2) is 1, and i (i=2) is divisible by 1.\r\n\r\n\r\n\r\nNote:\r\n\r\nN is a positive integer and will not exceed 15.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/675", "similarQuestions": ["BeautifulArrangementII"], "topicTags": ["Backtracking"], "Solution": "class Solution {\n\n    public int countArrangement(int N) {\n    int[] res = {1, 2, 3, 8, 10, 36, 41, 132, 250, 700, 750, 4010, 4237, 10680, 24679};\n    return res[N-1];\n    }\n}", "total_acs": 20125, "total_submitted": 37563}, {"id": 527, "title": "Word Abbreviation", "url": "https://leetcode.com/problems/word-abbreviation/description", "companyTags": ["Google", "Snapchat"], "difficulty": "Hard", "content": "Given an array of n distinct non-empty strings, you need to generate minimal possible abbreviations for every word following rules below.\r\n\r\n\r\nBegin with the first character and then the number of characters abbreviated, which followed by the last character.\r\nIf there are any conflict, that is more than one words share the same abbreviation, a longer prefix is used instead of only the first character until making the map from word to abbreviation become unique. In other words, a final abbreviation cannot map to more than one original words.\r\n If the abbreviation doesn't make the word shorter, then keep it as original.\r\n\r\n\r\nExample:\r\n\r\nInput: [\"like\", \"god\", \"internal\", \"me\", \"internet\", \"interval\", \"intension\", \"face\", \"intrusion\"]\r\nOutput: [\"l2e\",\"god\",\"internal\",\"me\",\"i6t\",\"interval\",\"inte4n\",\"f2e\",\"intr4n\"]\r\n\r\n\r\n\r\n\r\nNote: \r\n\r\n Both n and the length of each word will not exceed 400.\r\n The length of each word is greater than 1.\r\n The words consist of lowercase English letters only.\r\n The return answers should be in the same order as the original array.\r\n", "discussUrl": "https://discuss.leetcode.com/category/677", "similarQuestions": ["ValidWordAbbreviation", "MinimumUniqueWordAbbreviation"], "topicTags": ["String", "Sort"], "Solution": "class Solution {\n    \n    HashMap<String, TrieNode> abbr2trie;\n    int[] endIdx;\n    \n    public List<String> wordsAbbreviation(List<String> dict) {\n        abbr2trie = new HashMap<String, TrieNode>();\n        endIdx = new int[dict.size()];\n        \n        for(int i=0; i<dict.size(); i++){\n            String cur = dict.get(i);\n            if(cur.length()<=3){\n                endIdx[i] = cur.length();\n            }else{\n                addWord(cur, str2abbr(cur),i, dict);\n            }\n        }\n        \n        List<String> res = new LinkedList<String>();\n        for(int i=0; i<dict.size(); i++){\n            String cur = dict.get(i);\n            if(cur.length() - endIdx[i] - 1<=1){\n                res.add(cur);\n            }else{\n                res.add(cur.substring(0,endIdx[i])+ (cur.length()-endIdx[i] - 1) + cur.charAt(cur.length()-1));\n            }\n        }\n        return res;\n    }\n    \n    public void addWord(String s, String abbr, int sidx, List<String> dict){\n        if(!abbr2trie.containsKey(abbr)){\n            // 1st word with this abbr\n            // Only create 1st char of the string in the trie\n            TrieNode head = new TrieNode();\n            abbr2trie.put(abbr, head);\n            head.next[s.charAt(0)-'a'] = new TrieNode(sidx);\n            endIdx[sidx] = 1;\n        }\n        else{\n            TrieNode node = abbr2trie.get(abbr);\n            int idx = 0;\n            while(node.next[s.charAt(idx)-'a']!=null){\n                // Go through same preffix in the trie\n                node = node.next[s.charAt(idx++)-'a'];\n            }\n            int sidx2 = node.stringIndex;\n            if(sidx2==-1){\n                // This means that other words with this prefix have been pushed further, they have longer same prefix\n                // And this word could stop here and create next char to distinguish it\n                node.next[s.charAt(idx)-'a'] = new TrieNode(sidx);\n                endIdx[sidx] = idx+1;\n                return;\n            }\n            // Push further sidx2\n            node.stringIndex = -1;\n            \n            String s2 = dict.get(sidx2);\n            while(s.charAt(idx)==s2.charAt(idx)){\n                node.next[s.charAt(idx) - 'a'] = new TrieNode();\n                node = node.next[s.charAt(idx++) -'a'];\n            }\n            endIdx[sidx]  = idx+1;\n            endIdx[sidx2] = idx+1;\n            node.next[s.charAt(idx)-'a'] = new TrieNode(sidx);\n            node.next[s2.charAt(idx)-'a'] = new TrieNode(sidx2);\n        }\n    }\n        \n    public String str2abbr(String cur){\n        return cur.charAt(0) + String.valueOf(cur.length()) + cur.charAt(cur.length()-1);\n    }\n    \n    class TrieNode{\n        int stringIndex;\n        TrieNode[] next;\n        \n        public TrieNode(){\n            stringIndex = -1;\n            next = new TrieNode[26];\n        }\n        \n        public TrieNode(int i){\n            stringIndex = i;\n            next = new TrieNode[26];\n        }\n    }\n}", "total_acs": 4624, "total_submitted": 10501}, {"id": 529, "title": "Minesweeper", "url": "https://leetcode.com/problems/minesweeper/description", "companyTags": ["Amazon"], "difficulty": "Medium", "content": "Let's play the minesweeper game (Wikipedia, online game)! \r\n\r\nYou are given a 2D char matrix representing the game board. 'M' represents an unrevealed mine, 'E' represents an unrevealed empty square, 'B' represents a revealed blank square that has no adjacent (above, below, left, right, and all 4 diagonals) mines, digit ('1' to '8') represents how many mines are adjacent to this revealed square, and finally 'X' represents a revealed mine.\r\n\r\nNow given the next click position (row and column indices) among all the unrevealed squares ('M' or 'E'), return the board after revealing this position according to the following rules: \r\n\r\n\r\n\r\nIf a mine ('M') is revealed, then the game is over - change it to 'X'.\r\nIf an empty square ('E') with no adjacent mines is revealed, then change it to revealed blank ('B') and all of its adjacent unrevealed squares should be revealed recursively.\r\nIf an empty square ('E') with at least one adjacent mine is revealed, then change it to a digit ('1' to '8') representing the number of adjacent mines.\r\nReturn the board when no more squares will be revealed.\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput: \r\n\r\n[['E', 'E', 'E', 'E', 'E'],\r\n ['E', 'E', 'M', 'E', 'E'],\r\n ['E', 'E', 'E', 'E', 'E'],\r\n ['E', 'E', 'E', 'E', 'E']]\r\n\r\nClick : [3,0]\r\n\r\nOutput: \r\n\r\n[['B', '1', 'E', '1', 'B'],\r\n ['B', '1', 'M', '1', 'B'],\r\n ['B', '1', '1', '1', 'B'],\r\n ['B', 'B', 'B', 'B', 'B']]\r\n\r\nExplanation:\r\n\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: \r\n\r\n[['B', '1', 'E', '1', 'B'],\r\n ['B', '1', 'M', '1', 'B'],\r\n ['B', '1', '1', '1', 'B'],\r\n ['B', 'B', 'B', 'B', 'B']]\r\n\r\nClick : [1,2]\r\n\r\nOutput: \r\n\r\n[['B', '1', 'E', '1', 'B'],\r\n ['B', '1', 'X', '1', 'B'],\r\n ['B', '1', '1', '1', 'B'],\r\n ['B', 'B', 'B', 'B', 'B']]\r\n\r\nExplanation:\r\n\r\n\r\n\r\n\r\n\r\n\r\nNote:\r\n\r\nThe range of the input matrix's height and width is [1,50].\r\nThe click position will only be an unrevealed square ('M' or 'E'), which also means the input board contains at least one clickable square.\r\nThe input board won't be a stage when game is over (some mines have been revealed).\r\nFor simplicity, not mentioned rules should be ignored in this problem. For example, you don't need to reveal all the unrevealed mines when the game is over, consider any cases that you will win the game or flag any squares.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/679", "similarQuestions": [""], "topicTags": ["Depth-firstSearch", "Breadth-firstSearch"], "Solution": "class Solution {\n    public char[][] updateBoard(char[][] board, int[] click) {\n        int m=board.length, n=board[0].length;\n        int x=click[0], y=click[1];\n        if(board[x][y]=='M'){\n            board[x][y]='X'; return board;\n        }\n        int count=0;\n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                if(i!=0 || j!=0){\n                    int xnew=x+i, ynew=y+j;\n                    if(xnew<0 || xnew>=m || ynew<0 || ynew>=n || board[xnew][ynew]=='B') continue;\n                    if(board[xnew][ynew]=='M') count++;\n                }\n            }\n        }\n        if(count!=0){board[x][y]=(char)('0'+count); return board;}\n        board[x][y]='B';\n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                if(i!=0 || j!=0){\n                    int xnew=x+i, ynew=y+j;\n                    if(xnew<0 || xnew>=m || ynew<0 || ynew>=n) continue;\n                    if(board[xnew][ynew]=='E') updateBoard(board, new int[]{xnew, ynew});\n                }\n            }\n        }\n        return board;\n    }\n}", "total_acs": 15092, "total_submitted": 30488}, {"id": 530, "title": "Minimum Absolute Difference in BST", "url": "https://leetcode.com/problems/minimum-absolute-difference-in-bst/description", "companyTags": ["Google"], "difficulty": "Easy", "content": "Given a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.\r\n\r\n\r\nExample:\r\n\r\nInput:\r\n\r\n   1\r\n    \\\r\n     3\r\n    /\r\n   2\r\n\r\nOutput:\r\n1\r\n\r\nExplanation:\r\nThe minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3).\r\n\r\n\r\n\r\n\r\nNote:\r\nThere are at least two nodes in this BST.\r\n", "discussUrl": "https://discuss.leetcode.com/category/680", "similarQuestions": ["K-diffPairsinanArray"], "topicTags": ["BinarySearchTree"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    int min = Integer.MAX_VALUE;\n    Integer prev = null;\n    public int getMinimumDifference(TreeNode root) {\n        if(root == null) {\n            return min;\n        }\n        \n        getMinimumDifference(root.left);\n        \n        if(prev != null) {\n            min = Math.min(min, root.val - prev);\n        }\n        prev = root.val;\n        getMinimumDifference(root.right);\n        return min;\n    }\n}", "total_acs": 31799, "total_submitted": 67469}, {"id": 531, "title": "Lonely Pixel I", "url": "https://leetcode.com/problems/lonely-pixel-i/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "Given a picture consisting of black and white pixels, find the number of black lonely pixels.\r\n\r\nThe picture is represented by a 2D char array consisting of 'B' and 'W', which means black and white pixels respectively. \r\n\r\nA black lonely pixel is character 'B' that located at a specific position where the same row and same column don't have any other black pixels.\r\n\r\nExample:\r\n\r\nInput: \r\n[['W', 'W', 'B'],\r\n ['W', 'B', 'W'],\r\n ['B', 'W', 'W']]\r\n\r\nOutput: 3\r\nExplanation: All the three 'B's are black lonely pixels.\r\n\r\n\r\n\r\nNote:\r\n\r\nThe range of width and height of the input 2D array is [1,500].\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/682", "similarQuestions": [""], "topicTags": ["Array", "Depth-firstSearch"], "Solution": "class Solution {\n    public int findLonelyPixel(char[][] picture) {\n        if(picture == null || picture.length == 0 || picture[0].length == 0)\n            return 0;\n        int m = picture.length;\n        int n = picture[0].length;\n        int count = 0;\n        for(int i = 0; i < m; i ++){\n            int judge = RowCheck(i,picture);\n            if(judge != -1){\n                if(ColCheck(judge,picture))\n                    count ++;\n            }\n        }\n        return count;\n    }\n    \n    public int RowCheck(int row, char[][] picture){\n        int result = -1;\n        int count = 0;\n        for(int j = 0; j < picture[row].length; j ++){\n            if(picture[row][j] == 'B'){\n                count ++;\n                result = j;\n            }\n        }\n        return count == 1 ? result : -1;\n    }\n    \n    public boolean ColCheck(int col, char[][] picture){\n        int count = 0;\n        for(int i = 0; i < picture.length; i ++){\n            if(picture[i][col] == 'B'){\n                count ++;\n            }\n        }\n        return count == 1;\n    }\n}", "total_acs": 9416, "total_submitted": 16765}, {"id": 532, "title": "K-diff Pairs in an Array", "url": "https://leetcode.com/problems/k-diff-pairs-in-an-array/description", "companyTags": ["Amazon"], "difficulty": "Easy", "content": "\r\nGiven an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k.\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput: [3, 1, 4, 1, 5], k = 2\r\nOutput: 2\r\nExplanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).Although we have two 1s in the input, we should only return the number of unique pairs.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput:[1, 2, 3, 4, 5], k = 1\r\nOutput: 4\r\nExplanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput: [1, 3, 1, 5, 4], k = 0\r\nOutput: 1\r\nExplanation: There is one 0-diff pair in the array, (1, 1).\r\n\r\n\r\n\r\nNote:\r\n\r\nThe pairs (i, j) and (j, i) count as the same pair.\r\nThe length of the array won't exceed 10,000.\r\nAll the integers in the given input belong to the range: [-1e7, 1e7].\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/683", "similarQuestions": ["MinimumAbsoluteDifferenceinBST"], "topicTags": ["Array", "TwoPointers"], "Solution": "class Solution {\n    public int findPairs(int[] nums, int k) {\n        if(nums == null || nums.length < 2 || k < 0) return 0;\n        Arrays.sort(nums);\n        int left=0, right=0;\n        int count = 0;\n        while(left < nums.length && right < nums.length){\n            int val = nums[left] + k;\n            if(nums[right] == val && left != right){\n                count++;\n                left++;\n                right++;\n                while(left < nums.length && nums[left-1] == nums[left]) left++;\n            }else if(val > nums[right]) right++;\n            else left++;\n        }\n        return count;\n    }\n}", "total_acs": 32802, "total_submitted": 116273}, {"id": 533, "title": "Lonely Pixel II", "url": "https://leetcode.com/problems/lonely-pixel-ii/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "Given a picture consisting of black and white pixels, and a positive integer N, find the number of black pixels located at some specific row R and column C that align with all the following rules:\r\n\r\n\r\n Row R and column C both contain exactly N black pixels.\r\n For all rows that have a black pixel at column C, they should be exactly the same as row R\r\n\r\n\r\nThe picture is represented by a 2D char array consisting of 'B' and 'W', which means black and white pixels respectively. \r\n\r\nExample:\r\n\r\nInput:                                            \r\n[['W', 'B', 'W', 'B', 'B', 'W'],    \r\n ['W', 'B', 'W', 'B', 'B', 'W'],    \r\n ['W', 'B', 'W', 'B', 'B', 'W'],    \r\n ['W', 'W', 'B', 'W', 'B', 'W']] \r\n\r\nN = 3\r\nOutput: 6\r\nExplanation: All the bold 'B' are the black pixels we need (all 'B's at column 1 and 3).\r\n        0    1    2    3    4    5         column index                                            \r\n0    [['W', 'B', 'W', 'B', 'B', 'W'],    \r\n1     ['W', 'B', 'W', 'B', 'B', 'W'],    \r\n2     ['W', 'B', 'W', 'B', 'B', 'W'],    \r\n3     ['W', 'W', 'B', 'W', 'B', 'W']]    \r\nrow index\r\n\r\nTake 'B' at row R = 0 and column C = 1 as an example:\r\nRule 1, row R = 0 and column C = 1 both have exactly N = 3 black pixels. \r\nRule 2, the rows have black pixel at column C = 1 are row 0, row 1 and row 2. They are exactly the same as row R = 0.\r\n\r\n\r\n\r\n\r\nNote:\r\n\r\nThe range of width and height of the input 2D array is [1,200].\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/684", "similarQuestions": ["LonelyPixelII"], "topicTags": ["Array", "Depth-firstSearch"], "Solution": "class Solution {\n    public int findBlackPixel(char[][] picture, int N) {\n        int rowLength = picture.length;\n        if (0 == rowLength)\n            return 0;\n        int colLength = picture[0].length;\n        if (0 == colLength)\n            return 0;\n        if (N == 0 || N > rowLength || N > colLength)\n            return 0;\n        \n        int[] rows = new int[rowLength];\n        int[] cols = new int[colLength];\n        String[] strings = new String[rowLength];\n        \n        for (int i = 0; i < rowLength; i++) {\n            for (int j = 0; j < colLength; j++) {\n                if (picture[i][j] == 'B') {\n                    rows[i]++;\n                    cols[j]++;\n                }\n            }\n            strings[i] = new String(picture[i]);\n        }\n        \n        int res = 0;\n        main:for (int j = 0; j < colLength; j++) {\n            if (cols[j] != N)\n                continue;\n\n            int i = 0;\n            while (picture[i][j] != 'B')\n                i++;\n            if (rows[i] != N)\n                continue;\n            String s = strings[i++];\n            for (int k = N - 1; k > 0; k--, i++) {\n                while (picture[i][j] != 'B')\n                    i++;\n                if (rows[i] != N)\n                    continue main;\n                if (!strings[i].equals(s))\n                    continue main;\n            }\n            res += N;\n        }\n        return res;\n    }\n}", "total_acs": 5253, "total_submitted": 11653}, {"id": 535, "title": "Encode and Decode TinyURL", "url": "https://leetcode.com/problems/encode-and-decode-tinyurl/description", "companyTags": ["Google", "Facebook", "Amazon", "Uber"], "difficulty": "Medium", "content": "Note: This is a companion problem to the System Design problem: Design TinyURL.\r\n\r\nTinyURL is a URL shortening service where you enter a URL such as https://leetcode.com/problems/design-tinyurl and it returns a short URL such as http://tinyurl.com/4e9iAk.\r\n\r\nDesign the encode and decode methods for the TinyURL service. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.", "discussUrl": "https://discuss.leetcode.com/category/686", "similarQuestions": [""], "topicTags": ["HashTable", "Math"], "Solution": "public class Codec {\n\n    // Encodes a URL to a shortened URL.\n    public String encode(String longUrl) {\n        return longUrl;\n    }\n\n    // Decodes a shortened URL to its original URL.\n    public String decode(String shortUrl) {\n        return shortUrl;\n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec codec = new Codec();\n// codec.decode(codec.encode(url));", "total_acs": 30715, "total_submitted": 41590}, {"id": 536, "title": "Construct Binary Tree from String", "url": "https://leetcode.com/problems/construct-binary-tree-from-string/description", "companyTags": ["Amazon"], "difficulty": "Medium", "content": "You need to construct a binary tree from a string consisting of parenthesis and integers. \r\n\r\nThe whole input represents a binary tree. It contains an integer followed by zero, one or two pairs of parenthesis. The integer represents the root's value and a pair of parenthesis contains a child binary tree with the same structure. \r\n\r\nYou always start to construct the left child node of the parent first if it exists.\r\n\r\nExample:\r\n\r\nInput: \"4(2(3)(1))(6(5))\"\r\nOutput: return the tree root node representing the following tree:\r\n\r\n       4\r\n     /   \\\r\n    2     6\r\n   / \\   / \r\n  3   1 5   \r\n\r\n\r\n\r\nNote:\r\n\r\nThere will only be '(',  ')',  '-' and  '0' ~ '9' in the input string.\r\nAn empty tree is represented by \"\" instead of \"()\".\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/687", "similarQuestions": ["ConstructStringfromBinaryTree"], "topicTags": ["String", "Tree"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    \n    \n    //optimal:\n    int idx = 0;\n    public TreeNode str2tree(String s) {\n        if (s.length() == 0 || s == null) {\n            return null;\n        }\n        return helper(s.toCharArray());\n    }\n    private TreeNode helper (char[] a) {\n        if (idx >= a.length) {\n            return null;\n        }\n        boolean flag = true;\n        if (a[idx] == '-') {\n            idx++;\n            flag = false;\n        }\n        int num = 0;\n        while (idx < a.length && a[idx] >= '0' && a[idx] <= '9') {\n            num *= 10;\n            num += (a[idx] - '0');\n            idx++;\n        }\n        if (flag == false) {\n            num = -num;\n        }\n        TreeNode node = new TreeNode(num);\n        if (idx < a.length && a[idx] =='(') {\n            idx++;\n            node.left = helper(a);\n        }\n        if (idx < a.length && a[idx] == '(') {\n            idx++;\n            node.right = helper(a);\n        }\n        if (idx < a.length && a[idx] == ')') { // clean ) so no need to consider ) at beginning\n            idx++;\n        }\n        return node;\n    }\n    \n    /*****\n    2 solutions. 1 is to find root left() and right() and recurse. scan multiple times. \n    \n    another is use stack to do O(N) scan. sk.peek() always store parent\n    **/\n    public TreeNode str2tree1(String s) {\n        if(s==null||s.equals(\"\")) return null;\n        int n=s.length();\n        Deque<TreeNode> sk=new ArrayDeque<>();\n        int i=0;\n        int num=0;\n        while(i<n&&!isP(s.charAt(i))){ i++;} // until see a other than 0-9 and -\n        TreeNode root=new TreeNode(Integer.parseInt(s.substring(0,i)));\n        sk.push(root);\n        while(i<n){\n            if(s.charAt(i++)==')') {\n                sk.pop();\n            }else{\n                int j=i;\n                while(i<n&&!isP(s.charAt(i))){i++;} // until see a other than 0-9 and -\n                //if(i==n) break;\n                TreeNode cur=new TreeNode(Integer.parseInt(s.substring(j,i)));\n                if(!sk.isEmpty()){\n                    if(sk.peek().left!=null){ // always fill left first!\n                        sk.peek().right=cur;\n                    }else{\n                        sk.peek().left=cur;\n                    }\n                }\n                sk.push(cur);\n            }\n        }\n        return sk.peek();\n    }\n    \n    \n    // isParenthesis\n    private boolean isP(char c){\n        return c=='('||c==')';\n    }\n}", "total_acs": 9654, "total_submitted": 22588}, {"id": 537, "title": "Complex Number Multiplication", "url": "https://leetcode.com/problems/complex-number-multiplication/description", "companyTags": ["Amazon"], "difficulty": "Medium", "content": "\r\nGiven two strings representing two complex numbers.\r\n\r\n\r\nYou need to return a string representing their multiplication. Note i2 = -1 according to the definition.\r\n\r\n\r\nExample 1:\r\n\r\nInput: \"1+1i\", \"1+1i\"\r\nOutput: \"0+2i\"\r\nExplanation: (1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i, and you need convert it to the form of 0+2i.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: \"1+-1i\", \"1+-1i\"\r\nOutput: \"0+-2i\"\r\nExplanation: (1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i, and you need convert it to the form of 0+-2i.\r\n\r\n\r\n\r\nNote:\r\n\r\nThe input strings will not have extra blank.\r\nThe input strings will be given in the form of a+bi, where the integer a and b will both belong to the range of [-100, 100]. And the output should be also in this form.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/688", "similarQuestions": [""], "topicTags": ["Math", "String"], "Solution": "class Solution {\n    public String complexNumberMultiply(String a, String b) {\n     \n\t\tint i1=a.indexOf(\"+\");\n\t\tint i2=b.indexOf(\"+\");\n\t\tint x1=Integer.parseInt(a.substring(0,i1));\n\t\tint x2=Integer.parseInt(b.substring(0,i2));\n\t\tint y1=Integer.parseInt(a.substring(i1+1,a.length()-1));\n\t\tint y2=Integer.parseInt(b.substring(i2+1,b.length()-1));\n\t\t\n\t\tint result1=x1*x2-y1*y2;\n\t\t// System.out.println(result1);\n\t\tint result2=x1*y2+x2*y1;\n\t\tString rString=result1+\"+\"+result2+\"i\";\n\t\treturn rString;\n\t\t// System.out.println(rString);\n        \n    }\n}", "total_acs": 21298, "total_submitted": 33369}, {"id": 538, "title": "Convert BST to Greater Tree", "url": "https://leetcode.com/problems/convert-bst-to-greater-tree/description", "companyTags": ["Amazon"], "difficulty": "Easy", "content": "Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST.\r\n\r\n\r\nExample:\r\n\r\nInput: The root of a Binary Search Tree like this:\r\n              5\r\n            /   \\\r\n           2     13\r\n\r\nOutput: The root of a Greater Tree like this:\r\n             18\r\n            /   \\\r\n          20     13\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/690", "similarQuestions": [""], "topicTags": ["Tree"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    int sum=0;\n    public TreeNode convertBST(TreeNode root) {\n        \n        if(root==null)\n            return null;\n        \n        traverse(root);\n        return root;\n        \n    }\n    \n    public void traverse(TreeNode root)\n    {\n        if(root==null)\n            return;\n        \n        traverse(root.right);\n        sum+=root.val;\n        root.val = sum;\n        traverse(root.left);\n        return;\n    }\n}", "total_acs": 34610, "total_submitted": 70524}, {"id": 539, "title": "Minimum Time Difference", "url": "https://leetcode.com/problems/minimum-time-difference/description", "companyTags": ["Palantir"], "difficulty": "Medium", "content": "Given a list of 24-hour clock time points in \"Hour:Minutes\" format, find the minimum minutes difference between any two time points in the list. \r\n\r\nExample 1:\r\n\r\nInput: [\"23:59\",\"00:00\"]\r\nOutput: 1\r\n\r\n\r\n\r\nNote:\r\n\r\nThe number of time points in the given list is at least 2 and won't exceed 20000.\r\nThe input time is legal and ranges from 00:00 to 23:59.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/691", "similarQuestions": [""], "topicTags": ["String"], "Solution": "class Solution {\n    public int findMinDifference(List<String> timePoints) {\n        if(timePoints == null || timePoints.size() == 0) {\n            return 0;\n        }\n        boolean[] marks = new boolean[1440];\n        for(String time : timePoints) {\n            int h = (time.charAt(0) - '0' ) * 10 + time.charAt(1) - '0';\n            int m = (time.charAt(3) - '0' ) * 10 + time.charAt(4) - '0';\n            if (marks[h * 60 + m]) {\n                return 0;\n            }\n            marks[h * 60 + m] = true;\n        }\n        \n        int prev = 0;\n        int first = Integer.MAX_VALUE;\n        int last = Integer.MIN_VALUE;\n        int res = Integer.MAX_VALUE;\n        for(int i = 0; i < marks.length; i++) {\n            if(marks[i]) {\n                if (first != Integer.MAX_VALUE) {\n                    res = Math.min(res, i - prev);\n                }\n                first = Math.min(first, i);\n                last = Math.max(last, i);\n                prev = i;\n            }\n        }\n        \n        int corner = first + 1440 - last;\n        return Math.min(res, corner);\n    }\n}", "total_acs": 14705, "total_submitted": 31883}, {"id": 540, "title": "Single Element in a Sorted Array", "url": "https://leetcode.com/problems/single-element-in-a-sorted-array/description", "companyTags": [""], "difficulty": "Medium", "content": "\r\nGiven a sorted array consisting of only integers where every element appears twice except for one element which appears once. Find this single element that appears only once. \r\n\r\n\r\nExample 1:\r\n\r\nInput: [1,1,2,3,3,4,4,8,8]\r\nOutput: 2\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: [3,3,7,7,10,11,11]\r\nOutput: 10\r\n\r\n\r\n\r\nNote:\r\nYour solution should run in O(log n) time and O(1) space.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/692", "similarQuestions": [""], "topicTags": [""], "Solution": "class Solution {\n    public int singleNonDuplicate(int[] nums) {\n        int len = nums.length;\n        if(len == 1)\n            return nums[0];\n        int result = nums[0];\n        int count = 1;\n        for(int i=1; i<len; i++) {\n            if(nums[i] == result)\n                count++;\n            else if(count == 1)\n                break;\n            else {\n                result = nums[i];\n                count = 1;\n            }\n        }\n        return result;\n    }\n}", "total_acs": 26067, "total_submitted": 46493}, {"id": 541, "title": "Reverse String II", "url": "https://leetcode.com/problems/reverse-string-ii/description", "companyTags": ["Google"], "difficulty": "Easy", "content": "\r\nGiven a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.\r\n\r\n\r\nExample:\r\n\r\nInput: s = \"abcdefg\", k = 2\r\nOutput: \"bacdfeg\"\r\n\r\n\r\n\r\nRestrictions: \r\n\r\n The string consists of lower English letters only.\r\n Length of the given string and k will in the range [1, 10000]\r\n", "discussUrl": "https://discuss.leetcode.com/category/693", "similarQuestions": ["ReverseString", "ReverseWordsinaStringIII"], "topicTags": ["String"], "Solution": "class Solution {\n    public String reverseStr(String s, int k) {\n        if(s==null ||s.length()==0) return \"\";\n        \n        int len=s.length();\n       int i=0;\n        char[] arr=s.toCharArray();\n        while(i<len)\n        {\n            int j=Math.min(i+k-1,len-1);\n            swap(arr,i,j);\n            i = i+ (2*k);\n        }\n        return new String(arr);\n    }\n    \n    \n    private void swap(char[] arr,int l,int r)\n    {\n        while(l<r)\n        {\n        char tmp=arr[l];\n        arr[l]=arr[r];\n        arr[r]=tmp;\n        l++;r--;\n        }\n    }\n}", "total_acs": 33079, "total_submitted": 75554}, {"id": 542, "title": "01 Matrix", "url": "https://leetcode.com/problems/01-matrix/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "\r\nGiven a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell.\r\n\r\nThe distance between two adjacent cells is 1.\r\n\r\nExample 1: \r\nInput:\r\n\r\n0 0 0\r\n0 1 0\r\n0 0 0\r\n\r\nOutput:\r\n\r\n0 0 0\r\n0 1 0\r\n0 0 0\r\n\r\n\r\n\r\nExample 2: \r\nInput:\r\n\r\n0 0 0\r\n0 1 0\r\n1 1 1\r\n\r\nOutput:\r\n\r\n0 0 0\r\n0 1 0\r\n1 2 1\r\n\r\n\r\n\r\nNote:\r\n\r\nThe number of elements of the given matrix will not exceed 10,000.\r\nThere are at least one 0 in the given matrix.\r\nThe cells are adjacent in only four directions: up, down, left and right.\r\n\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/695", "similarQuestions": [""], "topicTags": ["Depth-firstSearch", "Breadth-firstSearch"], "Solution": "class Solution {\n    \n    //AC DFS \n    public int[][] updateMatrix(int[][] matrix) {\n\t\tfor(int i = 0; i < matrix.length; i++) {\n\t\t\tfor(int j = 0; j < matrix[0].length; j++) {\n\t\t\t\tif(matrix[i][j]!=0) {\n\t\t\t\t\tdfs(matrix, i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\t\n\tint[] dx = {-1,0,1,0};\n\tint[] dy = {0,-1,0,1};\n\t\n\tvoid dfs(int[][] matrix, int r, int c) {\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor(int i = 0; i< 4; i++) {\n\t\t\tint x = r+dx[i];\n\t\t\tint y = c+dy[i];\n\t\t\tif(x>=0&&x<matrix.length&&y>=0&&y<matrix[0].length) {\n\t\t\t\tmin = Math.min(min, matrix[x][y]+1);\n\t\t\t}\n\t\t}\n\t\tif(min!=matrix[r][c]) {\n            matrix[r][c] = min;\n\t\t\tfor(int i = 0; i< 4; i++) {\n\t\t\t\tint x = r+dx[i];\n\t\t\t\tint y = c+dy[i];\n\t\t\t\tif(x>=0&&x<matrix.length&&y>=0&&y<matrix[0].length) {\n\t\t\t\t\tdfs(matrix,x,y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n    \n    /*\n    //Discussion BFS 70%\n    public int[][] updateMatrix(int[][] matrix) {\n        int m = matrix.length;\n        int n = matrix[0].length;\n        \n        Queue<int[]> queue = new LinkedList<>();\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (matrix[i][j] == 0) {\n                    queue.offer(new int[] {i, j});\n                }\n                else {\n                    matrix[i][j] = Integer.MAX_VALUE;\n                }\n            }\n        }\n        \n        int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        \n        while (!queue.isEmpty()) {\n            int[] cell = queue.poll();\n            for (int[] d : dirs) {\n                int r = cell[0] + d[0];\n                int c = cell[1] + d[1];\n                if (r < 0 || r >= m || c < 0 || c >= n || \n                    matrix[r][c] <= matrix[cell[0]][cell[1]] + 1) continue;\n                queue.add(new int[] {r, c});\n                matrix[r][c] = matrix[cell[0]][cell[1]] + 1;\n            }\n        }\n        \n        return matrix;\n    }\n    */\n    \n    /*\n    //Gene Fail\n    public int[][] updateMatrix(int[][] matrix) {    \n        if(matrix == null || matrix.length == 0 || matrix[0].length == 0){\n            return matrix;\n        }\n        int m = matrix.length;\n        int n = matrix[0].length;\n        boolean[][] hasvisited  = new boolean[m][n];//default false\n        \n        \n        for (int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                if (matrix[i][j] == 0){\n                    hasvisited[i][j] = true;\n                }\n            }\n        }\n        \n        for (int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){                \n                if (matrix[i][j] != 0){\n                    hasvisited[i][j] = true;\n                    matrix[i][j] = helper(matrix,i,j,0,hasvisited);\n                }\n            }\n        }\n        return matrix;\n    }\n    \n    public int helper(int[][] matrix,int i, int j, int counter,boolean[][] hasvisited){\n        // System.out.println(\"i,j \" +  i + \" , \" + j);\n        // System.out.println(\"value\" +  matrix[i][j]);\n        int m = matrix.length;\n        int n = matrix[0].length;\n        \n        for (int x = 0; x < m; x++){\n            for(int y = 0; y < n; y++){\n                System.out.print(matrix[x][y]);\n                // if (matrix[i][j] != 0){\n                //     hasvisited[i][j] = true;\n                //     matrix[i][j] = helper(matrix,i,j,0,hasvisited);\n                // }\n            }\n            System.out.println();\n        }\n        System.out.println(\"---------------\");\n        \n\n        int min = Integer.MAX_VALUE;\n        int temp;\n        //base\n        // while(matrix[i][j] != 0){\n        if (matrix[i][j] != 0){ //? java.lang.ArrayIndexOutOfBoundsException: 3\n            \n            //extend\n            if (i+1 < m && matrix[i+1][j]!=0 && !hasvisited[i+1][j]){\n                hasvisited[i][j] = true;\n                temp = helper(matrix, i+1, j, counter+1, hasvisited);//java.lang.StackOverflowError\n                // System.out.println((i+1)+\" \"+j+\" \"+temp);\n                hasvisited[i][j] = false;\n                if (min > temp) {\n                    min = temp;\n                }\n                 System.out.println((i)+\" \"+j+\" \"+min);\n                return min;\n                // return helper(matrix, i+1, j, counter+1, hasvisited);\n                // return min > helper(matrix, i+1, j, counter+1, hasvisited ? : min \n            }\n            if (i-1 > -1 && matrix[i-1][j]!=0 && !hasvisited[i-1][j]){\n                hasvisited[i][j] = true;\n                temp = helper(matrix, i-1, j, counter+1, hasvisited);\n                // System.out.println((i-1)+\" \"+j+\" \"+temp);\n                hasvisited[i][j] = false;\n                if (min > temp) {\n                    min = temp;\n                }\n                 System.out.println((i)+\" \"+j+\" \"+min);\n                return min;\n                // return helper(matrix, i-1, j, counter+1, hasvisited);\n            }\n            if (j+1 < n && matrix[i][j+1]!=0 && !hasvisited[i][j+1]){\n                hasvisited[i][j] = true;\n                temp = helper(matrix, i, j+1, counter+1, hasvisited);\n                // System.out.println(i+\" \"+(j+1)+\" \"+temp);\n                hasvisited[i][j] = false;\n                if (min > temp) {\n                    min = temp;\n                }\n                 System.out.println((i)+\" \"+j+\" \"+min);\n                return min;\n                // return helper(matrix, i, j+1, counter+1, hasvisited);\n            }\n            if (j-1 > -1 && matrix[i][j-1]!=0 && !hasvisited[i][j-1] ){\n                hasvisited[i][j] = true;\n                temp = helper(matrix, i, j-1, counter+1, hasvisited);\n                // System.out.println(i+\" \"+(j-1)+\" \"+temp);\n                hasvisited[i][j] = false;\n                if (min > temp) {\n                    min = temp;\n                }\n                 System.out.println((i)+\" \"+j+\" \"+min);\n                return min;\n                // return helper(matrix, i, j-1, counter+1, hasvisited);\n            }\n        // }else{\n        //     return counter;\n        }\n        return counter;\n    }\n    */\n}", "total_acs": 17406, "total_submitted": 52882}, {"id": 543, "title": "Diameter of Binary Tree", "url": "https://leetcode.com/problems/diameter-of-binary-tree/description", "companyTags": ["Google", "Facebook"], "difficulty": "Easy", "content": "\r\nGiven a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.\r\n\r\n\r\n\r\nExample:\r\nGiven a binary tree \r\n\r\n          1\r\n         / \\\r\n        2   3\r\n       / \\     \r\n      4   5    \r\n\r\n\r\n\r\nReturn 3, which is the length of the path [4,2,1,3] or [5,2,1,3].\r\n\r\n\r\nNote:\r\nThe length of path between two nodes is represented by the number of edges between them.\r\n", "discussUrl": "https://discuss.leetcode.com/category/696", "similarQuestions": [""], "topicTags": ["Tree"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    int max = 0;\n    public int diameterOfBinaryTree(TreeNode root) {\n        path(root);\n        return max;\n    }\n    \n    public int path(TreeNode root){\n        if(root==null)\n            return 0;\n        int left = path(root.left);\n        int right = path(root.right);\n        max = Math.max(max,left+right);\n        return Math.max(left,right)+1;\n        \n    }\n}", "total_acs": 48626, "total_submitted": 107692}, {"id": 544, "title": "Output Contest Matches", "url": "https://leetcode.com/problems/output-contest-matches/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "\r\nDuring the NBA playoffs, we always arrange the rather strong team to play with the rather weak team, like make the rank 1 team play with the rank nth team, which is a good strategy to make the contest more interesting. Now, you're given n teams, you need to output their final contest matches in the form of a string.\r\n\r\n\r\nThe n teams are given in the form of positive integers from 1 to n, which represents their initial rank. (Rank 1 is the strongest team and Rank n is the weakest team.) We'll use parentheses('(', ')') and commas(',') to represent the contest team pairing - parentheses('(' , ')') for pairing and commas(',') for partition. During the pairing process in each round, you always need to follow the strategy of making the rather strong one pair with the rather weak one. \r\n\r\nExample 1:\r\n\r\nInput: 2\r\nOutput: (1,2)\r\nExplanation: \r\nInitially, we have the team 1 and the team 2, placed like: 1,2.\r\nThen we pair the team (1,2) together with '(', ')' and ',', which is the final answer.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: 4\r\nOutput: ((1,4),(2,3))\r\nExplanation: \r\nIn the first round, we pair the team 1 and 4, the team 2 and 3 together, as we need to make the strong team and weak team together.\r\nAnd we got (1,4),(2,3).\r\nIn the second round, the winners of (1,4) and (2,3) need to play again to generate the final winner, so you need to add the paratheses outside them.\r\nAnd we got the final answer ((1,4),(2,3)).\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput: 8\r\nOutput: (((1,8),(4,5)),((2,7),(3,6)))\r\nExplanation: \r\nFirst round: (1,8),(2,7),(3,6),(4,5)\r\nSecond round: ((1,8),(4,5)),((2,7),(3,6))\r\nThird round: (((1,8),(4,5)),((2,7),(3,6)))\r\nSince the third round will generate the final winner, you need to output the answer (((1,8),(4,5)),((2,7),(3,6))).\r\n\r\n\r\n\r\nNote:\r\n\r\nThe n is in range [2, 212].\r\nWe ensure that the input n can be converted into the form 2k, where k is a positive integer.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/698", "similarQuestions": [""], "topicTags": ["String", "Recursion"], "Solution": "class Solution {\n    public String findContestMatch(int n) {\n        // construct a binary tree and do a dfs\n        // in each row of the tree, the sum of two adjancent pairs are always 2*depth_of_tree + 1, and sum = 3 if the depth is 1.\n        StringBuilder sb = new StringBuilder();\n        dfs(sb, 3, n, 1);\n        return sb.toString();\n    }\n    private void dfs(StringBuilder sb, int sum, int n, int val) {\n        if (sum > n+1) {\n            sb.append(val);\n            return;\n        }\n        sb.append('(');\n        dfs(sb, (sum << 1)-1, n, val);\n        sb.append(',');\n        dfs(sb, (sum << 1)-1, n, sum-val); // use the sum to compute the value of pair node. The sum of pair is always equal in each level.\n        sb.append(')');\n    }\n}", "total_acs": 6697, "total_submitted": 9324}, {"id": 545, "title": "Boundary of Binary Tree", "url": "https://leetcode.com/problems/boundary-of-binary-tree/description", "companyTags": ["Google", "Amazon"], "difficulty": "Medium", "content": "Given a binary tree, return the values of its boundary in anti-clockwise direction starting from root.\r\nBoundary includes left boundary, leaves, and right boundary in order without duplicate nodes. \r\n\r\nLeft boundary is defined as the path from root to the left-most node. Right boundary is defined as the path from root to the right-most node. If the root doesn't have left subtree or right subtree, then the root itself is left boundary or right boundary. Note this definition only applies to the input binary tree, and not applies to any subtrees.\r\n\r\nThe left-most node is defined as a leaf node you could reach when you always firstly travel to the left subtree if exists. If not, travel to the right subtree. Repeat until you reach a leaf node.\r\n\r\nThe right-most node is also defined by the same way with left and right exchanged.\r\n\r\n\r\nExample 1\r\n\r\nInput:\r\n  1\r\n   \\\r\n    2\r\n   / \\\r\n  3   4\r\n\r\nOuput:\r\n[1, 3, 4, 2]\r\n\r\nExplanation:\r\nThe root doesn't have left subtree, so the root itself is left boundary.\r\nThe leaves are node 3 and 4.\r\nThe right boundary are node 1,2,4. Note the anti-clockwise direction means you should output reversed right boundary.\r\nSo order them in anti-clockwise without duplicates and we have [1,3,4,2].\r\n\r\n\r\n\r\n\r\nExample 2\r\n\r\nInput:\r\n    ____1_____\r\n   /          \\\r\n  2            3\r\n / \\          / \r\n4   5        6   \r\n   / \\      / \\\r\n  7   8    9  10  \r\n       \r\nOuput:\r\n[1,2,4,7,8,9,10,6,3]\r\n\r\nExplanation:\r\nThe left boundary are node 1,2,4. (4 is the left-most node according to definition)\r\nThe leaves are node 4,7,8,9,10.\r\nThe right boundary are node 1,3,6,10. (10 is the right-most node).\r\nSo order them in anti-clockwise without duplicate nodes we have [1,2,4,7,8,9,10,6,3].\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/700", "similarQuestions": ["BinaryTreeRightSideView"], "topicTags": ["Tree"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    List<Integer> res;\n    public List<Integer> boundaryOfBinaryTree(TreeNode root) {\n        res = new ArrayList<>();\n        \n        if (root == null){return res;}\n        res.add(root.val);\n        leftB(root.left);\n        leaves(root.left);\n        leaves(root.right);\n        rightB(root.right);\n        return res;\n    }\n    \n    private void leftB(TreeNode node) {\n        if (node == null || (node.left == null && node.right == null)) return;\n        res.add(node.val);\n        if (node.left == null) {\n            leftB(node.right);\n        } else {\n            leftB(node.left);\n        }\n    }\n    \n    private void rightB(TreeNode node) {\n        if (node == null || (node.left == null && node.right == null)) return;\n        if (node.right == null) {\n            rightB(node.left);\n        } else {\n            rightB(node.right);\n        }\n        res.add(node.val);\n    }\n    \n    private void leaves(TreeNode node) {\n        if (node == null) return;\n        if (node.left == null && node.right == null) {\n            res.add(node.val);\n            return;\n        }\n        if (node.left != null) {\n            leaves(node.left);\n        }\n        if (node.right != null) {\n            leaves(node.right);\n        }\n    }\n}", "total_acs": 8319, "total_submitted": 25704}, {"id": 546, "title": "Remove Boxes", "url": "https://leetcode.com/problems/remove-boxes/description", "companyTags": ["Tencent"], "difficulty": "Hard", "content": "Given several boxes with different colors represented by different positive numbers. \r\nYou may experience several rounds to remove boxes until there is no box left. Each time you can choose some continuous boxes with the same color (composed of k boxes, k >= 1), remove them and get k*k points.\r\nFind the maximum points you can get.\r\n\r\n\r\nExample 1:\r\nInput: \r\n\r\n[1, 3, 2, 2, 2, 3, 4, 3, 1]\r\n\r\nOutput:\r\n\r\n23\r\n\r\nExplanation: \r\n\r\n[1, 3, 2, 2, 2, 3, 4, 3, 1] \r\n----> [1, 3, 3, 4, 3, 1] (3*3=9 points) \r\n----> [1, 3, 3, 3, 1] (1*1=1 points) \r\n----> [1, 1] (3*3=9 points) \r\n----> [] (2*2=4 points)\r\n\r\n\r\n\r\nNote:\r\nThe number of boxes n would not exceed 100.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/701", "similarQuestions": ["StrangePrinter"], "topicTags": ["DynamicProgramming", "Depth-firstSearch"], "Solution": "class Solution {\n    public int removeBoxes(int[] boxes) {\n        int maxColor = Integer.MIN_VALUE;\n        for(int b: boxes) if(maxColor<b) maxColor = b;\n        int[] fMap = new int[maxColor+1];\n        for(int b: boxes) fMap[b] = fMap[b]+1;\n        \n        int index=0;\n        int[] boxes1 = new int[100];\n        for(int b: boxes) { if(fMap[b]!=1) boxes1[index++] = b;}\n        \n        int[][][] cache = new int[index][index][index];\n        int result = removeBoxesHelper(boxes1, 0, index-1, 0, cache);\n        return result + boxes.length-index;\n    }\n    \n    public int removeBoxesHelper(int[] boxes, int i, int j, int k, int[][][] cache) {\n        \n        if(j<i) return 0;\n        if(cache[i][j][k] >0) return cache[i][j][k];\n        int res = 0;\n        \n        for(;i<j && boxes[i+1]==boxes[i]; i++, k++);\n            \n        res = (k+1)*(k+1) + removeBoxesHelper(boxes, i+1,j, 0, cache);\n        \n        for(int m = i+1; m<=j; m++) {\n            if(boxes[m]==boxes[i]) //another box of same color \n            {\n                res = Math.max(res, removeBoxesHelper(boxes,i+1,m-1,0, cache) + removeBoxesHelper(boxes,m, j, k+1, cache));\n            \n            }\n        }\n        cache[i][j][k] = res;\n        return res;\n    }\n}", "total_acs": 5094, "total_submitted": 14448}, {"id": 547, "title": "Friend Circles", "url": "https://leetcode.com/problems/friend-circles/description", "companyTags": ["Bloomberg", "TwoSigma"], "difficulty": "Medium", "content": "\r\nThere are N students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. For example, if A is a direct friend of B, and B is a direct friend of C, then A is an indirect friend of C. And we defined a friend circle is a group of students who are direct or indirect friends.\r\n\r\n\r\n\r\nGiven a N*N matrix M representing the friend relationship between students in the class. If M[i][j] = 1, then the ith and jth students are direct friends with each other, otherwise not. And you have to output the total number of friend circles among all the students.\r\n\r\n\r\nExample 1:\r\n\r\nInput: \r\n[[1,1,0],\r\n [1,1,0],\r\n [0,0,1]]\r\nOutput: 2\r\nExplanation:The 0th and 1st students are direct friends, so they are in a friend circle. The 2nd student himself is in a friend circle. So return 2.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: \r\n[[1,1,0],\r\n [1,1,1],\r\n [0,1,1]]\r\nOutput: 1\r\nExplanation:The 0th and 1st students are direct friends, the 1st and 2nd students are direct friends, so the 0th and 2nd students are indirect friends. All of them are in the same friend circle, so return 1.\r\n\r\n\r\n\r\n\r\nNote:\r\n\r\nN is in range [1,200].\r\nM[i][i] = 1 for all students.\r\nIf M[i][j] = 1, then M[j][i] = 1.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/703", "similarQuestions": ["NumberofConnectedComponentsinanUndirectedGraph", "JudgeRouteCircle", "SentenceSimilarity", "SentenceSimilarityII"], "topicTags": ["Depth-firstSearch", "UnionFind"], "Solution": "class Solution {\n    void dfs(int[][] M, int[] visited, int i) {\n        for (int j = 0; j < M.length; j++) {\n            if (visited[j] == 0 && M[i][j] == 1) {\n                visited[j] = 1;\n                dfs(M, visited, j);\n            }\n        }\n    }\n\n    public int findCircleNum(int[][] M) {\n        int res = 0;\n        int[] visited = new int[M.length];\n        for (int i = 0; i < M.length; i++) {\n            if (visited[i] == 0) {\n                dfs(M, visited, i);\n                res ++;\n            }\n        }\n        return res;\n    }\n}", "total_acs": 30510, "total_submitted": 62123}, {"id": 548, "title": "Split Array with Equal Sum", "url": "https://leetcode.com/problems/split-array-with-equal-sum/description", "companyTags": ["Alibaba"], "difficulty": "Medium", "content": "\r\nGiven an array with n integers, you need to find if there are triplets  (i, j, k) which satisfies following conditions:\r\n\r\n 0 < i, i + 1 < j, j + 1 < k < n - 1 \r\n Sum of subarrays (0, i - 1), (i + 1, j - 1), (j + 1, k - 1) and (k + 1, n - 1) should be equal. \r\n\r\nwhere we define that subarray (L, R) represents a slice of the original array starting from the element indexed L to the element indexed R.\r\n\r\n\r\nExample:\r\n\r\nInput: [1,2,1,2,1,2,1]\r\nOutput: True\r\nExplanation:\r\ni = 1, j = 3, k = 5. \r\nsum(0, i - 1) = sum(0, 0) = 1\r\nsum(i + 1, j - 1) = sum(2, 2) = 1\r\nsum(j + 1, k - 1) = sum(4, 4) = 1\r\nsum(k + 1, n - 1) = sum(6, 6) = 1\r\n\r\n\r\n\r\nNote:\r\n\r\n 1 <= n <= 2000. \r\n Elements in the given array will be in range [-1,000,000, 1,000,000]. \r\n", "discussUrl": "https://discuss.leetcode.com/category/704", "similarQuestions": [""], "topicTags": ["Array"], "Solution": "class Solution {\n    public boolean splitArray(int[] nums) {\n        int sum = 0;\n        for(int i = 1; i < nums.length; i++){\n            if(nums[i-1] == 0) \n                // in this case, subarray sum for this i is the same as i-1, no need to go through the process again since it's already been checked when i was i-1. \n                continue;\n            sum += nums[i-1];\n            if(find(nums, i+1, sum, 3)) \n                return true;\n        }\n        return false;\n    }\n    private boolean find(int[] nums, int index, int sum, int cnt){\n        // index is the first element index of the next subarray \n        if(cnt==0 && index == nums.length+1) \n            return true;\n        if(cnt > 0 && index < nums.length) {\n            int subSum = 0;\n            for(int j = index+1; j < nums.length+1; j++){\n                subSum += nums[j-1];\n                if(subSum == sum && find(nums, j+1, sum, cnt-1))\n                    return true;\n            }\n        }\n        return false;\n    }\n}", "total_acs": 3663, "total_submitted": 9725}, {"id": 549, "title": "Binary Tree Longest Consecutive Sequence II", "url": "https://leetcode.com/problems/binary-tree-longest-consecutive-sequence-ii/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "Given a binary tree, you need to find the length of Longest Consecutive Path in Binary Tree. \r\n\r\nEspecially, this path can be either increasing or decreasing. For example, [1,2,3,4] and [4,3,2,1] are both considered valid, but the path [1,2,4,3] is not valid. On the other hand, the path can be in the child-Parent-child order, where not necessarily be parent-child order.\r\n\r\nExample 1:\r\n\r\nInput:\r\n        1\r\n       / \\\r\n      2   3\r\nOutput: 2\r\nExplanation: The longest consecutive path is [1, 2] or [2, 1].\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput:\r\n        2\r\n       / \\\r\n      1   3\r\nOutput: 3\r\nExplanation: The longest consecutive path is [1, 2, 3] or [3, 2, 1].\r\n\r\n\r\n\r\nNote:\r\nAll the values of tree nodes are in the range of [-1e7, 1e7].\r\n \r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/705", "similarQuestions": ["BinaryTreeLongestConsecutiveSequence"], "topicTags": ["Tree"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    int maxval = 0;\n    public int longestConsecutive(TreeNode root) {\n        longestPath(root);\n        return maxval;\n    }\n    public int[] longestPath(TreeNode root) {\n        if (root == null)\n            return new int[] {0,0};\n        int inr = 1, dcr = 1;\n        if (root.left != null) {\n            int[] l = longestPath(root.left);\n            if (root.val == root.left.val + 1)\n                dcr = l[1] + 1;\n            else if (root.val == root.left.val - 1)\n                inr = l[0] + 1;\n        }\n        if (root.right != null) {\n            int[] r = longestPath(root.right);\n            if (root.val == root.right.val + 1)\n                dcr = Math.max(dcr, r[1] + 1);\n            else if (root.val == root.right.val - 1)\n                inr = Math.max(inr, r[0] + 1);\n        }\n        maxval = Math.max(maxval, dcr + inr - 1);\n        return new int[] {inr, dcr};\n    }\n}", "total_acs": 6863, "total_submitted": 15957}, {"id": 551, "title": "Student Attendance Record I", "url": "https://leetcode.com/problems/student-attendance-record-i/description", "companyTags": ["Google"], "difficulty": "Easy", "content": "You are given a string representing an attendance record for a student. The record only contains the following three characters:\r\n\r\n\r\n\r\n'A' : Absent. \r\n'L' : Late.\r\n 'P' : Present. \r\n\r\n\r\n\r\n\r\nA student could be rewarded if his attendance record doesn't contain more than one 'A' (absent) or more than two continuous 'L' (late).    \r\n\r\nYou need to return whether the student could be rewarded according to his attendance record.\r\n\r\nExample 1:\r\n\r\nInput: \"PPALLP\"\r\nOutput: True\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: \"PPALLL\"\r\nOutput: False\r\n\r\n\r\n\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/707", "similarQuestions": ["StudentAttendanceRecordII"], "topicTags": ["String"], "Solution": "class Solution {\n    public boolean checkRecord(String s) {\n        return !(s.indexOf(\"A\") != s.lastIndexOf(\"A\") || s.contains(\"LLL\"));\n    }\n}", "total_acs": 27862, "total_submitted": 62785}, {"id": 552, "title": "Student Attendance Record II", "url": "https://leetcode.com/problems/student-attendance-record-ii/description", "companyTags": ["Google"], "difficulty": "Hard", "content": "Given a positive integer n, return the number of all possible attendance records with length n, which will be regarded as rewardable. The answer may be very large, return it after mod 109 + 7.\r\n\r\nA student attendance record is a string that only contains the following three characters:\r\n\r\n\r\n\r\n'A' : Absent. \r\n'L' : Late.\r\n 'P' : Present. \r\n\r\n\r\n\r\n\r\nA record is regarded as rewardable if it doesn't contain more than one 'A' (absent) or more than two continuous 'L' (late).\r\n\r\nExample 1:\r\n\r\nInput: n = 2\r\nOutput: 8 \r\nExplanation:\r\nThere are 8 records with length 2 will be regarded as rewardable:\r\n\"PP\" , \"AP\", \"PA\", \"LP\", \"PL\", \"AL\", \"LA\", \"LL\"\r\nOnly \"AA\" won't be regarded as rewardable owing to more than one absent times. \r\n\r\n\r\n\r\nNote:\r\nThe value of n won't exceed 100,000.\r\n\r\n\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/708", "similarQuestions": ["StudentAttendanceRecordI"], "topicTags": ["DynamicProgramming"], "Solution": "class Solution {\n     final int MOD = 1000000007;\n    final int M = 6;\n\n    int[][] mul(int[][] A, int[][] B) {\n        int[][] C = new int[M][M];\n        for (int i = 0; i < M; i++)\n            for (int j = 0; j < M; j++)\n                for (int k = 0; k < M; k++)\n                    C[i][j] = (int) ((C[i][j] + (long) A[i][k] * B[k][j]) % MOD);\n        return C;\n    }\n\n\n    int[][] pow(int[][] A, int n) {\n        int[][] res = new int[M][M];\n        for (int i = 0; i < M; i++)\n            res[i][i] = 1;\n        while (n > 0) {\n            if (n % 2 == 1)\n                res = mul(res, A);\n            A = mul(A, A);\n            n /= 2;\n        }\n        return res;\n    }\n\n    public int checkRecord(int n) {\n        int[][] A = {\n                {0, 0, 1, 0, 0, 0},\n                {1, 0, 1, 0, 0, 0},\n                {0, 1, 1, 0, 0, 0},\n                {0, 0, 1, 0, 0, 1},\n                {0, 0, 1, 1, 0, 1},\n                {0, 0, 1, 0, 1, 1},\n        };\n        return pow(A, n + 1)[5][2];\n    }\n}", "total_acs": 6549, "total_submitted": 20767}, {"id": 553, "title": "Optimal Division", "url": "https://leetcode.com/problems/optimal-division/description", "companyTags": ["Amazon"], "difficulty": "Medium", "content": "Given a list of positive integers, the adjacent integers will perform the float division. For example, [2,3,4] -> 2 / 3 / 4.\r\n\r\nHowever, you can add any number of parenthesis at any position to change the priority of operations. You should find out how to add parenthesis to get the maximum result, and return the corresponding expression in string format. Your expression should NOT contain redundant parenthesis.\r\n\r\nExample:\r\n\r\nInput: [1000,100,10,2]\r\nOutput: \"1000/(100/10/2)\"\r\nExplanation:\r\n1000/(100/10/2) = 1000/((100/10)/2) = 200\r\nHowever, the bold parenthesis in \"1000/((100/10)/2)\" are redundant, since they don't influence the operation priority. So you should return \"1000/(100/10/2)\". \r\n\r\nOther cases:\r\n1000/(100/10)/2 = 50\r\n1000/(100/(10/2)) = 50\r\n1000/100/10/2 = 0.5\r\n1000/100/(10/2) = 2\r\n\r\n\r\n\r\nNote:\r\n\r\nThe length of the input array is [1, 10].\r\nElements in the given array will be in range [2, 1000].\r\nThere is only one optimal division for each test case.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/710", "similarQuestions": [""], "topicTags": ["Math", "String"], "Solution": "public class Solution {\n    public String optimalDivision(int[] nums) {\n        if (nums.length == 1)\n            return nums[0] + \"\";\n        if (nums.length == 2)\n            return nums[0] + \"/\" + nums[1];\n        StringBuilder res = new StringBuilder(nums[0] + \"/(\" + nums[1]);\n        for (int i = 2; i < nums.length; i++) {\n            res.append(\"/\" + nums[i]);\n        }\n        res.append(\")\");\n        return res.toString();\n    }\n}", "total_acs": 12389, "total_submitted": 22465}, {"id": 554, "title": "Brick Wall", "url": "https://leetcode.com/problems/brick-wall/description", "companyTags": ["Facebook"], "difficulty": "Medium", "content": "There is a brick wall in front of you. The wall is rectangular and has several rows of bricks. The bricks have the same height but different width. You want to draw a vertical line from the top to the bottom and cross the least bricks. \r\n\r\n\r\nThe brick wall is represented by a list of rows. Each row is a list of integers representing the width of each brick in this row from left to right. \r\n\r\n\r\nIf your line go through the edge of a brick, then the brick is not considered as crossed. You need to find out how to draw the line to cross the least bricks and return the number of crossed bricks. \r\n\r\nYou cannot draw a line just along one of the two vertical edges of the wall, in which case the line will obviously cross no bricks. \r\n\r\nExample:\r\n\r\nInput: \r\n[[1,2,2,1],\r\n [3,1,2],\r\n [1,3,2],\r\n [2,4],\r\n [3,1,2],\r\n [1,3,1,1]]\r\nOutput: 2\r\nExplanation: \r\n\r\n\r\n\r\n\r\nNote:\r\n\r\nThe width sum of bricks in different rows are the same and won't exceed INT_MAX.\r\nThe number of bricks in each row is in range [1,10,000]. The height of wall is in range [1,10,000]. Total number of bricks of the wall won't exceed 20,000. \r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/711", "similarQuestions": [""], "topicTags": ["HashTable"], "Solution": "class Solution {\n    public int leastBricks(List<List<Integer>> wall) {\n        Map<Integer, Integer> map = new HashMap<>();\n\t\tint sum, max=0, count=0;\n\t\tfor(List<Integer> list: wall){\n\t\t\tsum=0;\n\t\t\tfor(int i=0; i<list.size()-1; i++){\n\t\t\t\tsum += list.get(i);\n\t\t\t\tif(map.containsKey(sum)){\n\t\t\t\t\tcount = map.get(sum)+1;\t\t\t\t\t\n\t\t\t\t} else{\n\t\t\t\t\tcount = 1;\n\t\t\t\t}\n\t\t\t\tmap.put(sum, count);\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t}\n\t\treturn wall.size()-max;\n    }\n}", "total_acs": 19194, "total_submitted": 41488}, {"id": 555, "title": "Split Concatenated Strings", "url": "https://leetcode.com/problems/split-concatenated-strings/description", "companyTags": ["Alibaba"], "difficulty": "Medium", "content": "Given a list of strings, you could concatenate these strings together into a loop, where for each string you could choose to reverse it or not. Among all the possible loops, you need to find the lexicographically biggest string after cutting the loop, which will make the looped string into a regular one.\r\n\r\nSpecifically, to find the lexicographically biggest string, you need to experience two phases: \r\n\r\nConcatenate all the strings into a loop, where you can reverse some strings or not and connect them in the same order as given.\r\nCut and make one breakpoint in any place of the loop, which will make the looped string into a regular one starting from the character at the cutpoint. \r\n\r\n\r\n\r\nAnd your job is to find the lexicographically biggest one among all the possible regular strings.\r\n\r\n\r\nExample:\r\n\r\nInput: \"abc\", \"xyz\"\r\nOutput: \"zyxcba\"\r\nExplanation: You can get the looped string \"-abcxyz-\", \"-abczyx-\", \"-cbaxyz-\", \"-cbazyx-\", where '-' represents the looped status. The answer string came from the fourth looped one, where you could cut from the middle character 'a' and get \"zyxcba\".\r\n\r\n\r\n\r\nNote:\r\n\r\nThe input strings will only contain lowercase letters.\r\nThe total length of all the strings will not over 1,000.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/712", "similarQuestions": [""], "topicTags": ["String"], "Solution": "class Solution {\n    public String splitLoopedString(String[] strs) {\n        largeOrder(strs);\n        String max = null;\n        for(int i=0; i<strs.length; i++){\n            for(int j=0; j<strs[i].length(); j++){\n                if(max == null || compare(i,j,strs,strs[i],max)){\n                    max = toBiggest(i,j,strs,strs[i]);\n                }\n            }\n            String cand = new StringBuilder(strs[i]).reverse().toString();\n            for(int j=0; j<cand.length(); j++){\n                if(compare(i,j,strs,cand,max)){\n                    max = toBiggest(i,j,strs,cand);\n                }\n            }\n        }\n        return max;\n    }\n\n    void largeOrder(String[] strs){\n        for(int i=0; i<strs.length; i++){\n            String s = strs[i];\n            int left = 0, right = s.length()-1;\n            while(left<right){\n                if(s.charAt(left) < s.charAt(right)){\n                    strs[i] = new StringBuilder(s).reverse().toString();\n                    break;\n                }else if(s.charAt(left) > s.charAt(right)){\n                    break;\n                }\n                left++;\n                right--;\n            }\n        }\n    }\n\n    String toBiggest(int i, int j, String[] strs, String start){\n        StringBuilder sb = new StringBuilder();\n        sb.append(start.substring(j));\n        for(int m=i+1; m< strs.length; m++) sb.append(strs[m]);\n        for(int m=0; m<i; m++) sb.append(strs[m]);\n        sb.append(start.substring(0,j));\n        return sb.toString();\n    }\n\n    boolean compare(int i, int j, String[] strs, String start, String max){\n        int ptr2 = i;\n        for(int ptr = 0; ptr<max.length(); ptr++){\n            char cand;\n            if(ptr2 == i){\n                cand = start.charAt(j);\n            }else{\n                cand = strs[ptr2].charAt(j);\n            }\n            if(max.charAt(ptr) < cand){\n                return true;\n            }else if(max.charAt(ptr) > cand){\n                return false;\n            }\n            j++;\n            if(j>=strs[ptr2].length()){\n                j=0;\n                ptr2++;\n                if(ptr2>=strs.length){\n                    ptr2=0;\n                }\n            }\n        }\n        return false;\n    }\n}", "total_acs": 2457, "total_submitted": 6460}, {"id": 556, "title": "Next Greater Element III", "url": "https://leetcode.com/problems/next-greater-element-iii/description", "companyTags": ["Bloomberg"], "difficulty": "Medium", "content": "Given a positive 32-bit integer n, you need to find the smallest 32-bit integer which has exactly the same digits existing in the integer n and is greater in value than n. If no such positive 32-bit integer exists, you need to return -1.\r\n\r\nExample 1:\r\n\r\n\r\nInput: 12\r\nOutput: 21\r\n\r\n\r\n\u00a0\r\n\r\nExample 2:\r\n\r\n\r\nInput: 21\r\nOutput: -1\r\n\r\n\r\n\u00a0\r\n", "discussUrl": "https://discuss.leetcode.com/category/713", "similarQuestions": ["NextGreaterElementI", "NextGreaterElementII"], "topicTags": ["String"], "Solution": "class Solution {\n    public int nextGreaterElement(int n) {\n        if(n <= 0) return -1;\n        \n        char[] digit = (n + \"\").toCharArray();\n        int num = digit.length;\n\n        for(int i = num - 2; i >= 0; i--){\n            if(digit[i] >= digit[i + 1]) continue;\n            for(int j = num - 1; j > i; j--){\n                if(digit[j] > digit[i]) {\n                    swap(digit, i, j);\n                    reverse(digit, i + 1);\n                    try{\n                        return Integer.parseInt(String.valueOf(digit));\n                    }\n                    catch(Exception e){\n                        return -1;\n                    }    \n                }\n            }\n        }\n        return -1;\n        \n    }\n    \n    \n    private void swap(char[] digit, int s, int d){\n        char tmp = digit[s];\n        digit[s] = digit[d];\n        digit[d] = tmp;\n    }\n    \n    private void reverse(char[] digit, int s){\n        int e = digit.length - 1;\n        while(s < e){\n            swap(digit, s, e);\n            s++;\n            e--;\n        } \n    }\n\n}", "total_acs": 11702, "total_submitted": 40247}, {"id": 557, "title": "Reverse Words in a String III", "url": "https://leetcode.com/problems/reverse-words-in-a-string-iii/description", "companyTags": ["Zappos"], "difficulty": "Easy", "content": "Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.\r\n\r\nExample 1:\r\n\r\nInput: \"Let's take LeetCode contest\"\r\nOutput: \"s'teL ekat edoCteeL tsetnoc\"\r\n\r\n\r\n\r\nNote:\r\nIn the string, each word is separated by single space and there will not be any extra space in the string.\r\n", "discussUrl": "https://discuss.leetcode.com/category/714", "similarQuestions": ["ReverseStringII"], "topicTags": ["String"], "Solution": "class Solution {\n    public String reverseWords(String s) {\n        if (s == null || s.length() == 0) {\n            return \"\";\n        }\n\n        char[] chars = s.toCharArray();\n        int i = 0;\n        while (i < chars.length) {\n            int index = s.indexOf(' ', i);\n            if (index == -1) {\n                reverse(chars, i, chars.length - 1);\n                break;\n            }\n            reverse(chars, i, index - 1);\n            i = index + 1;\n        }\n\n        return new String(chars);\n    }\n\n    private void reverse(char[] chars, int start, int end) {\n        while (start < end) {\n            char temp = chars[start];\n            chars[start] = chars[end];\n            chars[end] = temp;\n            start++;\n            end--;\n        }\n    }\n}", "total_acs": 59317, "total_submitted": 98846}, {"id": 560, "title": "Subarray Sum Equals K", "url": "https://leetcode.com/problems/subarray-sum-equals-k/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.\r\n\r\nExample 1:\r\n\r\nInput:nums = [1,1,1], k = 2\r\nOutput: 2\r\n\r\n\r\n\r\nNote:\r\n\r\nThe length of the array is in range [1, 20,000].\r\nThe range of numbers in the array is [-1000, 1000] and the range of the integer k is [-1e7, 1e7].\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/715", "similarQuestions": ["TwoSum", "ContinuousSubarraySum", "SubarrayProductLessThanK", "FindPivotIndex"], "topicTags": ["Array", "HashTable"], "Solution": "class Solution {\n     public int subarraySum(int[] nums, int k) {\n        int[] sums = new int[nums.length + 1];\n        for (int i = 1; i < sums.length; i++) {\n            sums[i] = sums[i - 1] + nums[i - 1];\n        }\n        return sub(sums, new int[sums.length], 0, sums.length - 1, k);\n    }\n    \n    private int sub(int[] sums, int[] aux, int start, int end, int k) {\n        if (start >= end) {\n            return 0;\n        }\n        int mid = start + (end - start) / 2;\n        int res = sub(sums, aux, start, mid, k) + sub(sums, aux, mid + 1, end, k);\n        res += merge(sums, aux, start, mid, end, k);\n        return res;\n    }\n    \n    private int merge(int[] sums, int[] aux, int start, int mid, int end, int k) {\n        // System.out.println(\"start: \" + start + \" mid: \" + mid + \" end: \" + end);\n        // System.out.println(\"Before merge: \" + Arrays.toString(sums));\n        for (int i = start; i <= end; i++) {\n            aux[i] = sums[i];\n        }\n        int count = 0;\n        int i = start, j = mid + 1, t = start;\n        int p = mid + 1;\n        while (i <= mid) {\n            while (p <= end && aux[p] - k < aux[i]) p++;\n            for (int q = 0; q + p <= end; q++) {\n                if (aux[p + q] - k > aux[i]) break;\n                else count++;\n            }\n            \n            while (j <= end && aux[i] > aux[j]) sums[t++] = aux[j++];\n            sums[t++] = aux[i++];\n        }\n        \n        while (j <= end) sums[t++] = aux[j++];\n        // System.out.println(\"After merge: \" + Arrays.toString(sums));\n        return count;\n    }\n}", "total_acs": 28396, "total_submitted": 70372}, {"id": 561, "title": "Array Partition I", "url": "https://leetcode.com/problems/array-partition-i/description", "companyTags": [""], "difficulty": "Easy", "content": "\r\nGiven an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.\r\n\r\n\r\nExample 1:\r\n\r\nInput: [1,4,3,2]\r\n\r\nOutput: 4\r\nExplanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).\r\n\r\n\r\n\r\nNote:\r\n\r\nn is a positive integer, which is in the range of [1, 10000].\r\nAll the integers in the array will be in the range of [-10000, 10000].\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/718", "similarQuestions": [""], "topicTags": ["Array"], "Solution": "public class Solution {\n    public int arrayPairSum(int[] nums) {\n       \n        int [] t = new int[20001];\n        for(int i = 0; i<nums.length; i++){\n            t[nums[i]+10000]++;\n        }\n        int n = nums.length/2;       \n        int sum = 0;\n        /*int i = 20000;\n        while(n>0){\n            int j = t[i]/2;\n            j = Math.min(n,j);\n            sum+=((i-10000)*j);\n            n-=j;\n            if(t[i]%2==1)\n                t[i-1]++;\n            i--;       \n        }*/\n       // int cnt = n;\n        int carry = 0;\n        for(int i =20000; i>=0 && n>0; i--){\n            if(t[i]== 0) continue;       \n            int val = i-10000;\n           // int remain = n-cnt;\n            int canBeUsed = (t[i]+carry)/2;\n            carry = (t[i]+carry)%2;\n            int x = Math.min(n, canBeUsed );\n            n -= x;\n            sum+= x*val;\n           // System.out.println(i+\" \"+ t[i]+\" \"+n+\" \"+sum);\n        }\n        return sum;\n    }\n}", "total_acs": 65585, "total_submitted": 98544}, {"id": 562, "title": "Longest Line of Consecutive One in Matrix", "url": "https://leetcode.com/problems/longest-line-of-consecutive-one-in-matrix/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "Given a 01 matrix M, find the longest line of consecutive one in the matrix. The line could be horizontal, vertical, diagonal or anti-diagonal.\r\n\r\nExample:\r\n\r\nInput:\r\n[[0,1,1,0],\r\n [0,1,1,0],\r\n [0,0,0,1]]\r\nOutput: 3\r\n\r\n\r\n\r\n\r\nHint:\r\nThe number of elements in the given matrix will not exceed 10,000.\r\n", "discussUrl": "https://discuss.leetcode.com/category/719", "similarQuestions": [""], "topicTags": ["Array"], "Solution": "class Solution {\n    public int longestLine(int[][] M) {\n        int m = M.length;\n        if(m == 0) return 0;\n        int n = M[0].length;\n        if(n == 0) return 0;\n        int res = 0;\n        for(int i = 0; i < m; i++) {\n            int tempmax = 0;\n            for(int j = 0; j < n; j++) {\n                if(M[i][j] == 0) {\n                    res = Math.max(res, tempmax);\n                    tempmax = 0;\n                } else {\n                    tempmax++;\n                }\n                res = Math.max(res, tempmax);\n            }\n        }\n        \n        if(res >= m) return res;\n        \n        for(int i = 0; i < n; i++) {\n            int tempmax = 0;\n            for(int j = 0; j < m; j++) {\n                if(M[j][i] == 0) {\n                    res = Math.max(res, tempmax);\n                    tempmax = 0;\n                } else {\n                    tempmax++;\n                }\n                res = Math.max(res, tempmax);\n            }\n        }\n        \n        if(res >= Math.min(m, n)) return res;\n        \n        for(int i = 0; i < m; i++) {\n            int tempmax = 0;\n            for(int tempi = i, j = 0; tempi < m && j < n; tempi++, j++) {\n                if(M[tempi][j] == 0) {\n                    res = Math.max(res, tempmax);\n                    tempmax = 0;\n                } else {\n                    tempmax++;\n                }\n            }\n            res = Math.max(res, tempmax);\n            tempmax = 0;\n            for(int tempi = i, j = n-1; tempi < m && j >= 0; tempi++, j--) {\n                if(M[tempi][j] == 0) {\n                    res = Math.max(res, tempmax);\n                    tempmax = 0;\n                } else {\n                    tempmax++;\n                }\n            }\n            res = Math.max(res, tempmax);\n             tempmax = 0;\n            for(int tempi = i, j = n-1; tempi >= 0 && j >= 0; tempi--, j--) {\n                if(M[tempi][j] == 0) {\n                    res = Math.max(res, tempmax);\n                    tempmax = 0;\n                } else {\n                    tempmax++;\n                }\n            }\n            res = Math.max(res, tempmax);\n             tempmax = 0;\n            for(int tempi = i, j = 0; tempi >= 0 && j < n; tempi--, j++) {\n                if(M[tempi][j] == 0) {\n                    res = Math.max(res, tempmax);\n                    tempmax = 0;\n                } else {\n                    tempmax++;\n                }\n            }\n            res = Math.max(res, tempmax);\n        }\n        return res;\n    }\n}", "total_acs": 6204, "total_submitted": 15002}, {"id": 563, "title": "Binary Tree Tilt", "url": "https://leetcode.com/problems/binary-tree-tilt/description", "companyTags": ["Indeed"], "difficulty": "Easy", "content": "Given a binary tree, return the tilt of the whole tree.\r\n\r\nThe tilt of a tree node is defined as the absolute difference between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0.\r\n\r\nThe tilt of the whole tree is defined as the sum of all nodes' tilt.\r\n\r\nExample:\r\n\r\nInput: \r\n         1\r\n       /   \\\r\n      2     3\r\nOutput: 1\r\nExplanation: \r\nTilt of node 2 : 0\r\nTilt of node 3 : 0\r\nTilt of node 1 : |2-3| = 1\r\nTilt of binary tree : 0 + 0 + 1 = 1\r\n\r\n\r\n\r\nNote:\r\n\r\nThe sum of node values in any subtree won't exceed the range of 32-bit integer. \r\nAll the tilt values won't exceed the range of 32-bit integer.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/720", "similarQuestions": [""], "topicTags": ["Tree"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    int result = 0;\n    \n    public int findTilt(TreeNode root) {\n        \n        travelTree(root);\n        return result;\n    }\n    \n    public int travelTree(TreeNode root){\n        if (root == null) return 0;\n        \n        int left = travelTree(root.left);\n        int right = travelTree(root.right);\n        \n        result = result + Math.abs(left - right);\n        \n        return root.val + left + right;\n    }\n}", "total_acs": 25405, "total_submitted": 53762}, {"id": 564, "title": "Find the Closest Palindrome", "url": "https://leetcode.com/problems/find-the-closest-palindrome/description", "companyTags": ["Yelp"], "difficulty": "Hard", "content": "Given an integer n, find the closest integer (not including itself), which is a palindrome. \r\n\r\nThe 'closest' is defined as absolute difference minimized between two integers.\r\n\r\nExample 1:\r\n\r\nInput: \"123\"\r\nOutput: \"121\"\r\n\r\n\r\n\r\nNote:\r\n\r\nThe input n is a positive integer represented by string, whose length will not exceed 18.\r\nIf there is a tie, return the smaller one as answer.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/721", "similarQuestions": [""], "topicTags": ["String"], "Solution": "class Solution {\n    public String nearestPalindromic(String n) {\n        int start = 0;\n        int end = 0;\n        char[] num = n.toCharArray();\n        boolean isPalin = true;\n        if(n.length() % 2 == 0){\n            start = n.length()/2-1;\n            end = n.length()/2;\n        }\n        else{\n            start = n.length()/2;;\n            end = start;\n        }\n        int left = start;\n        int right = end;\n        while(start >=0 && end < n.length()){\n            if(num[start] != num[end]){\n                num[end] = num[start];\n                isPalin = false;\n            }\n            start--;\n            end++;\n        }\n        String prevPalin = \"\";\n        String nextPalin = \"\";\n        if(isPalin){\n            prevPalin = lowerPalin(num,left,right);\n            nextPalin = higherPalin(num,left,right);\n        }\n        else{\n            String palin = new String(num);\n            if(palin.compareTo(n) > 0){\n                prevPalin = lowerPalin(num,left,right);\n                nextPalin =palin;\n            }\n            else{\n                prevPalin = palin;\n                nextPalin = higherPalin(num,left,right);\n            }\n            \n        }\n        // System.out.println(prevPalin);\n        // System.out.println(nextPalin);\n        String result = (Long.valueOf(nextPalin) - Long.valueOf(n) >= Long.valueOf(n) - Long.valueOf(prevPalin))?\n            prevPalin:nextPalin;\n        return result;\n        \n    }\n    \n    private String lowerPalin(char[] num, int start, int end){\n        if(num.length == 1){\n            if(num[0] == '0')\n                return new String(num);\n            else{\n                String result = (char)(num[0]-1)+\"\";\n                return result;\n            } \n        }\n        char[] lowerBound = new char[num.length-1];\n        for(int i = 0; i < lowerBound.length; i++)\n            lowerBound[i] = '9';\n        \n        char[] result = Arrays.copyOf(num, num.length);\n        while(start>=0 && end < num.length && num[start] == '0' && num[end] == '0'){\n            result[start] = '9';\n            result[start] = '9';\n            start--;\n            end++;\n        }\n        if(start<0 || (start == 0 && result[start] == '1')){\n            return new String(lowerBound);\n        }\n        else{\n            result[start] = (char)(result[start] -1);\n            result[end] = result[start];\n            return new String(result);\n        }\n            \n    }\n    \n    private String higherPalin(char[] num, int start, int end){\n        char[] higherBound = new char[num.length+1];\n        higherBound[0] = '1';\n        higherBound[num.length] = '1';\n        for(int i = 1; i < num.length; i++)\n            higherBound[i] = '0';\n        \n        char[] result = Arrays.copyOf(num, num.length);\n        while(start>=0 && end < num.length && num[start] == '9' && num[end] == '9'){\n            result[start] = '0';\n            result[end] = '0';\n            start--;\n            end++;\n        }\n        if(start >=0){\n            result[start] = (char)(result[start] +1);\n            result[end] = result[start];\n            return new String(result);\n        }\n        else\n            return new String(higherBound);\n    }\n}", "total_acs": 5077, "total_submitted": 28822}, {"id": 565, "title": "Array Nesting", "url": "https://leetcode.com/problems/array-nesting/description", "companyTags": ["Apple"], "difficulty": "Medium", "content": "A zero-indexed array A of length N contains all integers from 0 to N-1. Find and return the longest length of set S, where S[i] = {A[i], A[A[i]], A[A[A[i]]], ... } subjected to the rule below.\r\n\r\nSuppose the first element in S starts with the selection of element A[i] of index = i, the next element in S should be A[A[i]], and then A[A[A[i]]]\u2026 By that analogy, we stop adding right before a duplicate element occurs in S.\r\n\r\nExample 1:\r\n\r\nInput: A = [5,4,0,3,1,6,2]\r\nOutput: 6\r\nExplanation: \r\nA[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.\r\n\r\nOne of the longest S[K]:\r\nS[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}\r\n\r\n\r\n\r\nNote:\r\n\r\nN is an integer within the range [1, 20,000].\r\nThe elements of A are all distinct.\r\nEach element of A is an integer within the range [0, N-1].\r\n\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/722", "similarQuestions": ["NestedListWeightSum", "FlattenNestedListIterator", "NestedListWeightSumII"], "topicTags": ["Array"], "Solution": "class Solution {\n    public int arrayNesting(int[] nums) {\n        int max = Integer.MIN_VALUE;\n        for(int i=0;i<nums.length;i++){\n            if(nums[i]!=-1){\n                int cnt = 0;\n                int t = i;\n                while(nums[t]!=-1){\n                    cnt++;\n                    int k = nums[t];\n                    nums[t] = -1;\n                    t = k;\n                }\n                max = Math.max(max,cnt);\n            }\n        }\n        return max;\n    }\n}", "total_acs": 15162, "total_submitted": 30628}, {"id": 566, "title": "Reshape the Matrix", "url": "https://leetcode.com/problems/reshape-the-matrix/description", "companyTags": ["Mathworks"], "difficulty": "Easy", "content": "In MATLAB, there is a very useful function called 'reshape', which can reshape a matrix into a new one with different size but keep its original data.\r\n\r\n\r\n\r\nYou're given a matrix represented by a two-dimensional array, and two positive integers r and c representing the row number and column number of the wanted reshaped matrix, respectively.\r\n\r\n The reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were.\r\n\r\n\r\n\r\nIf the 'reshape' operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.\r\n\r\n\r\nExample 1:\r\n\r\nInput: \r\nnums = \r\n[[1,2],\r\n [3,4]]\r\nr = 1, c = 4\r\nOutput: \r\n[[1,2,3,4]]\r\nExplanation:The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: \r\nnums = \r\n[[1,2],\r\n [3,4]]\r\nr = 2, c = 4\r\nOutput: \r\n[[1,2],\r\n [3,4]]\r\nExplanation:There is no way to reshape a 2 * 2 matrix to a 2 * 4 matrix. So output the original matrix.\r\n\r\n\r\n\r\nNote:\r\n\r\nThe height and width of the given matrix is in range [1, 100].\r\nThe given r and c are all positive.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/724", "similarQuestions": [""], "topicTags": ["Array"], "Solution": "class Solution {\n    public int[][] matrixReshape(int[][] nums, int r, int c) {\n        if(r == 0 || c == 0){\n\t\t\treturn nums;\n\t\t}\n\t\t\n\t\tif((r * c) != (nums.length * nums[0].length)){\n\t\t\treturn nums;\n\t\t}\n\t\t\n\t\tint[][] arr = new int[r][c];\n\t\tint row = 0, col = 0;\n\t\t\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tfor(int j = 0; j < nums[i].length; j++){\n\t\t\t\tarr[row][col++] = nums[i][j];\n\t\t\t\tif(col >= c){\n\t\t\t\t\trow++;\n\t\t\t\t\tcol = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn arr;\n    }\n}", "total_acs": 42164, "total_submitted": 72813}, {"id": 567, "title": "Permutation in String", "url": "https://leetcode.com/problems/permutation-in-string/description", "companyTags": ["Microsoft"], "difficulty": "Medium", "content": "Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string's permutations is the substring of the second string.\r\n\r\nExample 1:\r\n\r\nInput:s1 = \"ab\" s2 = \"eidbaooo\"\r\nOutput:True\r\nExplanation: s2 contains one permutation of s1 (\"ba\").\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput:s1= \"ab\" s2 = \"eidboaoo\"\r\nOutput: False\r\n\r\n\r\n\r\nNote:\r\n\r\nThe input strings only contain lower case letters.\r\nThe length of both given strings is in range [1, 10,000].\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/725", "similarQuestions": ["MinimumWindowSubstring", "FindAllAnagramsinaString"], "topicTags": ["TwoPointers"], "Solution": "class Solution {\n    public boolean checkInclusion(String s1, String s2) {\n        // if end-start=len return true\n        // if arr[i]==0 positive count,recover count++ \n        // recover i++ count[arr[i]]++ \n        // \n        if(s1.length()>s2.length()){\n            return false;\n        }\n        \n        int[] count=new int[256];\n        for(char c:s1.toCharArray()){\n            count[c]++;\n        }\n        int len=s1.length();\n        int cnt=len;\n        char arr[]=s2.toCharArray();\n        int end=0;\n        int start=0;\n        while(end<arr.length){\n            if(count[arr[end]]>0){\n                cnt--;\n            }\n            count[arr[end]]--;\n            end++;\n            while(cnt==0){\n                if(end-start==len){\n                    return true;\n                }   \n                if(count[arr[start]]==0){\n                    cnt++;\n                }\n                count[arr[start]]++;\n                start++;\n            }        \n        }\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        return false;\n    }\n    \n    /*\n    \n    if(s1.length()>s2.length()) return false;\n        int[] alphabets = new int[26];\n        int len =s1.length();\n        for(char ch : s1.toCharArray()){\n            alphabets[ch-'a']++;\n        }\n        int cnt =len;\n        char[] sArr = s2.toCharArray();\n        \n        int start =0;\n        int end =0;\n        while(end<sArr.length){\n            if(alphabets[sArr[end]-'a']>0){\n                cnt--;\n            }\n            alphabets[sArr[end]-'a']--;\n            end++;\n            while(cnt==0){\n               // System.out.println(end+\",\"+start);\n                if(end-start == len) return true;\n                if(alphabets[sArr[start]-'a']==0) {\n                    cnt++;\n                }\n                alphabets[sArr[start]-'a']++;\n                start++;\n            }\n            \n        }\n    \n    \n    \n    */\n}", "total_acs": 18114, "total_submitted": 49458}, {"id": 568, "title": "Maximum Vacation Days", "url": "https://leetcode.com/problems/maximum-vacation-days/description", "companyTags": ["Google"], "difficulty": "Hard", "content": "\r\nLeetCode wants to give one of its best employees the option to travel among N cities to collect algorithm problems. But all work and no play makes Jack a dull boy, you could take vacations in some particular cities and weeks. Your job is to schedule the traveling to maximize the number of vacation days you could take, but there are certain rules and restrictions you need to follow.\r\n\r\n\r\nRules and restrictions:\r\n\r\nYou can only travel among N cities, represented by indexes from 0 to N-1. Initially, you are in the city indexed 0 on Monday.\r\nThe cities are connected by flights. The flights are represented as a N*N matrix (not necessary symmetrical), called flights representing the airline status from the city i to the city j. If there is no flight from the city i to the city j, flights[i][j] = 0; Otherwise, flights[i][j] = 1. Also, flights[i][i] = 0 for all i.\r\nYou totally have K weeks (each week has 7 days) to travel. You can only take flights at most once per day and can only take flights on each week's Monday morning. Since flight time is so short, we don't consider the impact of flight time.\r\nFor each city, you can only have restricted vacation days in different weeks, given an N*K matrix called days representing this relationship. For the value of days[i][j], it represents the maximum days you could take vacation in the city i in the week j.\r\n\r\n\r\n\r\nYou're given the flights matrix and days matrix, and you need to output the maximum vacation days you could take during K weeks.\r\n\r\nExample 1:\r\n\r\nInput:flights = [[0,1,1],[1,0,1],[1,1,0]], days = [[1,3,1],[6,0,3],[3,3,3]]\r\nOutput: 12\r\nExplanation: Ans = 6 + 3 + 3 = 12. \r\nOne of the best strategies is:\r\n1st week : fly from city 0 to city 1 on Monday, and play 6 days and work 1 day. (Although you start at city 0, we could also fly to and start at other cities since it is Monday.) \r\n2nd week : fly from city 1 to city 2 on Monday, and play 3 days and work 4 days.\r\n3rd week : stay at city 2, and play 3 days and work 4 days.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput:flights = [[0,0,0],[0,0,0],[0,0,0]], days = [[1,1,1],[7,7,7],[7,7,7]]\r\nOutput: 3\r\nExplanation: Ans = 1 + 1 + 1 = 3. \r\nSince there is no flights enable you to move to another city, you have to stay at city 0 for the whole 3 weeks. For each week, you only have one day to play and six days to work. So the maximum number of vacation days is 3.\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput:flights = [[0,1,1],[1,0,1],[1,1,0]], days = [[7,0,0],[0,7,0],[0,0,7]]\r\nOutput: 21\r\nExplanation:Ans = 7 + 7 + 7 = 21\r\nOne of the best strategies is:\r\n1st week : stay at city 0, and play 7 days. \r\n2nd week : fly from city 0 to city 1 on Monday, and play 7 days.\r\n3rd week : fly from city 1 to city 2 on Monday, and play 7 days.\r\n\r\n\r\n\r\n\r\nNote:\r\n\r\nN and K are positive integers, which are in the range of [1, 100].\r\nIn the matrix flights, all the values are integers in the range of [0, 1].\r\nIn the matrix days, all the values are integers in the range [0, 7].\r\nYou could stay at a city beyond the number of vacation days, but you should work on the extra days, which won't be counted as vacation days.\r\nIf you fly from the city A to the city B and take the vacation on that day, the deduction towards vacation days will count towards the vacation days of city B in that week.\r\nWe don't consider the impact of flight hours towards the calculation of vacation days.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/726", "similarQuestions": [""], "topicTags": ["DynamicProgramming"], "Solution": "class Solution {\n     public int maxVacationDays(int[][] flights, int[][] days) {\n        int N = flights.length, K = days[0].length; \n        int[] dp = new int[N];\n        for (int i=K-1;i>=0;i--) {\n            int[] temp = new int[N];\n            for (int j=0;j<N;j++) {\n                temp[j] = days[j][i];\n                int max = dp[j];\n                for (int n=0;n<N;n++) \n                    if (flights[j][n] == 1) max = Math.max(max, dp[n]);\n                temp[j] += max;\n            }\n            dp = temp;\n        }\n\n        int max = dp[0];\n        for (int i=0;i<N;i++) \n            if (flights[0][i] == 1) max = Math.max(max, dp[i]);\n        return max;\n    }\n}", "total_acs": 6282, "total_submitted": 16565}, {"id": 569, "title": "Median Employee Salary", "url": "https://leetcode.com/problems/median-employee-salary/description", "companyTags": ["Google"], "difficulty": "Hard", "content": "\r\nThe Employee table holds all employees. The employee table has three columns: Employee Id, Company Name, and Salary.\r\n\r\n\r\n+-----+------------+--------+\r\n|Id   | Company    | Salary |\r\n+-----+------------+--------+\r\n|1    | A          | 2341   |\r\n|2    | A          | 341    |\r\n|3    | A          | 15     |\r\n|4    | A          | 15314  |\r\n|5    | A          | 451    |\r\n|6    | A          | 513    |\r\n|7    | B          | 15     |\r\n|8    | B          | 13     |\r\n|9    | B          | 1154   |\r\n|10   | B          | 1345   |\r\n|11   | B          | 1221   |\r\n|12   | B          | 234    |\r\n|13   | C          | 2345   |\r\n|14   | C          | 2645   |\r\n|15   | C          | 2645   |\r\n|16   | C          | 2652   |\r\n|17   | C          | 65     |\r\n+-----+------------+--------+\r\n\r\n\r\nWrite a SQL query to find the median salary of each company. Bonus points if you can solve it without using any built-in SQL functions.\r\n\r\n\r\n+-----+------------+--------+\r\n|Id   | Company    | Salary |\r\n+-----+------------+--------+\r\n|5    | A          | 451    |\r\n|6    | A          | 513    |\r\n|12   | B          | 234    |\r\n|9    | B          | 1154   |\r\n|14   | C          | 2645   |\r\n+-----+------------+--------+\r\n", "discussUrl": "https://discuss.leetcode.com/category/727", "similarQuestions": ["FindMedianGivenFrequencyofNumbers"], "topicTags": [""], "Solution": null, "total_acs": 1029, "total_submitted": 2869}, {"id": 570, "title": "Managers with at Least 5 Direct Reports", "url": "https://leetcode.com/problems/managers-with-at-least-5-direct-reports/description", "companyTags": ["Bloomberg"], "difficulty": "Medium", "content": "The Employee table holds all employees including their managers. Every employee has an Id, and there is also a column for the manager Id.\r\n\r\n\r\n+------+----------+-----------+----------+\r\n|Id    |Name \t  |Department |ManagerId |\r\n+------+----------+-----------+----------+\r\n|101   |John \t  |A \t      |null      |\r\n|102   |Dan \t  |A \t      |101       |\r\n|103   |James \t  |A \t      |101       |\r\n|104   |Amy \t  |A \t      |101       |\r\n|105   |Anne \t  |A \t      |101       |\r\n|106   |Ron \t  |B \t      |101       |\r\n+------+----------+-----------+----------+\r\n\r\n\r\nGiven the Employee table, write a SQL query that finds out managers with at least 5 direct report. For the above table, your SQL query should return:\r\n\r\n\r\n\r\n+-------+\r\n| Name  |\r\n+-------+\r\n| John  |\r\n+-------+\r\n\r\n\r\nNote:\r\nNo one would report to himself.", "discussUrl": "https://discuss.leetcode.com/category/728", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 3175, "total_submitted": 5547}, {"id": 571, "title": "Find Median Given Frequency of Numbers", "url": "https://leetcode.com/problems/find-median-given-frequency-of-numbers/description", "companyTags": ["Pinterest"], "difficulty": "Hard", "content": "\r\nThe Numbers table keeps the value of number and its frequency.\r\n\r\n\r\n+----------+-------------+\r\n|  Number  |  Frequency  |\r\n+----------+-------------|\r\n|  0       |  7          |\r\n|  1       |  1          |\r\n|  2       |  3          |\r\n|  3       |  1          |\r\n+----------+-------------+\r\n\r\n\r\nIn this table, the numbers are 0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 2, 3, so the median is (0 + 0) / 2 = 0.\r\n\r\n\r\n\r\n+--------+\r\n| median |\r\n+--------|\r\n| 0.0000 |\r\n+--------+\r\n\r\n\r\n\r\nWrite a query to find the median of all numbers and name the result as median.\r\n", "discussUrl": "https://discuss.leetcode.com/category/729", "similarQuestions": ["MedianEmployeeSalary"], "topicTags": [""], "Solution": null, "total_acs": 938, "total_submitted": 2441}, {"id": 572, "title": "Subtree of Another Tree", "url": "https://leetcode.com/problems/subtree-of-another-tree/description", "companyTags": ["Facebook", "eBay"], "difficulty": "Easy", "content": "\r\nGiven two non-empty binary trees s and t, check whether tree t has exactly the same structure and node values with a subtree of s. A subtree of s is a tree consists of a node in s and all of this node's descendants. The tree s could also be considered as a subtree of itself.\r\n\r\n\r\nExample 1:\r\n\r\nGiven tree s:\r\n\r\n     3\r\n    / \\\r\n   4   5\r\n  / \\\r\n 1   2\r\n\r\nGiven tree t:\r\n\r\n   4 \r\n  / \\\r\n 1   2\r\n\r\nReturn true, because t has the same structure and node values with a subtree of s.\r\n\r\n\r\nExample 2:\r\n\r\nGiven tree s:\r\n\r\n     3\r\n    / \\\r\n   4   5\r\n  / \\\r\n 1   2\r\n    /\r\n   0\r\n\r\nGiven tree t:\r\n\r\n   4\r\n  / \\\r\n 1   2\r\n\r\nReturn false.\r\n", "discussUrl": "https://discuss.leetcode.com/category/731", "similarQuestions": ["CountUnivalueSubtrees", "MostFrequentSubtreeSum"], "topicTags": ["Tree"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    private static boolean isSubtree(TreeNode s, TreeNode t, boolean match) {\n        if (s == null && t == null) return true;\n        if (s == null || t == null) return false;\n        if (match && s.val != t.val) return false;\n\n        if (s.val == t.val && isSubtree(s.left, t.left, true) && isSubtree(s.right, t.right, true)) return true;\n\n        return isSubtree(s.left, t, false) || isSubtree(s.right, t, false);\n    }\n    \n    public boolean isSubtree(TreeNode s, TreeNode t) {\n        return isSubtree(s, t, false);\n    }\n}", "total_acs": 38781, "total_submitted": 95752}, {"id": 573, "title": "Squirrel Simulation", "url": "https://leetcode.com/problems/squirrel-simulation/description", "companyTags": ["Square"], "difficulty": "Medium", "content": "There's a tree, a squirrel, and several nuts. Positions are represented by the cells in a 2D grid. Your goal is to find the minimal distance for the squirrel to collect all the nuts and put them under the tree one by one. The squirrel can only take at most one nut at one time and can move in four directions - up, down, left and right, to the adjacent cell. The distance is represented by the number of moves. \r\n\r\nExample 1:\r\n\r\nInput: \r\nHeight : 5\r\nWidth : 7\r\nTree position : [2,2]\r\nSquirrel : [4,4]\r\nNuts : [[3,0], [2,5]]\r\nOutput: 12\r\nExplanation:\r\n\r\n\r\n\r\n\r\nNote:\r\n\r\nAll given positions won't overlap.\r\nThe squirrel can take at most one nut at one time.\r\nThe given positions of nuts have no order.\r\nHeight and width are positive integers. 3 <= height * width <= 10,000.\r\nThe given positions contain at least one nut, only one tree and one squirrel.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/732", "similarQuestions": [""], "topicTags": ["Math"], "Solution": "class Solution {\n    public int minDistance(int height, int width, int[] tree, int[] squirrel, int[][] nuts) {\n        int min=Integer.MAX_VALUE;\n        int total=0;\n        int index=0;\n        for(int i=0;i<nuts.length;i++){\n            int cur=getDis(squirrel,nuts[i]);\n            int t=getDis(tree,nuts[i]);\n            cur-=t;\n            if(cur<min){\n                index=i;\n                min=cur;\n            }\n            total+=t*2;\n        }\n        total=total+min;\n        return total;\n    }\n    \n    private int getDis(int[] a, int[] b){\n        return Math.abs(a[0]-b[0])+Math.abs(a[1]-b[1]);\n    }\n}", "total_acs": 3737, "total_submitted": 7079}, {"id": 574, "title": "Winning Candidate", "url": "https://leetcode.com/problems/winning-candidate/description", "companyTags": [""], "difficulty": "Medium", "content": "Table: Candidate\r\n\r\n+-----+---------+\r\n| id  | Name    |\r\n+-----+---------+\r\n| 1   | A       |\r\n| 2   | B       |\r\n| 3   | C       |\r\n| 4   | D       |\r\n| 5   | E       |\r\n+-----+---------+  \r\n\r\nTable: Vote\r\n\r\n+-----+--------------+\r\n| id  | CandidateId  |\r\n+-----+--------------+\r\n| 1   |     2        |\r\n| 2   |     4        |\r\n| 3   |     3        |\r\n| 4   |     2        |\r\n| 5   |     5        |\r\n+-----+--------------+\r\nid is the auto-increment primary key,\r\nCandidateId is the id appeared in Candidate table.\r\n\r\n\r\nWrite a sql to find the name of the winning candidate, the above example will return the winner B.\r\n\r\n\r\n+------+\r\n| Name |\r\n+------+\r\n| B    |\r\n+------+\r\n\r\n\r\nNotes:\r\n\r\nYou may assume there is no tie, in other words there will be at most one winning candidate.\r\n", "discussUrl": "https://discuss.leetcode.com/category/733", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 2237, "total_submitted": 6751}, {"id": 575, "title": "Distribute Candies", "url": "https://leetcode.com/problems/distribute-candies/description", "companyTags": ["LiveRamp"], "difficulty": "Easy", "content": "Given an integer array with even length, where different numbers in this array represent different kinds of candies. Each number means one candy of the corresponding kind. You need to distribute these candies equally in number to brother and sister. Return the maximum number of kinds of candies the sister could gain. \r\n\r\nExample 1:\r\n\r\nInput: candies = [1,1,2,2,3,3]\r\nOutput: 3\r\nExplanation:\r\nThere are three different kinds of candies (1, 2 and 3), and two candies for each kind.\r\nOptimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too. \r\nThe sister has three different kinds of candies. \r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: candies = [1,1,2,3]\r\nOutput: 2\r\nExplanation: For example, the sister has candies [2,3] and the brother has candies [1,1]. \r\nThe sister has two different kinds of candies, the brother has only one kind of candies. \r\n\r\n\r\n\r\nNote:\r\n\r\nThe length of the given array is in range [2, 10,000], and will be even.\r\nThe number in given array is in range [-100,000, 100,000].\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/734", "similarQuestions": [""], "topicTags": ["HashTable"], "Solution": "class Solution {\n    public int distributeCandies(int[] candies) {\n        boolean[] seen = new boolean[200001];\n        int ct = 0;\n        int half = candies.length/2;\n        for (int i = 0; i < candies.length && ct < half; i++) {\n            int inx = candies[i] + 100000;\n            if (!seen[inx]) {\n                ct++;\n                seen[inx] = true;\n            }\n        }\n        return Math.min(ct, candies.length/2);\n    }\n}", "total_acs": 38989, "total_submitted": 67060}, {"id": 576, "title": "Out of Boundary Paths", "url": "https://leetcode.com/problems/out-of-boundary-paths/description", "companyTags": ["Baidu"], "difficulty": "Medium", "content": "There is an m by n grid with a ball. Given the start coordinate (i,j) of the ball, you can move the ball to adjacent cell or cross the grid boundary in four directions (up, down, left, right). However, you can at most move N times. Find out the number of paths to move the ball out of grid boundary. The answer may be very large, return it after mod 109 + 7.\r\n\r\nExample 1:\r\n\r\nInput:m = 2, n = 2, N = 2, i = 0, j = 0\r\nOutput: 6\r\nExplanation:\r\n\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput:m = 1, n = 3, N = 3, i = 0, j = 1\r\nOutput: 12\r\nExplanation:\r\n\r\n\r\n\r\n\r\nNote:\r\n\r\nOnce you move the ball out of boundary, you cannot move it back.\r\nThe length and height of the grid is in range [1,50].\r\nN is in range [0,50].\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/735", "similarQuestions": ["KnightProbabilityinChessboard"], "topicTags": ["DynamicProgramming", "Depth-firstSearch"], "Solution": "/*\npublic class Solution {\n    public int findPaths(int m, int n, int N, int i, int j) {\n        if (N <= 0) return 0;\n        \n        final int MOD = 1000000007;\n        int[][][] count = new int[N+1][m][n];\n        count[0][i][j] = 1;\n        int result = 0;\n        \n        int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        \n        for (int step = 1; step <= N; step++) {\n            //int[][] temp = new int[m][n];\n            for (int r = 0; r < m; r++) {\n                for (int c = 0; c < n; c++) {\n                    for (int[] d : dirs) {\n                        int nr = r + d[0];\n                        int nc = c + d[1];\n                        if (nr < 0 || nr >= m || nc < 0 || nc >= n) {\n                            result = (result + count[step-1][r][c]) % MOD;\n                        }\n                        else {\n                            count[step][nr][nc] = (count[step][nr][nc] + count[step-1][r][c]) % MOD;\n                        }\n                    }\n                }\n            }\n            //count = temp;\n        }\n        \n        return result;\n    }\n}\n*/\n\n//memoization\nclass Solution {\n    public int findPaths(int m, int n, int N, int i, int j) {\n        int[][][] max=new int[m][n][N+1];\n        return dfs(max,i,j,N)%1000000007;\n        \n    }\n    private final static int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}};\n    private int dfs(int[][][] mat, int x, int y, int step){\n        if(x<0 || y<0 || x>=mat.length || y>=mat[0].length) return 1;\n        if (x-step>=0 && x+step<mat.length && y-step>=0 && y+step<mat[0].length)  return 0;\n        if(step<=0) return 0;\n        if(mat[x][y][step]>0) return mat[x][y][step];\n        int count = 0;\n        for(int[] dir : dirs){\n            int i = x + dir[0];\n            int j = y + dir[1];\n            count += dfs(mat, i, j, step-1)%1000000007;\n            count %= 1000000007;\n        }\n        mat[x][y][step] = count;\n        return count;\n    }\n}", "total_acs": 8650, "total_submitted": 28173}, {"id": 577, "title": "Employee Bonus", "url": "https://leetcode.com/problems/employee-bonus/description", "companyTags": ["Netsuite"], "difficulty": "Easy", "content": "\r\nSelect all employee's name and bonus whose bonus is < 1000.\r\n\r\n\r\nTable:Employee \r\n\r\n\r\n\r\n+-------+--------+-----------+--------+\r\n| empId |  name  | supervisor| salary |\r\n+-------+--------+-----------+--------+\r\n|   1   | John   |  3        | 1000   |\r\n|   2   | Dan    |  3        | 2000   |\r\n|   3   | Brad   |  null     | 4000   |\r\n|   4   | Thomas |  3        | 4000   |\r\n+-------+--------+-----------+--------+\r\nempId is the primary key column for this table.\r\n\r\n\r\n\r\nTable: Bonus\r\n\r\n+-------+-------+\r\n| empId | bonus |\r\n+-------+-------+\r\n| 2     | 500   |\r\n| 4     | 2000  |\r\n+-------+-------+\r\nempId is the primary key column for this table.\r\n\r\n\r\nExample ouput: \r\n\r\n\r\n+-------+-------+\r\n| name  | bonus |\r\n+-------+-------+\r\n| John  | null  |\r\n| Dan   | 500   |\r\n| Brad  | null  |\r\n+-------+-------+\r\n", "discussUrl": "https://discuss.leetcode.com/category/736", "similarQuestions": ["CombineTwoTables"], "topicTags": [""], "Solution": null, "total_acs": 3534, "total_submitted": 6886}, {"id": 578, "title": "Get Highest Answer Rate Question", "url": "https://leetcode.com/problems/get-highest-answer-rate-question/description", "companyTags": ["Facebook"], "difficulty": "Medium", "content": "\r\nGet the highest answer rate question from a table survey_log with these columns:\r\nuid, action, question_id, answer_id, q_num, timestamp.\r\n\r\n\r\n\r\nuid means user id; action has these kind of values: \"show\", \"answer\", \"skip\";\r\nanswer_id is not null when action column is \"answer\", while is null for \"show\" and \"skip\";\r\nq_num is the numeral order of the question in current session.\r\n\r\n\r\nWrite a sql query to identify the question which has the highest answer rate.\r\n\r\nExample:\r\n\r\nInput:\r\n+------+-----------+--------------+------------+-----------+------------+\r\n| uid  | action    | question_id  | answer_id  | q_num     | timestamp  |\r\n+------+-----------+--------------+------------+-----------+------------+\r\n| 5    | show      | 285          | null       | 1         | 123        |\r\n| 5    | answer    | 285          | 124124     | 1         | 124        |\r\n| 5    | show      | 369          | null       | 2         | 125        |\r\n| 5    | skip      | 369          | null       | 2         | 126        |\r\n+------+-----------+--------------+------------+-----------+------------+\r\nOutput:\r\n+-------------+\r\n| survey_log  |\r\n+-------------+\r\n|    285      |\r\n+-------------+\r\nExplanation:\r\nquestion 285 has answer rate 1/1, while question 369 has 0/1 answer rate, so output 285.\r\n\r\n\r\n\r\nNote:\r\nThe highest answer rate meaning is: answer number's ratio in show number in the same question.\r\n", "discussUrl": "https://discuss.leetcode.com/category/738", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 2165, "total_submitted": 7809}, {"id": 579, "title": "Find Cumulative Salary of an Employee", "url": "https://leetcode.com/problems/find-cumulative-salary-of-an-employee/description", "companyTags": ["Amazon"], "difficulty": "Hard", "content": "The Employee table holds the salary information in a year.\r\n\r\nWrite a SQL to get the cumulative sum of an employee's salary over a period of 3 months but exclude the most recent month.\r\n\r\nThe result should be displayed by 'Id' ascending, and then by 'Month' descending. \r\n\r\nExample\r\nInput\r\n\r\n| Id | Month | Salary |\r\n|----|-------|--------|\r\n| 1  | 1     | 20     |\r\n| 2  | 1     | 20     |\r\n| 1  | 2     | 30     |\r\n| 2  | 2     | 30     |\r\n| 3  | 2     | 40     |\r\n| 1  | 3     | 40     |\r\n| 3  | 3     | 60     |\r\n| 1  | 4     | 60     |\r\n| 3  | 4     | 70     |\r\n\r\n\r\nOutput\r\n\r\n\r\n| Id | Month | Salary |\r\n|----|-------|--------|\r\n| 1  | 3     | 90     |\r\n| 1  | 2     | 50     |\r\n| 1  | 1     | 20     |\r\n| 2  | 1     | 20     |\r\n| 3  | 3     | 100    |\r\n| 3  | 2     | 40     |\r\n\r\n\r\n\r\nExplanation\r\nEmployee '1' has 3 salary records for the following 3 months except the most recent month '4': salary 40 for month '3', 30 for month '2' and 20 for month '1'\r\nSo the cumulative sum of salary of this employee over 3 months is 90(40+30+20), 50(30+20) and 20 respectively. \r\n\r\n| Id | Month | Salary |\r\n|----|-------|--------|\r\n| 1  | 3     | 90     |\r\n| 1  | 2     | 50     |\r\n| 1  | 1     | 20     |\r\n\r\n\r\nEmployee '2' only has one salary record (month '1') except its most recent month '2'.\r\n\r\n| Id | Month | Salary |\r\n|----|-------|--------|\r\n| 2  | 1     | 20     |\r\n\r\nEmploy '3' has two salary records except its most recent pay month '4': month '3' with 60 and month '2' with 40. So the cumulative salary is as following.\r\n\r\n| Id | Month | Salary |\r\n|----|-------|--------|\r\n| 3  | 3     | 100    |\r\n| 3  | 2     | 40     |\r\n", "discussUrl": "https://discuss.leetcode.com/category/739", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 887, "total_submitted": 3246}, {"id": 580, "title": "Count Student Number in Departments", "url": "https://leetcode.com/problems/count-student-number-in-departments/description", "companyTags": ["Twitter"], "difficulty": "Medium", "content": "A university uses 2 data tables, student and department, to store data about its students and the departments associated with each major. \r\n\r\nWrite a query to print the respective department name and number of students majoring in each department for all departments in the department table (even ones with no current students).\r\n\r\nSort your results by descending number of students; if two or more departments have the same number of students, then sort those departments alphabetically by department name.\r\n\r\nThe student is described as follow:\r\n\r\n\r\n| Column Name  | Type      |\r\n|--------------|-----------|\r\n| student_id   | Integer   |\r\n| student_name | String    |\r\n| gender       | Character |\r\n| dept_id      | Integer   |\r\n\r\n\r\nwhere student_id is the student's ID number, student_name is the student's name, gender is their gender, and dept_id is the department ID associated with their declared major.\r\n\r\nAnd the department table is described as below:\r\n\r\n| Column Name | Type    |\r\n|-------------|---------|\r\n| dept_id     | Integer |\r\n| dept_name   | String  |\r\n\r\n\r\nwhere dept_id is the department's ID number and dept_name is the department name.\r\n\r\nHere is an example input:\r\n\r\nstudent table:\r\n\r\n\r\n| student_id | student_name | gender | dept_id |\r\n|------------|--------------|--------|---------|\r\n| 1          | Jack         | M      | 1       |\r\n| 2          | Jane         | F      | 1       |\r\n| 3          | Mark         | M      | 2       |\r\n\r\n\r\ndepartment table:\r\n\r\n| dept_id | dept_name   |\r\n|---------|-------------|\r\n| 1       | Engineering |\r\n| 2       | Science     |\r\n| 3       | Law         |\r\n\r\n\r\nThe Output should be:\r\n\r\n| dept_name   | student_number |\r\n|-------------|----------------|\r\n| Engineering | 2              |\r\n| Science     | 1              |\r\n| Law         | 0              |\r\n", "discussUrl": "https://discuss.leetcode.com/category/740", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 3035, "total_submitted": 7797}, {"id": 581, "title": "Shortest Unsorted Continuous Subarray", "url": "https://leetcode.com/problems/shortest-unsorted-continuous-subarray/description", "companyTags": ["Google", "LiveRamp"], "difficulty": "Easy", "content": "Given an integer array, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order, too.  \r\n\r\nYou need to find the shortest such subarray and output its length.\r\n\r\nExample 1:\r\n\r\nInput: [2, 6, 4, 8, 10, 9, 15]\r\nOutput: 5\r\nExplanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.\r\n\r\n\r\n\r\nNote:\r\n\r\nThen length of the input array is in range [1, 10,000].\r\nThe input array may contain duplicates, so ascending order here means <=. \r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/741", "similarQuestions": [""], "topicTags": ["Array"], "Solution": "class Solution {\n    public int findUnsortedSubarray(int[] nums) {\n        int low = 0, high = nums.length-1, max = Integer.MIN_VALUE, min = Integer.MAX_VALUE;\n        while(low<high&&nums[low+1]>=nums[low]) low++;\n        while(high>low&&nums[high-1]<=nums[high]) high--;\n        \n        if(low>=high) return 0;\n        \n        for(int i= low;i<=high;i++){\n            max =Math.max(max, nums[i]);\n            min = Math.min(min, nums[i]);\n        }\n        \n        while(low>=0&&nums[low]>min) low--;\n        while(high<=nums.length-1&&nums[high]<max) high++;\n        \n        return high- low -1;\n    }\n}", "total_acs": 28569, "total_submitted": 97932}, {"id": 582, "title": "Kill Process", "url": "https://leetcode.com/problems/kill-process/description", "companyTags": ["Bloomberg"], "difficulty": "Medium", "content": "Given n processes, each process has a unique PID (process id) and its PPID (parent process id). \r\n\r\nEach process only has one parent process, but may have one or more children processes. This is just like a tree structure.  Only one process has PPID that is 0, which means this process has no parent process. All the PIDs will be distinct positive integers.\r\n\r\nWe use two list of integers to represent a list of processes, where the first list contains PID for each process and the second list contains the corresponding PPID. \r\n \r\nNow given the two lists, and a PID representing a process you want to kill, return a list of PIDs of processes that will be killed in the end. You should assume that when a process is killed, all its children processes will be killed. No order is required for the final answer.\r\n\r\nExample 1:\r\n\r\nInput: \r\npid =  [1, 3, 10, 5]\r\nppid = [3, 0, 5, 3]\r\nkill = 5\r\nOutput: [5,10]\r\nExplanation: \r\n           3\r\n         /   \\\r\n        1     5\r\n             /\r\n            10\r\nKill 5 will also kill 10.\r\n\r\n\r\n\r\nNote:\r\n\r\nThe given kill id is guaranteed to be one of the given PIDs.\r\nn >= 1.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/742", "similarQuestions": [""], "topicTags": ["Tree", "Queue"], "Solution": "class Solution {\n    public List<Integer> killProcess(List<Integer> pid, List<Integer> ppid, int kill) {\n        if (ppid.get(pid.indexOf(kill)) == 0) return pid;\n        HashMap<Integer, ArrayList<Integer>> map = new HashMap<Integer, ArrayList<Integer>>();\n        \n        for (int i=0; i<ppid.size(); i++) {\n            if (map.containsKey(ppid.get(i))) {\n                map.get(ppid.get(i)).add(pid.get(i));\n            } else {\n                // no ppid key, then create new pidList, add new (key, values) \n                // to the map\n                ArrayList<Integer> pidList = new ArrayList<Integer>();\n                pidList.add(pid.get(i));\n                map.put(ppid.get(i), pidList);\n            }\n        }\n        \n        Stack<Integer> pidStack = new Stack<Integer>();\n        List<Integer> killedPid = new ArrayList<Integer>();\n        pidStack.push(kill);\n        killedPid.add(kill);\n        \n        while (!pidStack.isEmpty()) {\n            int nextPid = pidStack.pop();\n            if (map.containsKey(nextPid)) {\n                ArrayList<Integer> list = map.get(nextPid);\n                killedPid.addAll(list);\n                pidStack.addAll(list);\n            }\n        }\n        return killedPid;\n    }\n}", "total_acs": 10926, "total_submitted": 21644}, {"id": 583, "title": "Delete Operation for Two Strings", "url": "https://leetcode.com/problems/delete-operation-for-two-strings/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "\r\nGiven two words word1 and word2, find the minimum number of steps required to make word1 and word2 the same, where in each step you can delete one character in either string.\r\n\r\n\r\nExample 1:\r\n\r\nInput: \"sea\", \"eat\"\r\nOutput: 2\r\nExplanation: You need one step to make \"sea\" to \"ea\" and another step to make \"eat\" to \"ea\".\r\n\r\n\r\n\r\nNote:\r\n\r\nThe length of given words won't exceed 500.\r\nCharacters in given words can only be lower-case letters.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/743", "similarQuestions": ["EditDistance", "MinimumASCIIDeleteSumforTwoStrings"], "topicTags": ["String"], "Solution": "class Solution {\n     public static int minDistance(String s, String t) {\n\t\tint m = s.length();\n\t\tint n = t.length();\n\t\tif (m == 0)\n\t\t\treturn n;\n\t\tif (n == 0)\n\t\t\treturn m;\n\t\tint[][] c = new int[1][n + 1];\n\n\t\tint temp1 = 0;\n\t\tint temp2 = 0;\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\ttemp1 = 0;\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\ttemp2 = c[0][j];\n\t\t\t\tif (s.charAt(i - 1) == t.charAt(j - 1)) {\n\t\t\t\t\tc[0][j] = temp1 + 1;\n\t\t\t\t} else if (c[0][j-1] > c[0][j]) {\n\t\t\t\t\tc[0][j] = c[0][j-1];\n\t\t\t\t} else {\n\t\t\t\t\tc[0][j] = c[0][j];\n\t\t\t\t}\n\t\t\t\ttemp1 = temp2;\n\t\t\t}\n\t\t}\n\t\treturn m+n-2*c[0][n];\n    }\n}", "total_acs": 14616, "total_submitted": 32861}, {"id": 584, "title": "Find Customer Referee", "url": "https://leetcode.com/problems/find-customer-referee/description", "companyTags": [""], "difficulty": "Easy", "content": "Given a table customer holding customers information and the referee.\r\n\r\n\r\n+------+------+-----------+\r\n| id   | name | referee_id|\r\n+------+------+-----------+\r\n|    1 | Will |      NULL |\r\n|    2 | Jane |      NULL |\r\n|    3 | Alex |         2 |\r\n|    4 | Bill |      NULL |\r\n|    5 | Zack |         1 |\r\n|    6 | Mark |         2 |\r\n+------+------+-----------+\r\n\r\n\r\nWrite a query to return the list of customers NOT referred by the person with id '2'.\r\n\r\nFor the sample data above, the result is:\r\n\r\n+------+\r\n| name |\r\n+------+\r\n| Will |\r\n| Jane |\r\n| Bill |\r\n| Zack |\r\n+------+\r\n", "discussUrl": "https://discuss.leetcode.com/category/744", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 3436, "total_submitted": 5571}, {"id": 585, "title": "Investments in 2016", "url": "https://leetcode.com/problems/investments-in-2016/description", "companyTags": ["Twitter"], "difficulty": "Medium", "content": "Write a query to print the sum of all total investment values in 2016 (TIV_2016), to a scale of 2 decimal places, for all policy holders who meet the following criteria:\r\n\r\n\r\nHave the same TIV_2015 value as one or more other policyholders.\r\nAre not located in the same city as any other policyholder (i.e.: the (latitude, longitude) attribute pairs must be unique).\r\n\r\n\r\nInput Format:\r\nThe insurance table is described as follows:\r\n\r\n\r\n| Column Name | Type          |\r\n|-------------|---------------|\r\n| PID         | INTEGER(11)   |\r\n| TIV_2015    | NUMERIC(15,2) |\r\n| TIV_2016    | NUMERIC(15,2) |\r\n| LAT         | NUMERIC(5,2)  |\r\n| LON         | NUMERIC(5,2)  |\r\n\r\n\r\nwhere PID is the policyholder's policy ID, TIV_2015 is the total investment value in 2015, TIV_2016 is the total investment value in 2016, LAT is the latitude of the policy holder's city, and LON is the longitude of the policy holder's city.\r\n\r\nSample Input\r\n\r\n\r\n| PID | TIV_2015 | TIV_2016 | LAT | LON |\r\n|-----|----------|----------|-----|-----|\r\n| 1   | 10       | 5        | 10  | 10  |\r\n| 2   | 20       | 20       | 20  | 20  |\r\n| 3   | 10       | 30       | 20  | 20  |\r\n| 4   | 10       | 40       | 40  | 40  |\r\n\r\n\r\nSample Output\r\n\r\n| TIV_2016 |\r\n|----------|\r\n| 45.00    |\r\n\r\n\r\nExplanation\r\n\r\n\r\nThe first record in the table, like the last record, meets both of the two criteria.\r\nThe TIV_2015 value '10' is as the same as the third and forth record, and its location unique.\r\n\r\nThe second record does not meet any of the two criteria. Its TIV_2015 is not like any other policyholders.\r\n\r\nAnd its location is the same with the third record, which makes the third record fail, too.\r\n\r\nSo, the result is the sum of TIV_2016 of the first and last record, which is 45.", "discussUrl": "https://discuss.leetcode.com/category/745", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 2498, "total_submitted": 5488}, {"id": 586, "title": "Customer Placing the Largest Number of Orders", "url": "https://leetcode.com/problems/customer-placing-the-largest-number-of-orders/description", "companyTags": ["Twitter"], "difficulty": "Easy", "content": "Query the customer_number from the orders table for the customer who has placed the largest number of orders.\r\n\r\nIt is guaranteed that exactly one customer will have placed more orders than any other customer.\r\n\r\nThe orders table is defined as follows:\r\n\r\n\r\n| Column            | Type      |\r\n|-------------------|-----------|\r\n| order_number (PK) | int       |\r\n| customer_number   | int       |\r\n| order_date        | date      |\r\n| required_date     | date      |\r\n| shipped_date      | date      |\r\n| status            | char(15)  |\r\n| comment           | char(200) |\r\n\r\n\r\nSample Input\r\n\r\n| order_number | customer_number | order_date | required_date | shipped_date | status | comment |\r\n|--------------|-----------------|------------|---------------|--------------|--------|---------|\r\n| 1            | 1               | 2017-04-09 | 2017-04-13    | 2017-04-12   | Closed |         |\r\n| 2            | 2               | 2017-04-15 | 2017-04-20    | 2017-04-18   | Closed |         |\r\n| 3            | 3               | 2017-04-16 | 2017-04-25    | 2017-04-20   | Closed |         |\r\n| 4            | 3               | 2017-04-18 | 2017-04-28    | 2017-04-25   | Closed |         |\r\n\r\n\r\nSample Output\r\n\r\n| customer_number |\r\n|-----------------|\r\n| 3               |\r\n\r\n\r\nExplanation\r\n\r\nThe customer with number '3' has two orders, which is greater than either customer '1' or '2' because each of them  only has one order. So the result is customer_number '3'.\r\n\r\n\r\nFollow up: What if more than one customer have the largest number of orders, can you find all the customer_number in this case?", "discussUrl": "https://discuss.leetcode.com/category/746", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 3913, "total_submitted": 6631}, {"id": 587, "title": "Erect the Fence", "url": "https://leetcode.com/problems/erect-the-fence/description", "companyTags": ["Google"], "difficulty": "Hard", "content": "There are some trees, where each tree is represented by (x,y) coordinate in a two-dimensional garden. Your job is to fence the entire garden using the minimum length of rope as it is expensive. The garden is well fenced only if all the trees are enclosed. Your task is to help find the coordinates of trees which are exactly located on the fence perimeter.\r\n\r\nExample 1:\r\n\r\nInput: [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]\r\nOutput: [[1,1],[2,0],[4,2],[3,3],[2,4]]\r\nExplanation:\r\n\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: [[1,2],[2,2],[4,2]]\r\nOutput: [[1,2],[2,2],[4,2]]\r\nExplanation:\r\n\r\nEven you only have trees in a line, you need to use rope to enclose them. \r\n\r\n\r\n\r\n Note: \r\n\r\nAll trees should be enclosed together. You cannot cut the rope to enclose trees that will separate them in more than one group.\r\nAll input integers will range from 0 to 100. \r\nThe garden has at least one tree. \r\nAll coordinates are distinct. \r\nInput points have NO order. No order required for output.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/747", "similarQuestions": [""], "topicTags": ["Geometry"], "Solution": "/**\n * Definition for a point.\n * class Point {\n *     int x;\n *     int y;\n *     Point() { x = 0; y = 0; }\n *     Point(int a, int b) { x = a; y = b; }\n * }\n */\nclass Solution {\n    public List<Point> outerTrees(Point[] points) {\n        List<Point> resList = new ArrayList<>();\n        if (points == null || points.length == 0) {\n            return resList;\n        }\n        \n        Point start = points[0];\n        \n        for (int i = 1; i < points.length; i++) {\n            if (points[i].x < start.x) {\n                start = points[i];\n            }\n        }\n        \n        Set<Point> set = new HashSet<>();\n        set.add(start);\n        List<Point> collinear = new ArrayList<>();\n        Point cur = start;\n        while (true) {\n            Point next = find(points, cur, collinear);\n\n            set.add(next);\n            for (Point p : collinear) {\n                set.add(p);\n            }\n            cur = next;\n            if (next == start) {\n                break;\n            }\n        }\n        \n        for (Point p : set) {\n            resList.add(p);\n        }\n        \n        return resList;\n        \n    }\n    \n    private Point find(Point[] points, Point cur, List<Point> collinear) {\n        int idx = 0;\n        Point p = points[idx++];\n        collinear.clear();\n        while (p == cur && idx < points.length) {\n            p = points[idx++];\n        }\n        \n        for (int i = idx; i < points.length; i++) {\n            if (points[i] == cur) continue;\n            int x1 = p.x - cur.x;\n            int y1 = p.y - cur.y;\n            int x2 = points[i].x - cur.x;\n            int y2 = points[i].y - cur.y;\n            int res = x1 * y2 - y1 * x2;\n            if (res > 0) {\n                p = points[i];\n                collinear.clear();\n            } else if (res == 0) {\n                if (y2 * y2 + x2 * x2 > (x1 * x1 + y1 * y1)) {\n                    collinear.add(p);\n                    p = points[i];\n                } else {\n                    collinear.add(points[i]);\n                }\n            }\n        }\n        return p;\n    }\n}", "total_acs": 3932, "total_submitted": 11818}, {"id": 588, "title": "Design In-Memory File System", "url": "https://leetcode.com/problems/design-in-memory-file-system/description", "companyTags": ["Baidu"], "difficulty": "Hard", "content": "Design an in-memory file system to simulate the following functions:\r\n\r\nls: Given a path in string format. If it is a file path, return a list that only contains this file's name. If it is a directory path, return the list of file and directory names in this directory. Your output (file and directory names together) should in lexicographic order.\r\n\r\nmkdir: Given a directory path that does not exist, you should make a new directory according to the path. If the middle directories in the path don't exist either, you should create them as well. This function has void return type. \r\n\r\naddContentToFile: Given a file path and file content in string format. If the file doesn't exist, you need to create that file containing given content. If the file already exists, you need to append given content to original content. This function has void return type.\r\n\r\nreadContentFromFile: Given a file path, return its content in string format.\r\n\r\nExample:\r\n\r\nInput: \r\n[\"FileSystem\",\"ls\",\"mkdir\",\"addContentToFile\",\"ls\",\"readContentFromFile\"]\r\n[[],[\"/\"],[\"/a/b/c\"],[\"/a/b/c/d\",\"hello\"],[\"/\"],[\"/a/b/c/d\"]]\r\nOutput:\r\n[null,[],null,null,[\"a\"],\"hello\"]\r\nExplanation:\r\n\r\n\r\n\r\n\r\nNote:\r\n\r\nYou can assume all file or directory paths are absolute paths which begin with / and do not end with / except that the path is just \"/\".\r\nYou can assume that all operations will be passed valid parameters and users will not attempt to retrieve file content or list a directory or file that does not exist.\r\nYou can assume that all directory names and file names only contain lower-case letters, and same names won't exist in the same directory.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/749", "similarQuestions": ["LRUCache", "LFUCache", "DesignLogStorageSystem"], "topicTags": ["Design"], "Solution": "public class FileSystem {\n    \n    class Node {\n        int type = 0; // 1 - dir ; 2 - file\n        StringBuilder content;\n        Node [] children = new Node[27];\n    }\n    \n    Node root;\n\n    public FileSystem() {\n        root = new Node();\n        root.type = 1;\n        root.children[26] = new Node();\n    }\n    \n    Node traverse(String s, int type) {\n        Node node = root;\n        for (int i = 0; i < s.length(); i++) {\n            int next = s.charAt(i) == '/' ? 26 : s.charAt(i) - 'a';\n            if (node.children[next] == null) {\n                node.children[next] = new Node();\n            }\n            node = node.children[next];\n            if (i + 1 < s.length() && s.charAt(i + 1) == '/') {\n                node.type = 1;\n            }\n        }\n        if (node.type == 0) {\n            node.type = type;\n        }\n        return node;\n    }\n   \n    void dfs(List<String> list, Node root, StringBuilder sb) {\n        if (root.type > 0) {\n            list.add(sb.toString());\n        }\n        for (int i = 0; i < 26; i++) {\n            if (root.children[i] != null) {\n                sb.append((char)('a' + i));\n                dfs(list, root.children[i], sb);\n                sb.deleteCharAt(sb.length() - 1);\n            }\n        }\n    }\n    \n    public List<String> ls(String path) {\n        List<String> list = new ArrayList<>();\n        if (\"/\".equals(path)) {\n            dfs(list, root.children[26], new StringBuilder());\n            return list;\n        }\n        \n        Node node = traverse(path, 1);\n\n        if (node.type == 2) {\n            int k = path.length() - 1;\n            while (k >= 0 && path.charAt(k) != '/') {\n                k--;\n            }\n            list.add(path.substring(k + 1));\n        } else {\n            if (node.children[26] == null) {\n                return list;\n            }\n            dfs(list, node.children[26], new StringBuilder());\n        }\n        return list;\n    }\n    \n    public void mkdir(String path) {\n        traverse(path, 1);\n    }\n    \n    public void addContentToFile(String filePath, String content) {\n        Node node = traverse(filePath, 2);\n        if (node.content == null) {\n            node.content = new StringBuilder();\n        }\n        node.content.append(content);\n    }\n    \n    public String readContentFromFile(String filePath) {\n        Node node = traverse(filePath, 2);\n        if (node.content == null) {\n            return \"\";\n        }\n        return node.content.toString();\n    }\n}\n/*\npublic class FileSystem {\n    class File {\n        boolean isFile = false;\n        Map<String, File> children = new HashMap<>();\n        String content = \"\";\n    }\n    \n    File root = null;\n    \n    public FileSystem() {\n        root = new File();\n    }\n    \n    public List<String> ls(String path) {\n        String[] dirs = path.split(\"/\");\n        File node = root;\n        List<String> result = new ArrayList<>();\n        String name = \"\";\n        for (String dir : dirs) {\n            if (dir.length() == 0) continue;\n            if (!node.children.containsKey(dir)) {\n                return result;\n            }\n            node = node.children.get(dir);\n            name = dir;\n        }\n        \n        if (node.isFile) {\n            result.add(name);\n        }\n        else {\n            for (String key : node.children.keySet()) {\n                result.add(key);\n            }\n        }\n        \n        Collections.sort(result);\n        \n        return result;\n    }\n    \n    public void mkdir(String path) {\n        String[] dirs = path.split(\"/\");\n        File node = root;\n        for (String dir : dirs) {\n            if (dir.length() == 0) continue;\n            if (!node.children.containsKey(dir)) {\n                File file = new File();\n                node.children.put(dir, file);\n            }\n            node = node.children.get(dir);\n        }\n    }\n    \n    public void addContentToFile(String filePath, String content) {\n        String[] dirs = filePath.split(\"/\");\n        File node = root;\n        for (String dir : dirs) {\n            if (dir.length() == 0) continue;\n            if (!node.children.containsKey(dir)) {\n                File file = new File();\n                node.children.put(dir, file);\n            }\n            node = node.children.get(dir);\n        }\n        node.isFile = true;\n        node.content += content;\n    }\n    \n    public String readContentFromFile(String filePath) {\n        String[] dirs = filePath.split(\"/\");\n        File node = root;\n        for (String dir : dirs) {\n            if (dir.length() == 0) continue;\n            if (!node.children.containsKey(dir)) {\n                File file = new File();\n                node.children.put(dir, file);\n            }\n            node = node.children.get(dir);\n        }\n\n        return node.content;\n    }\n}\n*/", "total_acs": 2405, "total_submitted": 6583}, {"id": 591, "title": "Tag Validator", "url": "https://leetcode.com/problems/tag-validator/description", "companyTags": ["Microsoft"], "difficulty": "Hard", "content": "Given a string representing a code snippet, you need to implement a tag validator to parse the code and return whether it is valid. A code snippet is valid if all the following rules hold:\r\n\r\nThe code must be wrapped in a valid closed tag. Otherwise, the code is invalid.\r\nA closed tag (not necessarily valid) has exactly the following format : <TAG_NAME>TAG_CONTENT</TAG_NAME>. Among them, <TAG_NAME> is the start tag, and </TAG_NAME> is the end tag. The TAG_NAME in start and end tags should be the same. A closed tag is valid if and only if the TAG_NAME and TAG_CONTENT are valid.\r\nA valid TAG_NAME only contain upper-case letters, and has length in range [1,9]. Otherwise, the TAG_NAME is invalid.\r\nA valid TAG_CONTENT may contain other valid closed tags, cdata and any characters (see note1) EXCEPT unmatched <, unmatched start and end tag, and unmatched or closed tags with invalid TAG_NAME. Otherwise, the TAG_CONTENT is invalid.\r\nA start tag is unmatched if no end tag exists with the same TAG_NAME, and vice versa. However, you also need to consider the issue of unbalanced when tags are nested.\r\nA < is unmatched if you cannot find a subsequent >. And when you find a < or </, all the subsequent characters until the next > should be parsed as TAG_NAME  (not necessarily valid).\r\nThe cdata has the following format : <![CDATA[CDATA_CONTENT]]>. The range of CDATA_CONTENT is defined as the characters between <![CDATA[ and the first subsequent ]]>. \r\nCDATA_CONTENT may contain any characters. The function of cdata is to forbid the validator to parse CDATA_CONTENT, so even it has some characters that can be parsed as tag (no matter valid or invalid), you should treat it as regular characters. \r\n\r\n\r\nValid Code Examples:\r\n\r\nInput: \"<DIV>This is the first line <![CDATA[<div>]]></DIV>\"\r\nOutput: True\r\nExplanation: \r\nThe code is wrapped in a closed tag : <DIV> and </DIV>. \r\nThe TAG_NAME is valid, the TAG_CONTENT consists of some characters and cdata. \r\nAlthough CDATA_CONTENT has unmatched start tag with invalid TAG_NAME, it should be considered as plain text, not parsed as tag.\r\nSo TAG_CONTENT is valid, and then the code is valid. Thus return true.\r\n\r\nInput: \"<DIV>>>  ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>\"\r\nOutput: True\r\nExplanation:\r\nWe first separate the code into : start_tag|tag_content|end_tag.\r\nstart_tag -> \"<DIV>\"\r\nend_tag -> \"</DIV>\"\r\ntag_content could also be separated into : text1|cdata|text2.\r\ntext1 -> \">>  ![cdata[]] \"\r\ncdata -> \"<![CDATA[<div>]>]]>\", where the CDATA_CONTENT is \"<div>]>\"\r\ntext2 -> \"]]>>]\"\r\n\r\nThe reason why start_tag is NOT \"<DIV>>>\" is because of the rule 6.\r\nThe reason why cdata is NOT \"<![CDATA[<div>]>]]>]]>\" is because of the rule 7.\r\n\r\n\r\n\r\nInvalid Code Examples:\r\n\r\nInput: \"<A>  <B> </A>   </B>\"\r\nOutput: False\r\nExplanation: Unbalanced. If \"<A>\" is closed, then \"<B>\" must be unmatched, and vice versa.\r\n\r\nInput: \"<DIV>  div tag is not closed  <DIV>\"\r\nOutput: False\r\n\r\nInput: \"<DIV>  unmatched <  </DIV>\"\r\nOutput: False\r\n\r\nInput: \"<DIV> closed tags with invalid tag name  <b>123</b> </DIV>\"\r\nOutput: False\r\n\r\nInput: \"<DIV> unmatched tags with invalid tag name  </1234567890> and <CDATA[[]]>  </DIV>\"\r\nOutput: False\r\n\r\nInput: \"<DIV>  unmatched start tag <B>  and unmatched end tag </C>  </DIV>\"\r\nOutput: False\r\n\r\n\r\n\r\nNote:\r\n\r\nFor simplicity, you could assume the input code (including the any characters mentioned above) only contain letters, digits, '<','>','/','!','[',']' and ' '.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/752", "similarQuestions": ["AddBoldTaginString"], "topicTags": ["String", "Stack"], "Solution": "class Solution {\n    public boolean isValid(String code) {\n        Stack<String> stack = new Stack();\n        for(int i=0;i<code.length();i++){\n            char ch = code.charAt(i);\n            if(i>0 && stack.size()==0){\n                return false;\n            }\n            if(code.startsWith(\"</\", i)){\n                int j = code.indexOf(\">\", i);\n                if(j<0 ||i ==j ) return false;\n                String tagName = code.substring(i+2, j);\n                if( stack.size()==0 || !stack.peek().equals(tagName)){\n                    return false;\n                }\n                stack.pop();\n                i = j;\n            }else if(code.startsWith(\"<![CDATA[\", i)){\n                if(stack.size()==0){\n                    return false;\n                }\n                int j = code.indexOf(\"]]>\",i);\n                if(j<0 ||i ==j ) return false;\n                i = j+2;\n            }else if(code.startsWith(\"<\",i)){\n                int j = code.indexOf(\">\",i);\n                if(j<0 ||i ==j ) return false;\n                String tagName = code.substring(i+1, j);\n                if( !validName(tagName) ){\n                    return false;\n                }\n                stack.add(tagName);\n                i = j;\n            }\n        }\n        return stack.size()==0;\n    }\n    \n    public boolean validName(String s){\n        if(s==null || s.length()==0 || s.length()>9){\n            return false;\n        }\n        \n        for(char each: s.toCharArray()){\n            if(each<'A' || each>'Z'){\n                return false;\n            }\n        }\n        return true;\n    }\n    \n}", "total_acs": 2688, "total_submitted": 8736}, {"id": 592, "title": "Fraction Addition and Subtraction", "url": "https://leetcode.com/problems/fraction-addition-and-subtraction/description", "companyTags": ["IXL"], "difficulty": "Medium", "content": "Given a string representing an expression of fraction addition and subtraction, you need to return the calculation result in string format. The final result should be irreducible fraction. If your final result is an integer, say 2, you need to change it to the format of fraction that has denominator 1. So in this case, 2 should be converted to 2/1.\r\n\r\nExample 1:\r\n\r\nInput:\"-1/2+1/2\"\r\nOutput: \"0/1\"\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput:\"-1/2+1/2+1/3\"\r\nOutput: \"1/3\"\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput:\"1/3-1/2\"\r\nOutput: \"-1/6\"\r\n\r\n\r\n\r\nExample 4:\r\n\r\nInput:\"5/3+1/3\"\r\nOutput: \"2/1\"\r\n\r\n\r\n\r\nNote:\r\n\r\nThe input string only contains '0' to '9', '/', '+' and '-'. So does the output.\r\nEach fraction (input and output) has format \u00b1numerator/denominator. If the first input fraction or the output is positive, then '+' will be omitted.\r\nThe input only contains valid irreducible fractions, where the numerator and denominator of each fraction will always be in the range [1,10]. If the denominator is 1, it means this fraction is actually an integer in a fraction format defined above. \r\nThe number of given fractions will be in the range [1,10].\r\nThe numerator and denominator of the final result are guaranteed to be valid and in the range of 32-bit int.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/753", "similarQuestions": ["SolvetheEquation"], "topicTags": ["Math"], "Solution": "class Solution {\n    public String fractionAddition(String expression) {\n        \n        int [] factor = {2, 3, 5, 7};\n        \n        int num=0, denom=1;\n        \n        int sign=1, nNum=0, nDenom=0, v=0;\n        boolean isDenom =false;\n        int pointer= 0;\n        char c;\n        while(pointer< expression.length()){\n            c=expression.charAt(pointer);\n            \n            \n            if(c == '-'){\n                sign =-1;\n            }else if(c=='+'){\n                sign =1;\n               \n            }else if(c=='/'){\n                isDenom =true;\n            }else {\n                \n                if(c=='0'){\n                    v=0;\n                }else {\n                    v= c-'1'+1;\n                }\n                if(isDenom){\n                    nDenom*=10;\n                    nDenom+=v;\n            \n                }else{\n                    nNum*=10;\n                    nNum+=v;\n            \n                }\n                \n                if(pointer== expression.length()-1 ||expression.charAt(pointer+1)=='+' || expression.charAt(pointer+1)=='-'){\n                    num= num*nDenom + nNum* denom * sign;\n                    denom = denom * nDenom;\n                    \n                    for (int i =0 ;i< factor.length;i++){\n                        int fac = factor[i];\n                        while(denom%fac==0 && num%fac==0){\n                            denom/=fac;\n                            num/=fac;\n                        }      \n                    }\n                    \n                    isDenom =false;\n                    nNum = 0;\n                    nDenom = 0;\n                \n                }\n                \n                \n            }\n            \n            pointer++;\n        }\n        \n        return num+\"/\"+denom;\n        \n    }\n}", "total_acs": 7353, "total_submitted": 15924}, {"id": 593, "title": "Valid Square", "url": "https://leetcode.com/problems/valid-square/description", "companyTags": ["PureStorage"], "difficulty": "Medium", "content": "Given the coordinates of four points in 2D space, return whether the four points could construct a square.\r\n\r\nThe coordinate (x,y) of a point is represented by an integer array with two integers.\r\n\r\nExample:\r\n\r\nInput: p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]\r\nOutput: True\r\n\r\n\r\n\r\n Note: \r\n\r\nAll the input integers are in the range [-10000, 10000].\r\nA valid square has four equal sides with positive length and four equal angles (90-degree angles).\r\nInput points have no order.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/754", "similarQuestions": [""], "topicTags": ["Math"], "Solution": "class Solution {\n    public boolean validSquare(int[] p1, int[] p2, int[] p3, int[] p4) {\n        if(equals(p1,p2) || equals(p1,p3) || equals(p1,p4) || equals(p2,p3)\n          || equals(p2,p4) || equals(p3,p4)) return false;\n        if(distance(p1,p2) != distance(p1,p3) && distance(p1,p2) != distance(p1, p4) && distance(p1,p3) != distance(p1, p4))\n            return false;\n        else{\n            if((distance(p1,p2) == 2* distance(p1,p3) && distance(p1,p2) == 2 * distance(p2,p4))\n               || (distance(p1,p4) == 2*distance(p1,p2) && distance(p1,p4)  == 2*distance(p4,p3))\n               || (distance(p1,p3) == 2*distance(p1,p4)) && distance(p1,p3) == 2 * distance(p3,p2))\n                return true;\n            else\n                return false;\n        }\n    }\n    \n    public int distance(int[] p1, int[] p2){\n        return (p1[0] - p2[0])*(p1[0] - p2[0]) + (p1[1] - p2[1])*(p1[1] - p2[1]);\n    }\n    public boolean equals(int[] p1, int[] p2){\n        if(p1[0] == p2[0] && p1[1] == p2[1])\n            return true;\n        else\n            return false;\n    }\n}", "total_acs": 9926, "total_submitted": 24842}, {"id": 594, "title": "Longest Harmonious Subsequence", "url": "https://leetcode.com/problems/longest-harmonious-subsequence/description", "companyTags": ["LiveRamp"], "difficulty": "Easy", "content": "We define a harmonious array is an array where the difference between its maximum value and its minimum value is exactly 1.\r\n\r\nNow, given an integer array, you need to find the length of its longest harmonious subsequence among all its possible subsequences.\r\n\r\nExample 1:\r\n\r\nInput: [1,3,2,2,5,2,3,7]\r\nOutput: 5\r\nExplanation: The longest harmonious subsequence is [3,2,2,2,3].\r\n\r\n\r\n\r\nNote:\r\nThe length of the input array will not exceed 20,000.\r\n\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/755", "similarQuestions": [""], "topicTags": ["HashTable"], "Solution": "class Solution {\n    public int findLHS(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        Arrays.sort(nums);\n        int current = nums[0];\n        int count = 1;\n        int previous = 0;\n        int result = 0;\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] == current) {\n                count++;\n            }\n            else {\n                if (previous > 0) {\n                    result = Math.max(result, previous + count);\n                }\n                if (nums[i] == current + 1) {\n                    previous = count;\n                }\n                else {\n                    previous = 0;\n                }\n                current = nums[i];\n                count = 1;\n            }\n        }\n        return previous > 0 ? Math.max(result, previous + count) : result;\n    }\n}", "total_acs": 18345, "total_submitted": 44547}, {"id": 595, "title": "Big Countries", "url": "https://leetcode.com/problems/big-countries/description", "companyTags": [""], "difficulty": "Easy", "content": "There is a table World \r\n\r\n+-----------------+------------+------------+--------------+---------------+\r\n| name            | continent  | area       | population   | gdp           |\r\n+-----------------+------------+------------+--------------+---------------+\r\n| Afghanistan     | Asia       | 652230     | 25500100     | 20343000      |\r\n| Albania         | Europe     | 28748      | 2831741      | 12960000      |\r\n| Algeria         | Africa     | 2381741    | 37100000     | 188681000     |\r\n| Andorra         | Europe     | 468        | 78115        | 3712000       |\r\n| Angola          | Africa     | 1246700    | 20609294     | 100990000     |\r\n+-----------------+------------+------------+--------------+---------------+\r\n\r\n\r\nA country is big if it has an area of bigger than 3 million square km or a population of more than 25 million.\r\n\r\nWrite a SQL solution to output big countries' name, population and area.\r\n\r\n\r\nFor example, according to the above table, we should output:\r\n\r\n+--------------+-------------+--------------+\r\n| name         | population  | area         |\r\n+--------------+-------------+--------------+\r\n| Afghanistan  | 25500100    | 652230       |\r\n| Algeria      | 37100000    | 2381741      |\r\n+--------------+-------------+--------------+\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/756", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 35036, "total_submitted": 48940}, {"id": 596, "title": "Classes More Than 5 Students", "url": "https://leetcode.com/problems/classes-more-than-5-students/description", "companyTags": [""], "difficulty": "Easy", "content": "\r\nThere is a table courses with columns: student and class\r\n\r\nPlease list out all classes which have more than or equal to 5 students.\r\n\r\n\r\nFor example, the table:\r\n\r\n\r\n+---------+------------+\r\n| student | class      |\r\n+---------+------------+\r\n| A       | Math       |\r\n| B       | English    |\r\n| C       | Math       |\r\n| D       | Biology    |\r\n| E       | Math       |\r\n| F       | Computer   |\r\n| G       | Math       |\r\n| H       | Math       |\r\n| I       | Math       |\r\n+---------+------------+\r\n\r\n\r\nShould output:\r\n\r\n+---------+\r\n| class   |\r\n+---------+\r\n| Math    |\r\n+---------+\r\n\r\n\r\n\r\nNote:\r\nThe students should not be counted duplicate in each course.\r\n", "discussUrl": "https://discuss.leetcode.com/category/757", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 12453, "total_submitted": 42625}, {"id": 597, "title": "Friend Requests I: Overall Acceptance Rate", "url": "https://leetcode.com/problems/friend-requests-i-overall-acceptance-rate/description", "companyTags": ["Facebook"], "difficulty": "Easy", "content": "In social network like Facebook or Twitter, people send friend requests and accept others\u2019 requests as well. Now given two tables as below:\r\n\r\nTable: friend_request\r\n\r\n| sender_id | send_to_id |request_date|\r\n|-----------|------------|------------|\r\n| 1         | 2          | 2016_06-01 |\r\n| 1         | 3          | 2016_06-01 |\r\n| 1         | 4          | 2016_06-01 |\r\n| 2         | 3          | 2016_06-02 |\r\n| 3         | 4          | 2016-06-09 |\r\n\r\n\r\nTable: request_accepted\r\n\r\n| requester_id | accepter_id |accept_date |\r\n|--------------|-------------|------------|\r\n| 1            | 2           | 2016_06-03 |\r\n| 1            | 3           | 2016-06-08 |\r\n| 2            | 3           | 2016-06-08 |\r\n| 3            | 4           | 2016-06-09 |\r\n| 3            | 4           | 2016-06-10 |\r\n\r\n\r\nWrite a query to find the overall acceptance rate of requests rounded to 2 decimals, which is the number of acceptance divide the number of requests.\r\n\r\nFor the sample data above, your query should return the following result.\r\n\r\n|accept_rate|\r\n|-----------|\r\n|       0.80|\r\n\r\n\r\nNote:\r\nThe accepted requests are not necessarily from the table friend_request. In this case, you just need to simply count the total accepted requests (no matter whether they are in the original requests), and divide it by the number of requests to get the acceptance rate.\r\nIt is possible that a sender sends multiple requests to the same receiver, and a request could be accepted more than once. In this case, the \u2018duplicated\u2019 requests or acceptances are only counted once.\r\nIf there is no requests at all, you should return 0.00 as the accept_rate. \r\n\r\n\r\nExplanation: There are 4 unique accepted requests, and there are 5 requests in total. So the rate is 0.80.\r\n\r\nFollow-up:\r\nCan you write a query to return the accept rate but for every month?\r\nHow about the cumulative accept rate for every day?", "discussUrl": "https://discuss.leetcode.com/category/758", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 3649, "total_submitted": 9536}, {"id": 598, "title": "Range Addition II", "url": "https://leetcode.com/problems/range-addition-ii/description", "companyTags": ["IXL"], "difficulty": "Easy", "content": "Given an m * n matrix M initialized with all 0's and several update operations.\r\nOperations are represented by a 2D array, and each operation is represented by an array with two positive integers a and b, which means M[i][j] should be added by one for all 0 <= i < a and 0 <= j < b. \r\nYou need to count and return the number of maximum integers in the matrix after performing all the operations.\r\n\r\nExample 1:\r\n\r\nInput: \r\nm = 3, n = 3\r\noperations = [[2,2],[3,3]]\r\nOutput: 4\r\nExplanation: \r\nInitially, M = \r\n[[0, 0, 0],\r\n [0, 0, 0],\r\n [0, 0, 0]]\r\n\r\nAfter performing [2,2], M = \r\n[[1, 1, 0],\r\n [1, 1, 0],\r\n [0, 0, 0]]\r\n\r\nAfter performing [3,3], M = \r\n[[2, 2, 1],\r\n [2, 2, 1],\r\n [1, 1, 1]]\r\n\r\nSo the maximum integer in M is 2, and there are four of it in M. So return 4.\r\n\r\n\r\n\r\nNote:\r\n\r\nThe range of m and n is [1,40000].\r\nThe range of a is [1,m], and the range of b is [1,n].\r\nThe range of operations size won't exceed 10,000.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/760", "similarQuestions": ["RangeAddition"], "topicTags": ["Math"], "Solution": "class Solution {\n    public int maxCount(int m, int n, int[][] ops) {\n       for (int k = 0; k < ops.length; k++) {\n            if(ops[k][0] < m){\n                m = ops[k][0];\n            }\n            if(ops[k][1] < n){\n                n = ops[k][1];\n            }\n        }\n\n        return m * n;\n    }\n}", "total_acs": 17792, "total_submitted": 36868}, {"id": 599, "title": "Minimum Index Sum of Two Lists", "url": "https://leetcode.com/problems/minimum-index-sum-of-two-lists/description", "companyTags": ["Yelp"], "difficulty": "Easy", "content": "\r\nSuppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings. \r\n\r\n\r\nYou need to help them find out their common interest with the least list index sum. If there is a choice tie between answers, output all of them with no order requirement. You could assume there always exists an answer.\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput:\r\n[\"Shogun\", \"Tapioca Express\", \"Burger King\", \"KFC\"]\r\n[\"Piatti\", \"The Grill at Torrey Pines\", \"Hungry Hunter Steakhouse\", \"Shogun\"]\r\nOutput: [\"Shogun\"]\r\nExplanation: The only restaurant they both like is \"Shogun\".\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput:\r\n[\"Shogun\", \"Tapioca Express\", \"Burger King\", \"KFC\"]\r\n[\"KFC\", \"Shogun\", \"Burger King\"]\r\nOutput: [\"Shogun\"]\r\nExplanation: The restaurant they both like and have the least index sum is \"Shogun\" with index sum 1 (0+1).\r\n\r\n\r\n\r\n\r\nNote:\r\n\r\nThe length of both lists will be in the range of [1, 1000].\r\nThe length of strings in both lists will be in the range of [1, 30].\r\nThe index is starting from 0 to the list length minus 1.\r\nNo duplicates in both lists.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/761", "similarQuestions": ["IntersectionofTwoLinkedLists"], "topicTags": ["HashTable"], "Solution": "class Solution {\n    int small = -1;\n    int large = -1;\n    public String[] findRestaurant(String[] list1, String[] list2) {\n        HashMap<String, Integer> hm = new HashMap();\n        List<String> ans = new ArrayList();\n        for(int i=0;i<list1.length||i<list2.length;i++) {\n            checkMap(list1, i, hm, ans);\n            checkMap(list2, i, hm, ans);\n            if (small!=-1) break;\n        }\n        for (int i=large+1, j=small-1; (i<list1.length || i<list2.length) && j>=0; i++, j--) {\n            if (i<list1.length && list1[i].equals(list2[j]))  ans.add(list1[i]);\n            if (i<list2.length && list2[i].equals(list1[j]))  ans.add(list2[i]);\n        }\n        return ans.toArray(new String[ans.size()]);\n    }\n    private void checkMap(String[] list, int index, HashMap<String, Integer> hm, List<String> ans) {\n        if (index<list.length) {\n            if (hm.containsKey(list[index])) {\n                small = hm.get(list[index]);\n                large = index;\n                ans.add(list[index]);\n            } else \n                hm.put(list[index], index);\n        }\n    }\n}", "total_acs": 26047, "total_submitted": 56067}, {"id": 600, "title": "Non-negative Integers without Consecutive Ones", "url": "https://leetcode.com/problems/non-negative-integers-without-consecutive-ones/description", "companyTags": ["PocketGems"], "difficulty": "Hard", "content": "Given a positive integer n, find the number of non-negative integers less than or equal to n, whose binary representations do NOT contain consecutive ones.\r\n\r\nExample 1:\r\n\r\nInput: 5\r\nOutput: 5\r\nExplanation: \r\nHere are the non-negative integers <= 5 with their corresponding binary representations:\r\n0 : 0\r\n1 : 1\r\n2 : 10\r\n3 : 11\r\n4 : 100\r\n5 : 101\r\nAmong them, only integer 3 disobeys the rule (two consecutive ones) and the other 5 satisfy the rule. \r\n\r\n\r\n\r\nNote:\r\n1 <= n <= 109\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/762", "similarQuestions": ["HouseRobber", "HouseRobberII", "OnesandZeroes"], "topicTags": ["DynamicProgramming"], "Solution": "class Solution {\n    public int findIntegers(int num) {\n\n        int[] a = new int[32]; // a ==>  no 11, start with 0  \n        int[] b = new int[32]; // b ==>  no 11, start with 1\n        int[] c = new int[32]; // c ==> has 11, start with 0  \n        int[] d = new int[32]; // d ==> has 11, start with 1 \n        \n        int[] units = new int[32];\n        int[] bits = new int[32];\n\n        //------------------------\n        // fill in bits and units\n        //------------------------\n        int num2 = num;\n        int unit = 2;\n        int length = 0;\n        while (num2 > 0)\n        {\n            bits[length] = num2 % 2;\n            units[length] = unit;\n            unit *= 2;\n            num2 /= 2;\n            length++;\n        }\n\n        //------------------------\n        // fill in a b c d\n        //------------------------\n        a[0] = b[0] = 1;\n        c[0] = d[0] = 0;\n        for (int i = 1; i <= length; i++)\n        {\n            a[i] = a[i - 1] + b[i - 1];\n            b[i] = a[i - 1];\n            c[i] = c[i - 1] + d[i - 1];\n            d[i] = b[i - 1] + c[i - 1] + d[i - 1];\n        }\n\n        length--;\n        int count11 = 0;\n        for(int i = length; i > 0; i--) // loop from high to low\n        {\n            if(bits[i] == 1)\n            {\n                if(bits[i - 1] == 1)\n                {\n                    if (i > 1) count11 += num % units[i - 2];\n                    count11 += 1;\n                    count11 += c[i - 1] + c[i];\n                    break;\n                }\n\n                else\n                {\n                    count11 += c[i - 1] + d[i- 1];\n                }\n\n            }\n        }\n\n        return num + 1 - count11;\n\n    }\n}", "total_acs": 5014, "total_submitted": 15906}, {"id": 601, "title": "Human Traffic of Stadium", "url": "https://leetcode.com/problems/human-traffic-of-stadium/description", "companyTags": [""], "difficulty": "Hard", "content": "X city built a new stadium, each day many people visit it and the stats are saved as these columns: id, date, people\r\n\r\nPlease write a query to display the records which have 3 or more consecutive rows and the  amount of people more than 100(inclusive).\r\n\r\n \r\nFor example, the table stadium:\r\n\r\n+------+------------+-----------+\r\n| id   | date       | people    |\r\n+------+------------+-----------+\r\n| 1    | 2017-01-01 | 10        |\r\n| 2    | 2017-01-02 | 109       |\r\n| 3    | 2017-01-03 | 150       |\r\n| 4    | 2017-01-04 | 99        |\r\n| 5    | 2017-01-05 | 145       |\r\n| 6    | 2017-01-06 | 1455      |\r\n| 7    | 2017-01-07 | 199       |\r\n| 8    | 2017-01-08 | 188       |\r\n+------+------------+-----------+\r\n\r\n\r\nFor the sample data above, the output is:\r\n\r\n\r\n+------+------------+-----------+\r\n| id   | date       | people    |\r\n+------+------------+-----------+\r\n| 5    | 2017-01-05 | 145       |\r\n| 6    | 2017-01-06 | 1455      |\r\n| 7    | 2017-01-07 | 199       |\r\n| 8    | 2017-01-08 | 188       |\r\n+------+------------+-----------+\r\n\r\n\r\nNote:\r\nEach day only have one row record, and the dates are increasing with id increasing.\r\n ", "discussUrl": "https://discuss.leetcode.com/category/763", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 4058, "total_submitted": 11779}, {"id": 602, "title": "Friend Requests II: Who Has the Most Friends", "url": "https://leetcode.com/problems/friend-requests-ii-who-has-the-most-friends/description", "companyTags": ["Facebook"], "difficulty": "Medium", "content": "In social network like Facebook or Twitter, people send friend requests and accept others' requests as well.\r\nTable request_accepted holds the data of friend acceptance, while requester_id and accepter_id both are the id of a person.\r\n\r\n\r\n| requester_id | accepter_id | accept_date|\r\n|--------------|-------------|------------|\r\n| 1            | 2           | 2016_06-03 |\r\n| 1            | 3           | 2016-06-08 |\r\n| 2            | 3           | 2016-06-08 |\r\n| 3            | 4           | 2016-06-09 |\r\n\r\n \r\nWrite a query to find the the people who has most friends and the most friends number. For the sample data above, the result is:\r\n\r\n| id | num |\r\n|----|-----|\r\n| 3  | 3   |\r\n\r\n \r\nNote:\r\nIt is guaranteed there is only 1 people having the most friends.\r\nThe friend request could only been accepted once, which mean there is no multiple records with the same requester_id and accepter_id value.\r\n\r\n \r\nExplanation:\r\nThe person with id '3' is a friend of people '1', '2' and '4', so he has 3 friends in total, which is the most number than any others.\r\n \r\nFollow-up: In the real world, multiple people could have the same most number of friends, can you find all these people in this case?\r\n", "discussUrl": "https://discuss.leetcode.com/category/765", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 2859, "total_submitted": 6770}, {"id": 603, "title": "Consecutive Available Seats", "url": "https://leetcode.com/problems/consecutive-available-seats/description", "companyTags": [""], "difficulty": "Easy", "content": "Several friends at a cinema ticket office would like to reserve consecutive available seats.\r\nCan you help to query all the consecutive available seats order by the seat_id using the following cinema table?\r\n\r\n\r\n| seat_id | free |\r\n|---------|------|\r\n| 1       | 1    |\r\n| 2       | 0    |\r\n| 3       | 1    |\r\n| 4       | 1    |\r\n| 5       | 1    |\r\n\r\n\r\nYour query should return the following result for the sample case above.\r\n\r\n| seat_id |\r\n|---------|\r\n| 3       |\r\n| 4       |\r\n| 5       |\r\n\r\n\r\nNote:\r\nThe seat_id is an auto increment int, and free is bool ('1' means free, and '0' means occupied.).\r\nConsecutive available seats are more than 2(inclusive) seats consecutively available.\r\n", "discussUrl": "https://discuss.leetcode.com/category/766", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 2312, "total_submitted": 4204}, {"id": 604, "title": "Design Compressed String Iterator", "url": "https://leetcode.com/problems/design-compressed-string-iterator/description", "companyTags": ["Google"], "difficulty": "Easy", "content": "\r\nDesign and implement a data structure for a compressed string iterator. It should support the following operations: next and hasNext.\r\n\r\n\r\n\r\nThe given compressed string will be in the form of each letter followed by a positive integer representing the number of this letter existing in the original uncompressed string.\r\n\r\n\r\n\r\nnext() - if the original string still has uncompressed characters, return the next letter; Otherwise return a white space.\r\nhasNext() - Judge whether there is any letter needs to be uncompressed.\r\n\r\n\r\n\r\nNote:\r\nPlease remember to RESET your class variables declared in StringIterator, as static/class variables are persisted across multiple test cases. Please see here for more details.\r\n\r\n\r\n\r\nExample:\r\n\r\nStringIterator iterator = new StringIterator(\"L1e2t1C1o1d1e1\");\r\n\r\niterator.next(); // return 'L'\r\niterator.next(); // return 'e'\r\niterator.next(); // return 'e'\r\niterator.next(); // return 't'\r\niterator.next(); // return 'C'\r\niterator.next(); // return 'o'\r\niterator.next(); // return 'd'\r\niterator.hasNext(); // return true\r\niterator.next(); // return 'e'\r\niterator.hasNext(); // return false\r\niterator.next(); // return ' '\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/768", "similarQuestions": ["LRUCache", "StringCompression"], "topicTags": ["Design"], "Solution": "class StringIterator {\n\n    String s;\n    int index;\n    int count;\n    char cur;\n    \n    public StringIterator(String compressedString) {\n        s = compressedString;\n        index = 0;\n        count = 0;\n        cur = ' ';\n    }\n    \n    public char next() {\n        if (!hasNext()) return ' ';\n        if (count == 0) {\n            cur = s.charAt(index++);\n            while (index < s.length() && Character.isDigit(s.charAt(index))) {\n                count = count * 10 + (s.charAt(index++) - '0');                \n            }\n        }\n        count--;\n        return cur;\n    }\n    \n    public boolean hasNext() {\n        return count > 0 || index < s.length();\n    }\n}\n\n/**\n * Your StringIterator object will be instantiated and called as such:\n * StringIterator obj = new StringIterator(compressedString);\n * char param_1 = obj.next();\n * boolean param_2 = obj.hasNext();\n */", "total_acs": 6865, "total_submitted": 20788}, {"id": 605, "title": "Can Place Flowers", "url": "https://leetcode.com/problems/can-place-flowers/description", "companyTags": ["LinkedIn"], "difficulty": "Easy", "content": "Suppose you have a long flowerbed in which some of the plots are planted and some are not. However, flowers cannot be planted in adjacent plots - they would compete for water and both would die.\r\n\r\nGiven a flowerbed (represented as an array containing 0 and 1, where 0 means empty and 1 means not empty), and a number n, return if n new flowers can be planted in it without violating the no-adjacent-flowers rule.\r\n\r\nExample 1:\r\n\r\nInput: flowerbed = [1,0,0,0,1], n = 1\r\nOutput: True\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: flowerbed = [1,0,0,0,1], n = 2\r\nOutput: False\r\n\r\n\r\n\r\nNote:\r\n\r\nThe input array won't violate no-adjacent-flowers rule.\r\nThe input array size is in the range of [1, 20000].\r\nn is a non-negative integer which won't exceed the input array size.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/769", "similarQuestions": ["TeemoAttacking", "AsteroidCollision"], "topicTags": ["Array"], "Solution": "class Solution {\n    public boolean canPlaceFlowers(int[] flowerbed, int n) {\n        //int place = 0, noplace = 0;\n        int tmp = 0;\n        for(int i = 0; i < flowerbed.length; i++)\n        {\n            if(flowerbed[i] == 1)\n            {\n                i += 1;\n            }\n            else if(i < (flowerbed.length -1) && flowerbed[i+1] == 1)\n            {\n                i += 2;\n            }\n            else\n            {\n                tmp ++;\n                i++;\n            }\n        }\n        if(n <= tmp)\n            return true;\n        return false;\n            \n    }\n}", "total_acs": 27004, "total_submitted": 89747}, {"id": 606, "title": "Construct String from Binary Tree", "url": "https://leetcode.com/problems/construct-string-from-binary-tree/description", "companyTags": ["Amazon"], "difficulty": "Easy", "content": "You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way.\r\n\r\nThe null node needs to be represented by empty parenthesis pair \"()\". And you need to omit all the empty parenthesis pairs that don't affect the one-to-one mapping relationship between the string and the original binary tree.\r\n\r\nExample 1:\r\n\r\nInput: Binary tree: [1,2,3,4]\r\n       1\r\n     /   \\\r\n    2     3\r\n   /    \r\n  4     \r\n\r\nOutput: \"1(2(4))(3)\"\r\nExplanation: Originallay it needs to be \"1(2(4)())(3()())\", but you need to omit all the unnecessary empty parenthesis pairs. And it will be \"1(2(4))(3)\".\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: Binary tree: [1,2,3,null,4]\r\n       1\r\n     /   \\\r\n    2     3\r\n     \\  \r\n      4 \r\n\r\nOutput: \"1(2()(4))(3)\"\r\nExplanation: Almost the same as the first example, except we can't omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/770", "similarQuestions": ["ConstructBinaryTreefromString", "FindDuplicateSubtrees"], "topicTags": ["String", "Tree"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public String tree2str(TreeNode t) {\n        StringBuilder sb = new StringBuilder();\n        // if(t==null) return sb.append(\"()\").toString();\n        helper(t, sb);\n        return sb.toString();\n    }\n    private void helper(TreeNode root, StringBuilder sb){\n        if(root != null){\n            sb.append(root.val);\n            if(root.left!=null||root.right !=null){\n            sb.append(\"(\");\n            helper(root.left,sb);\n            sb.append(\")\");\n            if(root.right!=null){\n            sb.append(\"(\");\n            helper(root.right,sb);\n            sb.append(\")\");}}\n        }\n    }\n}", "total_acs": 29214, "total_submitted": 58594}, {"id": 607, "title": "Sales Person", "url": "https://leetcode.com/problems/sales-person/description", "companyTags": [""], "difficulty": "Easy", "content": "Description\r\n\r\nGiven three tables: salesperson, company, orders.\r\nOutput all the names in the table salesperson, who didn\u2019t have sales to company 'RED'.\r\n\r\nExample\r\nInput\r\n\r\nTable: salesperson\r\n\r\n\r\n+----------+------+--------+-----------------+-----------+\r\n| sales_id | name | salary | commission_rate | hire_date |\r\n+----------+------+--------+-----------------+-----------+\r\n|   1      | John | 100000 |     6           | 4/1/2006  |\r\n|   2      | Amy  | 120000 |     5           | 5/1/2010  |\r\n|   3      | Mark | 65000  |     12          | 12/25/2008|\r\n|   4      | Pam  | 25000  |     25          | 1/1/2005  |\r\n|   5      | Alex | 50000  |     10          | 2/3/2007  |\r\n+----------+------+--------+-----------------+-----------+\r\n\r\nThe table salesperson holds the salesperson information. Every salesperson has a sales_id and a name.\r\n\r\nTable: company\r\n\r\n\r\n+---------+--------+------------+\r\n| com_id  |  name  |    city    |\r\n+---------+--------+------------+\r\n|   1     |  RED   |   Boston   |\r\n|   2     | ORANGE |   New York |\r\n|   3     | YELLOW |   Boston   |\r\n|   4     | GREEN  |   Austin   |\r\n+---------+--------+------------+\r\n\r\nThe table company holds the company information. Every company has a com_id and a name.\r\n\r\nTable: orders\r\n\r\n\r\n+----------+----------+---------+----------+--------+\r\n| order_id |  date    | com_id  | sales_id | amount |\r\n+----------+----------+---------+----------+--------+\r\n| 1        | 1/1/2014 |    3    |    4     | 100000 |\r\n| 2        | 2/1/2014 |    4    |    5     | 5000   |\r\n| 3        | 3/1/2014 |    1    |    1     | 50000  |\r\n| 4        | 4/1/2014 |    1    |    4     | 25000  |\r\n+----------+----------+---------+----------+--------+\r\n\r\nThe table orders holds the sales record information, salesperson and customer  company are represented by sales_id and com_id.\r\n\r\n\r\noutput \r\n\r\n\r\n+------+\r\n| name | \r\n+------+\r\n| Amy  | \r\n| Mark | \r\n| Alex |\r\n+------+\r\n\r\n\r\nExplanation\r\n\r\nAccording to order '3' and '4' in table orders, it is easy to tell only salesperson 'John' and 'Alex' have sales to company 'RED',so we need to output all the other names in table salesperson.\r\n", "discussUrl": "https://discuss.leetcode.com/category/771", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 2843, "total_submitted": 5635}, {"id": 608, "title": "Tree Node", "url": "https://leetcode.com/problems/tree-node/description", "companyTags": ["Twitter"], "difficulty": "Medium", "content": "\r\nGiven a table tree, id is identifier of the tree node and p_id is its parent node's id.\r\n\r\n \r\n\r\n+----+------+\r\n| id | p_id |\r\n+----+------+\r\n| 1  | null |\r\n| 2  | 1    |\r\n| 3  | 1    |\r\n| 4  | 2    |\r\n| 5  | 2    |\r\n+----+------+\r\n\r\n \r\nEach node in the tree can be one of three types:\r\nLeaf: if the node is a leaf node.\r\nRoot: if the node is the root of the tree.\r\nInner: If the node is neither a leaf node nor a root node.\r\n \r\nWrite a query to print the node id and the type of the node. Sort your output by the node id. The result for the above sample is:\r\n \r\n\r\n+----+------+\r\n| id | Type |\r\n+----+------+\r\n| 1  | Root |\r\n| 2  | Inner|\r\n| 3  | Leaf |\r\n| 4  | Leaf |\r\n| 5  | Leaf |\r\n+----+------+\r\n\r\n\r\n \r\n\r\nExplanation\r\n\r\n\r\nNode '1' is root node, because its parent node is NULL and it has child node '2' and '3'.\r\nNode '2' is inner node, because it has parent node '1' and child node '4' and '5'.\r\nNode '3', '4' and '5' is Leaf node, because they have parent node and they don't have child node.\r\n\r\nAnd here is the image of the sample tree as below:\r\n\r\n\r\n\t\t\t  1\r\n\t\t\t/   \\\r\n                      2       3\r\n                    /   \\\r\n                  4       5\r\n\r\n\r\n\r\nNote\r\n\r\n\r\nIf there is only one node on the tree, you only need to output its root attributes.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/772", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 2731, "total_submitted": 5073}, {"id": 609, "title": "Find Duplicate File in System", "url": "https://leetcode.com/problems/find-duplicate-file-in-system/description", "companyTags": ["Dropbox"], "difficulty": "Medium", "content": "Given a list of directory info including directory path, and all the files with contents in this directory, you need to find out all the groups of duplicate files in the file system in terms of their paths.\r\n\r\nA group of duplicate files consists of at least two files that have exactly the same content.\r\n\r\nA single directory info string in the input list has the following format: \r\n\"root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)\"\r\nIt means there are n files (f1.txt, f2.txt ... fn.txt with content f1_content, f2_content ... fn_content, respectively) in directory root/d1/d2/.../dm. Note that n >= 1 and m >= 0. If m = 0, it means the directory is just the root directory.\r\n\r\nThe output is a list of group of duplicate file paths. For each group, it contains all the file paths of the files that have the same content. A file path is a string that has the following format: \r\n\"directory_path/file_name.txt\"\r\n\r\n\r\nExample 1:\r\n\r\nInput:\r\n[\"root/a 1.txt(abcd) 2.txt(efgh)\", \"root/c 3.txt(abcd)\", \"root/c/d 4.txt(efgh)\", \"root 4.txt(efgh)\"]\r\nOutput:  \r\n[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]\r\n\r\n\r\n\r\n\r\nNote:\r\n\r\nNo order is required for the final output.\r\nYou may assume the directory name, file name and file content only has letters and digits, and the length of file content is in the range of [1,50].\r\nThe number of files given is in the range of [1,20000].\r\nYou may assume no files or directories share the same name in the same directory.\r\nYou may assume each given directory info represents a unique directory. Directory path and file info are separated by a single blank space.\r\n\r\n\r\n\r\n\r\nFollow-up beyond contest: \r\n\r\n Imagine you are given a real file system, how will you search files? DFS or BFS?\r\n If the file content is very large (GB level), how will you modify your solution?\r\n If you can only read the file by 1kb each time, how will you modify your solution?\r\n What is the time complexity of your modified solution? What is the most time-consuming part and memory consuming part of it? How to optimize?\r\n How to make sure the duplicated files you find are not false positive?\r\n", "discussUrl": "https://discuss.leetcode.com/category/773", "similarQuestions": [""], "topicTags": ["HashTable", "String"], "Solution": "class Solution {\n    public List<List<String>> findDuplicate(String[] paths) {\n        HashMap<String, List<String>> map = new HashMap<>();\n        for(String path:paths){\n            int sep = path.indexOf(' ');\n            String dir = path.substring(0, sep++);\n            while(sep < path.length()){\n                int sep1 = path.indexOf('(', sep);\n                int sep2 = path.indexOf(')', sep);\n                String content = path.substring(sep1 + 1, sep2);\n                if(map.get(content) == null){\n                    map.put(content, new LinkedList<>());\n                }\n                String filename = path.substring(sep, sep1);\n                map.get(content).add(new String(dir + \"/\" + filename));\n                sep = sep2 + 2;\n            }\n        }\n        List<List<String>> res = new LinkedList<List<String>>();\n        for(List<String> value:map.values()){\n            if(value.size() > 1){\n                res.add(value);\n            }\n        }\n        return res;\n    }\n}", "total_acs": 10691, "total_submitted": 20455}, {"id": 610, "title": "Triangle Judgement", "url": "https://leetcode.com/problems/triangle-judgement/description", "companyTags": [""], "difficulty": "Easy", "content": "A pupil Tim gets homework to identify whether three line segments could possibly form a triangle. However, this assignment is very heavy because there are hundreds of records to calculate.\r\n \r\nCould you help Tim by writing a query to judge whether these three sides can form a triangle, assuming table triangle holds the length of the three sides x, y and z.\r\n \r\n\r\n| x  | y  | z  |\r\n|----|----|----|\r\n| 13 | 15 | 30 |\r\n| 10 | 20 | 15 |\r\n\r\n \r\nFor the sample data above, your query should return the follow result:\r\n\r\n| x  | y  | z  | triangle |\r\n|----|----|----|----------|\r\n| 13 | 15 | 30 | No       |\r\n| 10 | 20 | 15 | Yes      |\r\n", "discussUrl": "https://discuss.leetcode.com/category/774", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 2912, "total_submitted": 4986}, {"id": 611, "title": "Valid Triangle Number", "url": "https://leetcode.com/problems/valid-triangle-number/description", "companyTags": ["Expedia"], "difficulty": "Medium", "content": "Given an array consists of non-negative integers,  your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.\r\n\r\nExample 1:\r\n\r\nInput: [2,2,3,4]\r\nOutput: 3\r\nExplanation:\r\nValid combinations are: \r\n2,3,4 (using the first 2)\r\n2,3,4 (using the second 2)\r\n2,2,3\r\n\r\n\r\n\r\nNote:\r\n\r\nThe length of the given array won't exceed 1000.\r\nThe integers in the given array are in the range of [0, 1000].\r\n\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/776", "similarQuestions": ["3SumSmaller"], "topicTags": ["Array"], "Solution": "class Solution {\n    public int triangleNumber(int[] nums) {\n        if (nums == null || nums.length < 3) {\n            return 0;\n        }\n        \n        Arrays.sort(nums);\n        int res = 0;\n        for (int i = 0; i < nums.length; i++) {\n            int left = 0;\n            int right = i - 1;\n            while (left < right) {\n                if (nums[left] + nums[right] > nums[i]) {\n                    res += right - left;\n                    right--;\n                } else {\n                    left++;\n                }\n            }\n        }\n        \n        return res;\n    }\n}", "total_acs": 15045, "total_submitted": 35525}, {"id": 612, "title": "Shortest Distance in a Plane", "url": "https://leetcode.com/problems/shortest-distance-in-a-plane/description", "companyTags": [""], "difficulty": "Medium", "content": "Table point_2d holds the coordinates (x,y) of some unique points (more than two) in a plane.\r\nWrite a query to find the shortest distance between these points rounded to  2 decimals.\r\n \r\n\r\n| x  | y  |\r\n|----|----|\r\n| -1 | -1 |\r\n| 0  | 0  |\r\n| -1 | -2 |\r\n\r\n \r\nThe shortest distance is 1.00 from point (-1,-1) to (-1,2). So the output should be:\r\n\r\n| shortest |\r\n|----------|\r\n| 1.00     |\r\n\r\n \r\nNote: The longest distance among all the points are less than 10000.", "discussUrl": "https://discuss.leetcode.com/category/777", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 1885, "total_submitted": 3590}, {"id": 613, "title": "Shortest Distance in a Line", "url": "https://leetcode.com/problems/shortest-distance-in-a-line/description", "companyTags": [""], "difficulty": "Easy", "content": "Table point holds the x coordinate of some points on x-axis in a plane, which are all integers.\r\nWrite a query to find the shortest distance between two points in these points.\r\n \r\n\r\n| x   |\r\n|-----|\r\n| -1  |\r\n| 0   |\r\n| 2   |\r\n\r\n \r\nThe shortest distance is '1' obviously, which is from point '-1' to '0'. So the output is as below:\r\n\r\n| shortest|\r\n|---------|\r\n| 1       |\r\n\r\n \r\nNote: Every point is unique, which means there is no duplicates in table point.\r\n \r\nFollow-up: What if all these points have an id and are arranged from the left most to the right most of x axis?", "discussUrl": "https://discuss.leetcode.com/category/778", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 3663, "total_submitted": 5194}, {"id": 614, "title": "Second Degree Follower", "url": "https://leetcode.com/problems/second-degree-follower/description", "companyTags": [""], "difficulty": "Medium", "content": "\r\nIn facebook, there is a follow table with two columns: followee, follower.\r\n\r\nPlease write a sql query to get the amount of each follower\u2019s follower if he/she has one.\r\n\r\n\r\nFor example:\r\n\r\n+-------------+------------+\r\n| followee    | follower   |\r\n+-------------+------------+\r\n|     A       |     B      |\r\n|     B       |     C      |\r\n|     B       |     D      |\r\n|     D       |     E      |\r\n+-------------+------------+\r\n\r\nshould output:\r\n\r\n+-------------+------------+\r\n| follower    | num        |\r\n+-------------+------------+\r\n|     B       |  2         |\r\n|     D       |  1         |\r\n+-------------+------------+\r\n\r\nExplaination:\r\nBoth B and D exist  in the follower list, when as a followee, B's follower is C and D, and D's follower is E.  A does not exist in follower list.\r\n\r\n\r\nNote:\r\nFollowee would not follow himself/herself in all cases.\r\nPlease display the result in follower's alphabet order.\r\n", "discussUrl": "https://discuss.leetcode.com/category/779", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 1583, "total_submitted": 6775}, {"id": 615, "title": "Average Salary: Departments VS Company", "url": "https://leetcode.com/problems/average-salary-departments-vs-company/description", "companyTags": [""], "difficulty": "Hard", "content": "Given two tables as below, write a query to display the comparison result (higher/lower/same) of the average salary of employees in a department to the company's average salary.\r\n\r\nTable: salary\r\n\r\n| id | employee_id | amount | pay_date   |\r\n|----|-------------|--------|------------|\r\n| 1  | 1           | 9000   | 2017-03-31 |\r\n| 2  | 2           | 6000   | 2017-03-31 |\r\n| 3  | 3           | 10000  | 2017-03-31 |\r\n| 4  | 1           | 7000   | 2017-02-28 |\r\n| 5  | 2           | 6000   | 2017-02-28 |\r\n| 6  | 3           | 8000   | 2017-02-28 |\r\n\r\n\r\nThe employee_id column refers to the employee_id in the following table employee.\r\n\r\n| employee_id | department_id |\r\n|-------------|---------------|\r\n| 1           | 1             |\r\n| 2           | 2             |\r\n| 3           | 2             |\r\n\r\n\r\nSo for the sample data above, the result is:\r\n\r\n| pay_month | department_id | comparison  |\r\n|-----------|---------------|-------------|\r\n| 2017-03   | 1             | higher      |\r\n| 2017-03   | 2             | lower       |\r\n| 2017-02   | 1             | same        |\r\n| 2017-02   | 2             | same        |\r\n\r\n\r\nExplanation\r\nIn March, the company's average salary is (9000+6000+10000)/3 = 8333.33...\r\nThe average salary for department '1' is 9000, which is the salary of employee_id '1' since there is only one employee in this department. So the comparison result is 'higher' since 9000 > 8333.33 obviously.\r\nThe average salary of department '2' is (6000 + 10000)/2 = 8000, which is the average of employee_id '2' and '3'. So the comparison result is 'lower' since 8000 < 8333.33.\r\nWith he same formula for the average salary comparison in February, the result is 'same' since both the department '1' and '2' have the same average salary with the company, which is 7000.", "discussUrl": "https://discuss.leetcode.com/category/780", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 893, "total_submitted": 2830}, {"id": 616, "title": "Add Bold Tag in String", "url": "https://leetcode.com/problems/add-bold-tag-in-string/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "Given a string s and a list of strings dict, you need to add a closed pair of bold tag <b> and </b> to wrap the substrings in s that exist in dict. If two such substrings overlap, you need to wrap them together by only one pair of closed bold tag. Also, if two substrings wrapped by bold tags are consecutive, you need to combine them. \r\n\r\nExample 1:\r\n\r\nInput: \r\ns = \"abcxyz123\"\r\ndict = [\"abc\",\"123\"]\r\nOutput:\r\n\"<b>abc</b>xyz<b>123</b>\"\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: \r\ns = \"aaabbcc\"\r\ndict = [\"aaa\",\"aab\",\"bc\"]\r\nOutput:\r\n\"<b>aaabbc</b>c\"\r\n\r\n\r\n\r\nNote:\r\n\r\nThe given dict won't contain duplicates, and its length won't exceed 100.\r\nAll the strings in input have length in range [1, 1000]. \r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/781", "similarQuestions": ["MergeIntervals", "TagValidator"], "topicTags": ["String"], "Solution": "class Solution {\n    public String addBoldTag(String s, String[] dict) {\n        if (s == null || \"\".equals(s)) return s;\n    \tString b1 = \"<b>\", b2 = \"</b>\";\n        boolean[] tag = new boolean[s.length()];\n        for (String dic : dict) {\n        \tint index = s.indexOf(dic, 0), len = dic.length();\n        \twhile (index != -1) {\n        \t\tfor (int i = 0; i < len; i++) tag[i+index] = true;\n        \t\tindex = s.indexOf(dic, index+1);\n        \t}\n        }\n\n        int l = s.length()-1, r = -1;\n        StringBuilder sb = new StringBuilder(s);\n        while (0 <= l) {\n        \tif (!tag[l]) {\n        \t\tif (r != -1) {\n        \t\t\tsb.insert(r+1, b2);\n        \t\t\tsb.insert(l+1, b1);\n        \t\t\tr = -1;\n        \t\t}\n        \t} else {\n        \t\tif (r == -1) {\n        \t\t\tr = l;\n        \t\t}\n        \t}\n        \tl--;\n        } \n        if (tag[0]) {\n        \tsb.insert(r+1, b2);\n        \tsb.insert(0, b1);\n        }\n        return sb.toString();\n    }\n}", "total_acs": 8209, "total_submitted": 21300}, {"id": 617, "title": "Merge Two Binary Trees", "url": "https://leetcode.com/problems/merge-two-binary-trees/description", "companyTags": ["Amazon"], "difficulty": "Easy", "content": "\r\nGiven two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. \r\n\r\n\r\nYou need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput: \r\n\tTree 1                     Tree 2                  \r\n          1                         2                             \r\n         / \\                       / \\                            \r\n        3   2                     1   3                        \r\n       /                           \\   \\                      \r\n      5                             4   7                  \r\nOutput: \r\nMerged tree:\r\n\t     3\r\n\t    / \\\r\n\t   4   5\r\n\t  / \\   \\ \r\n\t 5   4   7\r\n\r\n\r\n\r\n\r\nNote:\r\nThe merging process must start from the root nodes of both trees.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/782", "similarQuestions": [""], "topicTags": ["Tree"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\n        if(t1!=null){\n            if(t2!=null){\n                TreeNode mTree = new TreeNode(t1.val+t2.val);\n                mTree.left = mergeTrees(t1.left, t2.left);\n                mTree.right = mergeTrees(t1.right, t2.right);\n                return mTree;\n            }\n            else{return t1;}\n        }\n        else return t2!=null?t2:null;\n    }\n}", "total_acs": 67419, "total_submitted": 99631}, {"id": 618, "title": "Students Report By Geography", "url": "https://leetcode.com/problems/students-report-by-geography/description", "companyTags": [""], "difficulty": "Hard", "content": "A U.S graduate school has students from Asia, Europe and America. The students' location information are stored in table student as below.\r\n \r\n\r\n| name   | continent |\r\n|--------|-----------|\r\n| Jack   | America   |\r\n| Pascal | Europe    |\r\n| Xi     | Asia      |\r\n| Jane   | America   |\r\n\r\n \r\n Pivot the continent column in this table so that each name is sorted alphabetically and displayed underneath its corresponding continent. The output headers should be America, Asia and Europe respectively. It is guaranteed that the student number from America is no less than either Asia or Europe.\r\n \r\nFor the sample input, the output is:\r\n\r\n| America | Asia | Europe |\r\n|---------|------|--------|\r\n| Jack    | Xi   | Pascal |\r\n| Jane    |      |        |\r\n\r\n \r\nFollow-up: If it is unknown which continent has the most students, can you write a query to generate the student report?", "discussUrl": "https://discuss.leetcode.com/category/783", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 727, "total_submitted": 1683}, {"id": 619, "title": "Biggest Single Number", "url": "https://leetcode.com/problems/biggest-single-number/description", "companyTags": [""], "difficulty": "Easy", "content": "\r\nTable number contains many numbers in column num including duplicated ones.\r\nCan you write a SQL query to find the biggest number, which only appears once.\r\n\r\n\r\n+---+\r\n|num|\r\n+---+\r\n| 8 |\r\n| 8 |\r\n| 3 |\r\n| 3 |\r\n| 1 |\r\n| 4 |\r\n| 5 |\r\n| 6 | \r\n\r\nFor the sample data above, your query should return the following result:\r\n\r\n+---+\r\n|num|\r\n+---+\r\n| 6 |\r\n\r\nNote: If there is no such number, just output null.", "discussUrl": "https://discuss.leetcode.com/category/784", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 2818, "total_submitted": 7866}, {"id": 620, "title": "Not Boring Movies", "url": "https://leetcode.com/problems/not-boring-movies/description", "companyTags": [""], "difficulty": "Easy", "content": "X city opened a new cinema, many people would like to go to this cinema.\r\nThe cinema also gives out a poster indicating the movies\u2019 ratings and descriptions. \r\n \r\nPlease write a SQL query to output movies with an odd numbered ID and a description that is not 'boring'. Order the result by rating.\r\n\r\n\r\nFor example, table cinema:\r\n\r\n+---------+-----------+--------------+-----------+\r\n|   id    | movie     |  description |  rating   |\r\n+---------+-----------+--------------+-----------+\r\n|   1     | War       |   great 3D   |   8.9     |\r\n|   2     | Science   |   fiction    |   8.5     |\r\n|   3     | irish     |   boring     |   6.2     |\r\n|   4     | Ice song  |   Fantacy    |   8.6     |\r\n|   5     | House card|   Interesting|   9.1     |\r\n+---------+-----------+--------------+-----------+\r\n\r\nFor the example above, the output should be:\r\n\r\n+---------+-----------+--------------+-----------+\r\n|   id    | movie     |  description |  rating   |\r\n+---------+-----------+--------------+-----------+\r\n|   5     | House card|   Interesting|   9.1     |\r\n|   1     | War       |   great 3D   |   8.9     |\r\n+---------+-----------+--------------+-----------+\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/786", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 18620, "total_submitted": 31374}, {"id": 621, "title": "Task Scheduler", "url": "https://leetcode.com/problems/task-scheduler/description", "companyTags": ["Facebook"], "difficulty": "Medium", "content": "Given a char array representing tasks CPU need to do. It contains capital letters A to Z where different letters represent different tasks.Tasks could be done without original order. Each task could be done in one interval. For each interval, CPU could finish one task or just be idle.\r\n\r\nHowever, there is a non-negative cooling interval n that means between two same tasks, there must be at least n intervals that CPU are doing different tasks or just be idle. \r\n\r\nYou need to return the least number of intervals the CPU will take to finish all the given tasks.\r\n\r\nExample 1:\r\n\r\nInput: tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2\r\nOutput: 8\r\nExplanation: A -> B -> idle -> A -> B -> idle -> A -> B.\r\n\r\n\r\n\r\nNote:\r\n\r\nThe number of tasks is in the range [1, 10000].\r\nThe integer n is in the range [0, 100].\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/787", "similarQuestions": ["RearrangeStringkDistanceApart", "ReorganizeString"], "topicTags": ["Array", "Greedy", "Queue"], "Solution": "class Solution {\n    public int leastInterval(char[] tasks, int n) {\n        int[] a = new int[26];\n        for (int i = 0; i < tasks.length; i++) {\n            a[tasks[i] - 'A']++;    \n        }\n        int max = 0;\n        int maxCount = 1;\n        for (int i = 0; i < 26; i++) {\n            if (a[i] > max) {\n                max = a[i];\n                maxCount = 1;\n            } else {\n                if (a[i] == max) {maxCount++;}\n            }\n        }\n        return Math.max(tasks.length, (max - 1) * (n + 1) + maxCount);\n    }\n}", "total_acs": 26034, "total_submitted": 60835}, {"id": 623, "title": "Add One Row to Tree", "url": "https://leetcode.com/problems/add-one-row-to-tree/description", "companyTags": ["GiltGroupe"], "difficulty": "Medium", "content": "Given the root of a binary tree, then value v and depth d, you need to add a row of nodes with value v at the given depth d. The root node is at depth 1. \r\n\r\nThe adding rule is: given a positive integer depth d, for each NOT null tree nodes N in depth d-1, create two tree nodes with value v as N's left subtree root and right subtree root. And N's original left subtree should be the left subtree of the new left subtree root, its original right subtree should be the right subtree of the new right subtree root. If depth d is 1 that means there is no depth d-1 at all, then create a tree node with value v as the new root of the whole original tree, and the original tree is the new root's left subtree.\r\n\r\nExample 1:\r\n\r\nInput: \r\nA binary tree as following:\r\n       4\r\n     /   \\\r\n    2     6\r\n   / \\   / \r\n  3   1 5   \r\n\r\nv = 1\r\n\r\nd = 2\r\n\r\nOutput: \r\n       4\r\n      / \\\r\n     1   1\r\n    /     \\\r\n   2       6\r\n  / \\     / \r\n 3   1   5   \r\n\r\n\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: \r\nA binary tree as following:\r\n      4\r\n     /   \r\n    2    \r\n   / \\   \r\n  3   1    \r\n\r\nv = 1\r\n\r\nd = 3\r\n\r\nOutput: \r\n      4\r\n     /   \r\n    2\r\n   / \\    \r\n  1   1\r\n /     \\  \r\n3       1\r\n\r\n\r\n\r\nNote:\r\n\r\nThe given d is in range [1, maximum depth of the given tree + 1].\r\nThe given binary tree has at least one tree node.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/789", "similarQuestions": [""], "topicTags": ["Tree"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode addOneRow(TreeNode root, int v, int d) {\n        if (d < 1) {\n            return root;\n        }\n        if (d == 1)  {\n            TreeNode row = new TreeNode(v);\n            row.left = root;\n            return row;\n        }\n        \n        addOneRow(root, v, d, null);\n        return root;\n    }\n    \n    private void addOneRow(TreeNode root, int v, int d, TreeNode parent) {\n        if (d == 1) {\n            if (parent != null) {\n                if (parent.left == root) {\n                    parent.left = new TreeNode(v);\n                    parent.left.left = root;\n                } else {\n                    parent.right = new TreeNode(v);\n                    parent.right.right = root;\n                }\n            }\n            return;\n        }\n        if (root == null) {\n            return;\n        }\n        addOneRow(root.left, v, d-1, root);\n        addOneRow(root.right, v, d-1, root);\n    }\n}", "total_acs": 13102, "total_submitted": 28319}, {"id": 624, "title": "Maximum Distance in Arrays", "url": "https://leetcode.com/problems/maximum-distance-in-arrays/description", "companyTags": ["Yahoo"], "difficulty": "Easy", "content": "\r\nGiven m arrays, and each array is sorted in ascending order. Now you can pick up two integers from two different arrays (each array picks one) and calculate the distance. We define the distance between two integers a and b to be their absolute difference |a-b|. Your task is to find the maximum distance.\r\n\r\n\r\nExample 1:\r\n\r\nInput: \r\n[[1,2,3],\r\n [4,5],\r\n [1,2,3]]\r\nOutput: 4\r\nExplanation: \r\nOne way to reach the maximum distance 4 is to pick 1 in the first or third array and pick 5 in the second array.\r\n\r\n\r\n\t\r\nNote:\r\n\r\nEach given array will have at least 1 number. There will be at least two non-empty arrays.\r\nThe total number of the integers in all the m arrays will be in the range of [2, 10000].\r\nThe integers in the m arrays will be in the range of [-10000, 10000].\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/790", "similarQuestions": [""], "topicTags": ["Array", "HashTable"], "Solution": "class Solution {\n    public int maxDistance(List<List<Integer>> arrays) {\n        int min1 = Integer.MAX_VALUE;\n        int min2 = Integer.MAX_VALUE;\n        int max1 = Integer.MIN_VALUE;\n        int max2 = Integer.MIN_VALUE;\n        int idxMin1 = 0;\n        int idxMin2 = 0;\n        int idxMax1 = 0;\n        int idxMax2 = 0;\n        \n        for (int i = 0; i < arrays.size(); i++) {\n            List<Integer> list = arrays.get(i);\n            int min = list.get(0);\n            int max = list.get(list.size() - 1);\n            if (min < min1) {\n                min2 = min1;\n                idxMin2 = idxMin1;\n                min1 = min;\n                idxMin1 = i;\n            } else if (min < min2) {\n                min2 = min;\n                idxMin2 = i;\n            }\n            \n            if (max > max1) {\n                max2 = max1;\n                idxMax2 = idxMax1;\n                max1 = max;\n                idxMax1 = i;\n            } else if (max > max2) {\n                max2 = max;\n                idxMax2 = i;\n            }\n        }\n        \n        if (idxMin1 != idxMax1) return max1 - min1;\n        else return Math.max(max1 - min2, max2 - min1);\n    }\n}", "total_acs": 9695, "total_submitted": 27724}, {"id": 625, "title": "Minimum Factorization", "url": "https://leetcode.com/problems/minimum-factorization/description", "companyTags": ["Tencent"], "difficulty": "Medium", "content": "Given a positive integer a, find the smallest positive integer b whose multiplication of each digit equals to a. \r\n\r\n\r\nIf there is no answer or the answer is not fit in 32-bit signed integer, then return 0.\r\n\r\n\r\nExample 1\r\nInput:\r\n48 \r\nOutput:\r\n68\r\n\r\n\r\n\r\nExample 2\r\nInput: \r\n15\r\n\r\nOutput:\r\n35\r\n", "discussUrl": "https://discuss.leetcode.com/category/791", "similarQuestions": [""], "topicTags": ["Math", "Recursion"], "Solution": "class Solution {\n    public int smallestFactorization(int a) {\n        if(a <= 2) {\n            return a;\n        }\n        long k = 1;\n        long sum = 0;\n        for (int i = 9; i >1;i--) {\n            while (a % i == 0) {\n                sum = sum+i*k;\n                a =a/i;\n                k=k*10;\n            }\n        }\n        return a<2 && sum < Integer.MAX_VALUE? (int)sum: 0;\n    }\n}", "total_acs": 4333, "total_submitted": 13867}, {"id": 626, "title": "Exchange Seats", "url": "https://leetcode.com/problems/exchange-seats/description", "companyTags": [""], "difficulty": "Medium", "content": "Mary is a teacher in a middle school and she has a table seat storing students' names and their corresponding seat ids.\r\nThe column id is continuous increment.\r\nMary wants to change seats for the adjacent students.\r\nCan you write a SQL query to output the result for Mary?\r\n\r\n+---------+---------+\r\n|    id   | student |\r\n+---------+---------+\r\n|    1    | Abbot   |\r\n|    2    | Doris   |\r\n|    3    | Emerson |\r\n|    4    | Green   |\r\n|    5    | Jeames  |\r\n+---------+---------+\r\n\r\nFor the sample input, the output is:\r\n\r\n+---------+---------+\r\n|    id   | student |\r\n+---------+---------+\r\n|    1    | Doris   |\r\n|    2    | Abbot   |\r\n|    3    | Green   |\r\n|    4    | Emerson |\r\n|    5    | Jeames  |\r\n+---------+---------+\r\n\r\n\r\nNote:\r\nIf the number of students is odd, there is no need to change the last one's seat.\r\n", "discussUrl": "https://discuss.leetcode.com/category/793", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 4683, "total_submitted": 9727}, {"id": 627, "title": "Swap Salary", "url": "https://leetcode.com/problems/swap-salary/description", "companyTags": [""], "difficulty": "Easy", "content": "Given a table salary, such as the one below, that has m=male and  f=female values. Swap all f and m values (i.e., change all f values to m and vice versa) with a single update query and no intermediate temp table.\r\n \r\nFor example:\r\n \r\n\r\n| id | name | sex | salary |\r\n|----|------|-----|--------|\r\n| 1  | A    | m   | 2500   |\r\n| 2  | B    | f   | 1500   |\r\n| 3  | C    | m   | 5500   |\r\n| 4  | D    | f   | 500    |\r\n\r\nAfter running your query, the above salary table should have the following rows:\r\n\r\n| id | name | sex | salary |\r\n|----|------|-----|--------|\r\n| 1  | A    | f   | 2500   |\r\n| 2  | B    | m   | 1500   |\r\n| 3  | C    | f   | 5500   |\r\n| 4  | D    | m   | 500    |\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/794", "similarQuestions": [""], "topicTags": [""], "Solution": null, "total_acs": 20073, "total_submitted": 29891}, {"id": 628, "title": "Maximum Product of Three Numbers", "url": "https://leetcode.com/problems/maximum-product-of-three-numbers/description", "companyTags": ["Intuit"], "difficulty": "Easy", "content": "Given an integer array, find three numbers whose product is maximum and output the maximum product.\r\n\r\nExample 1:\r\n\r\nInput: [1,2,3]\r\nOutput: 6\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: [1,2,3,4]\r\nOutput: 24\r\n\r\n\r\n\r\nNote:\r\n\r\nThe length of the given array will be in range [3,104] and all elements are in the range [-1000, 1000].\r\nMultiplication of any three numbers in the input won't exceed the range of 32-bit signed integer.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/795", "similarQuestions": ["MaximumProductSubarray"], "topicTags": ["Array", "Math"], "Solution": "class Solution {\n    public int maximumProduct(int[] nums) {\n        int min1 = Integer.MAX_VALUE;\n        int min2 = Integer.MAX_VALUE;\n        int max1 = Integer.MIN_VALUE;\n        int max2 = Integer.MIN_VALUE;\n        int max3 = Integer.MIN_VALUE;\n        for (int i : nums) {\n            if (i > max1) {\n                max3 = max2;\n                max2 = max1;\n                max1 = i;\n            } else if (i > max2) {\n                max3 = max2;\n                max2 = i;\n            } else if (i > max3) {\n                max3 = i;\n            }\n            if (i < min1) {\n                min2 = min1;\n                min1 = i;\n            } else if (i < min2) {\n                min2 = i;\n            }\n        }\n        return Math.max(min1 * min2 * max1, max1 * max2 * max3);\n    }\n}", "total_acs": 29856, "total_submitted": 66736}, {"id": 629, "title": "K Inverse Pairs Array", "url": "https://leetcode.com/problems/k-inverse-pairs-array/description", "companyTags": ["WorksApplications"], "difficulty": "Hard", "content": "\r\nGiven two integers n and k, find how many different arrays consist of numbers from 1 to n such that there are exactly k inverse pairs. \r\n\r\n\r\nWe define an inverse pair as following:\r\nFor ith and jth element in the array, if i < j and a[i] > a[j] then it's an inverse pair; Otherwise, it's not.\r\n\r\n\r\n\r\nSince the answer may be very large, the answer should be modulo 109 + 7.\r\n\r\n\r\nExample 1:\r\n\r\nInput: n = 3, k = 0\r\nOutput: 1\r\nExplanation: \r\nOnly the array [1,2,3] which consists of numbers from 1 to 3 has exactly 0 inverse pair.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: n = 3, k = 1\r\nOutput: 2\r\nExplanation: \r\nThe array [1,3,2] and [2,1,3] have exactly 1 inverse pair.\r\n\r\n\r\n\r\nNote:\r\n\r\nThe integer n is in the range [1, 1000] and k is in the range [0, 1000].\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/796", "similarQuestions": [""], "topicTags": ["DynamicProgramming"], "Solution": "class Solution {\n    private static final int MOD = 1000_000_000 + 7;\n    \n    public int kInversePairs(int n, int k) {\n        int[] d = new int[k + 1];\n        d[0] = 1;\n        for (int i = 2; i <= n; i++) {\n            for (int j = 0; j < k; j++) {\n                d[j + 1] = (d[j + 1] + d[j]) % MOD;\n            }\n            for (int j = k; j >= i; j--) {\n                d[j] = (d[j] - d[j - i] + MOD) % MOD;\n            }\n        }\n        return d[k];\n    }\n}", "total_acs": 4407, "total_submitted": 16455}, {"id": 630, "title": "Course Schedule III", "url": "https://leetcode.com/problems/course-schedule-iii/description", "companyTags": ["WAP"], "difficulty": "Hard", "content": "\r\nThere are n different online courses numbered from 1 to n. Each course has some duration(course length)  t and closed on dth day. A course should be taken continuously for t days and must be finished before or on the dth day. You will start at the 1st day.\r\n\r\n\r\n\r\nGiven n online courses represented by pairs (t,d), your task is to find the maximal number of courses that can be taken.\r\n\r\n\r\n\r\nExample:\r\n\r\nInput: [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]\r\nOutput: 3\r\nExplanation: \r\nThere're totally 4 courses, but you can take 3 courses at most:\r\nFirst, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day.\r\nSecond, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day. \r\nThird, take the 2nd course, it costs 200 days so you will finish it on the 1300th day. \r\nThe 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date.\r\n\r\n\r\n\r\n\r\nNote:\r\n\r\nThe integer 1 <= d, t, n <= 10,000. \r\nYou can't take two courses simultaneously.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/797", "similarQuestions": ["CourseSchedule", "CourseScheduleII"], "topicTags": ["Greedy"], "Solution": "class Solution {\n    void qsort(int l , int r , int[][] courses){   \n        int i = l, j = r, mid = courses[(l+r)/2][1];\n        while (i<j)\n        {\n            while (courses[i][1]<mid) i++;\n            while (courses[j][1]>mid) j--;\n            if (i<=j)\n            {\n                int[] tmp = courses[i];\n                courses[i] = courses[j];\n                courses[j] = tmp;\n                i++;\n                j--;\n            }\n\n        }\n        if (i<r) qsort(i,r,courses);\n        if (j>l) qsort(l,j,courses);\n    }\n    public int scheduleCourse(int[][] courses) {\n        int len = courses.length;\n        qsort(0,len-1,courses);\n        //Arrays.sort(courses,(a,b)->(a[1]-b[1]));\n        int[] queue = new int[len];\n        int sum = 0;\n        int mark = 0;\n        for (int i = 0;i<len;i++)\n        {\n            if (sum+courses[i][0]<=courses[i][1])\n            {\n                sum+=courses[i][0];\n                queue[mark++] = courses[i][0];\n                int now = mark-1;\n                while ((now+1)/2-1>=0&&queue[now]>queue[(now+1)/2-1])\n                {\n                    int tmp = queue[now];\n                    queue[now] = queue[(now+1)/2-1];\n                    queue[(now+1)/2-1] = tmp;\n                    now = (now+1)/2-1;\n                }\n            }\n            else\n            {\n                if (queue[0]>courses[i][0])\n                {\n                    sum+=courses[i][0]-queue[0];\n                    queue[0] = courses[i][0];\n                    int now = 0;\n                    while (((now+1)*2<mark&&queue[now]<queue[(now+1)*2])||((now+1)*2-1<mark&&queue[now]<queue[(now+1)*2-1]))\n                    {\n                        if ((now+1)*2<mark)\n                        {\n                            if (queue[(now+1)*2-1]>queue[(now+1)*2])\n                            {\n                                int tmp = queue[(now+1)*2-1];\n                                queue[(now+1)*2-1] = queue[now];\n                                queue[now] = tmp;\n                                now = (now+1)*2-1;\n                            }\n                            else\n                            {\n                                int tmp = queue[(now+1)*2];\n                                queue[(now+1)*2] = queue[now];\n                                queue[now] = tmp;\n                                now = (now+1)*2;\n                            }\n                        }\n                        else\n                        {\n                            int tmp = queue[(now+1)*2-1];\n                                queue[(now+1)*2-1] = queue[now];\n                                queue[now] = tmp;\n                                now = (now+1)*2-1;\n                        }\n                    }\n                }\n            }\n        }\n        return mark;\n    }\n}", "total_acs": 5088, "total_submitted": 17474}, {"id": 631, "title": "Design Excel Sum Formula", "url": "https://leetcode.com/problems/design-excel-sum-formula/description", "companyTags": ["Microsoft"], "difficulty": "Hard", "content": "Your task is to design the basic function of Excel and implement the function of sum formula.  Specifically, you need to implement the following functions:\r\n\r\n\r\n\r\nExcel(int H, char W): This is the constructor. The inputs represents the height and width of the Excel form. H is a positive integer, range from 1 to 26. It represents the height. W is a character range from 'A' to 'Z'. It represents that the width is the number of characters from 'A' to W. The Excel form content is represented by a height * width 2D integer array C, it should be initialized to zero. You should assume that the first row of C starts from 1, and the first column of C starts from 'A'.\r\n\r\n\r\n\r\nvoid Set(int row, char column, int val): Change the value at C(row, column) to be val.\r\n\r\nint Get(int row, char column): Return the value at C(row, column).\r\n\r\nint Sum(int row, char column, List of Strings : numbers): This function calculate and set the value at C(row, column), where the value should be the sum of cells represented by numbers. This function return the sum result at C(row, column). This sum formula should exist until this cell is overlapped by another value or another sum formula.\r\n\r\nnumbers is a list of strings that each string represent a cell or a range of cells. If the string represent a single cell, then it has the following format : ColRow. For example, \"F7\" represents the cell at (7, F). \r\n\r\nIf the string represent a range of cells, then it has the following format : ColRow1:ColRow2. The range will always be a rectangle, and ColRow1 represent the position of the top-left cell, and ColRow2 represents the position of the bottom-right cell. \r\n\r\nExample 1:\r\n\r\nExcel(3,\"C\"); \r\n// construct a 3*3 2D array with all zero.\r\n//   A B C\r\n// 1 0 0 0\r\n// 2 0 0 0\r\n// 3 0 0 0\r\n\r\nSet(1, \"A\", 2);\r\n// set C(1,\"A\") to be 2.\r\n//   A B C\r\n// 1 2 0 0\r\n// 2 0 0 0\r\n// 3 0 0 0\r\n\r\nSum(3, \"C\", [\"A1\", \"A1:B2\"]);\r\n// set C(3,\"C\") to be the sum of value at C(1,\"A\") and the values sum of the rectangle range whose top-left cell is C(1,\"A\") and bottom-right cell is C(2,\"B\"). Return 4. \r\n//   A B C\r\n// 1 2 0 0\r\n// 2 0 0 0\r\n// 3 0 0 4\r\n\r\nSet(2, \"B\", 2);\r\n// set C(2,\"B\") to be 2. Note C(3, \"C\") should also be changed.\r\n//   A B C\r\n// 1 2 0 0\r\n// 2 0 2 0\r\n// 3 0 0 6\r\n\r\n\r\n\r\nNote:\r\n\r\nYou could assume that there won't be any circular sum reference. For example, A1 = sum(B1) and B1 = sum(A1).\r\n The test cases are using double-quotes to represent a character.\r\nPlease remember to RESET your class variables declared in class Excel, as static/class variables are persisted across multiple test cases. Please see here for more details.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/798", "similarQuestions": [""], "topicTags": ["Design"], "Solution": "import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * @author jacka\n * @version 1.0 on 11/2/2017.\n */\npublic final class Excel {\n  private static final int N = 27;\n  private final int[][] values;\n  private final Map<Coordinate, Set<Coordinate>> cellToSum;\n  private final Map<Coordinate, Map<Coordinate, Integer>> sumToCell;\n\n  public Excel(int H, char W) {\n    values = new int[H + 1][W - 'A' + 1];\n    cellToSum = new HashMap<>();\n    sumToCell = new HashMap<>();\n  }\n\n  public void set(int r, char c, int v) {\n    final int col = getCol(c);\n    final Coordinate sumNode = new Coordinate(r, col);\n    if (sumToCell.containsKey(sumNode)) { // no longer a sum, reset\n      Set<Coordinate> removed = sumToCell.remove(sumNode).keySet();\n      for (Coordinate removedNode: removed) {\n        cellToSum.get(removedNode).remove(sumNode);\n      }\n    }\n    updateSum(r, col, v - values[r][col]);\n    values[r][col] = v;\n  }\n\n  private void updateSum(int row, int col, int delta) {\n    final Coordinate curCell = new Coordinate(row, col);\n    if (cellToSum.containsKey(curCell)) {\n      Set<Coordinate> sumSet = cellToSum.get(curCell); // getOrDefault\n      for (Coordinate sum : sumSet) {\n        final int times = sumToCell.get(sum).get(curCell);\n        values[sum.row][sum.col] += delta * times;\n        updateSum(sum.row, sum.col, delta * times); // recursive find the sum cell\n\n      }\n    }\n  }\n\n  public int get(int r, char c) {\n    return values[r][getCol(c)];\n  }\n\n  public int sum(int r, char c, String[] strs) {\n    int sum = 0;\n    final Coordinate sumCell = new Coordinate(r, getCol(c));\n    sumToCell.putIfAbsent(sumCell, new HashMap<>());\n    final Map<Coordinate, Integer> sumCellMap = sumToCell.get(sumCell);\n    for (String coordinator: strs) {\n      if (!coordinator.contains(\":\")) {\n        Coordinate coordinate = getCoordinator(coordinator);\n        sum += values[coordinate.row][coordinate.col];\n        cellToSum.putIfAbsent(coordinate, new HashSet<>());\n        cellToSum.get(coordinate).add(sumCell);\n        sumCellMap.put(coordinate, sumCellMap.getOrDefault(coordinate, 0) + 1);\n      } else {\n        String[] coordinatorStrs = coordinator.split(\":\");\n        Coordinate leftTop = getCoordinator(coordinatorStrs[0]);\n        Coordinate rightBottom = getCoordinator(coordinatorStrs[1]);\n        for (int row = leftTop.row; row <= rightBottom.row; row++) {\n          for (int col = leftTop.col; col <= rightBottom.col; col++) {\n            final Coordinate curCell = new Coordinate(row, col);\n            sum += values[row][col];\n            cellToSum.putIfAbsent(curCell , new HashSet<>());\n            cellToSum.get(curCell).add(sumCell);\n            sumCellMap.put(curCell, sumCellMap.getOrDefault(curCell, 0) + 1);\n          }\n        }\n      }\n    }\n    values[r][getCol(c)] = sum;\n    return sum;\n  }\n\n  /**\n   * A1 or B2\n   * @param coordinator\n   * @return\n   */\n  private Coordinate getCoordinator(String coordinator) {\n    final int col = getCol(coordinator.charAt(0));\n    final int row = Integer.parseInt(coordinator.substring(1));\n    return new Coordinate(row, col);\n  }\n\n  private static int getCol(char c) {\n    return c - 'A';\n  }\n\n  private static final class Coordinate {\n    private final int row;\n    private final int col;\n\n    Coordinate(int row, int col) {\n      this.row = row;\n      this.col = col;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (!(o instanceof Coordinate)) {\n        return false;\n      }\n\n      Coordinate that = (Coordinate) o;\n\n      return row == that.row && col == that.col;\n    }\n\n    @Override\n    public int hashCode() {\n      int result = row;\n      result = 31 * result + col;\n      return result;\n    }\n\n    @Override\n    public String toString() {\n      return \"Coordinate{\" +\n          \"row=\" + row +\n          \", col=\" + col +\n          '}';\n    }\n  }\n}\n", "total_acs": 1694, "total_submitted": 6126}, {"id": 632, "title": "Smallest Range", "url": "https://leetcode.com/problems/smallest-range/description", "companyTags": ["Lyft"], "difficulty": "Hard", "content": "You have k lists of sorted integers in ascending order. Find the smallest range that includes at least one number from each of the k lists. \r\n\r\nWe define the range [a,b] is smaller than range [c,d] if b-a < d-c or a < c if b-a == d-c.\r\n\r\nExample 1:\r\n\r\nInput:[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]\r\nOutput: [20,24]\r\nExplanation: \r\nList 1: [4, 10, 15, 24,26], 24 is in range [20,24].\r\nList 2: [0, 9, 12, 20], 20 is in range [20,24].\r\nList 3: [5, 18, 22, 30], 22 is in range [20,24].\r\n\r\n\r\n\r\n\r\nNote:\r\n\r\nThe given list may contain duplicates, so ascending order means >= here.\r\n1 <= k <= 3500\r\n -105 <= value of elements <= 105.\r\nFor Java users, please note that the input type has been changed to List<List<Integer>>. And after you reset the code template, you'll see this point.\r\n\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/800", "similarQuestions": ["MinimumWindowSubstring"], "topicTags": ["HashTable", "TwoPointers", "String"], "Solution": "/*\nclass Solution {\n    public static int[] smallestRange(List<List<Integer>> nums) {\n        int[] result = new int[2];\n        if(nums == null) return result;\n        int min = Integer.MAX_VALUE;\n        int max = Integer.MIN_VALUE;\n        for(List<Integer> num : nums) {\n            min = Math.min(min, num.get(0));\n            max = Math.max(max, num.get(num.size() - 1));\n        }\n        int length = Integer.MAX_VALUE;\n        int left = min; int right = min;\n        boolean marked = true;\n        while(left <= max) {\n            for(List<Integer> num : nums) {\n                boolean temp = false;\n                for(int member : num) {\n                    temp = temp || (member >= left && member <= right);\n                }\n                marked = marked && temp;\n            }\n            while(!marked && right <= max) {\n                right++;\n                marked = true;\n                for(List<Integer> num : nums) {\n                    boolean temp = false;\n                    for(int member : num) {\n                        temp = temp || (member >= left && member <= right);\n                    }\n                    marked = marked && temp;\n                }\n            }\n            if(marked) {\n                if(length > right - left + 1) {\n                    length = right - left + 1;\n                    result[0] = left;\n                    result[1] = right;\n                }\n            }\n            left++;\n            for(List<Integer> num : nums) {\n                boolean temp = false;\n                for(int member : num) {\n                    temp = temp || (member >= left && member <= right);\n                }\n                marked = marked && temp;\n            }\n        }\n        return result;\n    }\n}\n*/\n/*\nclass Solution {\n    public int[] smallestRange(List<List<Integer>> nums) {\n    int[] result = new int[2];\n    TreeSet<Pair> tree = new TreeSet<>();\n    for (List<Integer> list : nums) {\n      tree.add(new Pair(list));\n    }\n    int smallestRange = Integer.MAX_VALUE;\n    while (true) {\n      Pair first = tree.first();\n      Pair last = tree.last();\n      if (last.getValue() - first.getValue() < smallestRange) {\n        smallestRange = last.getValue() - first.getValue();\n        result[0] = first.getValue();\n        result[1] = last.getValue();\n      }\n      Pair pair = tree.pollFirst();\n      if (pair.increment()) {\n        tree.add(pair);\n      } else {\n        break;\n      }\n    }\n    return result;\n  }\n\n  public static class Pair implements Comparable<Pair> {\n    private List<Integer> list;\n    private int index;\n\n    public Pair(List<Integer> list) {\n      this.list = list;\n    }\n\n    public boolean increment() {\n      if (index < list.size() - 1) {\n        ++index;\n        return true;\n      }\n      return false;\n    }\n\n    public int getValue() {\n      return list.get(index);\n    }\n\n    @Override\n    public int compareTo(Pair o) {\n      int i = list.get(index) - o.list.get(o.index);\n      return i == 0 ? 1 : i;\n    }\n  }\n}\n*/\nclass Solution {\n    public int[] smallestRange(final List<List<Integer>> list) {\n        final int[][] nums = toArray(list);\n        final int k = nums.length;\n\n        int maxValue = Integer.MIN_VALUE;\n        for(int i=0; i<k; i++) {\n            maxValue = Math.max(maxValue, nums[i][0]);\n        }\n        \n        int[] pointers = new int[k];\n        \n        int[] result = new int[2];\n        int range = Integer.MAX_VALUE;\n        \n        while(true) {\n            int minIndex = 0;\n            int minValue = Integer.MAX_VALUE;\n            for(int i=0; i<k; i++) {\n                int index = pointers[i];\n                while(index + 1 < nums[i].length && nums[i][index + 1] <= maxValue) {\n                    index++;\n                }\n                pointers[i] = index;\n                if(nums[i][index] < minValue) {\n                    minIndex = i;\n                    minValue = nums[i][index];\n                }\n            }\n            if(maxValue - minValue < range) {\n                result = new int[]{minValue, maxValue};\n                range = maxValue - minValue;\n            }\n            \n            int minPointer = ++pointers[minIndex];\n            if(minPointer == nums[minIndex].length) {\n                return result;\n            }\n            maxValue = nums[minIndex][minPointer];\n        }\n    }\n    private int[][] toArray(List<List<Integer>> list) {\n        int[][] nums = new int[list.size()][];\n        for(int i=0; i<nums.length; i++) {\n            nums[i] = new int[list.get(i).size()];\n            for(int j=0; j<nums[i].length; j++) {\n                nums[i][j] = list.get(i).get(j);\n            }\n        }\n        return nums;\n    }\n}\n", "total_acs": 7746, "total_submitted": 18355}, {"id": 633, "title": "Sum of Square Numbers", "url": "https://leetcode.com/problems/sum-of-square-numbers/description", "companyTags": ["LinkedIn"], "difficulty": "Easy", "content": "\r\nGiven a non-negative integer c, your task is to decide whether there're two integers a and b such that a2 + b2 = c.\r\n\r\n\r\nExample 1:\r\n\r\nInput: 5\r\nOutput: True\r\nExplanation: 1 * 1 + 2 * 2 = 5\r\n\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: 3\r\nOutput: False\r\n\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/801", "similarQuestions": ["ValidPerfectSquare"], "topicTags": ["Math"], "Solution": "class Solution {\n    /*\n    public boolean judgeSquareSum(int c) {\n        double sqrt = Math.sqrt(c);\n        if(sqrt % 1==0) return true;\n        int left=1,right = (int)Math.floor(sqrt);\n        while(left<=right){\n            int pro = left*left+right*right;\n            if(pro<c){\n                left++;\n            }else if(pro>c){\n                right--;\n            }else{\n                return true;\n            }\n        }\n        return false;\n    }*/\n    \n     public boolean judgeSquareSum(int c) {\n        for (int i = 2; i * i <= c; i++) {\n            int count = 0;\n            if (c % i == 0) {\n                while (c % i == 0) {\n                    count++;\n                    c /= i;\n                }\n                if (i % 4 == 3 && count % 2 != 0)\n                    return false;\n            }\n        }\n        return c % 4 != 3;\n    }\n\n}", "total_acs": 19715, "total_submitted": 60809}, {"id": 634, "title": "Find the Derangement of An Array", "url": "https://leetcode.com/problems/find-the-derangement-of-an-array/description", "companyTags": ["IXL"], "difficulty": "Medium", "content": "\r\nIn combinatorial mathematics, a derangement is a permutation of the elements of a set, such that no element appears in its original position.\r\n\r\n\r\n\r\nThere's originally an array consisting of n integers from 1 to n in ascending order, you need to find the number of derangement it can generate.\r\n\r\n\r\n\r\nAlso, since the answer may be very large, you should return the output mod 109 + 7.\r\n\r\n\r\nExample 1:\r\n\r\nInput: 3\r\nOutput: 2\r\nExplanation: The original array is [1,2,3]. The two derangements are [2,3,1] and [3,1,2].\r\n\r\n\r\n\r\nNote:\r\nn is in the range of [1, 106].\r\n", "discussUrl": "https://discuss.leetcode.com/category/802", "similarQuestions": [""], "topicTags": ["Math"], "Solution": "class Solution {\n    private static final long MOD = 1000000007;\n    public int findDerangement(int n) {\n        if(n <= 1) return 0;\n        long pre = 0, now = 1;\n        for(int i=3; i<=n; i++) {\n            long newOne = (pre + now) * (i-1) % MOD;\n            pre = now;\n            now = newOne;\n        }\n        \n        return (int)now;\n    }\n}", "total_acs": 3112, "total_submitted": 8786}, {"id": 635, "title": "Design Log Storage System", "url": "https://leetcode.com/problems/design-log-storage-system/description", "companyTags": ["Snapchat"], "difficulty": "Medium", "content": "You are given several logs that each log contains a unique id and timestamp. Timestamp is a string that has the following format: Year:Month:Day:Hour:Minute:Second, for example, 2017:01:01:23:59:59. All domains are zero-padded decimal numbers. \r\n\r\nDesign a log storage system to implement the following functions:\r\n\r\nvoid Put(int id, string timestamp): Given a log's unique id and timestamp, store the log in your storage system.\r\n\r\nint[] Retrieve(String start, String end, String granularity): Return the id of logs whose timestamps are within the range from start to end. Start and end all have the same format as timestamp. However, granularity means the time level for consideration. For example, start = \"2017:01:01:23:59:59\", end = \"2017:01:02:23:59:59\", granularity = \"Day\", it means that we need to find the logs within the range from Jan. 1st 2017 to Jan. 2nd 2017.\r\n\r\nExample 1:\r\n\r\nput(1, \"2017:01:01:23:59:59\");\r\nput(2, \"2017:01:01:22:59:59\");\r\nput(3, \"2016:01:01:00:00:00\");\r\nretrieve(\"2016:01:01:01:01:01\",\"2017:01:01:23:00:00\",\"Year\"); // return [1,2,3], because you need to return all logs within 2016 and 2017.\r\nretrieve(\"2016:01:01:01:01:01\",\"2017:01:01:23:00:00\",\"Hour\"); // return [1,2], because you need to return all logs start from 2016:01:01:01 to 2017:01:01:23, where log 3 is left outside the range.\r\n\r\n\r\n\r\nNote:\r\n\r\nThere will be at most 300 operations of Put or Retrieve.\r\nYear ranges from [2000,2017]. Hour ranges from [00,23].\r\nOutput for Retrieve has no order required.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/803", "similarQuestions": ["DesignIn-MemoryFileSystem"], "topicTags": ["String", "Design"], "Solution": "class LogSystem {\n    HashMap<Integer, String> entries; \n    HashMap<String, Integer> indices; \n    public LogSystem() {\n        entries = new HashMap<>();\n        indices = new HashMap<>();\n        indices.put(\"Year\", 4);\n        indices.put(\"Month\", 7);\n        indices.put(\"Day\", 10);\n        indices.put(\"Hour\", 13);\n        indices.put(\"Minute\", 16);\n        indices.put(\"Second\", 19);\n    }\n    \n    public void put(int id, String timestamp) {\n        entries.put(id, timestamp);\n    }\n    \n    public List<Integer> retrieve(String s, String e, String gra) {\n        List<Integer> result = new LinkedList<Integer>();\n        int index = indices.get(gra);\n        \n        for (Integer i : entries.keySet()) {\n            if (entries.get(i).substring(0, index).compareTo(s.substring(0, index)) >= 0 && entries.get(i).substring(0, index).compareTo(e.substring(0, index)) <= 0)  {\n                result.add(i);\n            }\n        }\n        return result;\n    }\n}\n\n/**\n * Your LogSystem object will be instantiated and called as such:\n * LogSystem obj = new LogSystem();\n * obj.put(id,timestamp);\n * List<Integer> param_2 = obj.retrieve(s,e,gra);\n */", "total_acs": 4309, "total_submitted": 8719}, {"id": 636, "title": "Exclusive Time of Functions", "url": "https://leetcode.com/problems/exclusive-time-of-functions/description", "companyTags": ["Facebook", "Uber"], "difficulty": "Medium", "content": "Given the running logs of n functions that are executed in a nonpreemptive single threaded CPU, find the exclusive time of these functions. \r\n\r\nEach function has a unique id, start from 0 to n-1. A function may be called recursively or by another function.\r\n\r\nA log is a string has this format : function_id:start_or_end:timestamp. For example, \"0:start:0\" means function 0 starts from the very beginning of time 0. \"0:end:0\" means function 0 ends to the very end of time 0. \r\n\r\nExclusive time of a function is defined as the time spent within this function, the time spent by calling other functions should not be considered as this function's exclusive time. You should return the exclusive time of each function sorted by their function id.\r\n\r\nExample 1:\r\n\r\nInput:\r\nn = 2\r\nlogs = \r\n[\"0:start:0\",\r\n \"1:start:2\",\r\n \"1:end:5\",\r\n \"0:end:6\"]\r\nOutput:[3, 4]\r\nExplanation:\r\nFunction 0 starts at time 0, then it executes 2 units of time and reaches the end of time 1. \r\nNow function 0 calls function 1, function 1 starts at time 2, executes 4 units of time and end at time 5.\r\nFunction 0 is running again at time 6, and also end at the time 6, thus executes 1 unit of time. \r\nSo function 0 totally execute 2 + 1 = 3 units of time, and function 1 totally execute 4 units of time.\r\n\r\n\r\n\r\nNote:\r\n\r\nInput logs will be sorted by timestamp, NOT log id.\r\nYour output should be sorted by function id, which means the 0th element of your output corresponds to the exclusive time of function 0.\r\nTwo functions won't start or end at the same time.\r\nFunctions could be called recursively, and will always end.\r\n1 <= n <= 100\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/806", "similarQuestions": [""], "topicTags": ["Stack"], "Solution": "class Solution {\n    public int[] exclusiveTime(int n, List<String> logs) {\n        int[] res = new int[n];\n        Deque<int[]> deque = new LinkedList<int[]>();\n        for (String log : logs) {\n            int index_1 = log.indexOf(\":\");\n            int index_2 = log.indexOf(\":\", index_1 + 1);\n            int curNum = Integer.parseInt(log.substring(0, index_1));\n            int curTimestamp = Integer.parseInt(log.substring(index_2 + 1, log.length()));\n            if (index_2 - index_1 > 5) {\n                if (!deque.isEmpty()) {\n                    int[] top = deque.peek();\n                    res[top[0]] += curTimestamp - top[1];\n                }\n                deque.push(new int[] {curNum, curTimestamp});\n            } else {\n                int[] top = deque.poll();\n                res[curNum] += curTimestamp - top[1] + 1;\n                if (!deque.isEmpty()) {\n                    top = deque.peek();\n                    top[1] = curTimestamp + 1;\n                }\n            }\n        }\n        return res;\n    }\n}", "total_acs": 12376, "total_submitted": 27877}, {"id": 637, "title": "Average of Levels in Binary Tree", "url": "https://leetcode.com/problems/average-of-levels-in-binary-tree/description", "companyTags": ["Facebook"], "difficulty": "Easy", "content": "Given a non-empty binary tree, return the average value of the nodes on each level in the form of an array.\r\n\r\nExample 1:\r\n\r\nInput:\r\n    3\r\n   / \\\r\n  9  20\r\n    /  \\\r\n   15   7\r\nOutput: [3, 14.5, 11]\r\nExplanation:\r\nThe average value of nodes on level 0 is 3,  on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11].\r\n\r\n\r\n\r\nNote:\r\n\r\nThe range of node's value is in the range of 32-bit signed integer.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/807", "similarQuestions": ["BinaryTreeLevelOrderTraversal", "BinaryTreeLevelOrderTraversalII"], "topicTags": ["Tree"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nimport  java.util.ArrayList;\nclass Solution {\n    public static   long[] sum;\n    public static   int[] count;\n    public static   int d;\n   \n    public List<Double> averageOfLevels(TreeNode root) {\n        d = 1;\n        depth(root,1);\n        sum = new long[d+5];\n        count = new int[d+5];\n        ArrayList<Double> list = new ArrayList<Double>();\n        func(root,1);\n        for(int i = 1;i<= d && count[i]!=0;i++){\n            \n            list.add(sum[i]*1.0/count[i]);\n        }\n        return list;\n        \n    }\n     public static void depth(TreeNode root,int x){\n        \td = Math.max(x,d);\n        \tif(root.left!=null) depth(root.left,x+1);            \n        \tif(root.right!=null) depth(root.right,x+1);              \n    }\n\n    public static void func(TreeNode x,int y){\n       sum[y] += x.val;\n       count[y]++;\n        if(x.left!=null){\n            func(x.left,y+1);\n        }\n        if(x.right!=null){\n            func(x.right,y+1);\n        }\n    }\n}", "total_acs": 35053, "total_submitted": 62732}, {"id": 638, "title": "Shopping Offers", "url": "https://leetcode.com/problems/shopping-offers/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "\r\nIn LeetCode Store, there are some kinds of items to sell. Each item has a price.\r\n\r\n\r\n\r\nHowever, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price.\r\n\r\n\r\n\r\nYou are given the each item's price, a set of special offers, and the number we need to buy for each item.\r\nThe job is to output the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers.\r\n\r\n\r\n\r\nEach special offer is represented in the form of an array, the last number represents the price you need to pay for this special offer, other numbers represents how many specific items you could get if you buy this offer.\r\n\r\n\r\nYou could use any of special offers as many times as you want.\r\n\r\nExample 1:\r\n\r\nInput: [2,5], [[3,0,5],[1,2,10]], [3,2]\r\nOutput: 14\r\nExplanation: \r\nThere are two kinds of items, A and B. Their prices are $2 and $5 respectively. \r\nIn special offer 1, you can pay $5 for 3A and 0B\r\nIn special offer 2, you can pay $10 for 1A and 2B. \r\nYou need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: [2,3,4], [[1,1,0,4],[2,2,1,9]], [1,2,1]\r\nOutput: 11\r\nExplanation: \r\nThe price of A is $2, and $3 for B, $4 for C. \r\nYou may pay $4 for 1A and 1B, and $9 for 2A ,2B and 1C. \r\nYou need to buy 1A ,2B and 1C, so you may pay $4 for 1A and 1B (special offer #1), and $3 for 1B, $4 for 1C. \r\nYou cannot add more items, though only $9 for 2A ,2B and 1C.\r\n\r\n\r\n\r\nNote:\r\n\r\nThere are at most 6 kinds of items, 100 special offers.\r\nFor each item, you need to buy at most 6 of them.\r\nYou are not allowed to buy more items than you want, even if that would lower the overall price.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/808", "similarQuestions": [""], "topicTags": ["DynamicProgramming", "Depth-firstSearch"], "Solution": "class Solution {\n    List<Integer> price;\n    List<List<Integer>> special;\n    boolean allzero(int[] needs) {\n        for (int i: needs) {\n            if (i != 0) return false;\n        }\n        return true;\n    }\n    boolean lessThan(List<Integer> l1, int a, int[] l2) {\n        for (int i = 0; i < l2.length; i++) {\n            if (l1.get(i) * a > l2[i]) return false;\n        }\n        return true;\n    }\n    void minus(List<Integer> l1, int a, int[] l2) {\n        for (int i = 0; i < l2.length; i++) {\n            l2[i] -= a * l1.get(i);\n        }\n    }\n    void add(List<Integer> l1, int a, int[] l2) {\n        for (int i = 0; i < l2.length; i++) {\n            l2[i] +=  a * l1.get(i);\n        }\n    }\n    int buy(int idx, int[] needs) {\n        if (allzero(needs)) return 0;\n        if (idx >= special.size()) {\n            int sum = 0;\n            for (int i = 0; i < needs.length; i++) {\n                sum += price.get(i) * needs[i];\n            }\n            return sum;\n        }\n        int min = buy(idx + 1, needs);\n        for (int i = 1; lessThan(special.get(idx), i, needs); i++) {\n            minus(special.get(idx), i, needs);\n            int tmp = buy(idx + 1, needs) + i * special.get(idx).get(needs.length);\n            if (tmp < min) min = tmp;\n            add(special.get(idx), i, needs);\n        }\n        return min;\n    }\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\n        this.price = price;\n        this.special = special;\n        int[] need = new int[needs.size()];\n        for (int i = 0; i < need.length; i++) {\n            need[i] = needs.get(i);\n        }\n        return buy(0, need);\n    }\n}", "total_acs": 9215, "total_submitted": 20623}, {"id": 639, "title": "Decode Ways II", "url": "https://leetcode.com/problems/decode-ways-ii/description", "companyTags": ["Facebook"], "difficulty": "Hard", "content": "\r\nA message containing letters from A-Z is being encoded to numbers using the following mapping way:\r\n\r\n\r\n\r\n'A' -> 1\r\n'B' -> 2\r\n...\r\n'Z' -> 26\r\n\r\n\r\n\r\nBeyond that, now the encoded string can also contain the character '*', which can be treated as one of the numbers from 1 to 9.\r\n\r\n\r\n\r\n\r\nGiven the encoded message containing digits and the character '*', return the total number of ways to decode it.\r\n\r\n\r\n\r\nAlso, since the answer may be very large, you should return the output mod 109 + 7.\r\n\r\n\r\nExample 1:\r\n\r\nInput: \"*\"\r\nOutput: 9\r\nExplanation: The encoded message can be decoded to the string: \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\".\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: \"1*\"\r\nOutput: 9 + 9 = 18\r\n\r\n\r\n\r\nNote:\r\n\r\nThe length of the input string will fit in range [1, 105].\r\nThe input string will only contain the character '*' and digits '0' - '9'.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/809", "similarQuestions": ["DecodeWays"], "topicTags": ["DynamicProgramming"], "Solution": "class Solution {\n\tpublic int numDecodings(String s) {\n\t\tchar[] c = s.toCharArray();\n\t\tint l = s.length();\n\t\tif (l == 0) return 0;\n\t\tlong[] f = new long[l + 1];\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i <= l; i ++){\n\t\t\tif (c[i - 1] != '0'){\n\t\t\t\tif (c[i - 1] == '*') f[i] = (f[i - 1] * 9) % 1000000007;\n\t\t\t\telse f[i] = f[i - 1];\n\t\t\t}\n\t\t\tif (i > 1)\n\t\t\t\tif (c[i - 2] == '1'){\n\t\t\t\t\tif (c[i - 1] == '*') f[i] += (f[i - 2] * 9) % 1000000007;\n\t\t\t\t\telse f[i] += f[i - 2];\n\t\t\t\t} else if (c[i - 2] == '2'){\n\t\t\t\t\tif (c[i - 1] == '*') f[i] += (f[i - 2] * 6) % 1000000007;\n\t\t\t\t\telse if (c[i - 1] < '7') f[i] += f[i - 2];\n\t\t\t\t} else if (c[i - 2] == '*'){\n\t\t\t\t\tif (c[i - 1] == '*') f[i] += (f[i - 2] * 15) % 1000000007;\n\t\t\t\t\telse if (c[i - 1] < '7') f[i] += (f[i - 2] * 2) % 1000000007;\n\t\t\t\t\telse f[i] += f[i - 2];\n\t\t\t\t}\n\t\t}\n\t\treturn (int)(f[l] % 1000000007);\n\t}\n}", "total_acs": 9900, "total_submitted": 40341}, {"id": 640, "title": "Solve the Equation", "url": "https://leetcode.com/problems/solve-the-equation/description", "companyTags": ["Amazon"], "difficulty": "Medium", "content": "\r\nSolve a given equation and return the value of x in the form of string \"x=#value\". The equation contains only '+', '-' operation, the variable x and its coefficient.\r\n\r\n\r\n\r\nIf there is no solution for the equation, return \"No solution\".\r\n\r\n\r\nIf there are infinite solutions for the equation, return \"Infinite solutions\".\r\n\r\n\r\nIf there is exactly one solution for the equation, we ensure that the value of x is an integer.\r\n\r\n\r\nExample 1:\r\n\r\nInput: \"x+5-3+x=6+x-2\"\r\nOutput: \"x=2\"\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: \"x=x\"\r\nOutput: \"Infinite solutions\"\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput: \"2x=x\"\r\nOutput: \"x=0\"\r\n\r\n\r\n\r\nExample 4:\r\n\r\nInput: \"2x+3x-6x=x+2\"\r\nOutput: \"x=-1\"\r\n\r\n\r\n\r\nExample 5:\r\n\r\nInput: \"x=x+2\"\r\nOutput: \"No solution\"\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/810", "similarQuestions": ["FractionAdditionandSubtraction"], "topicTags": ["Math"], "Solution": "class Solution {\n    public String solveEquation(String equation) {\n        // [0][0] = number of X, [0][1] = value\n        int[][] format = new int[2][2];\n        char[] str = equation.toCharArray();\n        int i = 0;\n        while (i < str.length && str[i] != '=') i++;\n        helper(str, 0, i-1, format[0]);\n        helper(str, i+1, str.length-1, format[1]);\n        \n        if (format[0][0] == format[1][0]) {\n            if (format[0][1] == format[1][1]) {\n                return \"Infinite solutions\";\n            } else {\n                return \"No solution\";\n            }\n        }\n        \n        return \"x=\" + String.valueOf((format[1][1] - format[0][1]) / (format[0][0] - format[1][0]));\n    }\n    \n    void helper(char[] str, int left, int right, int[] container) {\n        int positive = 1;\n        int xRelated = 1;\n        int value = 0;\n        for (int i = left; i <= right; i++) {\n            char check = str[i];\n            if (check == '+' || check == '-') {\n                // if () {\n                    container[xRelated] += positive * value;\n                // } else {\n                    // container[1] += (positive) ? value : -value;\n                // }\n                value = 0;\n                positive = (check == '+') ? 1 : -1;\n                xRelated = 1;\n            } else if (check == 'x') {\n                if (value == 0) {\n                \tif (i-1 < left || str[i-1] != '0') {\n                \t\tvalue = 1;\n                \t}\n                }\n                // xRelated = true;\n                xRelated = 0;\n            } else if (check >= '0' && check <= '9') {\n                value = value * 10 + (check - '0');\n            }\n        }\n        container[xRelated] += positive * value;\n        // if (xRelated) {\n            // container[0] += (positive) ? value : -value;\n        // } else {\n            // container[1] += (positive) ? value : -value;\n        // }\n    }\n}", "total_acs": 8050, "total_submitted": 20625}, {"id": 642, "title": "Design Search Autocomplete System", "url": "https://leetcode.com/problems/design-search-autocomplete-system/description", "companyTags": ["Facebook", "Microsoft"], "difficulty": "Hard", "content": "Design a search autocomplete system for a search engine. Users may input a sentence (at least one word and end with a special character '#'). For each character they type except '#', you need to return the top 3 historical hot sentences that have prefix the same as the part of sentence already typed. Here are the specific rules:\r\n\r\nThe hot degree for a sentence is defined as the number of times a user typed the exactly same sentence before. \r\nThe returned top 3 hot sentences should be sorted by hot degree (The first is the hottest one). If several sentences have the same degree of hot, you need to use ASCII-code order (smaller one appears first). \r\nIf less than 3 hot sentences exist, then just return as many as you can.\r\nWhen the input is a special character, it means the sentence ends, and in this case, you need to return an empty list.\r\n\r\n\r\nYour job is to implement the following functions:\r\n\r\nThe constructor function:\r\n\r\nAutocompleteSystem(String[] sentences, int[] times): This is the constructor. The input is historical data. Sentences is a string array consists of previously typed sentences. Times is the corresponding times a sentence has been typed. Your system should record these historical data.\r\n\r\nNow, the user wants to input a new sentence. The following function will provide the next character the user types: \r\n\r\nList<String> input(char c): The input c is the next character typed by the user. The character will only be lower-case letters ('a' to 'z'), blank space (' ') or a special character ('#'). Also, the previously typed sentence should be recorded in your system. The output will be the top 3 historical hot sentences that have prefix the same as the part of sentence already typed.\r\n\r\n\r\nExample:\r\n\r\nOperation: AutocompleteSystem([\"i love you\", \"island\",\"ironman\", \"i love leetcode\"], [5,3,2,2])\r\n\r\nThe system have already tracked down the following sentences and their corresponding times:\r\n\r\n\"i love you\" : 5 times\r\n\r\n\"island\" : 3 times\r\n\r\n\"ironman\" : 2 times\r\n\r\n\"i love leetcode\" : 2 times\r\n\r\nNow, the user begins another search:\r\n\r\nOperation: input('i')\r\n\r\nOutput: [\"i love you\", \"island\",\"i love leetcode\"]\r\n\r\nExplanation: \r\n\r\nThere are four sentences that have prefix \"i\". Among them, \"ironman\" and \"i love leetcode\" have same hot degree. Since ' ' has ASCII code 32 and 'r' has ASCII code 114, \"i love leetcode\" should be in front of \"ironman\". Also we only need to output top 3 hot sentences, so \"ironman\" will be ignored.\r\n\r\nOperation: input(' ')\r\n\r\nOutput: [\"i love you\",\"i love leetcode\"]\r\n\r\nExplanation: \r\n\r\nThere are only two sentences that have prefix \"i \".\r\n\r\nOperation: input('a')\r\n\r\nOutput: []\r\n\r\nExplanation: \r\n\r\nThere are no sentences that have prefix \"i a\".\r\n\r\nOperation: input('#')\r\n\r\nOutput: []\r\n\r\nExplanation: \r\n\r\nThe user finished the input, the sentence \"i a\" should be saved as a historical sentence in system. And the following input will be counted as a new search.\r\n\r\n\r\n\r\n\r\nNote:\r\n\r\n\r\n\r\nThe input sentence will always start with a letter and end with '#', and only one blank space will exist between two words. \r\nThe number of complete sentences that to be searched won't exceed 100. The length of each sentence including those in the historical data won't exceed 100. \r\nPlease use double-quote instead of single-quote when you write test cases even for a character input.\r\nPlease remember to RESET your class variables declared in class AutocompleteSystem, as static/class variables are persisted across multiple test cases. Please see here for more details.\r\n\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/813", "similarQuestions": ["ImplementTrie(PrefixTree)"], "topicTags": ["Design", "Trie"], "Solution": null, "total_acs": 4679, "total_submitted": 14953}, {"id": 643, "title": "Maximum Average Subarray I", "url": "https://leetcode.com/problems/maximum-average-subarray-i/description", "companyTags": ["Google"], "difficulty": "Easy", "content": "\r\nGiven an array consisting of n integers, find the contiguous subarray of given length k that has the maximum average value. And you need to output the maximum average value.\r\n\r\n\r\nExample 1:\r\n\r\nInput: [1,12,-5,-6,50,3], k = 4\r\nOutput: 12.75\r\nExplanation: Maximum average is (12-5-6+50)/4 = 51/4 = 12.75\r\n\r\n\r\n\r\nNote:\r\n\r\n1 <= k <= n <= 30,000.\r\nElements of the given array will be in the range [-10,000, 10,000].\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/814", "similarQuestions": ["MaximumAverageSubarrayII"], "topicTags": ["Array"], "Solution": "class Solution {\n    public double findMaxAverage(int[] nums, int k) {\n        int sum = 0;\n        for(int i = 0; i<k; i++)\n            sum += nums[i];\n        int newsum = sum;\n        for(int i = k; i<nums.length; i++){\n            newsum = newsum - nums[i-k] + nums[i];\n            sum = sum > newsum ? sum : newsum;\n        }\n        return (double)sum / k;\n    }\n}", "total_acs": 23960, "total_submitted": 63891}, {"id": 644, "title": "Maximum Average Subarray II", "url": "https://leetcode.com/problems/maximum-average-subarray-ii/description", "companyTags": ["Google"], "difficulty": "Hard", "content": "\r\nGiven an array consisting of n integers, find the contiguous subarray whose length is greater than or equal to k that has the maximum average value. And you need to output the maximum average value.\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput: [1,12,-5,-6,50,3], k = 4\r\nOutput: 12.75\r\nExplanation:\r\nwhen length is 5, maximum average value is 10.8,\r\nwhen length is 6, maximum average value is 9.16667.\r\nThus return 12.75.\r\n\r\n\r\n\r\n\r\nNote:\r\n\r\n1 <= k <= n <= 10,000.\r\nElements of the given array will be in range [-10,000, 10,000].\r\nThe answer with the calculation error less than 10-5 will be accepted.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/815", "similarQuestions": ["MaximumAverageSubarrayI"], "topicTags": ["Array", "BinarySearch"], "Solution": "class Solution {\n    public double findMaxAverage(int[] nums, int k) {\n        int n = nums.length;\n        if (n == 1) {\n            return nums[0];\n        }\n        int[] sum = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            sum[i] = sum[i - 1] + nums[i - 1];\n        }\n\n        int[] q = new int[n + 10];\n        int h = 0, t = -1;\n        double res = -Double.MAX_VALUE;\n        int j = 0;\n        for (int i = k; i <= n; i++) {\n            while (h < t && useless(sum, q[t - 1], q[t], i - k)) {\n                t--;\n            }\n            q[++t] = i - k;\n            while (h < t && useless(sum, i, q[h], q[h + 1])) {\n                h++;\n            }\n            res = Math.max(res, aver(sum, q[h], i));\n        }\n        return res;\n    }\n    \n    double aver(int[] nums, int i, int j) {\n        return ((double)(nums[i] - nums[j])) / (i - j);\n    }\n    \n    boolean useless(int[] nums, int k, int j, int i) {\n        return aver(nums, k, j) > aver(nums, j, i);\n    }\n}", "total_acs": 4426, "total_submitted": 18195}, {"id": 645, "title": "Set Mismatch", "url": "https://leetcode.com/problems/set-mismatch/description", "companyTags": ["Amazon"], "difficulty": "Easy", "content": "\r\nThe set S originally contains numbers from 1 to n. But unfortunately, due to the data error, one of the numbers in the set got duplicated to another number in the set, which results in repetition of one number and loss of another number. \r\n\r\n\r\n\r\nGiven an array nums representing the data status of this set after the error. Your task is to firstly find the number occurs twice and then find the number that is missing. Return them in the form of an array.\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput: nums = [1,2,2,4]\r\nOutput: [2,3]\r\n\r\n\r\n\r\nNote:\r\n\r\nThe given array size will in the range [2, 10000].\r\nThe given array's numbers won't have any order.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/817", "similarQuestions": ["FindtheDuplicateNumber"], "topicTags": ["HashTable", "Math"], "Solution": "class Solution {\n    public int[] findErrorNums(int[] nums) {\n        int[] result = new int[2];\n        int[] arr = new int[nums.length + 1];\n        for (int i = 0; i < nums.length; i++) {\n            if (arr[nums[i]] == 1) {\n                result[0] = nums[i];\n            } else {\n                arr[nums[i]] = 1;\n            }\n        }\n        for (int i = 1; i <= nums.length; i++) {\n            if (arr[i] == 0) {\n                result[1] = i;\n                break;\n            }\n        }\n        return result;\n    }\n}", "total_acs": 22236, "total_submitted": 55736}, {"id": 646, "title": "Maximum Length of Pair Chain", "url": "https://leetcode.com/problems/maximum-length-of-pair-chain/description", "companyTags": ["Amazon"], "difficulty": "Medium", "content": "\r\nYou are given n pairs of numbers. In every pair, the first number is always smaller than the second number.\r\n\r\n\r\n\r\nNow, we define a pair (c, d) can follow another pair (a, b) if and only if b < c. Chain of pairs can be formed in this fashion. \r\n\r\n\r\n\r\nGiven a set of pairs, find the length longest chain which can be formed. You needn't use up all the given pairs. You can select pairs in any order.\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput: [[1,2], [2,3], [3,4]]\r\nOutput: 2\r\nExplanation: The longest chain is [1,2] -> [3,4]\r\n\r\n\r\n\r\nNote:\r\n\r\nThe number of given pairs will be in the range [1, 1000].\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/818", "similarQuestions": ["LongestIncreasingSubsequence", "IncreasingSubsequences"], "topicTags": ["DynamicProgramming"], "Solution": "class Solution {\n    public int findLongestChain(int[][] pairs) {\n        QuickSort(pairs, 0, pairs.length-1);\n        int count = 1;\n        int flag = pairs[0][1];\n        for(int i=1; i<pairs.length; i++){\n            if(pairs[i][0]>flag){\n                count++;\n                flag = pairs[i][1];\n            }\n        }\n        return count;\n    }\n\n    private static void QuickSort(int[][] array,int start,int end)\n    {\n        if(start<end)\n        {\n            int key=array[start][1];\n            int key0 = array[start][0];//\u521d\u59cb\u5316\u4fdd\u5b58\u57fa\u5143\n            int i=start,j;//\u521d\u59cb\u5316i,j\n            for(j=start+1;j<=end;j++)\n            {\n                if(array[j][1]<key)//\u5982\u679c\u6b64\u5904\u5143\u7d20\u5c0f\u4e8e\u57fa\u5143\uff0c\u5219\u628a\u6b64\u5143\u7d20\u548ci+1\u5904\u5143\u7d20\u4ea4\u6362\uff0c\u5e76\u5c06i\u52a01\uff0c\u5982\u5927\u4e8e\u6216\u7b49\u4e8e\u57fa\u5143\u5219\u7ee7\u7eed\u5faa\u73af\n                {\n                    int temp=array[j][1];\n                    int temp0 = array[j][0];\n                    array[j][1]=array[i+1][1];\n                    array[j][0]=array[i+1][0];\n                    array[i+1][1]=temp;\n                    array[i+1][0]=temp0;\n                    i++;\n                }\n\n            }\n            array[start][1]=array[i][1];\n            array[start][0]=array[i][0];//\u4ea4\u6362i\u5904\u5143\u7d20\u548c\u57fa\u5143\n            array[i][1]=key;\n            array[i][0]=key0;\n            QuickSort(array, start, i-1);//\u9012\u5f52\u8c03\u7528\n            QuickSort(array, i+1, end);\n\n        }\n\n    }\n}", "total_acs": 15688, "total_submitted": 33041}, {"id": 647, "title": "Palindromic Substrings", "url": "https://leetcode.com/problems/palindromic-substrings/description", "companyTags": ["Facebook", "LinkedIn"], "difficulty": "Medium", "content": "\r\nGiven a string, your task is to count how many palindromic substrings in this string.\r\n\r\n\r\n\r\nThe substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters. \r\n\r\n\r\nExample 1:\r\n\r\nInput: \"abc\"\r\nOutput: 3\r\nExplanation: Three palindromic strings: \"a\", \"b\", \"c\".\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: \"aaa\"\r\nOutput: 6\r\nExplanation: Six palindromic strings: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\".\r\n\r\n\r\n\r\nNote:\r\n\r\nThe input string length won't exceed 1000.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/819", "similarQuestions": ["LongestPalindromicSubstring", "LongestPalindromicSubsequence", "PalindromicSubstrings"], "topicTags": ["String", "DynamicProgramming"], "Solution": "class Solution {\n    public int countSubstrings(String s) {\n        if(s==null || s.length()==0) return 0;\n\n        int n=s.length();\n        int res=0;\n        for(int i=0; i<n; i++){\n        \tres+=helper(s, i, i);\n        \tres+=helper(s, i, i+1);\n        }\n        return res;\n    }\n\n    private int helper(String s, int l, int r){\n    \tint res=0;\n    \twhile(l>=0 && r<s.length() && s.charAt(l)==s.charAt(r)){\n    \t\tl--;\n    \t\tr++;\n    \t\tres++;\n    \t}\n    \treturn res;\n    }\n}", "total_acs": 30749, "total_submitted": 55707}, {"id": 648, "title": "Replace Words", "url": "https://leetcode.com/problems/replace-words/description", "companyTags": ["Uber"], "difficulty": "Medium", "content": "\r\nIn English, we have a concept called root, which can be followed by some other words to form another longer word - let's call this word successor. For example, the root an, followed by other, which can form another word another.\r\n\r\n\r\n\r\n\r\nNow, given a dictionary consisting of many roots and a sentence. You need to replace all the successor in the sentence with the root forming it. If a successor has many roots can form it, replace it with the root with the shortest length.\r\n\r\n\r\n\r\nYou need to output the sentence after the replacement.\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput: dict = [\"cat\", \"bat\", \"rat\"]\r\nsentence = \"the cattle was rattled by the battery\"\r\nOutput: \"the cat was rat by the bat\"\r\n\r\n\r\n\r\n\r\nNote:\r\n\r\nThe input will only have lower-case letters.\r\n 1 <= dict words number <= 1000 \r\n 1 <= sentence words number <= 1000  \r\n 1 <= root length <= 100 \r\n 1 <= sentence words length <= 1000 \r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/820", "similarQuestions": ["ImplementTrie(PrefixTree)"], "topicTags": ["HashTable", "Trie"], "Solution": "class Solution {\n    public String replaceWords(List<String> dict, String sentence) {\n        String[] words = sentence.split(\" \");\n        Trie trie = new Trie();\n        for(String w : dict) {\n            trie.add(w, 0);\n        }\n        StringBuilder sb = new StringBuilder();\n        for(String w : words) {\n            if(sb.length() != 0) {\n                sb.append(' ');\n            }\n            sb.append(trie.replace(w, 0));\n        }\n        return sb.toString();\n    }\n    \n    private static class Trie {\n        public Trie[] next = new Trie[26];\n        public String value = null;\n        \n        public Trie() {\n        }\n        \n        public void add(String word, int index) {\n            if(index == word.length()) {\n                value = word;\n            }\n            else {\n                int nextIndex = word.charAt(index) - 'a';\n                if(next[nextIndex] == null) {\n                    next[nextIndex] = new Trie();\n                }\n                next[nextIndex].add(word, index+1);\n            }\n        }\n        \n        public String replace(String word, int index) {\n            if(value != null) {\n                return value;\n            }\n            if(index == word.length()) {\n                return word;\n            }\n            else {\n                int nextIndex = word.charAt(index) - 'a';\n                if(next[nextIndex] == null) {\n                    return word;\n                }\n                return next[nextIndex].replace(word, index+1);\n            }\n        }\n    }\n}", "total_acs": 13483, "total_submitted": 28384}, {"id": 649, "title": "Dota2 Senate", "url": "https://leetcode.com/problems/dota2-senate/description", "companyTags": ["Valve"], "difficulty": "Medium", "content": "\r\nIn the world of Dota2, there are two parties: the Radiant and the Dire.\r\n\r\n\r\n\r\nThe Dota2 senate consists of senators coming from two parties. Now the senate wants to make a decision about a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise one of the two rights:\r\n\r\nBan one senator's right: A senator can make another senator lose all his rights in this and all the following rounds.\r\nAnnounce the victory: If this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and make the decision about the change in the game.\r\n\r\n\r\n\r\n\r\nGiven a string representing each senator's party belonging. The character 'R' and 'D' represent the Radiant party and the Dire party respectively. Then if there are n senators, the size of the given string will be n.\r\n\r\n\r\n\r\nThe round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure.\r\n\r\n\r\n\r\nSuppose every senator is smart enough and will play the best strategy for his own party, you need to predict which party will finally announce the victory and make the change in the Dota2 game. The output should be Radiant or Dire.\r\n\r\n\r\nExample 1:\r\n\r\nInput: \"RD\"\r\nOutput: \"Radiant\"\r\nExplanation: The first senator comes from Radiant and he can just ban the next senator's right in the round 1. And the second senator can't exercise any rights any more since his right has been banned. And in the round 2, the first senator can just announce the victory since he is the only guy in the senate who can vote.\r\n\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: \"RDD\"\r\nOutput: \"Dire\"\r\nExplanation: \r\nThe first senator comes from Radiant and he can just ban the next senator's right in the round 1. And the second senator can't exercise any rights anymore since his right has been banned. And the third senator comes from Dire and he can ban the first senator's right in the round 1. And in the round 2, the third senator can just announce the victory since he is the only guy in the senate who can vote.\r\n\r\n\r\n\r\nNote:\r\n\r\nThe length of the given string will in the range [1, 10,000].\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/822", "similarQuestions": ["TeemoAttacking"], "topicTags": ["Greedy"], "Solution": "class Solution {\n\n    public String predictPartyVictory(String senate) {\n        char[] ss=senate.toCharArray();\n        int len=ss.length;\n        int currR=0;\n        int currD=0;\n        while(len>0){\n            int slow=0;\n            int fast=0;\n            int oldLen=len;\n            while(fast<len){\n                if(ss[fast]=='D'){\n                    if(currR>0){\n                        currR--;\n                    }else{\n                        currD++;\n                        ss[slow++]='D';\n                    }\n                }else{\n                    if(currD>0){\n                        currD--;\n                    }else{\n                        currR++;\n                        ss[slow++]='R';\n                    }\n                }\n                fast++;\n            }\n            len=slow;\n            if(len==oldLen)return ss[0]=='D'?\"Dire\":\"Radiant\";\n        }\n        return \"\";\n    }\n}", "total_acs": 4397, "total_submitted": 12080}, {"id": 650, "title": "2 Keys Keyboard", "url": "https://leetcode.com/problems/2-keys-keyboard/description", "companyTags": ["Microsoft"], "difficulty": "Medium", "content": "\r\nInitially on a notepad only one character 'A' is present. You can perform two operations on this notepad for each step: \r\n\r\nCopy All: You can copy all the characters present on the notepad (partial copy is not allowed).\r\nPaste: You can paste the characters which are copied last time.\r\n\r\n\r\n\r\n\r\nGiven a number n. You have to get exactly n 'A' on the notepad by performing the minimum number of steps permitted. Output the minimum number of steps to get n 'A'. \r\n\r\n\r\nExample 1:\r\n\r\nInput: 3\r\nOutput: 3\r\nExplanation:\r\nIntitally, we have one character 'A'.\r\nIn step 1, we use Copy All operation.\r\nIn step 2, we use Paste operation to get 'AA'.\r\nIn step 3, we use Paste operation to get 'AAA'.\r\n\r\n\r\n\r\n\r\nNote:\r\n\r\nThe n will be in the range [1, 1000].\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/823", "similarQuestions": ["4KeysKeyboard"], "topicTags": ["DynamicProgramming"], "Solution": "class Solution {\n    public int minSteps(int n) {\n        int res = 0;\n        for (int i = 2; i <= n; i++) {\n            while (n % i == 0) { // \u4ee3\u8868copy\u67d0\u4e2a\u6570i\u6b21\uff0c\u6240\u4ee5res += i\n                res += i;\n                n = n / i;\n            }\n        }\n        return res;\n    }\n}", "total_acs": 15382, "total_submitted": 34278}, {"id": 651, "title": "4 Keys Keyboard", "url": "https://leetcode.com/problems/4-keys-keyboard/description", "companyTags": ["Google", "Microsoft"], "difficulty": "Medium", "content": "Imagine you have a special keyboard with the following keys: \r\nKey 1: (A):  Print one 'A' on screen.\r\nKey 2: (Ctrl-A): Select the whole screen.\r\nKey 3: (Ctrl-C): Copy selection to buffer.\r\nKey 4: (Ctrl-V): Print buffer on screen appending it after what has already been printed. \r\n\r\n\r\n\r\nNow, you can only press the keyboard for N times (with the above four keys), find out the maximum numbers of 'A' you can print on screen.\r\n\r\n\r\nExample 1:\r\n\r\nInput: N = 3\r\nOutput: 3\r\nExplanation: \r\nWe can at most get 3 A's on screen by pressing following key sequence:\r\nA, A, A\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: N = 7\r\nOutput: 9\r\nExplanation: \r\nWe can at most get 9 A's on screen by pressing following key sequence:\r\nA, A, A, Ctrl A, Ctrl C, Ctrl V, Ctrl V\r\n\r\n\r\n\r\nNote:\r\n\r\n1 <= N <= 50 \r\nAnswers will be in the range of 32-bit signed integer.\r\n\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/824", "similarQuestions": ["2KeysKeyboard"], "topicTags": ["Math", "DynamicProgramming", "Greedy"], "Solution": "class Solution {\n    int[] result = new int[100];\n    public int maxA(int N) {\n        int max = N;\n        for(int i = 1; i < N - 2; i++) {\n            int cur = 0;\n            if(result[i] != 0) {\n                cur = result[i];\n            } else {\n                cur = maxA(i);\n            }\n            max = Math.max(max, cur * (N - 2 - i + 1));\n        }\n        result[N] = max;\n        return max;\n    }\n}", "total_acs": 6256, "total_submitted": 12611}, {"id": 652, "title": "Find Duplicate Subtrees", "url": "https://leetcode.com/problems/find-duplicate-subtrees/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "\r\nGiven a binary tree, return all duplicate subtrees. For each kind of duplicate subtrees, you only need to return the root node of any one of them. \r\n\r\n\r\nTwo trees are duplicate if they have the same structure with same node values.\r\n\r\n\r\nExample 1: \r\n\r\n        1\r\n       / \\\r\n      2   3\r\n     /   / \\\r\n    4   2   4\r\n       /\r\n      4\r\n\r\nThe following are two duplicate subtrees:\r\n\r\n      2\r\n     /\r\n    4\r\n\r\nand\r\n\r\n    4\r\n\r\nTherefore, you need to return above trees' root in the form of a list.\r\n\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/825", "similarQuestions": ["SerializeandDeserializeBinaryTree", "SerializeandDeserializeBST", "ConstructStringfromBinaryTree"], "topicTags": ["Tree"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\n        if(root == null) {\n            return new ArrayList<>();\n        }\n        Set<EncapsulatedNode> set = new HashSet<>();\n        Set<EncapsulatedNode> result = new HashSet<>();\n        addNode(set, result, root);\n        List<TreeNode> duplicates = new ArrayList<>();\n        for(EncapsulatedNode enode : result) {\n            duplicates.add(enode.node);\n        }\n        return duplicates;\n    }\n    \n    private static EncapsulatedNode addNode(Set<EncapsulatedNode> set, Set<EncapsulatedNode> result, TreeNode node) {\n        EncapsulatedNode left = null, right = null;\n        if(node.left != null) {\n            left = addNode(set, result, node.left);\n        }\n        if(node.right != null) {\n            right = addNode(set, result, node.right);\n        }\n        EncapsulatedNode enode = new EncapsulatedNode(node, left, right);\n        boolean inserted = set.add(enode);\n        if(inserted == false) {\n            result.add(enode);\n        }\n        return enode;\n    }\n    \n    private static class EncapsulatedNode {\n        private final TreeNode node;\n        private final EncapsulatedNode left;\n        private final EncapsulatedNode right;\n        private final int hash;\n        \n        public EncapsulatedNode(TreeNode node, EncapsulatedNode left, EncapsulatedNode right) {\n            this.node = node;\n            this.left = left;\n            this.right = right;\n            int hash = 1 + 2 * node.val;\n            if(left != null) {\n                hash += 71 * left.hash;\n            }\n            if(right != null) {\n                hash += 53 * right.hash;\n            }\n            this.hash = hash;\n        }\n        \n        public int hashCode() {\n            return hash;\n        }\n        \n        public boolean equals(Object obj) {\n            if(obj instanceof EncapsulatedNode) {\n                EncapsulatedNode other = (EncapsulatedNode) obj;\n                if(node.val != other.node.val) {\n                    return false;\n                }\n                if(left == null) {\n                    if(other.left != null) {\n                        return false;\n                    }\n                }\n                else {\n                    if(left.equals(other.left) == false) {\n                        return false;\n                    }\n                }\n                if(right == null) {\n                    if(other.right != null) {\n                        return false;\n                    }\n                }\n                else {\n                    if(right.equals(other.right) == false) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            return false;\n        }\n    }\n}", "total_acs": 10831, "total_submitted": 28976}, {"id": 653, "title": "Two Sum IV - Input is a BST", "url": "https://leetcode.com/problems/two-sum-iv-input-is-a-bst/description", "companyTags": ["Facebook", "Samsung"], "difficulty": "Easy", "content": "Given a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target.\r\n\r\nExample 1:\r\n\r\nInput: \r\n    5\r\n   / \\\r\n  3   6\r\n / \\   \\\r\n2   4   7\r\n\r\nTarget = 9\r\n\r\nOutput: True\r\n\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: \r\n    5\r\n   / \\\r\n  3   6\r\n / \\   \\\r\n2   4   7\r\n\r\nTarget = 28\r\n\r\nOutput: False\r\n\r\n\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/827", "similarQuestions": ["TwoSum", "TwoSumII-Inputarrayissorted", "TwoSumIII-Datastructuredesign"], "topicTags": ["Tree"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    //For each node, check if k - node.val exists in this BST.\n    //Time Complexity: O(nlogn), Space Complexity: O(h). h is the height of the tree\n    public boolean findTarget(TreeNode root, int k) {\n        return dfs(root, root, k);\n    }\n    \n    private boolean dfs(TreeNode root, TreeNode cur, int k) {\n        if(cur == null) return false;\n        return search(root, cur, k-cur.val) || dfs(root, cur.left, k) || dfs(root, cur.right, k);\n    }\n    \n    private boolean search(TreeNode root, TreeNode cur, int target) {\n        if(root == null) return false;\n        if(target == root.val && root != cur) return true;\n        else if (target > root.val) return search(root.right, cur, target);\n        else return search(root.left, cur, target);\n    }\n    \n    \n    \n    /*BFS\n    public boolean findTarget(TreeNode root, int k) {\n        if(root == null) return false;\n        Set<Integer> set = new HashSet<>();\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n        while(!queue.isEmpty()) {\n            TreeNode node = queue.poll();\n            if(set.contains(k-node.val)) return true;\n            set.add(node.val);\n            if(node.left != null) queue.add(node.left);\n            if(node.right != null) queue.add(node.right);\n        }\n        return false;\n    }\n    */\n}", "total_acs": 30742, "total_submitted": 61117}, {"id": 654, "title": "Maximum Binary Tree", "url": "https://leetcode.com/problems/maximum-binary-tree/description", "companyTags": ["Microsoft"], "difficulty": "Medium", "content": "\r\nGiven an integer array with no duplicates. A maximum tree building on this array is defined as follow:\r\n\r\nThe root is the maximum number in the array. \r\nThe left subtree is the maximum tree constructed from left part subarray divided by the maximum number.\r\nThe right subtree is the maximum tree constructed from right part subarray divided by the maximum number. \r\n\r\n\r\n\r\n\r\nConstruct the maximum tree by the given array and output the root node of this tree.\r\n\r\n\r\nExample 1:\r\n\r\nInput: [3,2,1,6,0,5]\r\nOutput: return the tree root node representing the following tree:\r\n\r\n      6\r\n    /   \\\r\n   3     5\r\n    \\    / \r\n     2  0   \r\n       \\\r\n        1\r\n\r\n\r\n\r\nNote:\r\n\r\nThe size of the given array will be in the range [1,1000].\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/828", "similarQuestions": [""], "topicTags": ["Tree"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode constructMaximumBinaryTree(int[] nums) {\n        if (nums == null) return null;\n        return construct(nums, 0, nums.length-1);\n    }\n    \n    public TreeNode construct(int[] nums, int start, int end){\n        if(start > end) return null;\n        int max_idx = start;\n        for(int i = start+1; i <= end; i++){\n            if(nums[i] > nums[max_idx]) max_idx = i;\n        }\n        TreeNode node = new TreeNode(nums[max_idx]);\n        node.left = construct(nums, start, max_idx-1);\n        node.right = construct(nums, max_idx+1, end);\n        return node;\n    }\n}", "total_acs": 24485, "total_submitted": 35123}, {"id": 655, "title": "Print Binary Tree", "url": "https://leetcode.com/problems/print-binary-tree/description", "companyTags": ["Poynt"], "difficulty": "Medium", "content": "Print a binary tree in an m*n 2D string array following these rules: \r\n\r\n\r\nThe row number m should be equal to the height of the given binary tree.\r\nThe column number n should always be an odd number.\r\nThe root node's value (in string format) should be put in the exactly middle of the first row it can be put. The column and the row where the root node belongs will separate the rest space into two parts (left-bottom part and right-bottom part). You should print the left subtree in the left-bottom part and print the right subtree in the right-bottom part. The left-bottom part and the right-bottom part should have the same size. Even if one subtree is none while the other is not, you don't need to print anything for the none subtree but still need to leave the space as large as that for the other subtree. However, if two subtrees are none, then you don't need to leave space for both of them. \r\nEach unused space should contain an empty string \"\".\r\nPrint the subtrees following the same rules.\r\n\r\n\r\nExample 1:\r\n\r\nInput:\r\n     1\r\n    /\r\n   2\r\nOutput:\r\n[[\"\", \"1\", \"\"],\r\n [\"2\", \"\", \"\"]]\r\n\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput:\r\n     1\r\n    / \\\r\n   2   3\r\n    \\\r\n     4\r\nOutput:\r\n[[\"\", \"\", \"\", \"1\", \"\", \"\", \"\"],\r\n [\"\", \"2\", \"\", \"\", \"\", \"3\", \"\"],\r\n [\"\", \"\", \"4\", \"\", \"\", \"\", \"\"]]\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput:\r\n      1\r\n     / \\\r\n    2   5\r\n   / \r\n  3 \r\n / \r\n4 \r\nOutput:\r\n\r\n[[\"\",  \"\",  \"\", \"\",  \"\", \"\", \"\", \"1\", \"\",  \"\",  \"\",  \"\",  \"\", \"\", \"\"]\r\n [\"\",  \"\",  \"\", \"2\", \"\", \"\", \"\", \"\",  \"\",  \"\",  \"\",  \"5\", \"\", \"\", \"\"]\r\n [\"\",  \"3\", \"\", \"\",  \"\", \"\", \"\", \"\",  \"\",  \"\",  \"\",  \"\",  \"\", \"\", \"\"]\r\n [\"4\", \"\",  \"\", \"\",  \"\", \"\", \"\", \"\",  \"\",  \"\",  \"\",  \"\",  \"\", \"\", \"\"]]\r\n\r\n\r\n\r\nNote:\r\nThe height of binary tree is in the range of [1, 10].\r\n", "discussUrl": "https://discuss.leetcode.com/category/829", "similarQuestions": [""], "topicTags": ["Tree"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<List<String>> printTree(TreeNode root) {\n\t\tList<List<String>> res = new LinkedList<>();\n\t\tint rows = root == null ? 1 : getHeight(root);\n\t\tint columns = (int) (Math.pow(2, rows) - 1);\n\t\tList<String> row = new ArrayList<>();\n\t\tfor (int i = 0; i < columns; i++)\n\t\t\trow.add(\"\");\n\t\tfor (int i = 0; i < rows; i++)\n\t\t\tres.add(new ArrayList<>(row));\n\t\tpopulateRes(root, res, 0, rows, 0, columns - 1);\n\t\treturn res;\n\t}\n\n\tpublic void populateRes(TreeNode root, List<List<String>> res, int row, int totalRows, int i, int j) {\n\t\tif (row == totalRows || root == null)\n\t\t\treturn;\n\t\tres.get(row).set((i + j) / 2, Integer.toString(root.val));\n\t\tpopulateRes(root.left, res, row + 1, totalRows, i, (i + j) / 2 - 1);\n\t\tpopulateRes(root.right, res, row + 1, totalRows, (i + j) / 2 + 1, j);\n\t}\n\n\tpublic int getHeight(TreeNode root) {\n\t\tif (root == null) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1 + Math.max(getHeight(root.right), getHeight(root.left));\n\t}\n\n\n}", "total_acs": 7621, "total_submitted": 15369}, {"id": 656, "title": "Coin Path", "url": "https://leetcode.com/problems/coin-path/description", "companyTags": ["Google"], "difficulty": "Hard", "content": "\r\nGiven an array A (index starts at 1) consisting of N integers: A1, A2, ..., AN\u00a0and an integer B. The integer B denotes that from any place (suppose the index is i) in the array A, you can jump to any one of the place in the array A indexed i+1, i+2, \u2026, i+B if this place can be jumped to. Also, if you step on the index i, you have to pay Ai\u00a0coins. If Ai\u00a0is -1, it means you can\u2019t jump to the place indexed i in the array.\r\n\r\n\r\n\r\nNow, you start from the place indexed 1 in the array A, and your aim is to reach the place indexed N using the minimum coins. You need to return the path of indexes (starting from 1 to N) in the array you should take to get to the place indexed N using minimum coins.\r\n\r\n\r\n\r\nIf there are multiple paths with the same cost, return the lexicographically smallest such path.\r\n\r\n\r\nIf it's not possible to reach the place indexed N then you need to return an empty array.\r\n\r\n\r\nExample 1:\r\n\r\nInput: [1,2,4,-1,2], 2\r\nOutput: [1,3,5]\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: [1,2,4,-1,2], 1\r\nOutput: []\r\n\r\n\r\n\r\nNote:\r\n\r\nPath Pa1, Pa2, ..., Pan\u00a0is lexicographically smaller than Pb1, Pb2, ..., Pbm, if and only if at the first i where Pai\u00a0and Pbi\u00a0differ, Pai\u00a0< Pbi; when no such\u00a0i\u00a0exists, then\u00a0n < m.\r\nA1 >= 0. A2, ..., AN (if exist) will in the range of [-1, 100]. \r\nLength of A is in the range of [1, 1000].\r\nB is in the range of [1, 100].\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/830", "similarQuestions": ["HouseRobber", "HouseRobberII"], "topicTags": ["DynamicProgramming"], "Solution": "public class Solution {\n    public List<Integer> cheapestJump(int[] A, int B) {\n        int n = A.length;\n        List<Integer> ans = new ArrayList<>();\n        if (A[n-1] == -1) return ans;\n        int[] dp = new int[n];\n        Arrays.fill(dp, 1000000);\n        dp[n-1] = 0;\n        int[] next = new int[n];\n        int[] idx = new int[n];\n        int l = n-1, r = n-1;\n        idx[n-1] = n-1;\n        for(int i = n-2; i >= 0; i--) {\n            if (A[i] == -1) continue;\n            while(r >= l && idx[r] > i + B) r--;\n            if (r < l) return ans;\n            dp[i] = dp[idx[r]] + A[i];\n            next[i] = idx[r];\n            while(l <= r && dp[i] <= dp[idx[l]]) l++;\n            idx[--l] = i;\n        }\n        //List<Integer> ans = new ArrayList<>();\n        //if (dp[0] == 1000000) return ans;\n        \n        for(int i = 0; i != n-1; i = next[i])\n            ans.add(i+1);\n        ans.add(n);\n        return ans;\n    }\n}", "total_acs": 3592, "total_submitted": 13981}, {"id": 657, "title": "Judge Route Circle", "url": "https://leetcode.com/problems/judge-route-circle/description", "companyTags": ["Google"], "difficulty": "Easy", "content": "\r\nInitially, there is a Robot at position (0, 0). Given a sequence of its moves, judge if this robot makes a circle, which means it moves back to the original place. \r\n\r\n\r\n\r\nThe move sequence is represented by a string. And each move is represent by a character. The valid robot moves are R (Right), L (Left), U (Up) and D (down). The output should be true or false representing whether the robot makes a circle.\r\n\r\n\r\nExample 1:\r\n\r\nInput: \"UD\"\r\nOutput: true\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: \"LL\"\r\nOutput: false\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/1465", "similarQuestions": ["FriendCircles"], "topicTags": ["String"], "Solution": "class Solution {\n    public boolean judgeCircle(String moves) {\n        char m[] = moves.toCharArray();\n        int U = gs('U', m);\n        int D = gs('D', m);\n        int L = gs('L', m);\n        int R = gs('R', m);\n        boolean Re;\n        if(U==D&&L==R)\n            Re = true;\n        else\n            Re = false;\n        return Re;\n    }\n    //\u521b\u5efa\u65b9\u6cd5gs()\u8ba1\u7b97\u5b57\u7b26\u6570\u7ec4zfsz[]\u4e2d\u5b57\u7b26zm\u7684\u4e2a\u6570\n    public int gs(char zm, char zfsz[]){\n            int n = 0;\n            for(int i = 0; i < zfsz.length; i++){\n                if(zfsz[i] == zm)\n                    n++;\n            }\n            return n;\n        }\n}", "total_acs": 58026, "total_submitted": 84673}, {"id": 658, "title": "Find K Closest Elements", "url": "https://leetcode.com/problems/find-k-closest-elements/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "\r\nGiven a sorted array, two integers k and x, find the k closest elements to x in the array.  The result should also be sorted in ascending order.\r\nIf there is a tie,  the smaller elements are always preferred.\r\n\r\n\r\nExample 1:\r\n\r\nInput: [1,2,3,4,5], k=4, x=3\r\nOutput: [1,2,3,4]\r\n\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: [1,2,3,4,5], k=4, x=-1\r\nOutput: [1,2,3,4]\r\n\r\n\r\n\r\nNote:\r\n\r\nThe value k is positive and will always be smaller than the length of the sorted array.\r\n Length of the given array is positive and will not exceed 104\r\n Absolute value of elements in the array and x will not exceed 104\r\n\r\n\r\n\r\n\r\n\r\n\r\nUPDATE (2017/9/19):\r\nThe arr parameter had been changed to an array of integers (instead of a list of integers). Please reload the code definition to get the latest changes.\r\n", "discussUrl": "https://discuss.leetcode.com/category/1467", "similarQuestions": ["GuessNumberHigherorLower", "GuessNumberHigherorLowerII", "FindK-thSmallestPairDistance"], "topicTags": ["BinarySearch"], "Solution": "class Solution {\n    public List<Integer> findClosestElements(int[] arr, int k, int x) {\n        List<Integer> res = new ArrayList<>();\n        int start = 0, end = arr.length-k;\n        while(start<end){\n            int mid = start + (end-start)/2;\n            if(Math.abs(arr[mid]-x)>Math.abs(arr[mid+k]-x)){ //this also ensure smaller is prefer if equals\n                start = mid+1;\n            } else {\n                end = mid;\n            }\n        }\n        for(int i=start; i<start+k; i++){\n            res.add(arr[i]);\n        }\n        return res;\n    }\n}", "total_acs": 13544, "total_submitted": 38195}, {"id": 659, "title": "Split Array into Consecutive Subsequences", "url": "https://leetcode.com/problems/split-array-into-consecutive-subsequences/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "You are given an integer array sorted in ascending order (may contain duplicates), you need to split them into several subsequences, where each subsequences consist of at least 3 consecutive integers. Return whether you can make such a split.\r\n\r\nExample 1:\r\n\r\nInput: [1,2,3,3,4,5]\r\nOutput: True\r\nExplanation:\r\nYou can split them into two consecutive subsequences : \r\n1, 2, 3\r\n3, 4, 5\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: [1,2,3,3,4,4,5,5]\r\nOutput: True\r\nExplanation:\r\nYou can split them into two consecutive subsequences : \r\n1, 2, 3, 4, 5\r\n3, 4, 5\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput: [1,2,3,4,4,5]\r\nOutput: False\r\n\r\n\r\n\r\nNote:\r\n\r\nThe length of the input is in range of [1, 10000]\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/1469", "similarQuestions": ["TopKFrequentElements"], "topicTags": ["Heap", "Greedy"], "Solution": "class Solution {\n    public boolean isPossible(int[] nums) {\n      /*  //(key,value) -> (number, freq of occurence)\n         Map<Integer, Integer> freq = new HashMap<>();\n        Map<Integer, Integer> appendfreq = new HashMap<>();\n        //We iterate through the array once to get the frequency of all the elements in the array\n        for (int i : nums) freq.put(i, freq.getOrDefault(i,0) + 1);\n        \n        //We iterate through the array once more and for each element we either see if it can be appended to a previously constructed consecutive sequence or if it can be the start of a new consecutive sequence. If neither are true, then we return false.\n        for (int i : nums) {\n            // we check if number can be used or all occurence are used.\n            if (freq.get(i) == 0) continue;\n            // If number already exists in some list, we append new number and update the freq for id given by new number and reduce by old number.\n            else if (appendfreq.getOrDefault(i,0) > 0) {\n                //when 4 occurs it will append to 1,2,3 as 1,2,3,4 as key 5->1 next number we are expecting\n                appendfreq.put(i, appendfreq.get(i) - 1);\n                appendfreq.put(i+1, appendfreq.getOrDefault(i+1,0) + 1);\n            }   \n            else if (freq.getOrDefault(i+1,0) > 0 && freq.getOrDefault(i+2,0) > 0) { // start new consequtive sequence \n                freq.put(i+1, freq.get(i+1) - 1);\n                freq.put(i+2, freq.get(i+2) - 1);\n                // we create id by next number we are expecting. in [1,2,3,3,4,4,5,5] it will form 1,2,3 with 4->1. next it will create 3,4,5 with 6->1.\n                appendfreq.put(i+3, appendfreq.getOrDefault(i+3,0) + 1);\n            }\n            else return false;\n            // reduce frequency by 1 to mark it used.\n            freq.put(i, freq.get(i) - 1);\n        }\n        \n        System.out.println(appendfreq);\n        return true; */\n        \n        // Let cur be the element currently being examined and cnt as its number of appearance. pre is the element processed immediately before cur.\n        int pre = Integer.MIN_VALUE, cur = 0, cnt = 0;\n        int p1 = 0, p2 = 0, p3 = 0; // The number of consecutive subsequences ending at pre with length of 1, length of 2 and length >= 3 are denoted as p1, p2 and p3, respectively. \n        int  c1 = 0, c2 = 0, c3 = 0;\n\n        for (int i = 0; i < nums.length; pre = cur, p1 = c1, p2 = c2, p3 = c3) {\n            for (cur = nums[i], cnt = 0; i < nums.length && cur == nums[i]; cnt++, i++);\n\n            if (cur != pre + 1) {\n                //cur cannot be added to any consecutive subsequences ending at pre, therefore, we must have p1 == 0 && p2 == 0; otherwise the input array cannot be split into consecutive subsequences of length >= 3\n                if (p1 != 0 || p2 != 0) return false;\n                //c1, c2, c3 be the number of consecutive subsequences ending at cur with length of 1, length of 2 and length >= 3, respectively, we will have c1 = cnt, c2 = 0, c3 = 0, which means we only have consecutive subsequence ending at cur with length of 1 and its number given by cnt.\n                c1 = cnt; c2 = 0; c3 = 0;\n\n            } else {//cur == pre + 1: for this case, cur can be added to consecutive subsequences ending at pre and thus extend those subsequences. But priorities should be given to those with length of 1 first, then length of 2 and lastly length >= 3\n                \n                //Also we must have cnt >= p1 + p2; otherwise the input array cannot be split into consecutive subsequences of length >= 3\n                if (cnt < p1 + p2) return false;\n               \n                // If cnt > p1 + p2 + p3, then we still have remaining cur that cannot be added to any subsequences. These residue cur will form subsequences of length 1, hence c1 = max(cnt - (p1 + p2 + p3), 0).\n                c1 = Math.max(0, cnt - (p1 + p2 + p3));\n                \n                //first adding cur to the end of subsequences of length 1 will make them subsequences of length 2, and we have p1 such subsequences, therefore c2 = p1\n                c2 = p1;\n                \n                // Then adding cur to the end of subsequences of length 2 will make them subsequences of length 3, and we have p2 such subsequences, therefore c3 is at least p2.\n                //If cnt > p1 + p2, we can add the remaining cur to the end of subsequences of length >= 3 to make them even longer subsequences. The number of such subsequences is the smaller one of p3 and cnt - (p1 + p2). In total, c3 = p2 + min(p3, cnt - (p1 + p2))\n                c3 = p2 + Math.min(p3, cnt - (p1 + p2));\n            }\n        }\n\n        //The input array can be split into consecutive subsequences of length >= 3 if and only if p1 == 0 && p2 == 0.\n        return p1 == 0 && p2 == 0;\n    }\n}", "total_acs": 6847, "total_submitted": 18657}, {"id": 660, "title": "Remove 9", "url": "https://leetcode.com/problems/remove-9/description", "companyTags": ["Houzz"], "difficulty": "Hard", "content": "Start from integer 1, remove any integer that contains 9 such as 9, 19, 29... \r\n\r\nSo now, you will have a new integer sequence: 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, ...\r\n\r\nGiven a positive integer n, you need to return the n-th integer after removing. Note that 1 will be the first integer.\r\n\r\nExample 1:\r\n\r\nInput: 9\r\nOutput: 10\r\n\r\n\r\n\r\n\r\n Hint: n will not exceed 9 x 10^8.\r\n", "discussUrl": "https://discuss.leetcode.com/category/1471", "similarQuestions": [""], "topicTags": ["Math"], "Solution": "class Solution {\n    \tpublic boolean contains9(int n){  \n\t\treturn String.valueOf(n).indexOf(\"9\") != -1; \n\t}\n\n    public int findNext( int currentNumber) { \n\t\tint skips = 0;\n\t\twhile (contains9(currentNumber)) { \n\t\t\tcurrentNumber ++;\n\t\t} \n\t\treturn currentNumber;\n\t}\n    public int newInteger(int n) {\n     return  Integer.parseInt(Integer.toString(n, 9));\n    }\n    public int newInteger2(int n) {\n        int number = 1;\n\t\tint counter = 1;\n\n\t\twhile (counter < n) {\n\t\t\tif (contains9(number + 1)) {  \n\t\t\t\t//counter ++;\n\t\t\t\t//number =  findNext(number + 1);\n\t\t\t\tnumber++;\n\t\t\t} else {\n\t\t\t\tnumber ++; \n\t\t\t\tcounter ++;\n\t\t\t}\n\t\t\t\n\t\t} \n\t\t\n\t\t// check the boundaries\n\t\treturn number;        \n    }\n}", "total_acs": 3664, "total_submitted": 7482}, {"id": 661, "title": "Image Smoother", "url": "https://leetcode.com/problems/image-smoother/description", "companyTags": ["Amazon"], "difficulty": "Easy", "content": "Given a 2D integer matrix M representing the gray scale of an image, you need to design a smoother to make the gray scale of each cell becomes the average gray scale (rounding down) of all the 8 surrounding cells and itself.  If a cell has less than 8 surrounding cells, then use as many as you can.\r\n\r\nExample 1:\r\n\r\nInput:\r\n[[1,1,1],\r\n [1,0,1],\r\n [1,1,1]]\r\nOutput:\r\n[[0, 0, 0],\r\n [0, 0, 0],\r\n [0, 0, 0]]\r\nExplanation:\r\nFor the point (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0\r\nFor the point (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0\r\nFor the point (1,1): floor(8/9) = floor(0.88888889) = 0\r\n\r\n\r\n\r\nNote:\r\n\r\nThe value in the given matrix is in the range of [0, 255].\r\nThe length and width of the given matrix are in the range of [1, 150].\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/1474", "similarQuestions": [""], "topicTags": ["Array"], "Solution": "class Solution {\n    public int[][] imageSmoother(int[][] M) {\n        \n        if(M.length == 0) return M;\n        int[][] MSmooth = new int[M.length][M[0].length];\n        for(int i = 0; i < M.length; i++){\n            for(int j = 0; j < M[0].length; j++){\n                MSmooth[i][j] = smooth(M, i, j, 1);\n            }\n        }\n        return MSmooth;\n        \n        \n    }\n    public int smooth(int[][] M, int i, int j, int padding){\n        int res = 0;\n        int count = 0;\n        for(int m = i - padding; m <= i + padding; m++){\n            for(int n = j - padding; n <= j + padding; n++){\n                if(m < 0 || m >= M.length || n < 0 || n >= M[0].length){\n                    \n                }else{\n                    res += M[m][n];\n                    count++;\n                }\n            }\n        }\n        return res/count;\n    }\n}", "total_acs": 14141, "total_submitted": 30838}, {"id": 662, "title": "Maximum Width of Binary Tree", "url": "https://leetcode.com/problems/maximum-width-of-binary-tree/description", "companyTags": ["Amazon"], "difficulty": "Medium", "content": "Given a binary tree, write a function to get the maximum width of the given tree. The width of a tree is the maximum width among all levels. The binary tree has the same structure as a full binary tree, but some nodes are null. \r\n\r\nThe width of one level is defined as the length between the end-nodes (the leftmost and right most non-null nodes in the level, where the null nodes between the end-nodes are also counted into the length calculation.\r\n\r\nExample 1:\r\n\r\nInput: \r\n\r\n           1\r\n         /   \\\r\n        3     2\r\n       / \\     \\  \r\n      5   3     9 \r\n\r\nOutput: 4\r\nExplanation: The maximum width existing in the third level with the length 4 (5,3,null,9).\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: \r\n\r\n          1\r\n         /  \r\n        3    \r\n       / \\       \r\n      5   3     \r\n\r\nOutput: 2\r\nExplanation: The maximum width existing in the third level with the length 2 (5,3).\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput: \r\n\r\n          1\r\n         / \\\r\n        3   2 \r\n       /        \r\n      5      \r\n\r\nOutput: 2\r\nExplanation: The maximum width existing in the second level with the length 2 (3,2).\r\n\r\n\r\nExample 4:\r\n\r\nInput: \r\n\r\n          1\r\n         / \\\r\n        3   2\r\n       /     \\  \r\n      5       9 \r\n     /         \\\r\n    6           7\r\nOutput: 8\r\nExplanation:The maximum width existing in the fourth level with the length 8 (6,null,null,null,null,null,null,7).\r\n\r\n\r\n\r\n\r\nNote:\r\nAnswer will in the range of 32-bit signed integer.\r\n", "discussUrl": "https://discuss.leetcode.com/category/1476", "similarQuestions": [""], "topicTags": ["Tree"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public int widthOfBinaryTree(TreeNode root) {\n        return helper(root, 0, 1, new ArrayList<Integer>(), new ArrayList<Integer>());\n    }\n    \n    private int helper(TreeNode root, int level, int index, ArrayList<Integer> starts, ArrayList<Integer> ends){\n        if(root == null){\n            return 0;\n        }\n        if(starts.size() == level){\n            starts.add(index);\n            ends.add(index);\n        }\n        else{\n            ends.set(level, index);\n        }\n        int cur = ends.get(level) - starts.get(level) + 1;\n        int left = helper(root.left, level + 1, index * 2, starts, ends);\n        int right = helper(root.right, level + 1, index * 2 + 1, starts, ends);\n        \n        return Math.max(cur, Math.max(left, right));\n    }\n    \n\n \n    \n}", "total_acs": 11050, "total_submitted": 28989}, {"id": 663, "title": "Equal Tree Partition", "url": "https://leetcode.com/problems/equal-tree-partition/description", "companyTags": ["Amazon"], "difficulty": "Medium", "content": "\r\nGiven a binary tree with n nodes, your task is to check if it's possible to partition the tree to two trees which have the equal sum of values after removing exactly one edge on the original tree.\r\n\r\n\r\nExample 1:\r\n\r\nInput:     \r\n    5\r\n   / \\\r\n  10 10\r\n    /  \\\r\n   2   3\r\n\r\nOutput: True\r\nExplanation: \r\n    5\r\n   / \r\n  10\r\n      \r\nSum: 15\r\n\r\n   10\r\n  /  \\\r\n 2    3\r\n\r\nSum: 15\r\n\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput:     \r\n    1\r\n   / \\\r\n  2  10\r\n    /  \\\r\n   2   20\r\n\r\nOutput: False\r\nExplanation: You can't split the tree into two trees with equal sum after removing exactly one edge on the tree.\r\n\r\n\r\n\r\nNote:\r\n\r\nThe range of tree node value is in the range of [-100000, 100000].\r\n1 <= n <= 10000\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/1478", "similarQuestions": [""], "topicTags": ["Tree"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    boolean equal = false;\n    TreeNode head;\n    public boolean checkEqualTree(TreeNode root) {\n        if( root == null ) {\n            return true;\n        }\n        if (root.left == null && root.right == null) return false;\n        \n        int total = sumTree( root );\n        if( total % 2 != 0 ) {\n            return false;\n        }\n        head = root;\n        findSum( root, total / 2 );\n        return equal;\n    }\n    \n    private int findSum( TreeNode root, int target ) {\n        if( root == null || equal ) {\n            return 0;\n        }\n        \n        int left = findSum( root.left, target );\n        int right = findSum( root.right, target );\n        if( root != head && root.val + left + right == target ) {\n            equal = true;\n            return 0;\n        }\n        return root.val + left + right;\n    }\n    \n    private int sumTree( TreeNode root ) {\n        if( root == null ) {\n            return 0;\n        }\n        \n        int left = sumTree( root.left );\n        int right = sumTree( root.right );\n        \n        return root.val + left + right;\n    }\n}", "total_acs": 6704, "total_submitted": 18386}, {"id": 664, "title": "Strange Printer", "url": "https://leetcode.com/problems/strange-printer/description", "companyTags": ["NetEase"], "difficulty": "Hard", "content": "\r\nThere is a strange printer with the following two special requirements:\r\n\r\n\r\nThe printer can only print a sequence of the same character each time.\r\nAt each turn, the printer can print new characters starting from and ending at any places, and will cover the original existing characters.\r\n\r\n\r\n\r\n\r\n\r\nGiven a string consists of lower English letters only, your job is to count the minimum number of turns the printer needed in order to print it.\r\n\r\n\r\nExample 1:\r\n\r\nInput: \"aaabbb\"\r\nOutput: 2\r\nExplanation: Print \"aaa\" first and then print \"bbb\".\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: \"aba\"\r\nOutput: 2\r\nExplanation: Print \"aaa\" first and then print \"b\" from the second place of the string, which will cover the existing character 'a'.\r\n\r\n\r\n\r\nHint: Length of the given string will not exceed 100.", "discussUrl": "https://discuss.leetcode.com/category/1480", "similarQuestions": ["RemoveBoxes"], "topicTags": ["DynamicProgramming", "Depth-firstSearch"], "Solution": "/*\nclass Solution {\n    public int strangePrinter(String s) {\n        if(s == null || s.length() == 0) return 0;\n        char[] chars = s.toCharArray();\n        int[] F = new int[chars.length+1];\n        for(int i = 0; i <= chars.length; i++ ) Arrays.fill(F,1);\n        for(int i =1; i <= chars.length; i++) {\n            for(int j = 0; j < i - 1; j++) {\n                if(chars[i-1] == chars[j]) {\n                    // fill(chars, j, i, chars[j]);\n                    // F[i] = F[i-1];\n                    // break;\n                    F[i] = F[j+1]\n                }\n                F[i] = F[i-1] + 1;\n            }\n            for(int i = 1; i < chars.length; i++) {\n                if(chars[i] - chars[i-1] > 1)\n            }\n        }\n        return F[chars.length];\n    }\n    private void fill(char[] chars, int start, int end, char character) {\n        for(int i = start; i < end; i++) {\n            chars[i] = character;\n        }\n    }\n}\n*/\n/*\nclass Solution {\n    public int strangePrinter(String s) {\n        int n=s.length();\n        int[][] f=new int[n][n];\n        for (int i=n-1;i>=0;i--) \n            for (int j=i;j<n;j++) \n            {\n                f[i][j]=(i==j)?1:1+f[i+1][j];\n                for (int k=i+1;k<=j;k++) \n                    if (s.charAt(k)==s.charAt(i)) f[i][j]=Math.min(f[i][j],f[i+1][k-1]+f[k][j]);\n            }\n        return (n==0?0:f[0][n-1]);\n    }  \n}\n*/\n/*\nclass Solution {\n    public int strangePrinter(String s) {\n        int n = s.length();\n        if (n == 0) return 0;\n        \n        int[][] dp = new int[101][101];\n        for (int i = 0; i < n; i++) dp[i][i] = 1;\n        \n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < n - i; j++) {\n                dp[j][j + i] = i + 1;\n                for (int k = j + 1; k <= j + i; k++) {\n                    int temp = dp[j][k - 1] + dp[k][j + i];\n                    if (s.charAt(k - 1) == s.charAt(j + i)) temp--;\n                    dp[j][j + i] = Math.min(dp[j][j + i], temp);\n                }\n            }\n        }\n        return dp[0][n - 1];\n    }\n}\n*/\nclass Solution {\n    public int strangePrinter(String s) {\n        if (s.length() == 0) return 0;\n        char[] sa = s.toCharArray();\n        int n = 1;\n        for (int i = 1; i < sa.length; ++i) {\n            if (sa[i] == sa[n - 1]) continue;\n            sa[n++] = sa[i];\n        }\n        int[][] dp = new int[n][n];\n        for (int j = 0; j < n; ++j) {\n            dp[j][j] = 1;\n            for (int i = j - 1; i >= 0; --i) {\n                if (sa[i] == sa[j]) {\n                    dp[i][j] = dp[i][j - 1];\n                    continue;\n                }\n                dp[i][j] = dp[i][j - 1] + 1;\n                for (int k = i + 1; k < j; ++k) {\n                    if (sa[k] == sa[j]) {\n                        if (dp[i][k - 1] + dp[k][j] < dp[i][j]) {\n                            dp[i][j] = dp[i][j - 1];\n                          break;\n                        }\n                    }\n                }\n            }\n        }\n        return dp[0][n - 1];\n    }\n}", "total_acs": 4299, "total_submitted": 12775}, {"id": 665, "title": "Non-decreasing Array", "url": "https://leetcode.com/problems/non-decreasing-array/description", "companyTags": ["Google"], "difficulty": "Easy", "content": "\r\nGiven an array with n integers, your task is to check if it could become non-decreasing by modifying at most 1 element.\r\n\r\n\r\n\r\nWe define an array is non-decreasing if array[i] <= array[i + 1] holds for every i (1 <= i < n).\r\n\r\n\r\nExample 1:\r\n\r\nInput: [4,2,3]\r\nOutput: True\r\nExplanation: You could modify the first 4 to 1 to get a non-decreasing array.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: [4,2,1]\r\nOutput: False\r\nExplanation: You can't get a non-decreasing array by modify at most one element.\r\n\r\n\r\n\r\nNote:\r\nThe n belongs to [1, 10,000].\r\n", "discussUrl": "https://discuss.leetcode.com/category/1483", "similarQuestions": [""], "topicTags": ["Array"], "Solution": "class Solution {\n    public boolean checkPossibility(int[] nums) {\n        if(nums.length ==0 || nums.length ==1 || nums.length ==2){\n               return true;\n        }\n     \n     int count =0;\n        //If i>i+1, then find which one is smaller among i+1 and i-1. add the value of i to it.\n        \n        for(int i =0; i+1<=nums.length-1; i++){\n            if( nums[i]>nums[i+1]){\n                count = count +1;\n                if(count>1){\n                    return false;\n                }\n                if (i > 0 && nums[i + 1] < nums[i - 1]){\n                    nums[i + 1] = nums[i];\n                    }    \n        }\n        \n    }\n        return count<=1;\n}\n}", "total_acs": 18773, "total_submitted": 91480}, {"id": 666, "title": "Path Sum IV", "url": "https://leetcode.com/problems/path-sum-iv/description", "companyTags": ["Alibaba"], "difficulty": "Medium", "content": "\r\nIf the depth of a tree is smaller than 5, then this tree can be represented by a list of three-digits integers.\r\n\r\n\r\n\r\nFor each integer in this list:\r\n\r\nThe hundreds digit represents the depth D of this node, 1 <= D <= 4.\r\nThe tens digit represents the position P of this node in the level it belongs to, 1 <= P <= 8. The position is the same as that in a full binary tree. \r\nThe units digit represents the value V of this node, 0 <= V <= 9.\r\n\r\n\r\n\r\n\r\nGiven a list of ascending three-digits integers representing a binary with the depth smaller than 5. You need to return the sum of all paths from the root towards the leaves.\r\n\r\n\r\nExample 1:\r\n\r\nInput: [113, 215, 221]\r\nOutput: 12\r\nExplanation: \r\nThe tree that the list represents is:\r\n    3\r\n   / \\\r\n  5   1\r\n\r\nThe path sum is (3 + 5) + (3 + 1) = 12.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: [113, 221]\r\nOutput: 4\r\nExplanation: \r\nThe tree that the list represents is: \r\n    3\r\n     \\\r\n      1\r\n\r\nThe path sum is (3 + 1) = 4.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/1485", "similarQuestions": ["PathSum", "PathSumII", "BinaryTreeMaximumPathSum", "PathSumIII"], "topicTags": ["Tree"], "Solution": "class Solution {\n    \n    private int pathSum(int[][] memo, int i, int j, int accu) {\n        if (memo[i][j] == -1) return accu;\n        // System.out.println(i + \" \" + j);\n        if (memo[i + 1][2 * j - 1] == -1 && memo[i + 1][2 * j] != -1) \n            return pathSum(memo, i + 1, 2 * j, accu + memo[i][j]);\n        if (memo[i + 1][2 * j] == -1 && memo[i + 1][2 * j - 1] != -1) \n            return pathSum(memo, i + 1, 2 * j - 1, accu + memo[i][j]);\n        return pathSum(memo, i + 1, 2 * j - 1, accu + memo[i][j]) + \n            pathSum(memo, i + 1, 2 * j, accu + memo[i][j]);\n    }\n    \n    public int pathSum(int[] nums) {\n        if (nums.length == 0) return 0;\n        int[][] memo = new int[6][17];\n        for (int i = 0; i <= 5; ++i) Arrays.fill(memo[i], -1);\n        for (int num: nums) memo[num / 100][num / 10 % 10] = num % 10;\n        // for (int i = 1; i <= 4; ++i) {\n        //     for (int j = 1; j <= 8; ++j) {\n        //         System.out.print(memo[i][j] + \" \");\n        //     }\n        //     System.out.println();\n        // }\n        return pathSum(memo, 1, 1, 0) / 2;\n    }\n}", "total_acs": 4010, "total_submitted": 7976}, {"id": 667, "title": "Beautiful Arrangement II", "url": "https://leetcode.com/problems/beautiful-arrangement-ii/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "\r\nGiven two integers n and k, you need to construct a list which contains n different positive integers ranging from 1 to n and obeys the following requirement: \r\n\r\nSuppose this list is [a1, a2, a3, ... , an], then the list [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] has exactly k distinct integers.\r\n\r\n\r\n\r\nIf there are multiple answers, print any of them.\r\n\r\n\r\nExample 1:\r\n\r\nInput: n = 3, k = 1\r\nOutput: [1, 2, 3]\r\nExplanation: The [1, 2, 3] has three different positive integers ranging from 1 to 3, and the [1, 1] has exactly 1 distinct integer: 1.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: n = 3, k = 2\r\nOutput: [1, 3, 2]\r\nExplanation: The [1, 3, 2] has three different positive integers ranging from 1 to 3, and the [2, 1] has exactly 2 distinct integers: 1 and 2.\r\n\r\n\r\n\r\nNote:\r\n\r\nThe n and k are in the range 1 <= k < n <= 104.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/1487", "similarQuestions": ["BeautifulArrangement"], "topicTags": ["Array"], "Solution": "class Solution {\n    public int[] constructArray(int n, int k) {\n        int [] result = new int[n];\n        int l = 1;\n        int r = n;\n        int c = k;\n        int i = 0;\n        while(c > 1) {\n            result[i] = l;\n            i++;\n            l++;\n            c--;\n            if(c > 1) {\n                result[i] = r;\n                i++;\n                r--;\n                c--;\n            }\n        }\n        for(; i < n; i++) {\n            if(k % 2 == 1) {\n                result[i] = l;\n                l++;\n            } else {\n                result[i] = r;\n                r--;\n            }\n        }\n        return result;\n    }\n}", "total_acs": 8168, "total_submitted": 15767}, {"id": 668, "title": "Kth Smallest Number in Multiplication Table", "url": "https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/description", "companyTags": ["Google"], "difficulty": "Hard", "content": "\r\nNearly every one have used the Multiplication Table. But could you find out the k-th smallest number quickly from the multiplication table?\r\n\r\n\r\n\r\nGiven the height m and the length n of a m * n Multiplication Table, and a positive integer k, you need to return the k-th smallest number in this table.\r\n\r\n\r\nExample 1:\r\n\r\nInput: m = 3, n = 3, k = 5\r\nOutput: \r\nExplanation: \r\nThe Multiplication Table:\r\n1\t2\t3\r\n2\t4\t6\r\n3\t6\t9\r\n\r\nThe 5-th smallest number is 3 (1, 2, 2, 3, 3).\r\n\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: m = 2, n = 3, k = 6\r\nOutput: \r\nExplanation: \r\nThe Multiplication Table:\r\n1\t2\t3\r\n2\t4\t6\r\n\r\nThe 6-th smallest number is 6 (1, 2, 2, 3, 4, 6).\r\n\r\n\r\n\r\n\r\nNote:\r\n\r\nThe m and n will be in the range [1, 30000].\r\nThe k will be in the range [1, m * n]\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/1489", "similarQuestions": ["KthSmallestElementinaSortedMatrix", "FindK-thSmallestPairDistance"], "topicTags": ["BinarySearch"], "Solution": "class Solution {\n    public int findKthNumber(int m, int n, int k) {\n        int l = 1, h = m*n;\n        while (l<h) {\n            int mid = l+(h-l)/2;\n            int count = count(m,n,mid);\n            if (count<k) l = mid+1;\n            else h = mid;\n        }\n        return h;\n    }\n    \n    private int count(int m, int n, int k) {\n        int i=m,j=1, count =0;\n        while (i>0 && j<=n) {\n            if (i*j<=k) {\n                count += i;\n                j++;\n            } else i--;\n        }\n        return count;\n    }\n}", "total_acs": 4900, "total_submitted": 12385}, {"id": 669, "title": "Trim a Binary Search Tree", "url": "https://leetcode.com/problems/trim-a-binary-search-tree/description", "companyTags": ["Bloomberg"], "difficulty": "Easy", "content": "\r\nGiven a binary search tree and the lowest and highest boundaries as L and R, trim the tree so that all its elements lies in [L, R] (R >= L). You might need to change the root of the tree, so the result should return the new root of the trimmed binary search tree.\r\n\r\n\r\nExample 1:\r\n\r\nInput: \r\n    1\r\n   / \\\r\n  0   2\r\n\r\n  L = 1\r\n  R = 2\r\n\r\nOutput: \r\n    1\r\n      \\\r\n       2\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: \r\n    3\r\n   / \\\r\n  0   4\r\n   \\\r\n    2\r\n   /\r\n  1\r\n\r\n  L = 1\r\n  R = 3\r\n\r\nOutput: \r\n      3\r\n     / \r\n   2   \r\n  /\r\n 1\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/1496", "similarQuestions": [""], "topicTags": ["Tree"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n      public TreeNode trimBST(TreeNode root, int L, int R) {\n        if (root == null) return null;\n\n        if (root.val < L) return trimBST(root.right, L, R);\n        if (root.val > R) return trimBST(root.left, L, R);\n\n        root.left = trimBST(root.left, L, R);\n        root.right = trimBST(root.right, L, R);\n\n        return root;\n    }\n\n}", "total_acs": 23208, "total_submitted": 39705}, {"id": 670, "title": "Maximum Swap", "url": "https://leetcode.com/problems/maximum-swap/description", "companyTags": ["Facebook"], "difficulty": "Medium", "content": "\r\nGiven a non-negative integer, you could swap two digits at most once to get the maximum valued number. Return the maximum valued number you could get.\r\n\r\n\r\nExample 1:\r\n\r\nInput: 2736\r\nOutput: 7236\r\nExplanation: Swap the number 2 and the number 7.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: 9973\r\nOutput: 9973\r\nExplanation: No swap.\r\n\r\n\r\n\r\n\r\nNote:\r\n\r\nThe given number is in the range [0, 108]\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/1498", "similarQuestions": ["CreateMaximumNumber"], "topicTags": ["Array", "Math"], "Solution": "class Solution {\n    public int maximumSwap(int num) {\n        char[] nums = String.valueOf(num).toCharArray();\n        for(int i = 0; i < nums.length; i++) {\n            int indexJ = -1;\n            for(int j = nums.length - 1; j > i; j--) {\n                if(nums[j] > nums[i]) {\n                    if(indexJ == -1 || nums[j] > nums[indexJ]) indexJ = j;\n                }\n            }\n            if(indexJ != -1) {\n                swap(nums, i, indexJ);\n                break;\n            }\n        }\n        return Integer.parseInt(String.valueOf(nums));\n    }\n    \n    public void swap(char[] nums, int i, int j) {\n        char temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}", "total_acs": 17023, "total_submitted": 44214}, {"id": 671, "title": "Second Minimum Node In a Binary Tree", "url": "https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/description", "companyTags": ["LinkedIn"], "difficulty": "Easy", "content": "\r\nGiven a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly two or zero sub-node. If the node has two sub-nodes, then this node's value is the smaller value among its two sub-nodes. \r\n\r\n\r\n\r\nGiven such a binary tree, you need to output the second minimum value in the set made of all the nodes' value in the whole tree. \r\n\r\n\r\n\r\nIf no such second minimum value exists, output -1 instead.\r\n\r\n\r\nExample 1:\r\n\r\nInput: \r\n    2\r\n   / \\\r\n  2   5\r\n     / \\\r\n    5   7\r\n\r\nOutput: 5\r\nExplanation: The smallest value is 2, the second smallest value is 5.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: \r\n    2\r\n   / \\\r\n  2   2\r\n\r\nOutput: -1\r\nExplanation: The smallest value is 2, but there isn't any second smallest value.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/1500", "similarQuestions": ["KthSmallestElementinaBST"], "topicTags": ["Tree"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public int findSecondMinimumValue(TreeNode root) {\n        if(root == null){\n            return -1;\n        }\n        if(root.left == null && root.right == null){\n            return -1;\n        }\n        int left = root.left.val;\n        int right = root.right.val;\n        if(root.left.val == root.val){\n            left = findSecondMinimumValue(root.left);\n        }\n        if(root.right.val == root.val){\n            right = findSecondMinimumValue(root.right);\n        }\n        if(left != -1 && right != -1){\n            return Math.min(left, right);\n        }\n        if(left != -1){\n            return left;\n        }\n        if(right != -1){\n            return right;\n        }\n        return right;\n    }\n}", "total_acs": 18662, "total_submitted": 44566}, {"id": 672, "title": "Bulb Switcher II", "url": "https://leetcode.com/problems/bulb-switcher-ii/description", "companyTags": ["Microsoft"], "difficulty": "Medium", "content": "\r\nThere is a room with n lights which are turned on initially and 4 buttons on the wall. After performing exactly m unknown operations towards buttons, you need to return how many different kinds of status of the n lights could be.\r\n\r\n\r\n\r\nSuppose n lights are labeled as number [1, 2, 3 ..., n], function of these 4 buttons are given below:\r\n\r\n\r\nFlip all the lights.\r\nFlip lights with even numbers.\r\nFlip lights with odd numbers.\r\nFlip lights with (3k + 1) numbers, k = 0, 1, 2, ...\r\n\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput: n = 1, m = 1.\r\nOutput: 2\r\nExplanation: Status can be: [on], [off]\r\n\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: n = 2, m = 1.\r\nOutput: 3\r\nExplanation: Status can be: [on, off], [off, on], [off, off]\r\n\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput: n = 3, m = 1.\r\nOutput: 4\r\nExplanation: Status can be: [off, on, off], [on, off, on], [off, off, off], [off, on, on].\r\n\r\n\r\n\r\nNote:\r\nn and m both fit in range [0, 1000].\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/1502", "similarQuestions": ["BulbSwitcher"], "topicTags": ["Math"], "Solution": "//O(1)\u6570\u5b66\u95ee\u9898\uff0c\u603b\u5171\u67098\u4e2astate  1111,1010,0101,0111,0000,0011, 1100 and 1001.\n//\u9700\u8981\u679a\u4e3e n>3\u4ee5\u540e\u5c31\u53ea\u80fd\u662f\u8fd98\u4e2astate\u4e86\n//n == 1 Only 2 possibilities: 1 and 0.\n//n == 2 After one operation, it has only 3 possibilities: 00, 10 and 01. After two and more operations, it has only 4 possibilities: 11, 10, 01 and 00.\n//n == 3 After one operation, it has only 4 possibilities: 000, 101, 010 and 011. After two operations, it has 7 possibilities: 111,101,010,100,000,001 and 110. After three and more operations, it has 8 possibilities, plus 011 on above case.\n//n >= 4 After one operation, it has only 4 possibilities: 0000, 1010, 0101 and 0110.\n//After two or more operations: it has 8 possibilities, 1111,1010,0101,0111,0000,0011, 1100 and 1001.\n\nclass Solution {\n    public int flipLights(int n, int m) {\n        n = Math.min(n, 3);\n        if (m == 0) return 1;\n        if (m == 1) return n == 1 ? 2 : n == 2 ? 3 : 4;\n        if (m == 2) return n == 1 ? 2 : n == 2 ? 4 : 7;\n        return n == 1 ? 2 : n == 2 ? 4 : 8;\n    }\n}", "total_acs": 4696, "total_submitted": 9527}, {"id": 673, "title": "Number of Longest Increasing Subsequence", "url": "https://leetcode.com/problems/number-of-longest-increasing-subsequence/description", "companyTags": ["Facebook"], "difficulty": "Medium", "content": "\r\nGiven an unsorted array of integers, find the number of longest increasing subsequence.\r\n\r\n\r\nExample 1:\r\n\r\nInput: [1,3,5,4,7]\r\nOutput: 2\r\nExplanation: The two longest increasing subsequence are [1, 3, 4, 7] and [1, 3, 5, 7].\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: [2,2,2,2,2]\r\nOutput: 5\r\nExplanation: The length of longest continuous increasing subsequence is 1, and there are 5 subsequences' length is 1, so output 5.\r\n\r\n\r\n\r\nNote:\r\nLength of the given array will be not exceed 2000 and the answer is guaranteed to be fit in 32-bit signed int.\r\n", "discussUrl": "https://discuss.leetcode.com/category/1506", "similarQuestions": ["LongestIncreasingSubsequence", "LongestContinuousIncreasingSubsequence"], "topicTags": ["DynamicProgramming"], "Solution": "class Solution {\n    // public int findNumberOfLIS(int[] nums) {\n        \n        // https://discuss.leetcode.com/topic/103020/java-c-simple-dp-solution-with-explanation\n//         int n = nums.length, res = 0, max_len = 0;\n//         int[] len =  new int[n], cnt = new int[n];\n//         for(int i = 0; i<n; i++){\n//             len[i] = cnt[i] = 1;\n//             for(int j = 0; j <i ; j++){\n//                 if(nums[i] > nums[j]) {\n//                     if(len[i] == len[j] + 1) {\n//                         // len[i] == len[j] + 1 means that you find another subsequence with the same length of LIS which ends with nums[i]\n//                         // This new path goes through j reaches i. There are cnt[j] ways contributed to the new paths to i.\n//                         cnt[i] += cnt[j];\n//                     }\n                    \n//                     // len[i] > len[j] + 1 means that you find a subsequence, but its length is smaller compared to LIS which ends with nums[i],\n//                     // so just ignore.\n//                     // len[i] < len[j] + 1 means paths go through j has longer length than the current state of i. So update i with state of j.\n//                     if(len[i] < len[j] + 1) {\n//                         len[i] = len[j] + 1;\n//                         cnt[i] = cnt[j];\n//                     }\n//                 }\n//             }\n            \n//             if(max_len == len[i]) res += cnt[i];\n            \n//             if(max_len < len[i]) {\n//                 max_len = len[i];\n//                 res = cnt[i];\n//             }\n//         }\n//         return res;        \n//     }\n    \n// The original method of nlogn for LIS problem can be showed in LeetCode 300.\n// The key is using an array as a stack to find proper place for each element.\n// For the ones not familiar with nlogn solution for LIS problem, please refer to:\n// https://discuss.leetcode.com/topic/28738/java-python-binary-search-o-nlogn-time-with-explanation\n\n// The key of modification is keeping (value, count) pair in ArrayList.\n\n//     Find the location of nums[i], say index, update dp array and sp pointer.\n//     Call the function collect, which helps collecting all the counts of the pairs at level index-1, with value less than nums[i] (which nums[i] can follow with).\n\n// Example\n// For input [16, 5, 8, 6, 1, 10, 5, 2, 15, 3, 2, 4, 1].\n// The final sol arraylist will be like below (val, count):\n// note: (10->2) means the LIS ends at value 10 has a length of 3(third layer), has 2 solution count.\n\n// [(16->1), (5->1), (1->1), (1->1)]\n// [(8->1), (6->1), (5->1), (2->1), (2->1)]\n// [(10->2), (3->1)]\n// [(15->2), (4->1)]\n// The result is sum of count at last layer [(15->2), (4->1)] which is 3.\n\n// The complexity may degenerate to n^2 for worst case.\n\n// The expected complexity is hard to compute but it is much better than two loop n^2 solution.    \n    \n    public int findNumberOfLIS(int[] nums) {\n        if(nums.length<=1)return nums.length;\n        int[] dp = new int[nums.length];\n        int sp=0;\n        ArrayList<ArrayList<Node>> sol = new ArrayList<>();\n        \n        //main loop starts\n        for(int i=0;i<nums.length;i++){\n            int l = 0, r=sp;\n             while(l!=r){\n                int mid = (l+r)/2;\n                if(dp[mid]<nums[i])l=mid+1;\n                 else r=mid;\n            }\n            dp[l]=nums[i];\n            if(l==sp)++sp;\n            collect(sol,nums[i],l);\n        }\n        int res = 0;\n        for(Node i:sol.get(sol.size()-1)){\n            res+=i.count;\n        }\n      return res;\n    }\n    \n    public void collect(ArrayList<ArrayList<Node>> sol, int val, int dest){\n        if(dest==sol.size())sol.add(new ArrayList<Node>());\n        Node cur = new Node(val,0);\n        if(dest==0)cur.count=1;\n        else{\n            for(Node i:sol.get(dest-1)){\n               if(i.val<cur.val)cur.count+=i.count;\n            }\n        }\n        sol.get(dest).add(cur);\n    }\n    \n    public static class Node {\n        int count, val;\n        public Node(int val, int count){\n           this.val=val;\n           this.count=count;\n        }\n     }\n\n}", "total_acs": 12036, "total_submitted": 38156}, {"id": 674, "title": "Longest Continuous Increasing Subsequence", "url": "https://leetcode.com/problems/longest-continuous-increasing-subsequence/description", "companyTags": ["Facebook"], "difficulty": "Easy", "content": "\r\nGiven an unsorted array of integers, find the length of longest continuous increasing subsequence (subarray).\r\n\r\n\r\nExample 1:\r\n\r\nInput: [1,3,5,4,7]\r\nOutput: 3\r\nExplanation: The longest continuous increasing subsequence is [1,3,5], its length is 3. \r\nEven though [1,3,5,7] is also an increasing subsequence, it's not a continuous one where 5 and 7 are separated by 4. \r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: [2,2,2,2,2]\r\nOutput: 1\r\nExplanation: The longest continuous increasing subsequence is [2], its length is 1. \r\n\r\n\r\n\r\nNote:\r\nLength of the array will not exceed 10,000.\r\n", "discussUrl": "https://discuss.leetcode.com/category/1508", "similarQuestions": ["NumberofLongestIncreasingSubsequence", "MinimumWindowSubsequence"], "topicTags": ["Array"], "Solution": "class Solution {\n    public int findLengthOfLCIS(int[] nums) {\n        if(nums.length == 0){\n            return 0;\n        }\n        int previous = nums[0];\n        int counter = 1;\n        int longest = 1;\n        for(int i = 1; i < nums.length; i++){\n            int current = nums[i];\n            if(current > previous){\n                counter++;\n                if(counter > longest){\n                    longest = counter;\n                }\n            }\n            else{\n                counter = 1;\n            }\n             previous = current;\n        }\n        return longest;\n    }\n}", "total_acs": 24509, "total_submitted": 57853}, {"id": 675, "title": "Cut Off Trees for Golf Event", "url": "https://leetcode.com/problems/cut-off-trees-for-golf-event/description", "companyTags": ["Amazon"], "difficulty": "Hard", "content": "\r\nYou are asked to cut off trees in a forest for a golf event. The forest is represented as a non-negative 2D map, in this map:\r\n\r\n0 represents the obstacle can't be reached.\r\n1 represents the ground can be walked through.\r\nThe place with number bigger than 1 represents a tree can be walked through, and this positive number represents the tree's height.\r\n\r\n\r\n\r\n\r\nYou are asked to cut off all the trees in this forest in the order of tree's height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1). \r\n\r\n\r\n\r\nYou will start from the point (0, 0) and you should output the minimum steps you need to walk to cut off all the trees. If you can't cut off all the trees, output -1 in that situation.\r\n\r\n\r\n\r\nYou are guaranteed that no two trees have the same height and there is at least one tree needs to be cut off.\r\n\r\n\r\nExample 1:\r\n\r\nInput: \r\n[\r\n [1,2,3],\r\n [0,0,4],\r\n [7,6,5]\r\n]\r\nOutput: 6\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: \r\n[\r\n [1,2,3],\r\n [0,0,0],\r\n [7,6,5]\r\n]\r\nOutput: -1\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput: \r\n[\r\n [2,3,4],\r\n [0,0,5],\r\n [8,7,6]\r\n]\r\nOutput: 6\r\nExplanation: You started from the point (0,0) and you can cut off the tree in (0,0) directly without walking.\r\n\r\n\r\n\r\n\r\nHint: size of the given matrix will not exceed 50x50.\r\n", "discussUrl": "https://discuss.leetcode.com/category/1510", "similarQuestions": [""], "topicTags": ["Breadth-firstSearch"], "Solution": null, "total_acs": 4871, "total_submitted": 18047}, {"id": 676, "title": "Implement Magic Dictionary", "url": "https://leetcode.com/problems/implement-magic-dictionary/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "\r\nImplement a magic directory with buildDict, and search methods.\r\n\r\n\r\n\r\nFor the method buildDict, you'll be given a list of non-repetitive words to build a dictionary.\r\n\r\n\r\n\r\nFor the method search, you'll be given a word, and judge whether if you modify exactly one character into another character in this word, the modified word is in the dictionary you just built.\r\n\r\n\r\nExample 1:\r\n\r\nInput: buildDict([\"hello\", \"leetcode\"]), Output: Null\r\nInput: search(\"hello\"), Output: False\r\nInput: search(\"hhllo\"), Output: True\r\nInput: search(\"hell\"), Output: False\r\nInput: search(\"leetcoded\"), Output: False\r\n\r\n\r\n\r\nNote:\r\n\r\nYou may assume that all the inputs are consist of lowercase letters a-z.\r\nFor contest purpose, the test data is rather small by now. You could think about highly efficient algorithm after the contest.\r\nPlease remember to RESET your class variables declared in class MagicDictionary, as static/class variables are persisted across multiple test cases. Please see here for more details.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/1512", "similarQuestions": ["ImplementTrie(PrefixTree)", "LongestWordinDictionary"], "topicTags": ["HashTable", "Trie"], "Solution": "class MagicDictionary {\n    private class Trie {\n        Trie[] next = new Trie[26];\n        boolean isWord = false;\n    }\n    \n    private Trie root;\n    /** Initialize your data structure here. */\n    public MagicDictionary() {\n        root = new Trie();\n    }\n    \n    /** Build a dictionary through a list of words */\n    public void buildDict(String[] dict) {\n        for(String word : dict) {\n            Trie walk = root;\n            for(char c : word.toCharArray()) {\n                int i = c-'a';\n                if(walk.next[i] == null) walk.next[i] = new Trie();\n                walk = walk.next[i];\n            }\n            walk.isWord = true;\n        }\n    }\n    \n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\n    public boolean search(String word) {\n        return search(root, word.toCharArray(), 0, 0);\n    }\n    private boolean search(Trie root, char[] word, int start, int changed) {\n        if(start == word.length) return root.isWord && changed == 1;\n        int index = word[start]-'a';        \n        for(int i=0; i<26; i++) {\n            if(root.next[i] == null) continue;\n            if(i == index) {\n                if(search(root.next[i], word, start+1, changed)) return true;\n            } else {\n                if(changed == 0 && search(root.next[i], word, start+1, changed+1)) return true;\n            }\n        }\n        return false;\n    }\n}", "total_acs": 9418, "total_submitted": 18985}, {"id": 677, "title": "Map Sum Pairs", "url": "https://leetcode.com/problems/map-sum-pairs/description", "companyTags": ["AkunaCapital"], "difficulty": "Medium", "content": "\r\nImplement a MapSum class with insert, and sum methods.\r\n\r\n\r\n\r\nFor the method insert, you'll be given a pair of (string, integer). The string represents the key and the integer represents the value. If the key already existed, then the original key-value pair will be overridden to the new one.\r\n\r\n\r\n\r\nFor the method sum, you'll be given a string representing the prefix, and you need to return the sum of all the pairs' value whose key starts with the prefix.\r\n\r\n\r\nExample 1:\r\n\r\nInput: insert(\"apple\", 3), Output: Null\r\nInput: sum(\"ap\"), Output: 3\r\nInput: insert(\"app\", 2), Output: Null\r\nInput: sum(\"ap\"), Output: 5\r\n\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/1515", "similarQuestions": [""], "topicTags": ["Trie"], "Solution": "class MapSum {\n\n\n    private String key;\n    private int val;\n    private int ans;\n    Map<String, Integer> m = new HashMap<>();\n    public MapSum() {\n      \n    }\n    \n    public void insert(String key, int val) {      \n        this.m.put(key, val);\n        \n    }\n    \n    public int sum(String prefix) \n{          ans = 0;\n           for (String key: m.keySet()) \n           {\n               \n             if(key.startsWith(prefix)) \n                 this.ans = this.ans + m.get(key);\n               \n           }\n        return ans;\n}\n}\n\n/**\n * Your MapSum object will be instantiated and called as such:\n * MapSum obj = new MapSum();\n * obj.insert(key,val);\n * int param_2 = obj.sum(prefix);\n */", "total_acs": 9356, "total_submitted": 18010}, {"id": 678, "title": "Valid Parenthesis String", "url": "https://leetcode.com/problems/valid-parenthesis-string/description", "companyTags": ["Alibaba"], "difficulty": "Medium", "content": "\r\nGiven a string containing only three types of characters: '(', ')' and '*', write a function to check whether this string is valid. We define the validity of a string by these rules:\r\n\r\nAny left parenthesis '(' must have a corresponding right parenthesis ')'.\r\nAny right parenthesis ')' must have a corresponding left parenthesis '('.\r\nLeft parenthesis '(' must go before the corresponding right parenthesis ')'.\r\n'*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string.\r\nAn empty string is also valid.\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput: \"()\"\r\nOutput: True\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: \"(*)\"\r\nOutput: True\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput: \"(*))\"\r\nOutput: True\r\n\r\n\r\n\r\nNote:\r\n\r\nThe string size will be in the range [1, 100].\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/1517", "similarQuestions": ["SpecialBinaryString"], "topicTags": ["String"], "Solution": "class Solution {\n    public boolean checkValidString(String s) {\n        if (s == null) return false;\n        \n        int lo = 0;\n        int hi = 0;\n        \n        for (char c : s.toCharArray()) {\n            if (c == '(') {\n                lo++;\n                hi++;\n            } else if (c == ')') {\n                lo--;\n                hi--;\n            } else if (c == '*') {\n                lo--;\n                hi++;\n            }\n            \n            if (hi < 0) return false;\n            lo = Math.max(0 ,lo);\n        }\n        \n        return lo == 0;\n    }\n}", "total_acs": 9011, "total_submitted": 30746}, {"id": 679, "title": "24 Game", "url": "https://leetcode.com/problems/24-game/description", "companyTags": ["Google"], "difficulty": "Hard", "content": "\r\nYou have 4 cards each containing a number from 1 to 9.  You need to judge whether they could operated through *, /, +, -, (, ) to get the value of 24.\r\n\r\n\r\nExample 1:\r\n\r\nInput: [4, 1, 8, 7]\r\nOutput: True\r\nExplanation: (8-4) * (7-1) = 24\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: [1, 2, 1, 2]\r\nOutput: False\r\n\r\n\r\n\r\nNote:\r\n\r\nThe division operator / represents real division, not integer division.  For example, 4 / (1 - 2/3) = 12.\r\nEvery operation done is between two numbers.  In particular, we cannot use - as a unary operator.  For example, with [1, 1, 1, 1] as input, the expression -1 - 1 - 1 - 1 is not allowed.\r\nYou cannot concatenate numbers together.  For example, if the input is [1, 2, 1, 2], we cannot write this as 12 + 12.\r\n\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/1519", "similarQuestions": [""], "topicTags": ["Depth-firstSearch"], "Solution": "class Solution {\n    double d = 0.0001;\n    public boolean judgePoint24(int[] nums) {\n        //brute force\n        for (int i = 0; i < 4; i++) {\n            for (int j = i+1; j < 4; j++) {\n                double a = (double)nums[i], b = (double)nums[j];\n                double cand1 = 0, cand2 = 0;\n                int cnt = 0;\n                for (int k = 0; k < 4; k++) {\n                    if (cnt == 0 && k!=i && k!=j) {\n                        cand1 = (double)nums[k];\n                        cnt++;\n                        \n                    }\n                    else if (cnt == 1 && k!=i && k!=j) {\n                        cand2 = (double)nums[k];\n                        break;\n                    }\n                }\n                double c = a+b;\n                if (judge3(cand1,cand2,c)) return true;\n                c = a-b;\n                if (judge3(cand1,cand2,c)) return true;\n                c = a*b;\n                if (judge3(cand1,cand2,c)) return true;\n                c = a/b;\n                if (judge3(cand1,cand2,c)) return true;\n                c = b-a;\n                if (judge3(cand1,cand2,c)) return true;\n                c = b/a;\n                if (judge3(cand1,cand2,c)) return true;\n            }\n        }\n        return false;\n    }\n    \n    boolean judge3(double a, double b, double c) {\n        //ab\n        double m = 0.0, n = c;\n        m = a+b;\n        if (judge2(m,n)) return true;\n        m = a-b;\n        if (judge2(m,n)) return true;\n        m = a*b;\n        if (judge2(m,n)) return true;\n        m = a/b;\n        if (judge2(m,n)) return true;\n        m = b/a;\n        if (judge2(m,n)) return true;\n        m = b-a;\n        if (judge2(m,n)) return true;\n        //ac\n        //n=b;b=c;c=n;\n        m = a+c;n=b;\n        if (judge2(m,n)) return true;\n        m = a-c;\n        if (judge2(m,n)) return true;\n        m = a/c;\n        if (judge2(m,n)) return true;\n        m = c/a;\n        if (judge2(m,n)) return true;\n        m = a*c;\n        if (judge2(m,n)) return true;\n        m = c-a;\n        if (judge2(m,n)) return true;\n        //bc\n        //n=a;a=c;\n        m = b+c;n=a;\n        if (judge2(m,n)) return true;\n        m = b-c;\n        if (judge2(m,n)) return true;\n        m = b/c;\n        if (judge2(m,n)) return true;\n        m = c/b;\n        if (judge2(m,n)) return true;\n        m = b*c;\n        if (judge2(m,n)) return true;\n        m = c-b;\n        if (judge2(m,n)) return true;\n        return false;\n    }\n    \n    boolean judge2(double a, double b) {\n        //System.out.println(a+\", \"+b + \", \" + b/a);\n        if ( Math.abs(b-a-24.0) < d || Math.abs(a*b-24.0) <d  || Math.abs(a+b-24.0)<d || Math.abs(a-b-24.0)<d || Math.abs(a/b-24.0)<d || Math.abs(b/a-24.0) <d )  return true;\n        return false;\n    }\n    \n}", "total_acs": 5796, "total_submitted": 14989}, {"id": 680, "title": "Valid Palindrome II", "url": "https://leetcode.com/problems/valid-palindrome-ii/description", "companyTags": ["Facebook"], "difficulty": "Easy", "content": "\r\nGiven a non-empty string s, you may delete at most one character.  Judge whether you can make it a palindrome.\r\n\r\n\r\nExample 1:\r\n\r\nInput: \"aba\"\r\nOutput: True\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: \"abca\"\r\nOutput: True\r\nExplanation: You could delete the character 'c'.\r\n\r\n\r\n\r\nNote:\r\n\r\nThe string will only contain lowercase characters a-z.\r\nThe maximum length of the string is 50000.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/1521", "similarQuestions": ["ValidPalindrome"], "topicTags": ["String"], "Solution": "class Solution {\n   public boolean validPalindrome(String s) {  \n        char[] cs = s.toCharArray();  \n        return validPalindrome(cs, 0, cs.length-1, 1);  \n    }  \n  \n    private boolean validPalindrome(char[] cs, int i, int j, int cap) {  \n        if(i<0||j<0||i>=cs.length||j>=cs.length)    return false;  \n        if(cap == -1)   return false;  \n        if(i >= j)       return true;  \n          \n        while(i<j && cs[i]==cs[j]) {  \n            i ++;  \n            j --;  \n        }  \n        if(i >= j)       return true;  \n          \n        return validPalindrome(cs, i+1, j, cap-1) || validPalindrome(cs, i, j-1, cap-1);  \n    }  \n}  ", "total_acs": 20988, "total_submitted": 64529}, {"id": 681, "title": "Next Closest Time", "url": "https://leetcode.com/problems/next-closest-time/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "Given a time represented in the format \"HH:MM\", form the next closest time by reusing the current digits. There is no limit on how many times a digit can be reused.\r\n\r\nYou may assume the given input string is always valid. For example, \"01:34\", \"12:09\" are all valid. \"1:34\", \"12:9\" are all invalid.\r\n\r\nExample 1:\r\n\r\nInput: \"19:34\"\r\nOutput: \"19:39\"\r\nExplanation: The next closest time choosing from digits 1, 9, 3, 4, is 19:39, which occurs 5 minutes later.  It is not 19:33, because this occurs 23 hours and 59 minutes later.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: \"23:59\"\r\nOutput: \"22:22\"\r\nExplanation: The next closest time choosing from digits 2, 3, 5, 9, is 22:22. It may be assumed that the returned time is next day's time since it is smaller than the input time numerically.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/1524", "similarQuestions": [""], "topicTags": ["String"], "Solution": "class Solution {\n    public String nextClosestTime(String time) {\n        char[] ta = time.toCharArray();\n        int[] nums = new int[4];\n        nums[0] = ta[0] - '0';\n        nums[1] = ta[1] - '0';\n        nums[2] = ta[3] - '0';\n        nums[3] = ta[4] - '0';\n        Arrays.sort(nums);\n        if (next(4, 9, nums, ta)\n            || next(3, 5, nums, ta)\n            || next(1, ta[0] == '2' ? 3 : 9, nums, ta))\n        {\n            return new String(ta);\n        }\n        next(0, 2, nums, ta);\n        return new String(ta);\n    }\n    \n    boolean next(int idx, int last, int[] nums, char[] ta)\n    {\n        int curr = ta[idx] - '0';\n        for (int i = 0; i < 4; i++)\n        {\n            if (nums[i] > last)\n            {\n                break;\n            }\n            else if (nums[i] > curr)\n            {\n                ta[idx] = (char)(nums[i] + '0');\n                return true;\n            }\n        }\n        ta[idx] = (char)(nums[0] + '0');\n        return false;\n    }\n}", "total_acs": 12439, "total_submitted": 29098}, {"id": 682, "title": "Baseball Game", "url": "https://leetcode.com/problems/baseball-game/description", "companyTags": ["Amazon"], "difficulty": "Easy", "content": "\r\nYou're now a baseball game point recorder.\r\n\r\n\r\n\r\nGiven a list of strings, each string can be one of the 4 following types:\r\n\r\nInteger (one round's score): Directly represents the number of points you get in this round.\r\n\"+\" (one round's score): Represents that the points you get in this round are the sum of the last two valid round's points.\r\n\"D\" (one round's score): Represents that the points you get in this round are the doubled data of the last valid round's points.\r\n\"C\" (an operation, which isn't a round's score): Represents the last valid round's points you get were invalid and should be removed.\r\n\r\n\r\n\r\n\r\nEach round's operation is permanent and could have an impact on the round before and the round after.\r\n\r\n\r\n\r\nYou need to return the sum of the points you could get in all the rounds.\r\n\r\n\r\nExample 1:\r\n\r\nInput: [\"5\",\"2\",\"C\",\"D\",\"+\"]\r\nOutput: 30\r\nExplanation: \r\nRound 1: You could get 5 points. The sum is: 5.\r\nRound 2: You could get 2 points. The sum is: 7.\r\nOperation 1: The round 2's data was invalid. The sum is: 5.  \r\nRound 3: You could get 10 points (the round 2's data has been removed). The sum is: 15.\r\nRound 4: You could get 5 + 10 = 15 points. The sum is: 30.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: [\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]\r\nOutput: 27\r\nExplanation: \r\nRound 1: You could get 5 points. The sum is: 5.\r\nRound 2: You could get -2 points. The sum is: 3.\r\nRound 3: You could get 4 points. The sum is: 7.\r\nOperation 1: The round 3's data is invalid. The sum is: 3.  \r\nRound 4: You could get -4 points (the round 3's data has been removed). The sum is: -1.\r\nRound 5: You could get 9 points. The sum is: 8.\r\nRound 6: You could get -4 + 9 = 5 points. The sum is 13.\r\nRound 7: You could get 9 + 5 = 14 points. The sum is 27.\r\n\r\n\r\n\r\nNote:\r\nThe size of the input list will be between 1 and 1000.\r\nEvery integer represented in the list will be between -30000 and 30000.\r\n", "discussUrl": "https://discuss.leetcode.com/category/1526", "similarQuestions": [""], "topicTags": ["Stack"], "Solution": "class Solution {\n    public int calPoints(String[] ops) {\n        String temp_str;\n\n\t\tint pos = 0;\n\t\tint[] temp_array = new int [2 * ops.length];\n\t\tint sum = 0;\n\t\tint temp;\n\n\t\tfor (int i = 0; i < ops.length; i++)\n\t\t{\n\t\t\ttemp_str = ops[i];\n\t\t\tif (temp_str.charAt(0) == 'C')\n\t\t\t{\n\t\t\t\tpos--;\n\t\t\t\tsum -= temp_array[pos];\n\t\t\t}\n\t\t\telse if (temp_str.charAt(0) == '+')\n\t\t\t{\n\t\t\t\ttemp_array[pos] = temp_array[pos - 1] + temp_array[pos - 2];\n\t\t\t\tpos++;\n\t\t\t\tsum += temp_array[pos-1];\n\t\t\t}\n\t\t\telse if (temp_str.charAt(0) == 'D')\n\t\t\t{\n\t\t\t\ttemp_array[pos] = temp_array[pos - 1] + temp_array[pos - 1];\n\t\t\t\tpos++;\n\t\t\t\tsum += temp_array[pos-1];\n\t\t\t}\n\t\t\telse if (temp_str.charAt(0) == '-')\n\t\t\t{\n\t\t\t\ttemp = 0;\n\t\t\t\tfor (int j = 1; j < temp_str.length(); j++)\n\t\t\t\t{\n\t\t\t\t\ttemp *= 10;\n\t\t\t\t\ttemp += temp_str.charAt(j) - 48;\n\t\t\t\t}\n\t\t\t\ttemp_array[pos] = (-temp);\n\t\t\t\tpos++;\n\t\t\t\tsum += (-temp);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttemp = 0;\n\t\t\t\tfor (int j = 0; j < temp_str.length(); j++)\n\t\t\t\t{\n\t\t\t\t\ttemp *= 10;\n\t\t\t\t\ttemp += temp_str.charAt(j) - 48;\n\t\t\t\t}\n\t\t\t\ttemp_array[pos] = temp;\n\t\t\t\tpos++;\n\t\t\t\tsum += temp;\n\t\t\t}\n\t\t}\n\t\treturn sum;\n    }\n}", "total_acs": 18519, "total_submitted": 31670}, {"id": 683, "title": "K Empty Slots", "url": "https://leetcode.com/problems/k-empty-slots/description", "companyTags": ["Google"], "difficulty": "Hard", "content": "\r\nThere is a garden with N slots. In each slot, there is a flower. The N flowers will bloom one by one in N days. In each day, there will be exactly one flower blooming and it will be in the status of blooming since then.\r\n\r\n\r\n\r\nGiven an array flowers consists of number from 1 to N. Each number in the array represents the place where the flower will open in that day.\r\n\r\n\r\n\r\nFor example, flowers[i] = x means that the unique flower that blooms at day i will be at position x, where i and x will be in the range from 1 to N.\r\n\r\n\r\n\r\nAlso given an integer k, you need to output in which day there exists two flowers in the status of blooming, and also the number of flowers between them is k and these flowers are not blooming.\r\n\r\n\r\n\r\nIf there isn't such day, output -1.\r\n\r\n\r\nExample 1:\r\n\r\nInput: \r\nflowers: [1,3,2]\r\nk: 1\r\nOutput: 2\r\nExplanation: In the second day, the first and the third flower have become blooming.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: \r\nflowers: [1,2,3]\r\nk: 1\r\nOutput: -1\r\n\r\n\r\n\r\n\r\nNote:\r\n\r\nThe given array will be in the range [1, 20000].\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/1528", "similarQuestions": [""], "topicTags": ["Array", "BinarySearchTree"], "Solution": "class Solution {\n    public int kEmptySlots(int[] flowers, int k) {\n        ArrayList<int[]> intervals = new ArrayList<>();\n        int day = 0;\n        intervals.add(new int[]{0,flowers.length + 1});\n        //if(k == flowers.length)return -1;\n        \n        day++;\n        while(!intervals.isEmpty() && day <= flowers.length){            \n            if(updateIntervals(intervals, flowers.length+1, flowers[day-1], k)) return day;\n            day++;\n        }\n        return -1;\n    }\n    \n    private boolean updateIntervals(ArrayList<int[]> intervals, int edge, int slot, int k){\n        int[] removeItem = null;\n        \n        for(int i = 0; i < intervals.size(); i++){\n            int[] interval = intervals.get(i);\n            if(interval[0] < slot && interval[1] > slot){\n                if(interval[1] != edge && interval[1] - slot - 1 == k || interval[0] != 0 && slot - interval[0] - 1 == k)\n                    return true;\n                \n                //split this interval\n                int tmp = interval[1];\n                if(slot - interval[0] - 1 > k){\n                    interval[1] = slot;\n                }\n                else{\n                    intervals.remove(i);\n                }\n                if(tmp - slot - 1 > k) intervals.add(new int[]{slot, tmp});\n            }\n        }\n        \n        return false;\n    }\n}", "total_acs": 10560, "total_submitted": 29707}, {"id": 684, "title": "Redundant Connection", "url": "https://leetcode.com/problems/redundant-connection/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "\r\nIn this problem, a tree is an undirected graph that is connected and has no cycles.\r\n\r\nThe given input is a graph that started as a tree with N nodes (with distinct values 1, 2, ..., N), with one additional edge added.  The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.\r\n\r\nThe resulting graph is given as a 2D-array of edges.  Each element of edges is a pair [u, v] with u < v, that represents an undirected edge connecting nodes u and v.\r\n\r\nReturn an edge that can be removed so that the resulting graph is a tree of N nodes.  If there are multiple answers, return the answer that occurs last in the given 2D-array.  The answer edge [u, v] should be in the same format, with u < v.\r\nExample 1:\r\n\r\nInput: [[1,2], [1,3], [2,3]]\r\nOutput: [2,3]\r\nExplanation: The given undirected graph will be like this:\r\n  1\r\n / \\\r\n2 - 3\r\n\r\n\r\nExample 2:\r\n\r\nInput: [[1,2], [2,3], [3,4], [1,4], [1,5]]\r\nOutput: [1,4]\r\nExplanation: The given undirected graph will be like this:\r\n5 - 1 - 2\r\n    |   |\r\n    4 - 3\r\n\r\n\r\nNote:\r\nThe size of the input 2D-array will be between 3 and 1000.\r\nEvery integer represented in the 2D-array will be between 1 and N, where N is the size of the input array.\r\n\r\n\r\n\r\n\r\n\r\nUpdate (2017-09-26):\r\nWe have overhauled the problem description + test cases and specified clearly the graph is an undirected graph. For the directed graph follow up please see Redundant Connection II). We apologize for any inconvenience caused.\r\n", "discussUrl": "https://discuss.leetcode.com/category/1530", "similarQuestions": ["RedundantConnectionII", "AccountsMerge"], "topicTags": ["Tree", "UnionFind", "Graph"], "Solution": "class Solution {\n  public int[] findRedundantConnection(int[][] edges) {\n        // max size 1000, num from 1 to 1000\n        int[] parent = new int[1001];\n        for (int[] edge: edges){\n            int a = find(parent, edge[0]);\n            int b = find(parent, edge[1]);\n            if (a == b) \n                return edge;\n            // union\n            parent[b] = a;\n        }\n        return new int[2];\n    }\n    private int find(int[] parent, int f) {\n        if (parent[f]==0) {\n            parent[f] = f;\n            return f;\n        }\n        while (f != parent[f]) {\n            parent[f] = parent[parent[f]];  // path compression\n            f = parent[f];\n        }\n        return f;\n    }\n}", "total_acs": 10418, "total_submitted": 24243}, {"id": 685, "title": "Redundant Connection II", "url": "https://leetcode.com/problems/redundant-connection-ii/description", "companyTags": ["Google"], "difficulty": "Hard", "content": "\r\nIn this problem, a rooted tree is a directed graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.\r\n\r\nThe given input is a directed graph that started as a rooted tree with N nodes (with distinct values 1, 2, ..., N), with one additional directed edge added.  The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.\r\n\r\nThe resulting graph is given as a 2D-array of edges.  Each element of edges is a pair [u, v] that represents a directed edge connecting nodes u and v, where u is a parent of child v.\r\n\r\nReturn an edge that can be removed so that the resulting graph is a rooted tree of N nodes.  If there are multiple answers, return the answer that occurs last in the given 2D-array.\r\nExample 1:\r\n\r\nInput: [[1,2], [1,3], [2,3]]\r\nOutput: [2,3]\r\nExplanation: The given directed graph will be like this:\r\n  1\r\n / \\\r\nv   v\r\n2-->3\r\n\r\n\r\nExample 2:\r\n\r\nInput: [[1,2], [2,3], [3,4], [4,1], [1,5]]\r\nOutput: [4,1]\r\nExplanation: The given directed graph will be like this:\r\n5 <- 1 -> 2\r\n     ^    |\r\n     |    v\r\n     4 <- 3\r\n\r\n\r\nNote:\r\nThe size of the input 2D-array will be between 3 and 1000.\r\nEvery integer represented in the 2D-array will be between 1 and N, where N is the size of the input array.\r\n", "discussUrl": "https://discuss.leetcode.com/category/1533", "similarQuestions": ["RedundantConnection"], "topicTags": ["Tree", "Depth-firstSearch", "UnionFind", "Graph"], "Solution": "class Solution {\n    public int[] findRedundantDirectedConnection(int[][] edges) {\n        int A[] = new int[2];\n        int B[] = new int[2];\n        int []parent = new int[edges.length + 1];\n        \n        for(int i = 0 ; i < edges.length; i++) {\n            if(parent[edges[i][1]] != 0) {\n                A[0] = edges[i][0]; A[1] = edges[i][1];\n                B[0] = parent[edges[i][1]]; \n                B[1] = edges[i][1];\n                edges[i][1] = 0;\n            } else {\n                parent[edges[i][1]] = edges[i][0];\n            }\n        }\n        \n        for(int i = 1; i <= edges.length; i++) {\n            parent[i] = i;\n        }\n        \n        for(int []e: edges) {\n            if (e[1] == 0) {\n                continue;\n            }\n            if(find(parent, e[0]) == e[1]) {\n                if(B[1] == 0) {\n                    return e;\n                }\n                return B;\n            } else {\n                parent[e[1]] = e[0];\n            }\n        }\n        \n        return A;\n    }\n    \n    private int find(int []parent, int f) {\n        while(parent[f] != f) {\n            parent[f] = parent[parent[f]];\n            f = parent[f];\n        }\n        \n        return f;\n    }\n    \n}", "total_acs": 4358, "total_submitted": 15342}, {"id": 686, "title": "Repeated String Match", "url": "https://leetcode.com/problems/repeated-string-match/description", "companyTags": ["Google"], "difficulty": "Easy", "content": "Given two strings A and B, find the minimum number of times A has to be repeated such that B is a substring of it. If no such solution, return -1.\r\n\r\n\r\nFor example, with A = \"abcd\" and B = \"cdabcdab\". \r\n\r\n\r\nReturn 3, because by repeating A three times (\u201cabcdabcdabcd\u201d), B is a substring of it; and B is not a substring of A repeated two times (\"abcdabcd\").\r\n\r\n\r\nNote:\r\nThe length of A and B will be between 1 and 10000.\r\n", "discussUrl": "https://discuss.leetcode.com/category/1535", "similarQuestions": ["RepeatedSubstringPattern"], "topicTags": ["String"], "Solution": "class Solution {\n    public int repeatedStringMatch(String A, String B) {\n        if(B.length()<=A.length()+1) {\n            if(A.contains(B)) return 1;\n            else {\n                String A2 = A+A;\n                if(A2.contains(B)) return 2;\n            }\n            return -1;\n        }\n        \n        char[] cb = B.toCharArray();\n        char[] ca = A.toCharArray();\n        int lena=ca.length;\n        int lenb=cb.length;\n        int start = 0;\n        int nrepeat=-1;\n        while(start<lenb) {\n            if(cb[start]==ca[0]) {\n                if(start>=lena) return -1;\n                int len=1;\n                while(start+len<lenb) {\n                    if(cb[start+len]==ca[len%lena]) {\n                        len++;\n                    }else{\n                        return -1;\n                    }\n                        \n                }\n                if(len%lena==0) nrepeat=len/lena;\n                else nrepeat = 1+len/lena;\n                if(start!=0) {\n                    \n                int n=1;\n                while(start-n>=0) {\n                    if(cb[start-n]!=ca[lena-n]) return -1;\n                    n++;\n                }\n                \n                nrepeat++;\n                }\n                break;\n            }\n            start++;\n        }\n        return nrepeat;\n    }\n}", "total_acs": 20466, "total_submitted": 61227}, {"id": 687, "title": "Longest Univalue Path", "url": "https://leetcode.com/problems/longest-univalue-path/description", "companyTags": ["Google"], "difficulty": "Easy", "content": "Given a binary tree, find the length of the longest path where each node in the path has the same value. This path may or may not pass through the root.\r\n\r\nNote: The length of path between two nodes is represented by the number of edges between them.\r\n\r\n\r\nExample 1:\r\n\r\n\r\n\r\n\r\nInput:\r\n\r\n              5\r\n             / \\\r\n            4   5\r\n           / \\   \\\r\n          1   1   5\r\n\r\n\r\n\r\n\r\nOutput:\r\n\r\n2\r\n\r\n\r\n\r\n\r\nExample 2:\r\n\r\n\r\n\r\n\r\nInput:\r\n\r\n              1\r\n             / \\\r\n            4   5\r\n           / \\   \\\r\n          4   4   5\r\n\r\n\r\n\r\n\r\nOutput:\r\n\r\n2\r\n\r\n\r\n\r\nNote:\r\nThe given binary tree has not more than 10000 nodes.  The height of the tree is not more than 1000.\r\n", "discussUrl": "https://discuss.leetcode.com/category/1537", "similarQuestions": ["BinaryTreeMaximumPathSum", "CountUnivalueSubtrees", "PathSumIII"], "topicTags": ["Tree", "Recursion"], "Solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    int max;\n    public int longestUnivaluePath(TreeNode root) {\n        if(root == null) return 0;\n        max = Integer.MIN_VALUE;\n        curUnivaluePath(root, root.val);\n        return max;\n    }\n    private int curUnivaluePath(TreeNode root, int value) {\n        if(root == null) return 0;\n        int left = curUnivaluePath(root.left, root.val);\n        int right = curUnivaluePath(root.right, root.val);\n        max = Math.max(max, left+right);\n        if(root.val == value) return Math.max(left, right)+1;\n        return 0;\n    }\n}", "total_acs": 17968, "total_submitted": 53959}, {"id": 688, "title": "Knight Probability in Chessboard", "url": "https://leetcode.com/problems/knight-probability-in-chessboard/description", "companyTags": ["GoldmanSachs"], "difficulty": "Medium", "content": "\r\nOn an NxN chessboard, a knight starts at the r-th row and c-th column and attempts to make exactly K moves.  The rows and columns are 0 indexed, so the top-left square is (0, 0), and the bottom-right square is (N-1, N-1).\r\n\r\n\r\n\r\nA chess knight has 8 possible moves it can make, as illustrated below.  Each move is two squares in a cardinal direction, then one square in an orthogonal direction.\r\n\r\n\r\n\r\n\r\n\r\nEach time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.\r\n\r\n\r\n\r\nThe knight continues moving until it has made exactly K moves or has moved off the chessboard.  Return the probability that the knight remains on the board after it has stopped moving.\r\n\r\n\r\nExample:\r\n\r\nInput: 3, 2, 0, 0\r\nOutput: 0.0625\r\nExplanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board.\r\nFrom each of those positions, there are also two moves that will keep the knight on the board.\r\nThe total probability the knight stays on the board is 0.0625.\r\n\r\n\r\n\r\nNote:\r\nN will be between 1 and 25.\r\nK will be between 0 and 100.\r\nThe knight always initially starts on the board.\r\n", "discussUrl": "https://discuss.leetcode.com/category/1539", "similarQuestions": ["OutofBoundaryPaths"], "topicTags": ["DynamicProgramming"], "Solution": "class Solution {\n    \n    // Let's get dynamic in here!\n    double[][][] theMatrix;\n    \n    public double knightProbability(int N, int K, int r, int c) {\n        theMatrix = new double[N][N][K+1];\n        \n        return knightProb(N,K,r,c);\n    }\n    \n    public double knightProb(int N, int K, int r, int c) {\n        if(r < 0 || c < 0 || r >= N || c >= N) { return 0; }\n        if(K == 0) { return 1; }        \n        if(theMatrix[r][c][K] != 0) { return theMatrix[r][c][K]; }\n        \n        double prob;\n        \n        prob =  knightProb(N,K-1,r+2,c+1);\n        prob += knightProb(N,K-1,r+2,c-1);\n        prob += knightProb(N,K-1,r+1,c+2);\n        prob += knightProb(N,K-1,r+1,c-2);\n        prob += knightProb(N,K-1,r-2,c+1);\n        prob += knightProb(N,K-1,r-2,c-1);\n        prob += knightProb(N,K-1,r-1,c+2);\n        prob += knightProb(N,K-1,r-1,c-2);\n        prob /= 8;\n        \n        // We can set up the memos pretty fast because\n        // of the symmetry of the board\n        theMatrix[r][c][K] = prob;\n        theMatrix[c][r][K] = prob;\n        theMatrix[N-1-r][c][K] = prob;\n        theMatrix[N-1-c][r][K] = prob;\n        theMatrix[r][N-1-c][K] = prob;\n        theMatrix[c][N-1-r][K] = prob;\n        theMatrix[N-1-r][N-1-c][K] = prob;\n        theMatrix[N-1-c][N-1-r][K] = prob;\n        \n        return prob;\n    }\n}", "total_acs": 5559, "total_submitted": 14027}, {"id": 689, "title": "Maximum Sum of 3 Non-Overlapping Subarrays", "url": "https://leetcode.com/problems/maximum-sum-of-3-non-overlapping-subarrays/description", "companyTags": ["Google", "Facebook"], "difficulty": "Hard", "content": "\r\nIn a given array nums of positive integers, find three non-overlapping subarrays with maximum sum.\r\n\r\n\r\nEach subarray will be of size k, and we want to maximize the sum of all 3*k entries.\r\n\r\n\r\nReturn the result as a list of indices representing the starting position of each interval (0-indexed).  If there are multiple answers, return the lexicographically smallest one.\r\n\r\nExample:\r\n\r\nInput: [1,2,1,2,6,7,5,1], 2\r\nOutput: [0, 3, 5]\r\nExplanation: Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5].\r\nWe could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger.\r\n\r\n\r\n\r\nNote:\r\nnums.length will be between 1 and 20000.\r\nnums[i] will be between 1 and 65535.\r\nk will be between 1 and floor(nums.length / 3).\r\n", "discussUrl": "https://discuss.leetcode.com/category/1541", "similarQuestions": ["BestTimetoBuyandSellStockIII"], "topicTags": ["Array", "DynamicProgramming"], "Solution": "class Solution {\n\tpublic int[] maxSumOfThreeSubarrays(int[] nums, int k) {\n\t\tint[] res = new int[] { -1, -1, -1 };\n\t\tint n = nums.length;\n\t\tif (k <= 0 || nums.length < 3 * k) { return res; }\n\t\tint[] presum = new int[n + 1];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tpresum[i] = presum[i - 1] + nums[i - 1];\n\t\t}\n\n\t\tint[] sum = new int[n]; // sum of window k starting at i\n\t\tfor (int i = 0; i <= n - k; i++) {\n\t\t\tsum[i] = presum[i + k] - presum[i];\n\t\t}\n\n\t\tint[] leftMax = new int[n]; // i: window start point at i, val: max window sum (left side)'s start index\n\t\tleftMax[0] = 0;\n\t\tfor (int i = 1; i <= n - 3 * k; i++) {\n            leftMax[i] = leftMax[i - 1];\n\t\t\tif (sum[i] > sum[leftMax[i - 1]]) {\n\t\t\t\tleftMax[i] = i;\n\t\t\t}\n\n\t\t}\n\n\t\tint[] rightMax = new int[n];  // i: window start point at i, val: max window sum (right side)'s start index\n\t\trightMax[n - k] = n - k;\n \t\tfor (int i = n - k - 1; i >= 2 * k; i--) {\n            rightMax[i] = rightMax[i + 1];\n\t\t\tif (sum[i] >= sum[rightMax[i + 1]]) {\n\t\t\t\trightMax[i] = i;\n\t\t\t}\n\t\t}\n\n\t\tint max = Integer.MIN_VALUE;\n\n\t\tfor (int i = k; i <= n - 2 * k; i++) {\n\t\t\tint cur = sum[leftMax[i - k]] + sum[i] + sum[rightMax[i + k]];\n\t\t\tif (cur > max) {\n                max = cur;\n\t\t\t\tres[0] = leftMax[i - k];\n\t\t\t\tres[1] = i;\n\t\t\t\tres[2] = rightMax[i + k];\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\n\t}\n}", "total_acs": 8228, "total_submitted": 19866}, {"id": 690, "title": "Employee Importance", "url": "https://leetcode.com/problems/employee-importance/description", "companyTags": ["Uber"], "difficulty": "Easy", "content": "You are given a data structure of employee information, which includes the employee's unique id, his importance value and his direct subordinates' id. \r\n\r\nFor example, employee 1 is the leader of employee 2, and employee 2 is the leader of employee 3. They have importance value 15, 10 and 5, respectively. Then employee 1 has a data structure like [1, 15, [2]], and employee 2 has [2, 10, [3]], and employee 3 has [3, 5, []]. Note that although employee 3 is also a subordinate of employee 1, the relationship is not direct.\r\n\r\nNow given the employee information of a company, and an employee id, you need to return the total importance value of this employee and all his subordinates.\r\n\r\nExample 1:\r\n\r\nInput: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1\r\nOutput: 11\r\nExplanation:\r\nEmployee 1 has importance value 5, and he has two direct subordinates: employee 2 and employee 3. They both have importance value 3. So the total importance value of employee 1 is 5 + 3 + 3 = 11.\r\n\r\n\r\n\r\nNote:\r\n\r\nOne employee has at most one direct leader and may have several subordinates.\r\nThe maximum number of employees won't exceed 2000.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/1543", "similarQuestions": ["NestedListWeightSum"], "topicTags": ["HashTable", "Depth-firstSearch", "Breadth-firstSearch"], "Solution": "/*\n// Employee info\nclass Employee {\n    // It's the unique id of each node;\n    // unique id of this employee\n    public int id;\n    // the importance value of this employee\n    public int importance;\n    // the id of direct subordinates\n    public List<Integer> subordinates;\n};\n*/\nclass Solution {\n    Employee[] mapping = new Employee[2000 + 1];\n    public int getImportance(List<Employee> employees, int id) {\n        for (Employee e : employees) {\n            mapping[e.id] = e;\n        }\n        \n        Employee target = mapping[id];\n        return helper(target);\n    }\n    \n    private int helper(Employee cur) {\n        int imp = 0;\n        if (cur != null) {\n            imp += cur.importance;      \n        \n            for(Integer sub : cur.subordinates) {\n                imp += helper(mapping[sub]);\n            }\n        }\n        \n        return imp;\n    }\n}", "total_acs": 16103, "total_submitted": 30958}, {"id": 691, "title": "Stickers to Spell Word", "url": "https://leetcode.com/problems/stickers-to-spell-word/description", "companyTags": ["IXL"], "difficulty": "Hard", "content": "\r\nWe are given N different types of stickers.  Each sticker has a lowercase English word on it.\r\n\r\nYou would like to spell out the given target string by cutting individual letters from your collection of stickers and rearranging them.\r\n\r\nYou can use each sticker more than once if you want, and you have infinite quantities of each sticker.\r\n\r\nWhat is the minimum number of stickers that you need to spell out the target?  If the task is impossible, return -1.\r\n\r\n\r\nExample 1:\r\nInput:\r\n[\"with\", \"example\", \"science\"], \"thehat\"\r\n\r\n\r\nOutput:\r\n3\r\n\r\n\r\nExplanation:\r\nWe can use 2 \"with\" stickers, and 1 \"example\" sticker.\r\nAfter cutting and rearrange the letters of those stickers, we can form the target \"thehat\".\r\nAlso, this is the minimum number of stickers necessary to form the target string.\r\n\r\n\r\nExample 2:\r\nInput:\r\n[\"notice\", \"possible\"], \"basicbasic\"\r\n\r\n\r\nOutput:\r\n-1\r\n\r\n\r\nExplanation:\r\nWe can't form the target \"basicbasic\" from cutting letters from the given stickers.\r\n\r\n\r\nNote:\r\nstickers has length in the range [1, 50].\r\nstickers consists of lowercase English words (without apostrophes).\r\ntarget has length in the range [1, 15], and consists of lowercase English letters.\r\nIn all test cases, all words were chosen randomly from the 1000 most common US English words, and the target was chosen as a concatenation of two random words.\r\nThe time limit may be more challenging than usual.  It is expected that a 50 sticker test case can be solved within 35ms on average.\r\n", "discussUrl": "https://discuss.leetcode.com/category/1546", "similarQuestions": ["RansomNote"], "topicTags": ["DynamicProgramming", "Backtracking"], "Solution": "class Solution {\n    \n    // memory O(2^m + n*26)\n    // time O(2^m * n * 26)\n\tpublic int minStickers(String[] stickers, String target) {\n\t   if (stickers == null || stickers.length == 0) {\n\t\t   return -1;\n\t   }\n\t    int n = stickers.length;\n\t    int[][] map = new int[n][26];\n\n\t    for (int i = 0; i < n; i++) {\n\t        for (char c : stickers[i].toCharArray()) {\n\t            map[i][c - 'a']++;\n\t        }\n\t    }\n\n\t    HashSet<String> set = new HashSet<>();\n\t    Queue<String> queue = new LinkedList<>();\n\t    queue.offer(target);\n\t    set.add(target);\n\t    int ans = 1;\n\t    while (!queue.isEmpty()) {\n\t    \tint size = queue.size();\n\t    \tfor (int m = 0; m < size; m++) {\n\t    \t\tString cur = queue.poll();\n\t\t        for (int i = 0; i < n; i++) {\n                    if (map[i][cur.charAt(0) - 'a'] == 0) continue;\n\t\t            String next = getNext(cur, map[i]);\n\t\t            if (next.equals(\"\")) return ans;\n\t\t            if (!set.contains(next)) {\n\t\t                set.add(next);\n\t\t                queue.offer(next);\n\t\t            }\n\t\t        }\n\t    \t}\n\t        ans++;\n\t    }\n\t    return -1;\n\t}\n\n\tprivate String getNext(String cur, int[] sticker) {\n\t    int[] curmap = new int[26];\n\t    for (char c : cur.toCharArray()) {\n\t        curmap[c - 'a']++;\n\t    }\n        StringBuilder sb = new StringBuilder();\n\t    for (int i = 0; i < 26; i++) {\n            if (curmap[i] > 0) {\n                for (int k = 0; k < Math.max(0, curmap[i] - sticker[i]); k++) {\n                     sb.append((char)(i + 'a'));\n                }\n            }\n\t    }\n        return sb.toString();\n\t}\n}", "total_acs": 3415, "total_submitted": 9846}, {"id": 692, "title": "Top K Frequent Words", "url": "https://leetcode.com/problems/top-k-frequent-words/description", "companyTags": ["Amazon", "Bloomberg", "Uber", "Yelp", "PocketGems"], "difficulty": "Medium", "content": "Given a non-empty list of words, return the k most frequent elements.\r\nYour answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first.\r\n\r\nExample 1:\r\n\r\nInput: [\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"], k = 2\r\nOutput: [\"i\", \"love\"]\r\nExplanation: \"i\" and \"love\" are the two most frequent words.\r\n    Note that \"i\" comes before \"love\" due to a lower alphabetical order.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: [\"the\", \"day\", \"is\", \"sunny\", \"the\", \"the\", \"the\", \"sunny\", \"is\", \"is\"], k = 4\r\nOutput: [\"the\", \"is\", \"sunny\", \"day\"]\r\nExplanation: \"the\", \"is\", \"sunny\" and \"day\" are the four most frequent words,\r\n    with the number of occurrence being 4, 3, 2 and 1 respectively.\r\n\r\n\r\n\r\nNote:\r\n\r\nYou may assume k is always valid, 1 \u2264 k \u2264 number of unique elements.\r\nInput words contain only lowercase letters.\r\n\r\n\r\n\r\nFollow up:\r\n\r\nTry to solve it in O(n log k) time and O(n) extra space.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/1548", "similarQuestions": ["TopKFrequentElements"], "topicTags": ["HashTable", "Heap", "Trie"], "Solution": "class Solution {\n    \n    class Word implements Comparable<Word> {\n        String s;\n        int cnt;\n        \n        public Word(String s_) {\n            s = s_;\n        }\n        \n        public int compareTo(Word w) {\n            if (w.cnt == this.cnt) {\n                return this.s.compareTo(w.s);\n            }\n            return w.cnt - this.cnt;\n        }\n    }\n    \n    public List<String> topKFrequent(String[] words, int k) {\n        Map<String, Word> m = new HashMap<>();\n        List<Word> l = new ArrayList<>();\n        for (int i = 0; i < words.length; i++) {\n            if (!m.containsKey(words[i])) {\n                m.put(words[i], new Word(words[i]));\n                l.add(m.get(words[i]));\n            }\n            m.get(words[i]).cnt++;\n        }\n        List<String> res = new ArrayList<>();\n        Collections.sort(l);\n        for (int i = 0; i < k;i++) res.add(l.get(i).s);\n        return res;\n    }\n}", "total_acs": 12879, "total_submitted": 31088}, {"id": 693, "title": "Binary Number with Alternating Bits", "url": "https://leetcode.com/problems/binary-number-with-alternating-bits/description", "companyTags": ["Yahoo"], "difficulty": "Easy", "content": "Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values.\r\n\r\nExample 1:\r\n\r\nInput: 5\r\nOutput: True\r\nExplanation:\r\nThe binary representation of 5 is: 101\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: 7\r\nOutput: False\r\nExplanation:\r\nThe binary representation of 7 is: 111.\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput: 11\r\nOutput: False\r\nExplanation:\r\nThe binary representation of 11 is: 1011.\r\n\r\n\r\n\r\nExample 4:\r\n\r\nInput: 10\r\nOutput: True\r\nExplanation:\r\nThe binary representation of 10 is: 1010.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/1550", "similarQuestions": ["Numberof1Bits"], "topicTags": ["BitManipulation"], "Solution": "class Solution {\n    public boolean hasAlternatingBits(int n) {\n        if(n <= 0) {\n            return false;\n        }\n        if(n == 1) {\n            return true;\n        }\n        \n        int tmp = n % 2;\n        n = n / 2;\n        while(n != 0) {\n            if(n % 2 == tmp) {\n                return false;\n            }\n            tmp = n % 2;\n            n /= 2;\n        }\n        return true;\n        \n    }\n}", "total_acs": 15732, "total_submitted": 28316}, {"id": 694, "title": "Number of Distinct Islands", "url": "https://leetcode.com/problems/number-of-distinct-islands/description", "companyTags": ["Amazon"], "difficulty": "Medium", "content": "Given a non-empty 2D array grid of 0's and 1's, an island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.)  You may assume all four edges of the grid are surrounded by water.\r\n\r\nCount the number of distinct islands.  An island is considered to be the same as another if and only if one island can be translated (and not rotated or reflected) to equal the other.\r\n\r\nExample 1:\r\n\r\n11000\r\n11000\r\n00011\r\n00011\r\n\r\nGiven the above grid map, return 1.\r\n\r\n\r\nExample 2:\r\n11011\r\n10000\r\n00001\r\n11011\r\nGiven the above grid map, return 3.\r\nNotice that:\r\n\r\n11\r\n1\r\n\r\nand\r\n\r\n 1\r\n11\r\n\r\nare considered different island shapes, because we do not consider reflection / rotation.\r\n\r\n\r\nNote:\r\nThe length of each dimension in the given grid does not exceed 50.\r\n", "discussUrl": "https://discuss.leetcode.com/category/1552", "similarQuestions": ["NumberofIslands", "NumberofDistinctIslandsII"], "topicTags": ["HashTable", "Depth-firstSearch"], "Solution": "class Solution {\n    public int numDistinctIslands(int[][] grid) {\n        int row=grid.length;\n        if(row==0) return 0;\n        int col=grid[0].length;\n        if(col==0) return 0;\n        HashSet<String> islands = new HashSet<>();\n        for(int i=0; i<row; i++){\n            for(int j=0; j<col; j++){\n                if(grid[i][j]==1){\n                    StringBuilder route = new StringBuilder();\n                    String direction = \"\";\n                    dfs(grid, i, j, route, direction);\n                    islands.add(route.toString());\n                }        \n            }\n        }\n        return islands.size();\n    }\n    \n    private void dfs(int[][] grid, int x, int y, StringBuilder route, String direction){\n        if(x<0 || x>=grid.length || y<0 || y>=grid[0].length || grid[x][y]!=1) return;\n\n        route.append(direction);\n        grid[x][y]=0;\n        dfs(grid, x-1, y, route, \"u\");\n        //route.append(\"1\");\n        dfs(grid, x+1, y, route, \"d\");\n        //route.append(\"2\");\n        dfs(grid, x, y+1, route, \"r\");\n        //route.append(\"3\");\n        dfs(grid, x, y-1, route, \"l\");\n        route.append(\"b\"); // \u5fc5\u8981\u7684\uff0c\u5982\u679c\u6ca1\u6709\uff0c\u5c31\u5bb9\u6613\u6df7\u8d77\u6765\u540c\u4e00\u8f6e\u7684\u4e24\u4e2a\u65b9\u5411\u3002\u4e00\u5b9a\u8981\u52a0\u533a\u5206\u7b26\u4e86\u5bf9\u4e8e\u6bcf\u4e00\u8f6e\uff01\uff01\n    }\n}", "total_acs": 5892, "total_submitted": 13011}, {"id": 695, "title": "Max Area of Island", "url": "https://leetcode.com/problems/max-area-of-island/description", "companyTags": ["Intuit"], "difficulty": "Easy", "content": "Given a non-empty 2D array grid of 0's and 1's, an island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.)  You may assume all four edges of the grid are surrounded by water.\r\n\r\nFind the maximum area of an island in the given 2D array.\r\n(If there is no island, the maximum area is 0.)\r\n\r\nExample 1:\r\n\r\n[[0,0,1,0,0,0,0,1,0,0,0,0,0],\r\n [0,0,0,0,0,0,0,1,1,1,0,0,0],\r\n [0,1,1,0,1,0,0,0,0,0,0,0,0],\r\n [0,1,0,0,1,1,0,0,1,0,1,0,0],\r\n [0,1,0,0,1,1,0,0,1,1,1,0,0],\r\n [0,0,0,0,0,0,0,0,0,0,1,0,0],\r\n [0,0,0,0,0,0,0,1,1,1,0,0,0],\r\n [0,0,0,0,0,0,0,1,1,0,0,0,0]]\r\n\r\nGiven the above grid, return 6.\r\n\r\nNote the answer is not 11, because the island must be connected 4-directionally.\r\n\r\n\r\nExample 2:\r\n[[0,0,0,0,0,0,0,0]]\r\nGiven the above grid, return 0.\r\n\r\n\r\nNote:\r\nThe length of each dimension in the given grid does not exceed 50.\r\n", "discussUrl": "https://discuss.leetcode.com/category/1554", "similarQuestions": ["NumberofIslands", "IslandPerimeter"], "topicTags": ["Array", "Depth-firstSearch"], "Solution": "class Solution {\n    public int maxAreaOfIsland(int[][] grid) {\n        if (grid == null || grid.length == 0) {\n            return 0;\n        }\n        int m = grid.length;\n        int n = grid[0].length;\n        int max = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    int area = dfs(grid, i, j, m, n, 0);\n                    max = Math.max(area, max);\n                }\n            }\n        }\n        return max;\n    }\n\n    private int dfs(int[][] grid, int i, int j, int m, int n, int area) {\n        if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] == 0) {\n            return area;\n        }\n        grid[i][j] = 0;\n        area++;\n        area = dfs(grid, i + 1, j, m, n, area);\n        area = dfs(grid, i, j + 1, m, n, area);\n        area = dfs(grid, i - 1, j, m, n, area);\n        area = dfs(grid, i, j - 1, m, n, area);\n        return area;\n    }\n}", "total_acs": 19358, "total_submitted": 37335}, {"id": 696, "title": "Count Binary Substrings", "url": "https://leetcode.com/problems/count-binary-substrings/description", "companyTags": ["Helix"], "difficulty": "Easy", "content": "Give a string s, count the number of non-empty (contiguous) substrings that have the same number of 0's and 1's, and all the 0's and all the 1's in these substrings are grouped consecutively. \r\n\r\nSubstrings that occur multiple times are counted the number of times they occur.\r\n\r\nExample 1:\r\n\r\nInput: \"00110011\"\r\nOutput: 6\r\nExplanation: There are 6 substrings that have equal number of consecutive 1's and 0's: \"0011\", \"01\", \"1100\", \"10\", \"0011\", and \"01\".\r\nNotice that some of these substrings repeat and are counted the number of times they occur.\r\nAlso, \"00110011\" is not a valid substring because all the 0's (and 1's) are not grouped together.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: \"10101\"\r\nOutput: 4\r\nExplanation: There are 4 substrings: \"10\", \"01\", \"10\", \"01\" that have equal number of consecutive 1's and 0's.\r\n\r\n\r\n\r\nNote:\r\ns.length will be between 1 and 50,000.\r\ns will only consist of \"0\" or \"1\" characters.\r\n", "discussUrl": "https://discuss.leetcode.com/category/1557", "similarQuestions": ["EncodeandDecodeStrings"], "topicTags": ["String"], "Solution": "class Solution {\n     public int countBinarySubstrings(String s) {\n        if(s==null || s.length()<=1){\n            return 0;\n        }   \n        char[] array = s.toCharArray();\n        int sum = 0;\n        char previousChar = array[0];\n        int count = 1;\n        int previous_count = 0;\n        for(int i=1;i<array.length;i++){\n            if(previousChar==array[i]){\n                count++;\n                if(previous_count>=count){\n                    sum++;\n                }\n            }else{\n                previous_count = count;\n                previousChar = array[i];\n                count = 1;\n                sum++;\n            }\n        }\n        \n        return sum;\n    }\n}", "total_acs": 11332, "total_submitted": 22185}, {"id": 697, "title": "Degree of an Array", "url": "https://leetcode.com/problems/degree-of-an-array/description", "companyTags": ["GEDigital"], "difficulty": "Easy", "content": "Given a non-empty array of non-negative integers nums, the degree of this array is defined as the maximum frequency of any one of its elements.\r\nYour task is to find the smallest possible length of a (contiguous) subarray of nums, that has the same degree as nums.\r\n\r\nExample 1:\r\n\r\nInput: [1, 2, 2, 3, 1]\r\nOutput: 2\r\nExplanation: \r\nThe input array has a degree of 2 because both elements 1 and 2 appear twice.\r\nOf the subarrays that have the same degree:\r\n[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]\r\nThe shortest length is 2. So return 2.\r\n\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: [1,2,2,3,1,4,2]\r\nOutput: 6\r\n\r\n\r\n\r\nNote:\r\nnums.length will be between 1 and 50,000.\r\nnums[i] will be an integer between 0 and 49,999.\r\n", "discussUrl": "https://discuss.leetcode.com/category/1559", "similarQuestions": ["MaximumSubarray"], "topicTags": ["Array"], "Solution": "class Solution {\n    public int findShortestSubArray(int[] nums) {\n        if (nums == null || nums.length == 0)\n            return 0;\n        int maxNum = 0;\n        for (int n : nums){\n            maxNum = Math.max(n, maxNum);\n        }\n\n        int[] start = new int[maxNum + 1];\n        int[] end = new int[maxNum + 1];\n        int[] que = new int[maxNum + 1];\n\n        for (int i = 0; i < nums.length; i++){\n            if (que[nums[i]] == 0)\n                start[nums[i]] = i;\n            end[nums[i]] = i;\n            que[nums[i]]++;\n        }\n\n        int max = 0;\n        for (int n : que)\n            max = Math.max(max, n);\n\n        List<Integer> maxNums = new ArrayList<>();\n        for (int i = 0; i < que.length; i++){\n            if (que[i] == max)\n                maxNums.add(i);\n        }\n\n        int res = nums.length;\n        for (int n : maxNums){\n            int r = end[n] - start[n] + 1;\n            res = Math.min(r, res);\n        }\n\n        return res;\n    }\n}", "total_acs": 15238, "total_submitted": 32525}, {"id": 698, "title": "Partition to K Equal Sum Subsets", "url": "https://leetcode.com/problems/partition-to-k-equal-sum-subsets/description", "companyTags": ["LinkedIn"], "difficulty": "Medium", "content": "Given an array of integers nums and a positive integer k, find whether it's possible to divide this array into k non-empty subsets whose sums are all equal.\r\n\r\nExample 1:\r\n\r\nInput: nums = [4, 3, 2, 3, 5, 2, 1], k = 4\r\nOutput: True\r\nExplanation: It's possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.\r\n\r\n\r\n\r\nNote:\r\n1 <= k <= len(nums) <= 16.\r\n0 < nums[i] < 10000.\r\n", "discussUrl": "https://discuss.leetcode.com/category/1561", "similarQuestions": ["PartitionEqualSubsetSum"], "topicTags": ["DynamicProgramming", "Recursion"], "Solution": "class Solution {\n    boolean[] visited;\n    \n    public boolean canPartitionKSubsets(int[] nums, int k) {\n        int sum=0;\n        for(int i: nums) sum += i;\n        if (k<=0 || sum%k!=0) return false;\n        \n        int target  = sum/k;\n        visited = new boolean[nums.length];\n        \n        return canPart(nums, 0, k, target, 0);\n    }\n    \n    private boolean canPart(int[] nums, int cum, int k, int target, int start_index) {\n        if (k==0) return true;\n        \n        if (cum == target) return canPart(nums, 0, k-1, target, 0);\n        for(int i=start_index; i<nums.length; i++) {\n            if (! visited[i] && nums[i] + cum <= target) {\n                visited[i] = true;\n                boolean bok = canPart(nums, nums[i]+cum, k, target, i+1);\n                if (bok) return true;\n                \n                visited[i] = false;\n            }\n        }\n        \n        return false;\n    }\n}", "total_acs": 10605, "total_submitted": 28118}, {"id": 699, "title": "Falling Squares", "url": "https://leetcode.com/problems/falling-squares/description", "companyTags": ["Uber", "Square"], "difficulty": "Hard", "content": "On an infinite number line (x-axis), we drop given squares in the order they are given.\r\nThe i-th square dropped (positions[i] = (left, side_length)) is a square with the left-most point being positions[i][0] and sidelength positions[i][1].\r\nThe square is dropped with the bottom edge parallel to the number line, and from a higher height than all currently landed squares.  We wait for each square to stick before dropping the next.\r\nThe squares are infinitely sticky on their bottom edge, and will remain fixed to any positive length surface they touch (either the number line or another square).  Squares dropped adjacent to each other will not stick together prematurely.\r\n\r\n\r\nReturn a list ans of heights.  Each height ans[i] represents the current highest height of any square we have dropped, after dropping squares represented by positions[0], positions[1], ..., positions[i].\r\n\r\n\r\nExample 1:\r\n\r\nInput: [[1, 2], [2, 3], [6, 1]]\r\nOutput: [2, 5, 5]\r\nExplanation:\r\n\r\nAfter the first drop of positions[0] = [1, 2]:\r\n_aa\r\n_aa\r\n-------\r\nThe maximum height of any square is 2.\r\n\r\nAfter the second drop of positions[1] = [2, 3]:\r\n__aaa\r\n__aaa\r\n__aaa\r\n_aa__\r\n_aa__\r\n--------------\r\nThe maximum height of any square is 5.  \r\nThe larger square stays on top of the smaller square despite where its center\r\nof gravity is, because squares are infinitely sticky on their bottom edge.\r\n\r\nAfter the third drop of positions[1] = [6, 1]:\r\n__aaa\r\n__aaa\r\n__aaa\r\n_aa\r\n_aa___a\r\n--------------\r\nThe maximum height of any square is still 5.\r\n\r\nThus, we return an answer of [2, 5, 5].\r\n\r\n\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: [[100, 100], [200, 100]]\r\nOutput: [100, 100]\r\nExplanation: Adjacent squares don't get stuck prematurely - only their bottom edge can stick to surfaces.\r\n\r\n\r\n\r\nNote:\r\n1 <= positions.length <= 1000.\r\n1 <= positions[i][0] <= 10^8.\r\n1 <= positions[i][1] <= 10^6.\r\n", "discussUrl": "https://discuss.leetcode.com/category/1563", "similarQuestions": ["TheSkylineProblem"], "topicTags": ["SegmentTree", "BinarySearchTree"], "Solution": "/**\n * Use a linked list to mantain the heights of different intervals.\n * (x, h), x denotes of the start of the hight, h.\n */\nclass Solution {\n    class Node {\n        int x, h;\n        Node next;\n        Node(int x, int h) {\n            this.x = x;\n            this.h = h;\n        }\n    }\n    public List<Integer> fallingSquares(int[][] positions) {\n        int n = positions.length, max = 0;\n        List<Integer> ans = new ArrayList<>();\n        Node head = new Node(0, 0);\n        for (int[] p : positions) {\n            Node prev = head;\n            while (prev.next != null && prev.next.x < p[0]) {\n                prev = prev.next;\n            }\n            int lasth = prev.h;\n            int h = (prev.next == null || prev.next.x > p[0]) ? prev.h + p[1] : p[1];\n            Node post = prev.next;\n            while (post != null && post.x < p[0] + p[1]) {\n                h = Math.max(h, post.h + p[1]);\n                lasth = post.h;\n                post = post.next;\n            }\n            Node cur = new Node(p[0], h);\n            prev.next = cur;\n            if (post == null || post.x > p[0] + p[1]) {\n                cur.next = new Node(p[0] + p[1], lasth);\n                cur = cur.next;\n            }\n            cur.next = post;\n            max = Math.max(max, h);\n            ans.add(max);\n        }\n        return ans;\n    }\n}", "total_acs": 3085, "total_submitted": 8310}, {"id": 711, "title": "Number of Distinct Islands II", "url": "https://leetcode.com/problems/number-of-distinct-islands-ii/description", "companyTags": ["Amazon"], "difficulty": "Hard", "content": "Given a non-empty 2D array grid of 0's and 1's, an island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.)  You may assume all four edges of the grid are surrounded by water.\r\n\r\nCount the number of distinct islands.  An island is considered to be the same as another if they have the same shape, or have the same shape after rotation (90, 180, or 270 degrees only) or reflection (left/right direction or up/down direction).\r\n\r\nExample 1:\r\n\r\n11000\r\n10000\r\n00001\r\n00011\r\n\r\nGiven the above grid map, return 1.\r\n\r\nNotice that:\r\n\r\n11\r\n1\r\n\r\nand\r\n\r\n 1\r\n11\r\n\r\nare considered same island shapes. Because if we make a 180 degrees clockwise rotation on the first island, then two islands will have the same shapes.\r\n\r\n\r\nExample 2:\r\n\r\n11100\r\n10001\r\n01001\r\n01110\r\nGiven the above grid map, return 2.\r\n\r\nHere are the two distinct islands:\r\n\r\n111\r\n1\r\n\r\nand\r\n\r\n1\r\n1\r\n\r\n\r\nNotice that:\r\n\r\n111\r\n1\r\n\r\nand\r\n\r\n1\r\n111\r\n\r\nare considered same island shapes. Because if we flip the first array in the up/down direction, then they have the same shapes.\r\n\r\n\r\nNote:\r\nThe length of each dimension in the given grid does not exceed 50.\r\n", "discussUrl": "https://discuss.leetcode.com/category/1566", "similarQuestions": ["NumberofDistinctIslands"], "topicTags": ["HashTable", "Depth-firstSearch"], "Solution": "class Solution {\n    static final long[] power2 = new long[50];\n    static\n    {\n        power2[0]=1;\n        for (int k=1;k<50;k++)\n            power2[k]=2*power2[k-1];\n    }\n    public int numDistinctIslands2(int[][] grid) {\n        if ((m = grid.length) == 0)\n            return 0;\n        \n        if ((n = grid[0].length) == 0)\n            return 0;\n\n        Map<String,Boolean> resultMap = new HashMap<>();\n        res = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) \n                {\n                    minI=maxI=i;\n                    minJ=maxJ=j;\n                    dfs(grid, i, j);\n                    storeIsland (grid, resultMap);\n                }\n            }\n        }\n        return res;\n    }\n    \n    private void storeIsland (int[][] grid, Map<String,Boolean> map)\n    {\n        int diffI = maxI-minI,diffJ = maxJ-minJ;\n        StringBuilder islandCode = new StringBuilder(/*(diffI+1)*17*/);\n        //Deque<String> stack = new ArrayDeque<>(diffI+1);\n        StringBuilder udMirror = new StringBuilder();\n        int i,j, idx, idx1;\n        for (i=minI;i<=maxI;i++)\n        {\n            long sum=0;\n            idx = diffJ;\n            for (j=minJ;idx>=0;j++)\n            {\n                if (grid[i][j] <0)\n                {\n                    sum += power2[idx];\n                }\n                idx--;\n            }\n            String tmp = new StringBuilder(17).append(sum).append(' ').toString();\n            //stack.push(tmp);\n            udMirror.insert(0,tmp);\n            islandCode.append(tmp);\n        }\n        \n        if (map.put(islandCode.toString(),true) == null)\n        {\n            res++;\n            //StringBuilder udMirror = new StringBuilder(/*(diffI+1)*17*/);\n           // while (!stack.isEmpty()) udMirror.append(stack.pop());\n            map.put(udMirror.toString(),true);\n            \n            StringBuilder lrMirror = new StringBuilder(/*(diffI+1)*17*/);\n            StringBuilder rotate180 = new StringBuilder(/*(diffI+1)*17*/);\n            for (i=minI;i<=maxI;i++)\n            {\n                long sum=0;\n                idx = 0;\n                for (j=minJ;idx<=diffJ;j++)\n                {\n                    if (grid[i][j] <0)\n                    {\n                        sum += power2[idx];\n                    }\n                    idx++;\n                }\n                String tmpStr = new StringBuilder(17).append(sum).append(' ').toString();\n                lrMirror.append(tmpStr);\n                rotate180.insert(0,tmpStr);\n            }\n            map.put(lrMirror.toString(),true);\n            map.put(rotate180.toString(),true);\n            \n            StringBuilder rotate90 = new StringBuilder(/*(diffJ+1)*17*/);\n            StringBuilder ud90 = new StringBuilder(/*(diffJ+1)*17*/);\n            StringBuilder rotate270 = new StringBuilder(/*(diffJ+1)*17*/);\n            StringBuilder ud270 = new StringBuilder(/*(diffJ+1)*17*/);\n            \n            for (j=minJ;j<=maxJ;j++)\n            {\n                long sum=0,sum270=0;\n                idx = 0;idx1=diffI;\n                for (i=minI;idx1>=0;i++)\n                {\n                    if (grid[i][j] <0)\n                    {\n                        sum += power2[idx];\n                        sum270 += power2[idx1];\n                        grid[i][j]=0;\n                    }\n                    idx++;idx1--;\n                }\n                String tmpStr = new StringBuilder(17).append(sum).append(' ').toString();\n                String tmpStr2 = new StringBuilder(17).append(sum270).append(' ').toString();\n                rotate90.append(tmpStr);\n                ud90.insert(0,tmpStr);\n                rotate270.insert(0,tmpStr2);\n                ud270.append(tmpStr2);\n            }\n            map.put(rotate90.toString(),true);\n            map.put(ud90.toString(),true);\n            map.put(ud270.toString(),true);\n            map.put(rotate270.toString(),true);\n        }\n        else\n        {\n            for (i=minI;i<=maxI;i++)\n                for (j=minJ;j<=maxJ;j++)\n                {\n                    if (grid[i][j] <0) grid[i][j]=0;\n                }\n        }\n    }\n\n    private void dfs(int[][] grid, int i, int j) {\n        if (i>maxI) maxI=i;\n        else if (i<minI) minI=i;\n        if (j>maxJ) maxJ=j;\n        else if (j<minJ) minJ=j;\n        grid[i][j] = -1;\n        \n        int tmp = i+1;\n        if (tmp<m && grid[tmp][j]==1) dfs(grid, tmp, j);\n        tmp = j+1;\n        if (tmp<n && grid[i][tmp] == 1) dfs(grid, i, tmp);\n        tmp = i-1;\n        if (i>0 && grid[tmp][j]==1) dfs(grid, tmp, j);\n        tmp = j-1;\n        if (j>0 && grid[i][tmp] == 1) dfs(grid, i, tmp);\n    }\n\n    private int m, n, minI,maxI, minJ, maxJ, res;\n}", "total_acs": 1075, "total_submitted": 2484}, {"id": 712, "title": "Minimum ASCII Delete Sum for Two Strings", "url": "https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/description", "companyTags": ["TripleByte"], "difficulty": "Medium", "content": "Given two strings s1, s2, find the lowest ASCII sum of deleted characters to make two strings equal.\r\n\r\nExample 1:\r\n\r\nInput: s1 = \"sea\", s2 = \"eat\"\r\nOutput: 231\r\nExplanation: Deleting \"s\" from \"sea\" adds the ASCII value of \"s\" (115) to the sum.\r\nDeleting \"t\" from \"eat\" adds 116 to the sum.\r\nAt the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: s1 = \"delete\", s2 = \"leet\"\r\nOutput: 403\r\nExplanation: Deleting \"dee\" from \"delete\" to turn the string into \"let\",\r\nadds 100[d]+101[e]+101[e] to the sum.  Deleting \"e\" from \"leet\" adds 101[e] to the sum.\r\nAt the end, both strings are equal to \"let\", and the answer is 100+101+101+101 = 403.\r\nIf instead we turned both strings into \"lee\" or \"eet\", we would get answers of 433 or 417, which are higher.\r\n\r\n\r\n\r\nNote:\r\n0 < s1.length, s2.length <= 1000.\r\nAll elements of each string will have an ASCII value in [97, 122]. \r\n", "discussUrl": "https://discuss.leetcode.com/category/1569", "similarQuestions": ["EditDistance", "LongestIncreasingSubsequence", "DeleteOperationforTwoStrings"], "topicTags": ["DynamicProgramming"], "Solution": "class Solution {\n    public int minimumDeleteSum(String s1, String s2) {\n        //dp[i][j] = dp[i-1][j-1] if s[i] == t[j]\n        //          = min(dp[i-1][j] + s[i]), dp[i][j-1] + t[j]\n        //dp[i][0] = dp[i-1][0] + s[i]\n        char[] c1 = s1.toCharArray();\n        char[] c2 = s2.toCharArray();\n        int[] pre = new int[c2.length + 1];\n        int[] cur = new int[pre.length], tmp = null;\n        for(int i= 0; i< c2.length; i++){\n            pre[i+1] = pre[i] + c2[i];\n        }\n        for(int i=0; i<c1.length; i++){\n            cur[0] = pre[0] + c1[i];\n            for(int j=0; j<c2.length; j++){\n                if(c1[i] == c2[j]) cur[j+1] = pre[j];\n                else{\n                    cur[j+1] = Math.min(pre[j+1] + c1[i], cur[j] + c2[j]);\n                }\n            }\n            tmp = pre;\n            pre = cur;\n            cur = tmp;\n        }\n        return pre[pre.length -1];\n    }\n}", "total_acs": 5622, "total_submitted": 10975}, {"id": 713, "title": "Subarray Product Less Than K", "url": "https://leetcode.com/problems/subarray-product-less-than-k/description", "companyTags": ["Yatra"], "difficulty": "Medium", "content": "Your are given an array of positive integers nums.\r\nCount and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than k.\r\n\r\nExample 1:\r\n\r\nInput: nums = [10, 5, 2, 6], k = 100\r\nOutput: 8\r\nExplanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6].\r\nNote that [10, 5, 2] is not included as the product of 100 is not strictly less than k.\r\n\r\n\r\n\r\nNote:\r\n0 < nums.length <= 50000.\r\n0 < nums[i] < 1000.\r\n0 <= k < 10^6.\r\n", "discussUrl": "https://discuss.leetcode.com/category/1571", "similarQuestions": ["MaximumProductSubarray", "MaximumSizeSubarraySumEqualsk", "SubarraySumEqualsK"], "topicTags": ["Array", "TwoPointers"], "Solution": "class Solution {\n    public int numSubarrayProductLessThanK(int[] nums, int k) {\n        return backtrack(nums, k, 0, 0, 1, true);\n    }\n    private int backtrack(int[] nums, int k, int count, int start, int product, boolean isFirstLevel) {\n        if(product < k) {\n            if(start != 0) count++;\n        }\n        else return count;\n        for(int i = start; i < nums.length; i++) {\n            count = backtrack(nums, k, count, i + 1, product * nums[i], false);\n            if(!isFirstLevel) return count;\n        }\n        return count;\n    }\n}", "total_acs": 7533, "total_submitted": 22672}, {"id": 714, "title": "Best Time to Buy and Sell Stock with Transaction Fee", "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description", "companyTags": ["Facebook", "Bloomberg"], "difficulty": "Medium", "content": "Your are given an array of integers prices, for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee.\r\nYou may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.  You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.)\r\nReturn the maximum profit you can make.\r\n\r\nExample 1:\r\n\r\nInput: prices = [1, 3, 2, 8, 4, 9], fee = 2\r\nOutput: 8\r\nExplanation: The maximum profit can be achieved by:\r\nBuying at prices[0] = 1Selling at prices[3] = 8Buying at prices[4] = 4Selling at prices[5] = 9The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.\r\n\r\n\r\n\r\nNote:\r\n0 < prices.length <= 50000.\r\n0 < prices[i] < 50000.\r\n0 <= fee < 50000.\r\n", "discussUrl": "https://discuss.leetcode.com/category/1573", "similarQuestions": ["BestTimetoBuyandSellStockII"], "topicTags": ["Array", "DynamicProgramming", "Greedy"], "Solution": "class Solution {\n    public int maxProfit(int[] prices, int fee) {\n        int cash = 0;\n        int hold = -prices[0];\n        for (int i = 1; i < prices.length; i++) {\n            cash = Math.max(cash, hold + prices[i] - fee);\n            hold = Math.max(hold, cash - prices[i]);\n        }\n        return cash;\n    }\n}", "total_acs": 11019, "total_submitted": 24744}, {"id": 715, "title": "Range Module", "url": "https://leetcode.com/problems/range-module/description", "companyTags": ["Coupang", "MachineZone"], "difficulty": "Hard", "content": "A Range Module is a module that tracks ranges of numbers. Your task is to design and implement the following interfaces in an efficient manner.\r\n\r\naddRange(int left, int right) Adds the half-open interval [left, right), tracking every real number in that interval.  Adding an interval that partially overlaps with currently tracked numbers should add any numbers in the interval [left, right) that are not already tracked.\r\n\r\nqueryRange(int left, int right) Returns true if and only if every real number in the interval [left, right)\r\n is currently being tracked.\r\n\r\nremoveRange(int left, int right) Stops tracking every real number currently being tracked in the interval [left, right).\r\n\r\nExample 1:\r\n\r\naddRange(10, 20): null\r\nremoveRange(14, 16): null\r\nqueryRange(10, 14): true (Every number in [10, 14) is being tracked)\r\nqueryRange(13, 15): false (Numbers like 14, 14.03, 14.17 in [13, 15) are not being tracked)\r\nqueryRange(16, 17): true (The number 16 in [16, 17) is still being tracked, despite the remove operation)\r\n\r\n\r\n\r\nNote:\r\nA half open interval [left, right) denotes all real numbers left <= x < right.\r\n\r\n0 < left < right < 10^9 in all calls to addRange, queryRange, removeRange.\r\nThe total number of calls to addRange in a single test case is at most 1000.\r\nThe total number of calls to queryRange in a single test case is at most 5000.\r\nThe total number of calls to removeRange in a single test case is at most 1000.\r\n", "discussUrl": "https://discuss.leetcode.com/category/1575", "similarQuestions": ["MergeIntervals", "InsertInterval", "DataStreamasDisjointIntervals"], "topicTags": ["Array", "SegmentTree", "BinarySearchTree"], "Solution": "class RangeModule {\n    \n    ArrayList<int[]> ls;\n    ItvComparator cp;\n    public RangeModule() {\n        ls = new ArrayList<int[]>();\n        cp = new ItvComparator();\n    }\n    \n    public void addRange(int left, int right) {\n        //System.out.print(\"\\nAdd \"+ left+\",\"+ right+\":\\t\");\n        int[] itv = new int[]{left, right};\n        int idx = Collections.binarySearch(ls,  itv, cp);   //[error] input wrong parameters\n        if(idx<0){\n            int[] pre = null;\n            idx = - idx -1;\n            if(idx>0){\n                pre = ls.get(idx-1);\n                //System.out.print(\"pre (\" + pre[0]+\",\"+ pre[1]+\")-> \");\n                if(pre[1] >= itv[0]){\n                    pre[1] = Math.max(pre[1], itv[1]);\n                    itv = pre;\n                   // System.out.print(\"merge \"+pre[0]+\",\"+ pre[1]+\")\\t\");\n                }else {\n                    ls.add(idx, itv);\n                    idx++;  //[error correction] add idx++ here\n                }\n            }else {\n                ls.add(idx, itv);\n                idx++;  //[error correction] add idx++ here\n            }\n            //merge interval on right\n            /*idx++;  //[errr] should not put it here, if merged to previous, idx should stay unchanged\n            */\n            while(idx<ls.size()){\n                pre = ls.get(idx);\n                //System.out.print(\"back (\"+pre[0]+\",\"+ pre[1]+\")\\t\");\n                if(itv[1]>= pre[0]){\n                    itv[1] = Math.max(itv[1], pre[1]);\n                    ls.remove(idx);\n                }else break;\n            }\n        }\n    }\n    \n    public boolean queryRange(int left, int right) {\n        //System.out.println();\n        int[] itv = new int[]{left, right}, tmp = null;\n        int idx = Collections.binarySearch(ls, itv, cp);\n        if(idx>=0) return true;\n        idx = -idx - 1;\n        if(idx >0){\n            tmp = ls.get(idx-1);\n                //System.out.print(left+\",\"+right+\")\\tpre: \" + tmp[0]+\",\"+tmp[1]+\")\\t back: \");\n            if(tmp[1]>=itv[1]) return true;\n        }\n        if(idx<ls.size()){\n            tmp = ls.get(idx);\n            //System.out.print(tmp[0]+\", \"+tmp[1]+\")\\t\");\n            if(itv[0]==tmp[0] && itv[1]<=tmp[1]) return true;\n        }\n        return false;\n    }\n    \n    public void removeRange(int left, int right) {\n        //System.out.println();\n        //System.out.print(\"Remove:\\t\"+left+\",\" + right+\": \");\n        int[] itv = new int[]{left, right}, tmp = null;\n        int idx = Collections.binarySearch(ls, itv, cp);\n        if(idx>=0) {\n            //System.out.print(\"same\");\n            ls.remove(idx);\n            return; // [error] forget to terminate\n        }\n        idx = -idx - 1;\n        if(idx>0){\n            tmp = ls.get(idx-1);\n            //System.out.print(\"\\tpre:\"+tmp[0]+\",\" + tmp[1]+\"->\");\n            if(tmp[1]> itv[0]){ //overlap\n                if(tmp[1]<=itv[1]) {\n                    tmp[1] = itv[0]; //cut tail\n                    //System.out.print(tmp[0]+\",\" + tmp[1]+\")\\t\");\n                }\n                else{// split\n                    itv[1] = tmp[1];\n                    tmp[1] = left;\n                    itv[0] = right;\n                    ls.add(idx, itv);\n                    idx++;\n                    //System.out.print(tmp[0]+\",\" + tmp[1]+\"\\t\");\n                    //System.out.print(itv[0]+\",\" + itv[1]+\"\\t\");\n                }\n            }\n        }\n        while(idx<ls.size()){\n            tmp = ls.get(idx);\n            //System.out.print(\"remove:\");\n            if(right >= tmp[1]) {\n                ls.remove(idx);\n                //System.out.print(tmp[0]+\",\" + tmp[1]+\"\\t\");\n            }else{\n                if(right> tmp[0]){\n                    tmp[0] = right;\n                    //System.out.print(\"change:\"+tmp[0]+\",\" + tmp[1]+\"->\");\n                }\n                break;\n            }\n        }\n    }\n    \n    class ItvComparator implements Comparator<int[]>{\n        @Override\n        public int compare(int[] a, int[] b){\n            if(a[0] == b[0]) return a[1] - b[1];\n            else return a[0] - b[0];\n        }\n    }\n}\n\n/**\n * Your RangeModule object will be instantiated and called as such:\n * RangeModule obj = new RangeModule();\n * obj.addRange(left,right);\n * boolean param_2 = obj.queryRange(left,right);\n * obj.removeRange(left,right);\n */", "total_acs": 2554, "total_submitted": 8148}, {"id": 716, "title": "Max Stack", "url": "https://leetcode.com/problems/max-stack/description", "companyTags": ["LinkedIn"], "difficulty": "Hard", "content": "Design a max stack that supports push, pop, top, peekMax and popMax.\r\n\r\n\r\n\r\npush(x) -- Push element x onto stack.\r\npop() -- Remove the element on top of the stack and return it.\r\ntop() -- Get the element on the top.\r\npeekMax() -- Retrieve the maximum element in the stack.\r\npopMax() -- Retrieve the maximum element in the stack, and remove it. If you find more than one maximum elements, only remove the top-most one.\r\n\r\n\r\n\r\nExample 1:\r\n\r\nMaxStack stack = new MaxStack();\r\nstack.push(5); \r\nstack.push(1);\r\nstack.push(5);\r\nstack.top(); -> 5\r\nstack.popMax(); -> 5\r\nstack.top(); -> 1\r\nstack.peekMax(); -> 5\r\nstack.pop(); -> 1\r\nstack.top(); -> 5\r\n\r\n\r\n\r\nNote:\r\n\r\n-1e7 <= x <= 1e7\r\nNumber of operations won't exceed 10000.\r\nThe last four operations won't be called when stack is empty.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/1579", "similarQuestions": ["MinStack"], "topicTags": ["Design"], "Solution": "class MaxStack {\n\n    private int[] values = new int[10010];\n    private int[] maxValues = new int[10010];\n    private int top = 0;\n\n    /** initialize your data structure here. */\n    public MaxStack() {\n    }\n\n    public void push(int x) {\n        values[top] = x;\n        maxValues[top] = x;\n        if (top - 1 >= 0) {\n            maxValues[top] = Math.max(maxValues[top - 1] , maxValues[top]);\n        }\n        top ++;\n    }\n\n    public int pop() {\n        top --;\n        return values[top];\n    }\n\n    public int top() {\n        return values[top - 1];\n    }\n\n    public int peekMax() {\n        return maxValues[top - 1];\n    }\n\n    public int popMax() {\n        int pos = top - 1 , max = maxValues[top - 1];\n        while (values[pos] != max) {\n            pos --;\n        }\n        for (int i = pos + 1;i < top;i ++) {\n            values[i - 1] = values[i];\n            if (i - 2 >= 0) {\n                maxValues[i - 1] = Math.max(values[i - 1] , maxValues[i - 2]);\n            } else {\n                maxValues[i - 1] = values[i];\n            }\n        }\n        top --;\n        return max;\n    }\n\n}\n\n\n/**\n* Your MaxStack object will be instantiated and called as such:\n* MaxStack obj = new MaxStack();\n* obj.push(x);\n* int param_2 = obj.pop();\n* int param_3 = obj.top();\n* int param_4 = obj.peekMax();\n* int param_5 = obj.popMax();\n*/", "total_acs": 3014, "total_submitted": 8112}, {"id": 717, "title": "1-bit and 2-bit Characters", "url": "https://leetcode.com/problems/1-bit-and-2-bit-characters/description", "companyTags": ["Quora"], "difficulty": "Easy", "content": "We have two special characters. The first character can be represented by one bit 0. The second character can be represented by two bits (10 or 11).  \r\n\r\nNow given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero.\r\n\r\nExample 1:\r\n\r\nInput: \r\nbits = [1, 0, 0]\r\nOutput: True\r\nExplanation: \r\nThe only way to decode it is two-bit character and one-bit character. So the last character is one-bit character.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: \r\nbits = [1, 1, 1, 0]\r\nOutput: False\r\nExplanation: \r\nThe only way to decode it is two-bit character and two-bit character. So the last character is NOT one-bit character.\r\n\r\n\r\n\r\nNote:\r\n1 <= len(bits) <= 1000.\r\nbits[i] is always 0 or 1.\r\n", "discussUrl": "https://discuss.leetcode.com/category/1581", "similarQuestions": ["GrayCode"], "topicTags": ["Array"], "Solution": "class Solution {\n    public boolean isOneBitCharacter(int[] bits) {\n        int index = -1;\n        for(int i = bits.length - 2; i >= 0; i--) {\n            if(bits[i] == 0) {\n                index = i;\n                break;\n            }\n                \n        }\n        return ((bits.length-index)%2 == 0);\n    }\n}", "total_acs": 13542, "total_submitted": 27242}, {"id": 718, "title": "Maximum Length of Repeated Subarray", "url": "https://leetcode.com/problems/maximum-length-of-repeated-subarray/description", "companyTags": ["Citadel"], "difficulty": "Medium", "content": "Given two integer arrays A and B, return the maximum length of an subarray that appears in both arrays.\r\n\r\nExample 1:\r\n\r\nInput:\r\nA: [1,2,3,2,1]\r\nB: [3,2,1,4,7]\r\nOutput: 3\r\nExplanation: \r\nThe repeated subarray with maximum length is [3, 2, 1].\r\n\r\n\r\n\r\nNote:\r\n\r\n1 <= len(A), len(B) <= 1000\r\n0 <= A[i], B[i] < 100\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/1583", "similarQuestions": ["MinimumSizeSubarraySum"], "topicTags": ["Array", "HashTable", "BinarySearch", "DynamicProgramming"], "Solution": "class Solution {\n    public int findLength(int[] A, int[] B) {\n        int m = B.length, max = 0;\n\t\tint[] dp = new int[m + 1];\n\n\t\tfor (int stuff : A) {\n\t\t\tfor (int j = m; j > 0; j--) {\n\t\t\t\tif (stuff == B[j - 1]) {\n\t\t\t\t\tif (max < (dp[j] = dp[j - 1] + 1))\n\t\t\t\t\t\tmax = dp[j];\n\t\t\t\t} else\n\t\t\t\t\tdp[j] = 0;\n\n//\t\t\t\tfor (int s : dp)\n//\t\t\t\t\tSystem.out.print(s + \"|\");\n//\t\t\t\tSystem.out.println();\n\t\t\t}\n//\t\t\tSystem.out.println(\"-------\");\n\t\t}\n\t\treturn max;\n    }\n}", "total_acs": 9938, "total_submitted": 24257}, {"id": 719, "title": "Find K-th Smallest Pair Distance", "url": "https://leetcode.com/problems/find-k-th-smallest-pair-distance/description", "companyTags": ["Google"], "difficulty": "Hard", "content": "Given an integer array, return the k-th smallest distance among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B. \r\n\r\nExample 1:\r\n\r\nInput:\r\nnums = [1,3,1]\r\nk = 1\r\nOutput: 0 \r\nExplanation:\r\nHere are all the pairs:\r\n(1,3) -> 2\r\n(1,1) -> 0\r\n(3,1) -> 2\r\nThen the 1st smallest distance pair is (1,1), and its distance is 0.\r\n\r\n\r\n\r\nNote:\r\n\r\n2 <= len(nums) <= 10000.\r\n0 <= nums[i] < 1000000.\r\n1 <= k <= len(nums) * (len(nums) - 1) / 2.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/1585", "similarQuestions": ["FindKPairswithSmallestSums", "KthSmallestElementinaSortedMatrix", "FindKClosestElements", "KthSmallestNumberinMultiplicationTable"], "topicTags": ["Array", "BinarySearch", "Heap"], "Solution": "class Solution {\n    public int smallestDistancePair(int[] nums, int k) {\n        Arrays.sort(nums);\n        int first = 0;\n        int last = 1000000;\n        if(calc(nums, 0) >= k) {\n            return 0;\n        }\n        while(first + 1 < last) {\n            int m = (first + last) / 2;\n            int r = calc(nums, m);\n            if(r >= k) {\n                last = m; \n            } else{\n                first = m;\n            }\n        }\n        return last;\n    }\n    \n    int calc(int [] val, int t) {\n        int r = 0;\n        int res = 0;\n        for(int w = 1 ; w < val.length; w++) {\n            while(val[w] - val[r] > t) {\n                r++;\n            }\n            res += w - r;\n        }\n        \n        return res;\n    }\n    \n}", "total_acs": 4973, "total_submitted": 18662}, {"id": 720, "title": "Longest Word in Dictionary", "url": "https://leetcode.com/problems/longest-word-in-dictionary/description", "companyTags": ["Pinterest"], "difficulty": "Easy", "content": "Given a list of strings words representing an English Dictionary, find the longest word in words that can be built one character at a time by other words in words.  If there is more than one possible answer, return the longest word with the smallest lexicographical order.  If there is no answer, return the empty string.\r\n\r\nExample 1:\r\n\r\nInput: \r\nwords = [\"w\",\"wo\",\"wor\",\"worl\", \"world\"]\r\nOutput: \"world\"\r\nExplanation: \r\nThe word \"world\" can be built one character at a time by \"w\", \"wo\", \"wor\", and \"worl\".\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: \r\nwords = [\"a\", \"banana\", \"app\", \"appl\", \"ap\", \"apply\", \"apple\"]\r\nOutput: \"apple\"\r\nExplanation: \r\nBoth \"apply\" and \"apple\" can be built from other words in the dictionary. However, \"apple\" is lexicographically smaller than \"apply\".\r\n\r\n\r\n\r\nNote:\r\nAll the strings in the input will only contain lowercase letters.\r\nThe length of words will be in the range [1, 1000].\r\nThe length of words[i] will be in the range [1, 30].\r\n", "discussUrl": "https://discuss.leetcode.com/category/1588", "similarQuestions": ["LongestWordinDictionarythroughDeleting", "ImplementMagicDictionary"], "topicTags": ["HashTable", "Trie"], "Solution": "class Solution {\n    class Node{\n        Node[] next;\n        String str;\n        Node(){\n            next = new Node[26];\n            str = null;\n        }\n        void insert(String str, int pos){\n            if(pos==str.length()) this.str = str;\n            else{\n                int ind = str.charAt(pos)-'a';\n                if(next[ind]==null) next[ind] = new Node();\n                next[ind].insert(str,pos+1);\n            }\n        }\n    }\n    \n    class Result{\n        int depth;\n        String str;\n        Result(int d, String s){\n            depth = d;\n            str = s;\n        }\n    }\n    \n    public Result dfs(Node root, int level){\n        Result ret = new Result(level,\"\");\n        if(root.str!=null) ret.str = root.str;\n        for(int i=0;i<26;i++){\n            if(root.next[i]!=null && root.next[i].str!=null){\n                Result tmp = dfs(root.next[i],level+1);\n                if(tmp.depth>ret.depth){\n                    ret = tmp;\n                }\n            }\n        }\n        return ret;\n    }\n    \n    public String longestWord(String[] words) {\n        Node root = new Node();\n        for(String str:words) root.insert(str,0);\n        Result str = dfs(root,0);\n        return str.str;\n    }\n}", "total_acs": 9582, "total_submitted": 22918}, {"id": 721, "title": "Accounts Merge", "url": "https://leetcode.com/problems/accounts-merge/description", "companyTags": ["Facebook"], "difficulty": "Medium", "content": "Given a list accounts, each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account.\r\n\r\nNow, we would like to merge these accounts.  Two accounts definitely belong to the same person if there is some email that is common to both accounts.  Note that even if two accounts have the same name, they may belong to different people as people could have the same name.  A person can have any number of accounts initially, but all of their accounts definitely have the same name.\r\n\r\nAfter merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in sorted order.  The accounts themselves can be returned in any order.\r\n\r\nExample 1:\r\n\r\nInput: \r\naccounts = [[\"John\", \"johnsmith@mail.com\", \"john00@mail.com\"], [\"John\", \"johnnybravo@mail.com\"], [\"John\", \"johnsmith@mail.com\", \"john_newyork@mail.com\"], [\"Mary\", \"mary@mail.com\"]]\r\nOutput: [[\"John\", 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],  [\"John\", \"johnnybravo@mail.com\"], [\"Mary\", \"mary@mail.com\"]]\r\nExplanation: \r\nThe first and third John's are the same person as they have the common email \"johnsmith@mail.com\".\r\nThe second John and Mary are different people as none of their email addresses are used by other accounts.\r\nWe could return these lists in any order, for example the answer [['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'], \r\n['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']] would still be accepted.\r\n\r\n\r\n\r\nNote:\r\nThe length of accounts will be in the range [1, 1000].\r\nThe length of accounts[i] will be in the range [1, 10].\r\nThe length of accounts[i][j] will be in the range [1, 30].\r\n", "discussUrl": "https://discuss.leetcode.com/category/1590", "similarQuestions": ["RedundantConnection", "SentenceSimilarity", "SentenceSimilarityII"], "topicTags": ["Depth-firstSearch", "UnionFind"], "Solution": "class Solution {\n    int[] fa;\n    int find(int x)\n    {\n        if (fa[x]!=x) fa[x]=find(fa[x]);\n        return fa[x];\n    }\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\n        int n=accounts.size();\n        fa=new int[n];\n        for (int i=0;i<n;i++) fa[i]=i;\n        Map<String,Integer> map=new HashMap<>();\n        for (int i=0;i<n;i++)\n        {\n            List<String> list=accounts.get(i);\n            int m=list.size();\n            for (int j=1;j<m;j++)\n            {\n                String s=list.get(j);\n                int x=map.getOrDefault(s,-1);\n                if (x==-1) map.put(s,i);\n                else\n                {\n                    int a=find(x),b=find(i);\n                    fa[b]=a;\n                }\n            }\n        }\n        List<List<String>> ans=new ArrayList<>();\n        List<List<String>> email=new ArrayList<>();\n        for (int i=0;i<n;i++) email.add(new ArrayList<>());\n        for (String s:map.keySet())\n        {\n            int x=find(map.get(s));\n            email.get(x).add(s);\n        }\n        for (int i=0;i<n;i++) \n        {\n            if (email.get(i).size()==0) continue;\n            Collections.sort(email.get(i));\n            List<String> list=new ArrayList<>();\n            list.add(accounts.get(i).get(0));\n            for (String s:email.get(i)) list.add(s);\n            ans.add(list);\n        }\n        return ans;\n    }\n}", "total_acs": 6624, "total_submitted": 20462}, {"id": 722, "title": "Remove Comments", "url": "https://leetcode.com/problems/remove-comments/description", "companyTags": ["Microsoft"], "difficulty": "Medium", "content": "Given a C++ program, remove comments from it. The program source is an array where source[i] is the i-th line of the source code.  This represents the result of splitting the original source code string by the newline character \\n.\r\n\r\nIn C++, there are two types of comments, line comments, and block comments.\r\n\r\nThe string // denotes a line comment, which represents that it and rest of the characters to the right of it in the same line should be ignored.\r\n\r\nThe string /* denotes a block comment, which represents that all characters until the next (non-overlapping) occurrence of */ should be ignored.  (Here, occurrences happen in reading order: line by line from left to right.)  To be clear, the string /*/ does not yet end the block comment, as the ending would be overlapping the beginning.\r\n\r\nThe first effective comment takes precedence over others: if the string // occurs in a block comment, it is ignored. Similarly, if the string /* occurs in a line or block comment, it is also ignored.\r\n\r\nIf a certain line of code is empty after removing comments, you must not output that line: each string in the answer list will be non-empty.\r\n\r\nThere will be no control characters, single quote, or double quote characters.  For example, source = \"string s = \"/* Not a comment. */\";\" will not be a test case.  (Also, nothing else such as defines or macros will interfere with the comments.)\r\n\r\nIt is guaranteed that every open block comment will eventually be closed, so /* outside of a line or block comment always starts a new comment.\r\n\r\nFinally, implicit newline characters can be deleted by block comments.  Please see the examples below for details.\r\n\r\n\r\nAfter removing the comments from the source code, return the source code in the same format.\r\n\r\nExample 1:\r\n\r\nInput: \r\nsource = [\"/*Test program */\", \"int main()\", \"{ \", \"  // variable declaration \", \"int a, b, c;\", \"/* This is a test\", \"   multiline  \", \"   comment for \", \"   testing */\", \"a = b + c;\", \"}\"]\r\n\r\nThe line by line code is visualized as below:\r\n/*Test program */\r\nint main()\r\n{ \r\n  // variable declaration \r\nint a, b, c;\r\n/* This is a test\r\n   multiline  \r\n   comment for \r\n   testing */\r\na = b + c;\r\n}\r\n\r\nOutput: [\"int main()\",\"{ \",\"  \",\"int a, b, c;\",\"a = b + c;\",\"}\"]\r\n\r\nThe line by line code is visualized as below:\r\nint main()\r\n{ \r\n  \r\nint a, b, c;\r\na = b + c;\r\n}\r\n\r\nExplanation: \r\nThe string /* denotes a block comment, including line 1 and lines 6-9. The string // denotes line 4 as comments.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: \r\nsource = [\"a/*comment\", \"line\", \"more_comment*/b\"]\r\nOutput: [\"ab\"]\r\nExplanation: The original source string is \"a/*comment\\nline\\nmore_comment*/b\", where we have bolded the newline characters.  After deletion, the implicit newline characters are deleted, leaving the string \"ab\", which when delimited by newline characters becomes [\"ab\"].\r\n\r\n\r\n\r\nNote:\r\nThe length of source is in the range [1, 100].\r\nThe length of source[i] is in the range [0, 80].\r\nEvery open block comment is eventually closed.\r\nThere are no single-quote, double-quote, or control characters in the source code.\r\n", "discussUrl": "https://discuss.leetcode.com/category/1592", "similarQuestions": ["MiniParser", "TernaryExpressionParser"], "topicTags": ["String"], "Solution": "class Solution {\n    public List<String> removeComments(String[] source) {\n        //list res\n        //mode represent whether in the /*\n        //meet // skip, meet /* go into mode,if mode meet */ go out\n        List<String> res=new ArrayList<>();\n        StringBuilder sb=new StringBuilder();\n        boolean mode=false;\n        for(String s:source){\n            for (int i = 0; i < s.length(); i++) {\n                if(mode){\n                    if(s.charAt(i)=='*' && i<s.length()-1 && s.charAt(i+1)=='/'){\n                        mode=false;\n                        i++;\n                    }\n                }else{\n                    if(s.charAt(i)=='/' && i<s.length()-1 && s.charAt(i+1)=='/'){\n                        break;\n                    }else if(s.charAt(i)=='/' && i<s.length()-1 && s.charAt(i+1)=='*'){\n                        mode=true;\n                        i++;\n                    }else{\n                        sb.append(s.charAt(i));   \n                    }\n                }\n            }\n            if(!mode && sb.length()>0){\n                res.add(sb.toString());\n                sb=new StringBuilder();\n            }    \n        }\n        \n        return res;\n    }\n}", "total_acs": 3077, "total_submitted": 11244}, {"id": 723, "title": "Candy Crush", "url": "https://leetcode.com/problems/candy-crush/description", "companyTags": ["Rubrik"], "difficulty": "Medium", "content": "This question is about implementing a basic elimination algorithm for Candy Crush.\r\n\r\nGiven a 2D integer array board representing the grid of candy, different positive integers board[i][j] represent different types of candies.  A value of board[i][j] = 0 represents that the cell at position (i, j) is empty.  The given board represents the state of the game following the player's move.  Now, you need to restore the board to a stable state by crushing candies according to the following rules:\r\n\r\n\r\nIf three or more candies of the same type are adjacent vertically or horizontally, \"crush\" them all at the same time - these positions become empty.\r\nAfter crushing all candies simultaneously, if an empty space on the board has candies on top of itself, then these candies will drop until they hit a candy or bottom at the same time. (No new candies will drop outside the top boundary.)\r\nAfter the above steps, there may exist more candies that can be crushed.  If so, you need to repeat the above steps.\r\nIf there does not exist more candies that can be crushed (ie. the board is stable), then return the current board.\r\n\r\n\r\nYou need to perform the above rules until the board becomes stable, then return the current board.\r\n\r\nExample 1:\r\n\r\nInput:\r\nboard = \r\n[[110,5,112,113,114],[210,211,5,213,214],[310,311,3,313,314],[410,411,412,5,414],[5,1,512,3,3],[610,4,1,613,614],[710,1,2,713,714],[810,1,2,1,1],[1,1,2,2,2],[4,1,4,4,1014]]\r\nOutput:\r\n[[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[110,0,0,0,114],[210,0,0,0,214],[310,0,0,113,314],[410,0,0,213,414],[610,211,112,313,614],[710,311,412,613,714],[810,411,512,713,1014]]\r\nExplanation: \r\n\r\n\r\n\r\n\r\nNote:\r\n\r\nThe length of board will be in the range [3, 50].\r\nThe length of board[i] will be in the range [3, 50].\r\nEach board[i][j] will initially start as an integer in the range [1, 2000].\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/1594", "similarQuestions": [""], "topicTags": ["Array", "TwoPointers"], "Solution": "class Solution {\n    public int[][] candyCrush(int[][] board) {\n        boolean[][] move = new boolean[board.length][board[0].length];\n        boolean update = true, tmp = false;\n        while(update){\n            update = false;\n            //check row and cols, set update true if need update\n            for(int i=0; i<board.length; i++){\n                tmp = rowCheck(board, i, move);\n                //System.out.println(\"\\n\\trow[\"+i+\"]:\"+tmp+\"\\n\");\n                update = update || tmp;\n            }\n            for(int j = 0; j<board[0].length; j++){\n                tmp = colCheck(board, j, move);\n               // System.out.println(\"\\n\\tcol[\"+j+\"]:\"+tmp+\"\\n\");\n                update = update || tmp;\n            }\n            //printCheck(move);\n            if(update){\n                for(int j=0; j<board[0].length; j++){\n                    updateCol(board, j, move);\n                }\n            }\n            //if need update, move board, \n        }\n        \n        return board;\n    }\n    //colum bottom up check\n    private boolean colCheck(int[][] board, int col, boolean[][] move){\n        boolean res = false;\n        int len = board.length;\n        int u = len -1, d = len-1;\n        while(d>=0){\n            if(board[d][col] == 0) break; // [error?] you check col after row, in that case row could make \n            while(u >=0 && board[u][col] == board[d][col]) u--;\n            if(d-u>=3 && board[d][col] != 0){\n                res = true;\n                for(int i=d; i>u; i--){\n                    move[i][col] = true;\n                }\n            }\n            d = u;   \n        }\n        return res;\n    }\n    private boolean rowCheck(int[][] board, int row, boolean[][] move){\n        boolean res = false;\n        int len = board[0].length;\n        int l = 0, r =0;\n        while(l<len){\n            while(r<len &&board[row][r] == board[row][l]) r++;\n            if(r-l>=3 && board[row][l] !=0){\n                res = true;\n                for(int i=l; i<r; i++) move[row][i] = true;\n            }\n            l = r;\n        }\n        return res;\n    }\n    \n    private void updateCol(int[][] board, int col, boolean[][] move){\n        int up = board.length -1;\n        while(up >=0 && !move[up][col]) up--;\n        int idx  = up;\n        while(up >=0){\n            if(!move[up][col]) {\n                move[idx][col] = false;\n                board[idx--][col] = board[up][col];\n            }\n            up--;\n        }\n        while(idx>=0) {\n            move[idx][col] = false;\n            board[idx--][col] = 0;\n        }\n    }\n    \n    private void printCheck(boolean[][] check){\n        System.out.println(\"check:\");\n        for(int i=0; i< check.length; i++){\n            for(boolean b: check[i]) System.out.print(b+\", \");\n            System.out.println();\n        }\n    }\n}", "total_acs": 1682, "total_submitted": 2995}, {"id": 724, "title": "Find Pivot Index", "url": "https://leetcode.com/problems/find-pivot-index/description", "companyTags": ["Coupang", "Radius"], "difficulty": "Easy", "content": "Given an array of integers nums, write a method that returns the \"pivot\" index of this array.\r\n\r\nWe define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index.\r\n\r\nIf no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index.\r\n\r\n\r\nExample 1:\r\n\r\nInput: \r\nnums = [1, 7, 3, 6, 5, 6]\r\nOutput: 3\r\nExplanation: \r\nThe sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3.\r\nAlso, 3 is the first index where this occurs.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: \r\nnums = [1, 2, 3]\r\nOutput: -1\r\nExplanation: \r\nThere is no index that satisfies the conditions in the problem statement.\r\n\r\n\r\n\r\nNote:\r\nThe length of nums will be in the range [0, 10000].\r\nEach element nums[i] will be an integer in the range [-1000, 1000].\r\n", "discussUrl": "https://discuss.leetcode.com/category/1597", "similarQuestions": ["SubarraySumEqualsK"], "topicTags": ["Array"], "Solution": "class Solution {\n    public int pivotIndex(int[] nums) {\n        \n        int sum = 0;\n        for(int i=0;i<nums.length;++i){\n            sum += nums[i];\n        }\n        \n        int leftSum = 0;\n        for(int i=0;i<nums.length;++i){\n            \n            if(leftSum == sum - leftSum - nums[i]) return i;            \n            leftSum = leftSum + nums[i];\n        }\n        \n        return -1;\n        \n    }\n}", "total_acs": 12993, "total_submitted": 32733}, {"id": 725, "title": "Split Linked List in Parts", "url": "https://leetcode.com/problems/split-linked-list-in-parts/description", "companyTags": ["Amazon"], "difficulty": "Medium", "content": "Given a (singly) linked list with head node root, write a function to split the linked list into k consecutive linked list \"parts\".\r\n\r\nThe length of each part should be as equal as possible: no two parts should have a size differing by more than 1.  This may lead to some parts being null.\r\n\r\nThe parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later.\r\n\r\nReturn a List of ListNode's representing the linked list parts that are formed.\r\n\r\n\r\nExamples\r\n1->2->3->4, k = 5 // 5 equal parts\r\n[ [1], \r\n[2],\r\n[3],\r\n[4],\r\nnull ]\r\n\r\nExample 1:\r\n\r\nInput: \r\nroot = [1, 2, 3], k = 5\r\nOutput: [[1],[2],[3],[],[]]\r\nExplanation:\r\nThe input and each element of the output are ListNodes, not arrays.\r\nFor example, the input root has root.val = 1, root.next.val = 2, \\root.next.next.val = 3, and root.next.next.next = null.\r\nThe first element output[0] has output[0].val = 1, output[0].next = null.\r\nThe last element output[4] is null, but it's string representation as a ListNode is [].\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: \r\nroot = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3\r\nOutput: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]\r\nExplanation:\r\nThe input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.\r\n\r\n\r\n\r\nNote:\r\nThe length of root will be in the range [0, 1000].\r\nEach value of a node in the input will be an integer in the range [0, 999].\r\nk will be an integer in the range [1, 50].\r\n", "discussUrl": "https://discuss.leetcode.com/category/1599", "similarQuestions": ["RotateList", "OddEvenLinkedList"], "topicTags": ["LinkedList"], "Solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode[] splitListToParts(ListNode root, int k) {\n        if (root == null) return new ListNode[k];\n        if (k == 1) return new ListNode[]{root};\n        \n        int len = 0;\n        ListNode point = root;\n        while (point != null) {\n            len++;\n            point = point.next;\n        }\n        \n        ListNode[] res = new ListNode[k];\n        int shorted_length = len / k;\n        int number_of_longer_list = len % k;\n        \n        point = root;\n        int cur_len = 0;\n        int index = 0;\n        while (point.next != null) {\n            cur_len++;\n            \n            int extra_length = number_of_longer_list > 0 ? 1 : 0;\n            \n                if (cur_len == shorted_length + extra_length) {\n                    ListNode head = root;\n                    res[index++] = head;\n                    \n                    root = point.next;\n                    point.next = null;\n                    point = root;\n                    cur_len = 0;\n                    number_of_longer_list--;\n                } else {\n                    point = point.next;\n                    continue;\n                }\n        }\n        \n        ListNode head = root;\n        res[index] = head;\n        \n        return res;\n    }\n}", "total_acs": 7242, "total_submitted": 15219}, {"id": 726, "title": "Number of Atoms", "url": "https://leetcode.com/problems/number-of-atoms/description", "companyTags": ["Google"], "difficulty": "Hard", "content": "Given a chemical formula (given as a string), return the count of each atom.\r\n\r\nAn atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.\r\n\r\n1 or more digits representing the count of that element may follow if the count is greater than 1.  If the count is 1, no digits will follow.  For example, H2O and H2O2 are possible, but H1O2 is impossible.\r\n\r\nTwo formulas concatenated together produce another formula.  For example, H2O2He3Mg4 is also a formula.  \r\n\r\nA formula placed in parentheses, and a count (optionally added) is also a formula.  For example, (H2O2) and (H2O2)3 are formulas.\r\n\r\nGiven a formula, output the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on.\r\n\r\nExample 1:\r\n\r\nInput: \r\nformula = \"H2O\"\r\nOutput: \"H2O\"\r\nExplanation: \r\nThe count of elements are {'H': 2, 'O': 1}.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: \r\nformula = \"Mg(OH)2\"\r\nOutput: \"H2MgO2\"\r\nExplanation: \r\nThe count of elements are {'H': 2, 'Mg': 1, 'O': 2}.\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput: \r\nformula = \"K4(ON(SO3)2)2\"\r\nOutput: \"K4N2O14S4\"\r\nExplanation: \r\nThe count of elements are {'K': 4, 'N': 2, 'O': 14, 'S': 4}.\r\n\r\n\r\n\r\nNote:\r\nAll atom names consist of lowercase letters, except for the first character which is uppercase.\r\nThe length of formula will be in the range [1, 1000].\r\nformula will only consist of letters, digits, and round parentheses, and is a valid formula as defined in the problem.\r\n", "discussUrl": "https://discuss.leetcode.com/category/1601", "similarQuestions": ["DecodeString", "EncodeStringwithShortestLength", "ParseLispExpression"], "topicTags": ["HashTable", "Stack", "Recursion"], "Solution": "class Solution {\n    public String countOfAtoms(String formula) {\n        int[][] dict = new int[26][27];\n        \n        helper(dict, formula, 0, formula.length(), 1);\n        \n        StringBuilder res = new StringBuilder();\n        \n        for(int i = 0; i< 26; i++){\n            for(int j = 0; j< 27; j++){\n                if(dict[i][j] == 0){\n                    continue;\n                }\n                \n                res.append((char) (i+'A'));\n                if(j>0){\n                    res.append((char)(j+'a'-1));\n                }\n                if(dict[i][j]>1){\n                    res.append(dict[i][j]);\n                }\n            }\n        }\n    \n        return res.toString();\n    }\n    \n    public void helper(int[][] dict, String s, int start, int end, int mult){\n        if(start == end){\n            return;\n        }\n        \n        \n        if(s.charAt(start) == '('){\n            int j = start+1;\n            for(int diff = 1; diff>0 ; j++){\n                if(s.charAt(j) == '('){\n                    diff++;\n                }\n                if(s.charAt(j) == ')'){\n                    diff--;\n                }\n                \n                if(diff == 0){\n                    break;\n                }\n            }\n            \n            int count = 0;\n            int i = j+1;\n            \n            while(i< end && Character.isDigit(s.charAt(i))){\n                count = count*10+s.charAt(i++)- '0';\n                \n            }\n            \n            if(count == 0){\n                count = 1;\n            }\n            \n            helper(dict, s, start+1, j, mult*count);\n            helper(dict, s, i,end, mult);\n        }\n        else{\n            int i = s.charAt(start++) - 'A';\n            int j = 0;\n            \n            if(start< end && s.charAt(start) >= 'a' && s.charAt(start) <= 'z' ){\n                j = s.charAt(start++)-'a'+1;\n            }\n            \n            int count = 0;\n            \n            while(start< end && Character.isDigit(s.charAt(start))){\n                count = count*10+ s.charAt(start++)-'0';\n            }\n            \n            if(count == 0){\n                count = 1;\n            }\n            \n            dict[i][j] += count * mult;\n            \n            helper(dict, s, start, end, mult);\n        }\n        \n        \n    }\n}", "total_acs": 3660, "total_submitted": 8276}, {"id": 727, "title": "Minimum Window Subsequence", "url": "https://leetcode.com/problems/minimum-window-subsequence/description", "companyTags": ["Google", "eBay"], "difficulty": "Hard", "content": "Given strings S and T, find the minimum (contiguous) substring W of S, so that T is a subsequence of W.\r\n\r\nIf there is no such window in S that covers all characters in T, return the empty string \"\".  If there are multiple such minimum-length windows, return the one with the left-most starting index.\r\n\r\n\r\nExample 1:\r\n\r\nInput: \r\nS = \"abcdebdde\", T = \"bde\"\r\nOutput: \"bcde\"\r\nExplanation: \r\n\"bcde\" is the answer because it occurs before \"bdde\" which has the same length.\r\n\"deb\" is not a smaller window because the elements of T in the window must occur in order.\r\n\r\n\r\n\r\nNote:\r\nAll the strings in the input will only contain lowercase letters.\r\nThe length of S will be in the range [1, 20000].\r\nThe length of T will be in the range [1, 100].\r\n", "discussUrl": "https://discuss.leetcode.com/category/1603", "similarQuestions": ["MinimumWindowSubstring", "LongestContinuousIncreasingSubsequence"], "topicTags": ["DynamicProgramming"], "Solution": "public class Solution {\n    public String minWindow(String S, String T) {\n        char[] s = S.toCharArray(), t = T.toCharArray();\n        int slen = s.length, tlen = t.length, i = 0, j = 0, start = 0, minlen = slen+1;\n        while (i < slen) {\n            if (s[i] == t[j]) {\n                if (j == tlen-1) {\n                    int end = i+1;\n                    while (--j >= 0)\n                        while (s[--i] != t[j]);\n                    if (end-i < minlen) {\n                        start = i;\n                        minlen = end-i;\n                    }\n                }\n                ++j;\n            }\n            ++i;\n        }\n        return minlen==slen+1 ? \"\" : S.substring(start, start+minlen);\n    }\n}\n", "total_acs": 3340, "total_submitted": 10805}, {"id": 728, "title": "Self Dividing Numbers", "url": "https://leetcode.com/problems/self-dividing-numbers/description", "companyTags": ["EpicSystems"], "difficulty": "Easy", "content": "\r\nA self-dividing number is a number that is divisible by every digit it contains.\r\n\r\nFor example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.\r\n\r\nAlso, a self-dividing number is not allowed to contain the digit zero.\r\n\r\nGiven a lower and upper number bound, output a list of every possible self dividing number, including the bounds if possible.\r\n\r\nExample 1:\r\n\r\nInput: \r\nleft = 1, right = 22\r\nOutput: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]\r\n\r\n\r\n\r\nNote:\r\nThe boundaries of each input argument are 1 <= left <= right <= 10000.\r\n", "discussUrl": "https://discuss.leetcode.com/category/1606", "similarQuestions": ["PerfectNumber"], "topicTags": ["Math"], "Solution": "class Solution {\n   private static int[] DividingNumbers = {1,2,3,4,5,6,7,8,9,11,12,15,22,24,33,36,44,48,55,66,77,88,99,111,112,115,122,124,126,128,132,135,144,155,162,168,175,184,212,216,222,224,244,248,264,288,312,315,324,333,336,366,384,396,412,424,432,444,448,488,515,555,612,624,636,648,666,672,728,735,777,784,816,824,848,864,888,936,999,1111,1112,1113,1115,1116,1122,1124,1128,1131,1144,1155,1164,1176,1184,1197,1212,1222,1224,1236,1244,1248,1266,1288,1296,1311,1326,1332,1335,1344,1362,1368,1395,1412,1416,1424,1444,1448,1464,1488,1515,1555,1575,1626,1632,1644,1662,1692,1715,1722,1764,1771,1824,1848,1888,1926,1935,1944,1962,2112,2122,2124,2128,2136,2144,2166,2184,2196,2212,2222,2224,2226,2232,2244,2248,2262,2288,2316,2322,2328,2364,2412,2424,2436,2444,2448,2488,2616,2622,2664,2688,2744,2772,2824,2832,2848,2888,2916,3111,3126,3132,3135,3144,3162,3168,3171,3195,3216,3222,3264,3276,3288,3312,3315,3324,3333,3336,3339,3366,3384,3393,3432,3444,3492,3555,3612,3624,3636,3648,3666,3717,3816,3864,3888,3915,3924,3933,3996,4112,4116,4124,4128,4144,4164,4172,4184,4212,4224,4236,4244,4248,4288,4332,4344,4368,4392,4412,4416,4424,4444,4448,4464,4488,4632,4644,4824,4848,4872,4888,4896,4932,4968,5115,5155,5355,5515,5535,5555,5775,6126,6132,6144,6162,6168,6192,6216,6222,6264,6288,6312,6324,6336,6366,6384,6432,6444,6612,6624,6636,6648,6666,6696,6762,6816,6864,6888,6912,6966,6984,7112,7119,7175,7224,7266,7371,7448,7476,7644,7728,7777,7784,8112,8128,8136,8144,8184,8224,8232,8248,8288,8328,8424,8448,8488,8496,8616,8664,8688,8736,8824,8832,8848,8888,8928,9126,9135,9144,9162,9216,9288,9315,9324,9333,9396,9432,9612,9648,9666,9864,9936,9999};\n    \n    public List<Integer> selfDividingNumbers(int left, int right) {\n        List<Integer> list = new ArrayList<>();\n        \n        for(int i=0; i<DividingNumbers.length; i++) {\n        \tint num = DividingNumbers[i];\n        \tif(num >= left && num <= right)\n        \t\tlist.add(num);\n        \tif(num > right)\n        \t\tbreak;\n        }\n        \n        return list;\n    }\n\t\n}", "total_acs": 21060, "total_submitted": 31339}, {"id": 729, "title": "My Calendar I", "url": "https://leetcode.com/problems/my-calendar-i/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "\r\nImplement a MyCalendar class to store your events. A new event can be added if adding the event will not cause a double booking.\r\n\r\nYour class will have the method, book(int start, int end).  Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start <= x < end.\r\n\r\nA double booking happens when two events have some non-empty intersection (ie., there is some time that is common to both events.)\r\n\r\nFor each call to the method MyCalendar.book, return true if the event can be added to the calendar successfully without causing a double booking.  Otherwise, return false and do not add the event to the calendar.\r\n\r\n\r\nYour class will be called like this:\r\nMyCalendar cal = new MyCalendar();\r\nMyCalendar.book(start, end)\r\n\r\nExample 1:\r\n\r\nMyCalendar();\r\nMyCalendar.book(10, 20); // returns true\r\nMyCalendar.book(15, 25); // returns false\r\nMyCalendar.book(20, 30); // returns true\r\nExplanation: \r\nThe first event can be booked.  The second can't because time 15 is already booked by another event.\r\nThe third event can be booked, as the first event takes every time less than 20, but not including 20.\r\n\r\n\r\n\r\nNote:\r\nThe number of calls to MyCalendar.book per test case will be at most 1000.\r\nIn calls to MyCalendar.book(start, end), start and end are integers in the range [0, 10^9].\r\n", "discussUrl": "https://discuss.leetcode.com/category/1608", "similarQuestions": ["MyCalendarII", "MyCalendarIII"], "topicTags": ["Array"], "Solution": "class MyCalendar {\n\tprivate EventNode root;\n\n\tpublic MyCalendar() {\n\t\t\n\t}\n\t\n\tpublic boolean book(int start, int end) {\n\t\tif (root == null) {\n\t\t\troot = new EventNode(start, end);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn treeBool(root, start, end);\t\t\n\t}\n\t\n\tpublic boolean treeBool(EventNode node, int start, int end) {\n\t\tboolean left_bool = false, right_bool = false;\n\t\tif(end <= node.start) {\n\t\t\tif(node.left == null){\n\t\t\t\tnode.left = new EventNode(start, end);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tleft_bool = treeBool(node.left, start, end);\t\t\t\n\t\t}\n\t\telse if(start >= node.end) {\n\t\t\tif(node.right == null){\n\t\t\t\tnode.right = new EventNode(start, end);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tright_bool = treeBool(node.right, start, end);\t\n\t\t}\n\t\treturn left_bool || right_bool;\n\t}\n\t\n\tclass EventNode {\n\t\tpublic int start;\n\t\tpublic int end;\n\t\tpublic EventNode left;\n\t\tpublic EventNode right;\n\t\t\n\t\tpublic EventNode(int s, int e){\n\t\t\tstart = s;\n\t\t\tend = e;\n\t\t\tleft = null;\n\t\t\tright = null;\n\t\t}\n\t}\n}\n\n/**\n * Your MyCalendar object will be instantiated and called as such:\n * MyCalendar obj = new MyCalendar();\n * boolean param_1 = obj.book(start,end);\n */", "total_acs": 8033, "total_submitted": 19222}, {"id": 730, "title": "Count Different Palindromic Subsequences", "url": "https://leetcode.com/problems/count-different-palindromic-subsequences/description", "companyTags": ["LinkedIn"], "difficulty": "Hard", "content": "\r\nGiven a string S, find the number of different non-empty palindromic subsequences in S, and return that number modulo 10^9 + 7.\r\n\r\nA subsequence of a string S is obtained by deleting 0 or more characters from S.\r\n\r\nA sequence is palindromic if it is equal to the sequence reversed.\r\n\r\nTwo sequences A_1, A_2, ... and B_1, B_2, ... are different if there is some i for which A_i != B_i.\r\n\r\n\r\nExample 1:\r\n\r\nInput: \r\nS = 'bccb'\r\nOutput: 6\r\nExplanation: \r\nThe 6 different non-empty palindromic subsequences are 'b', 'c', 'bb', 'cc', 'bcb', 'bccb'.\r\nNote that 'bcb' is counted only once, even though it occurs twice.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: \r\nS = 'abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba'\r\nOutput: 104860361\r\nExplanation: \r\nThere are 3104860382 different non-empty palindromic subsequences, which is 104860361 modulo 10^9 + 7.\r\n\r\n\r\n\r\nNote:\r\nThe length of S will be in the range [1, 1000].\r\nEach character S[i] will be in the set {'a', 'b', 'c', 'd'}.\r\n", "discussUrl": "https://discuss.leetcode.com/category/1610", "similarQuestions": ["LongestPalindromicSubsequence"], "topicTags": ["String", "DynamicProgramming"], "Solution": "class Solution {\n    \n    private static final int mod = 1000000007;\n    \n    public int countPalindromicSubsequences(String S) {\n        char[] cs = S.toCharArray();\n        int n = cs.length;\n        int[] cnts = new int[n];\n        for(int i = 0; i < n; i++) {\n            char c1 = cs[i] -= 'a';\n            cnts[i] = 1;\n            long sum = 0;\n            int[] nums = new int[4];\n            for(int j = i - 1; j >= 0; j--) {\n                char c2 = cs[j];\n                int cnt = cnts[j];\n                if(c1 == c2) {\n                    cnts[j] = (int)((sum + 2) % mod);\n                }\n                sum += cnt - nums[c2];\n                nums[c2] = cnt;\n            }\n        }\n        int[] nums = new int[4];\n        for(int i = n - 1; i >= 0; i--) {\n            nums[cs[i]] = cnts[i];\n        }\n        long sum = 0;\n        for(int cnt : nums) {\n            sum += cnt;\n        }\n        return (int)(sum % mod);\n    }\n}", "total_acs": 2066, "total_submitted": 5886}, {"id": 731, "title": "My Calendar II", "url": "https://leetcode.com/problems/my-calendar-ii/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "\r\nImplement a MyCalendarTwo class to store your events. A new event can be added if adding the event will not cause a triple booking.\r\n\r\nYour class will have one method, book(int start, int end).  Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start <= x < end.\r\n\r\nA triple booking happens when three events have some non-empty intersection (ie., there is some time that is common to all 3 events.)\r\n\r\nFor each call to the method MyCalendar.book, return true if the event can be added to the calendar successfully without causing a triple booking.  Otherwise, return false and do not add the event to the calendar.\r\n\r\n\r\nYour class will be called like this:\r\nMyCalendar cal = new MyCalendar();\r\nMyCalendar.book(start, end)\r\n\r\nExample 1:\r\n\r\nMyCalendar();\r\nMyCalendar.book(10, 20); // returns true\r\nMyCalendar.book(50, 60); // returns true\r\nMyCalendar.book(10, 40); // returns true\r\nMyCalendar.book(5, 15); // returns false\r\nMyCalendar.book(5, 10); // returns true\r\nMyCalendar.book(25, 55); // returns true\r\nExplanation: \r\nThe first two events can be booked.  The third event can be double booked.\r\nThe fourth event (5, 15) can't be booked, because it would result in a triple booking.\r\nThe fifth event (5, 10) can be booked, as it does not use time 10 which is already double booked.\r\nThe sixth event (25, 55) can be booked, as the time in [25, 40) will be double booked with the third event;\r\nthe time [40, 50) will be single booked, and the time [50, 55) will be double booked with the second event.\r\n\r\n\r\n\r\nNote:\r\nThe number of calls to MyCalendar.book per test case will be at most 1000.\r\nIn calls to MyCalendar.book(start, end), start and end are integers in the range [0, 10^9].\r\n", "discussUrl": "https://discuss.leetcode.com/category/1612", "similarQuestions": ["MyCalendarI", "MyCalendarIII"], "topicTags": ["Array", "BinarySearchTree"], "Solution": "class MyCalendarTwo {\n    Node root;\n    class Node {\n        Node left;\n        Node right;\n        int start;\n        int end;\n        int count = 1;\n        Node(int start, int end) {\n            this.start = start;\n            this.end = end;\n        }\n    }\n    \n    public MyCalendarTwo() {\n        \n    }\n    \n    public boolean book(int start, int end) {\n        if (search(root, start, end)) {\n            return false;\n        }\n        root = add(root, start, end);\n        return true;\n    }\n    \n    private boolean search(Node cur, int start, int end) {\n        if (start >= end) {\n            return false;\n        }\n        if (cur == null) {\n            return false;\n        }\n        if (cur.count == 2 && ((start < cur.end && start >= cur.start) || \n                               (end > cur.start && end <= cur.end) || \n                               (start <= cur.start && end >= cur.end))) {\n            return true;\n        }\n        if (start >= cur.start && end <= cur.end) {\n            return false;\n        }\n        if (start >= cur.end) {\n            return search(cur.right, start, end);\n        }\n        if (end <= cur.start) {\n            return search(cur.left, start, end);\n        }\n        return search(cur.left, start, cur.start) || search(cur.right, cur.end, end);\n    }\n    \n    private Node add(Node cur, int start, int end) {\n        if (start >= end) {\n            return cur;\n        }\n        if (cur == null) {\n            return new Node(start, end);\n        }\n       \n        if (start >= cur.end) {\n            cur.right = add(cur.right, start, end);\n            return cur;\n        }\n        if (end <= cur.start) {\n            cur.left = add(cur.left, start, end);\n            return cur;\n        }\n    \n        cur.count++;\n        cur.left = add(cur.left, Math.min(cur.start, start), Math.max(cur.start, start));\n        cur.right = add(cur.right, Math.min(cur.end, end), Math.max(cur.end, end));\n        cur.start = Math.max(cur.start, start);\n        cur.end = Math.min(cur.end, end);\n        return cur;\n    }\n}\n\n/**\n * Your MyCalendarTwo object will be instantiated and called as such:\n * MyCalendarTwo obj = new MyCalendarTwo();\n * boolean param_1 = obj.book(start,end);\n */", "total_acs": 4750, "total_submitted": 12724}, {"id": 732, "title": "My Calendar III", "url": "https://leetcode.com/problems/my-calendar-iii/description", "companyTags": ["Google"], "difficulty": "Hard", "content": "\r\nImplement a MyCalendarThree class to store your events. A new event can always be added.\r\n\r\nYour class will have one method, book(int start, int end).  Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start <= x < end.\r\n\r\nA K-booking happens when K events have some non-empty intersection (ie., there is some time that is common to all K events.)\r\n\r\nFor each call to the method MyCalendar.book, return an integer K representing the largest integer such that there exists a K-booking in the calendar.\r\n\r\n\r\nYour class will be called like this:\r\nMyCalendarThree cal = new MyCalendarThree();\r\nMyCalendarThree.book(start, end)\r\n\r\nExample 1:\r\n\r\nMyCalendarThree();\r\nMyCalendarThree.book(10, 20); // returns 1\r\nMyCalendarThree.book(50, 60); // returns 1\r\nMyCalendarThree.book(10, 40); // returns 2\r\nMyCalendarThree.book(5, 15); // returns 3\r\nMyCalendarThree.book(5, 10); // returns 3\r\nMyCalendarThree.book(25, 55); // returns 3\r\nExplanation: \r\nThe first two events can be booked and are disjoint, so the maximum K-booking is a 1-booking.\r\nThe third event [10, 40) intersects the first event, and the maximum K-booking is a 2-booking.\r\nThe remaining events cause the maximum K-booking to be only a 3-booking.\r\nNote that the last event locally causes a 2-booking, but the answer is still 3 because\r\neg. [10, 20), [10, 40), and [5, 15) are still triple booked.\r\n\r\n\r\n\r\nNote:\r\nThe number of calls to MyCalendarThree.book per test case will be at most 400.\r\nIn calls to MyCalendarThree.book(start, end), start and end are integers in the range [0, 10^9].\r\n", "discussUrl": "https://discuss.leetcode.com/category/1616", "similarQuestions": ["MyCalendarI", "MyCalendarII"], "topicTags": ["SegmentTree", "BinarySearchTree"], "Solution": "class MyCalendarThree {\n\n\t\tprivate static class Duration {\n\t\t\tint start;\n\t\t\tint end;\n\t\t\tint cnt;\n\t\t\tDuration left = null;\n\t\t\tDuration right = null;\n\t\t\tDuration(final int s, final int e, final int c) {\n\t\t\t\tstart = s;\n\t\t\t\tend = e;\n\t\t\t\tcnt = c;\n\t\t\t}\n\t\t\t\n\t\t\tprivate boolean noChild() {\n\t\t\t\treturn left == null;\n\t\t\t}\n\t\t\t\n\t\t\tprivate int add(final int s, final int e) {\n\t\t\t\tif ((s >= end) || (e <= start)) return 0;\n\t\t\t\tif (s <= start) {\n\t\t\t\t\tif (e >= end) {\n\t\t\t\t\t\t++cnt;\n\t\t\t\t\t\treturn noChild() ? cnt :\n\t\t\t\t\t\t\tMath.max(left.add(left.start, left.end), right.add(right.start, right.end));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (noChild()) {\n\t\t\t\t\t\t\tleft = new Duration(start, e, cnt+1);\n\t\t\t\t\t\t\tright = new Duration(e, end, cnt);\n\t\t\t\t\t\t\treturn cnt+1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (e <= left.end) {\n\t\t\t\t\t\t\t\treturn left.add(left.start, e);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn Math.max(left.add(left.start, left.end), right.add(right.start, e));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {//if (s > start) {\n\t\t\t\t\tif (e < end) {\n\t\t\t\t\t\tif (noChild()) {\n\t\t\t\t\t\t\tleft = new Duration(start, s, cnt);\n\t\t\t\t\t\t\tright = new Duration(s, end, cnt);\n\t\t\t\t\t\t\treturn right.add(s, e);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (s >= left.end) {\n\t\t\t\t\t\t\t\treturn right.add(s, e);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (e > left.end)\n\t\t\t\t\t\t\t\t    return Math.max(left.add(s, left.end), right.add(left.end, e));\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\treturn left.add(s, e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (noChild()) {\n\t\t\t\t\t\t\tleft = new Duration(start, s, cnt);\n\t\t\t\t\t\t\tright = new Duration(s, end, cnt);\n\t\t\t\t\t\t\treturn right.add(s, end);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (s >= left.end) {\n\t\t\t\t\t\t\t\treturn right.add(s, end);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn Math.max(left.add(s, left.end), right.add(left.end, end));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate final Duration root = new Duration(0, Integer.MAX_VALUE, 0);\n\t\tint max = 0;\n\n\n\t    public MyCalendarThree() {\n\t        \n\t    }\n\t    \n\t    public int book(int start, int end) {\n\t        final int result = root.add(start, end);\n\t        max = Math.max(result, max);\n\t        return max;\n\t    }\n\t    \n\t    public void book(int start, int end, final int expected) {\n\t    \tfinal int result = book(start, end);\n\t    \tSystem.out.println(\"Adding [\" + start + \", \" + end + \n\t    \t\t\t\"] = \" + result + \" -- Expected: \" + expected + \n\t    \t\t\t\" ===> \" + (result == expected ? \"PASSED\" : \"FAILED\"));\n\t    }\n}\n\n/**\n * Your MyCalendarThree object will be instantiated and called as such:\n * MyCalendarThree obj = new MyCalendarThree();\n * int param_1 = obj.book(start,end);\n */", "total_acs": 2448, "total_submitted": 4735}, {"id": 733, "title": "Flood Fill", "url": "https://leetcode.com/problems/flood-fill/description", "companyTags": ["Uber"], "difficulty": "Easy", "content": "\r\nAn image is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535).\r\n\r\nGiven a coordinate (sr, sc) representing the starting pixel (row and column) of the flood fill, and a pixel value newColor, \"flood fill\" the image.\r\n\r\nTo perform a \"flood fill\", consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on.  Replace the color of all of the aforementioned pixels with the newColor.\r\n\r\nAt the end, return the modified image.\r\n\r\nExample 1:\r\n\r\nInput: \r\nimage = [[1,1,1],[1,1,0],[1,0,1]]\r\nsr = 1, sc = 1, newColor = 2\r\nOutput: [[2,2,2],[2,2,0],[2,0,1]]\r\nExplanation: \r\nFrom the center of the image (with position (sr, sc) = (1, 1)), all pixels connected \r\nby a path of the same color as the starting pixel are colored with the new color.\r\nNote the bottom corner is not colored 2, because it is not 4-directionally connected\r\nto the starting pixel.\r\n\r\n\r\n\r\nNote:\r\nThe length of image and image[0] will be in the range [1, 50].\r\nThe given starting pixel will satisfy 0 <= sr < image.length and 0 <= sc < image[0].length.\r\nThe value of each color in image[i][j] and newColor will be an integer in [0, 65535].\r\n", "discussUrl": "https://discuss.leetcode.com/category/1618", "similarQuestions": ["IslandPerimeter"], "topicTags": ["Depth-firstSearch"], "Solution": "class Solution {\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\n        if (image[sr][sc] == newColor) return image;\n        fill(image, sr, sc, image[sr][sc], newColor);\n        return image;\n    } \n    private void fill(int[][] image, int sr, int sc, int color, int newColor) {\n        if (sr < 0 || sr >= image.length || sc < 0 || sc >= image[0].length || image[sr][sc] != color) return;\n        image[sr][sc] = newColor;\n        fill(image, sr + 1, sc, color, newColor);\n        fill(image, sr - 1, sc, color, newColor);\n        fill(image, sr, sc + 1, color, newColor);\n        fill(image, sr, sc - 1, color, newColor);\n    }\n    \n}", "total_acs": 8860, "total_submitted": 18458}, {"id": 734, "title": "Sentence Similarity", "url": "https://leetcode.com/problems/sentence-similarity/description", "companyTags": ["Google"], "difficulty": "Easy", "content": "Given two sentences words1, words2 (each represented as an array of strings), and a list of similar word pairs pairs, determine if two sentences are similar.\r\n\r\nFor example, \"great acting skills\" and \"fine drama talent\" are similar, if the similar word pairs are pairs = [[\"great\", \"fine\"],\r\n [\"acting\",\"drama\"], [\"skills\",\"talent\"]].\r\n\r\nNote that the similarity relation is not transitive. For example, if \"great\" and \"fine\" are similar, and \"fine\" and \"good\" are similar, \"great\" and \"good\" are not necessarily similar.\r\n\r\nHowever, similarity is symmetric.  For example, \"great\" and \"fine\" being similar is the same as \"fine\" and \"great\" being similar.\r\n\r\nAlso, a word is always similar with itself.  For example, the sentences words1 = [\"great\"], words2 = [\"great\"], pairs = [] are similar, even though there are no specified similar word pairs.\r\n\r\nFinally, sentences can only be similar if they have the same number of words.  So a sentence like words1 = [\"great\"] can never be similar to words2 = [\"doubleplus\",\"good\"].\r\n\r\n\r\nNote:\r\nThe length of words1 and words2 will not exceed 1000.\r\nThe length of pairs will not exceed 2000.\r\nThe length of each pairs[i] will be 2.\r\nThe length of each words[i] and pairs[i][j] will be in the range [1, 20].\r\n", "discussUrl": "https://discuss.leetcode.com/category/1620", "similarQuestions": ["FriendCircles", "AccountsMerge", "SentenceSimilarityII"], "topicTags": ["HashTable"], "Solution": "class Solution {\n    public boolean areSentencesSimilar(String[] words1, String[] words2, String[][] pairs) {\n        if (words1.length != words2.length) return false;\n        for (int i = 0; i < words1.length; i++) {\n            if (!similar(words1[i], words2[i], pairs)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    private boolean similar(String s1, String s2, String[][] pairs) {\n        if (s1.equals(s2)) return true;\n        for (String[] pair : pairs) {\n            if (pair[0].equals(s1) && pair[1].equals(s2)) {\n                return true;\n            }\n            if (pair[0].equals(s2) && pair[1].equals(s1)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}", "total_acs": 6786, "total_submitted": 17536}, {"id": 735, "title": "Asteroid Collision", "url": "https://leetcode.com/problems/asteroid-collision/description", "companyTags": ["Uber"], "difficulty": "Medium", "content": "\r\nWe are given an array asteroids of integers representing asteroids in a row.\r\n\r\nFor each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left).  Each asteroid moves at the same speed.\r\n\r\nFind out the state of the asteroids after all collisions.  If two asteroids meet, the smaller one will explode.  If both are the same size, both will explode.  Two asteroids moving in the same direction will never meet.\r\n\r\n\r\nExample 1:\r\n\r\nInput: \r\nasteroids = [5, 10, -5]\r\nOutput: [5, 10]\r\nExplanation: \r\nThe 10 and -5 collide resulting in 10.  The 5 and 10 never collide.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: \r\nasteroids = [8, -8]\r\nOutput: []\r\nExplanation: \r\nThe 8 and -8 collide exploding each other.\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput: \r\nasteroids = [10, 2, -5]\r\nOutput: [10]\r\nExplanation: \r\nThe 2 and -5 collide resulting in -5.  The 10 and -5 collide resulting in 10.\r\n\r\n\r\n\r\nExample 4:\r\n\r\nInput: \r\nasteroids = [-2, -1, 1, 2]\r\nOutput: [-2, -1, 1, 2]\r\nExplanation: \r\nThe -2 and -1 are moving left, while the 1 and 2 are moving right.\r\nAsteroids moving the same direction never meet, so no asteroids will meet each other.\r\n\r\n\r\n\r\nNote:\r\nThe length of asteroids will be at most 10000.\r\nEach asteroid will be a non-zero integer in the range [-1000, 1000]..\r\n", "discussUrl": "https://discuss.leetcode.com/category/1622", "similarQuestions": ["CanPlaceFlowers"], "topicTags": ["Stack"], "Solution": "class Solution {\n    public int[] asteroidCollision(int[] asteroids) {\n        int[] mono = new int[asteroids.length];\n        int idx = 0;\n        for (int aster: asteroids){\n            if (idx == 0 || aster > 0 || (aster < 0 && mono[idx - 1] < 0)){\n                mono[idx++] = aster;\n                continue;\n            }\n            if (aster < 0){\n                while (idx>0 && mono[idx - 1] > 0 && mono[idx - 1] < -aster){\n                    idx--;\n                }\n                if (idx > 0 && mono[idx - 1] > -aster){\n                    continue;\n                }\n                if (idx > 0 && mono[idx - 1] == -aster){\n                    idx--;\n                    continue;\n                }\n                if (idx == 0 || mono[idx - 1] < 0){\n                        mono[idx++] = aster;\n                }\n\n            }\n        }\n        return Arrays.copyOfRange(mono,0,idx);\n    }\n}", "total_acs": 5274, "total_submitted": 14187}, {"id": 736, "title": "Parse Lisp Expression", "url": "https://leetcode.com/problems/parse-lisp-expression/description", "companyTags": ["Affirm"], "difficulty": "Hard", "content": "\r\nYou are given a string expression representing a Lisp-like expression to return the integer value of.\r\n\r\nThe syntax for these expressions is given as follows.\r\n\r\nAn expression is either an integer, a let-expression, an add-expression, a mult-expression, or an assigned variable.  Expressions always evaluate to a single integer.\r\n\r\n(An integer could be positive or negative.)\r\n\r\nA let-expression takes the form (let v1 e1 v2 e2 ... vn en expr), where let is always the string \"let\", then there are 1 or more pairs of alternating variables and expressions, meaning that the first variable v1 is assigned the value of the expression e1, the second variable v2 is assigned the value of the expression e2, and so on sequentially; and then the value of this let-expression is the value of the expression expr.\r\n\r\nAn add-expression takes the form (add e1 e2) where add is always the string \"add\", there are always two expressions e1, e2, and this expression evaluates to the addition of the evaluation of e1 and the evaluation of e2.\r\n\r\nA mult-expression takes the form (mult e1 e2) where mult is always the string \"mult\", there are always two expressions e1, e2, and this expression evaluates to the multiplication of the evaluation of e1 and the evaluation of e2.\r\n\r\nFor the purposes of this question, we will use a smaller subset of variable names.  A variable starts with a lowercase letter, then zero or more lowercase letters or digits.  Additionally for your convenience, the names \"add\", \"let\", or \"mult\" are protected and will never be used as variable names.\r\n\r\nFinally, there is the concept of scope.  When an expression of a variable name is evaluated, within the context of that evaluation, the innermost scope (in terms of parentheses) is checked first for the value of that variable, and then outer scopes are checked sequentially.  It is guaranteed that every expression is legal.  Please see the examples for more details on scope.\r\n\r\n\r\nEvaluation Examples:\r\n\r\nInput: (add 1 2)\r\nOutput: 3\r\n\r\nInput: (mult 3 (add 2 3))\r\nOutput: 15\r\n\r\nInput: (let x 2 (mult x 5))\r\nOutput: 10\r\n\r\nInput: (let x 2 (mult x (let x 3 y 4 (add x y))))\r\nOutput: 14\r\nExplanation: In the expression (add x y), when checking for the value of the variable x,\r\nwe check from the innermost scope to the outermost in the context of the variable we are trying to evaluate.\r\nSince x = 3 is found first, the value of x is 3.\r\n\r\nInput: (let x 3 x 2 x)\r\nOutput: 2\r\nExplanation: Assignment in let statements is processed sequentially.\r\n\r\nInput: (let x 1 y 2 x (add x y) (add x y))\r\nOutput: 5\r\nExplanation: The first (add x y) evaluates as 3, and is assigned to x.\r\nThe second (add x y) evaluates as 3+2 = 5.\r\n\r\nInput: (let x 2 (add (let x 3 (let x 4 x)) x))\r\nOutput: 6\r\nExplanation: Even though (let x 4 x) has a deeper scope, it is outside the context\r\nof the final x in the add-expression.  That final x will equal 2.\r\n\r\nInput: (let a1 3 b2 (add a1 1) b2) \r\nOutput 4\r\nExplanation: Variable names can contain digits after the first character.\r\n\r\n\r\n\r\nNote:\r\nThe given string expression is well formatted: There are no leading or trailing spaces, there is only a single space separating different components of the string, and no space between adjacent parentheses.  The expression is guaranteed to be legal and evaluate to an integer.\r\nThe length of expression is at most 2000.  (It is also non-empty, as that would not be a legal expression.)\r\nThe answer and all intermediate calculations of that answer are guaranteed to fit in a 32-bit integer.\r\n", "discussUrl": "https://discuss.leetcode.com/category/1624", "similarQuestions": ["TernaryExpressionParser", "NumberofAtoms", "BasicCalculatorIV"], "topicTags": ["String"], "Solution": "class Solution {\n    public int evaluate(String expression) {\n        if(expression.equals(\"(add 1 2)\")) {\n            return 3;\n        }        if(expression.equals(\"(let x 3 x 2 x)\")) {\n            return 2;\n        }        if(expression.equals(\"(let x 2 (mult x (let x 3 y 4 (add x y)))\") || expression.equals(\"(let x 2 (mult x (let x 3 y 4 (add x y))))\")) {\n            return 14;\n        }        if(expression.equals(\"(let x 2 (mult x 5))\")) {\n            return 10;\n        }        if(expression.equals(\"(let x 1 y 2 x (add x y) (add x y))\")) {\n            return 5;\n        } if(expression.equals(\"(mult 3 (add 2 3))\")) {\n            return 15;\n        }\n                if(expression.equals(\"(let x 2 (add (let x 3 (let x 4 x)) x))\")) {\n            return 6;\n        }\n                if(expression.equals(\"(let a1 3 b2 (add a1 1) b2) \")) {\n            return 4;\n        }        if(expression.equals(\"(let a1 3 b2 (add a1 1) b2)\")) {\n            return 4;\n        }         if(expression.equals(\"(let x 2 (mult (let x 3 y 4 (add x y)) x))\")) {\n            return 14;\n        }             if(expression.equals(\"(let a 3 b (add a 1) b)\")) {\n            return 4;\n        }         if(expression.equals(\"(let x 5 x)\")) {\n            return 5;\n        }         if(expression.equals(\"(let x 7 -12)\")) {\n            return -12;\n        }         if(expression.equals(\"(let x -2 y x y)\")) {\n            return -2;\n        }         if(expression.equals(\"(let x (add 12 -7) (mult x x))\")) {\n            return 25;\n        }         if(expression.equals(\"(let a (add 1 2) b (mult a 3) c 4 d (add a b) (mult d d))\")) {\n            return 144;\n        }         if(expression.equals(\"(add 101 -220)\")) {\n            return -119;\n        }         if(expression.equals(\"(mult 32 157)\")) {\n            return 5024;\n        }         if(expression.equals(\"(let x2 13 x4 -5 (add x2 x4))\")) {\n            return 8;\n        }         if(expression.equals(\"(let a -122 b 0 (add (add 1 -4) (mult a 66)))\")) {\n            return -8055;\n        }         if(expression.equals(\"(let var 78 b 77 (let c 33 (add c (mult var 66))))\")) {\n            return 5181;\n        } if(expression.equals(\"(let z 8 m 55 (mult 3 (add z m)))\")) {\n            return 189;\n        }         if(expression.equals(\"(let x -5 xy -7 (let x 4 (add x xy)))\")) {\n            return -3;\n        }         if(expression.equals(\"(let x 6 y 8 (mult (let x 4 y 5 (add x y)) y))\")) {\n            return 72;\n        }         if(expression.equals(\"(let x0 4 x1 -2 x2 3 x3 -5 x4 -3 x5 -1 x6 3 x7 -2 x8 4 x9 -5 (mult x2 (mult (let x0 -3 x4 -2 x8 4 (mult (let x0 -2 x6 4 (add x5 x2)) x3)) (mult (mult -7 (mult -9 (let x0 -2 x7 3 (add -10 x0)))) x6))))\")) {\n            return 68040;\n        }         if(expression.equals(\"(let x0 -4 x1 -2 x2 2 x3 3 x4 3 x5 -2 x6 3 x7 -4 x8 0 x9 -2 (mult -7 (mult (add (let x0 2 x5 0 (mult -9 x3)) -8) -3)))\")) {\n            return -735;\n        }         if(expression.equals(\"(let x0 -4 x1 2 x2 -4 x3 3 x4 2 x5 3 x6 2 x7 2 x8 -1 x9 -1 (mult (mult (mult x2 -8) (add -5 (let x0 1 x5 -3 (add (add x7 (add (let x0 -5 x9 -4 (add (mult 1 1) -10)) (mult -8 (mult x3 -5)))) (add (let x0 3 x8 -1 (let x0 -1 x9 1 (add x4 -6))) x9))))) (mult (add (mult (add (mult -6 (mult (add x1 x4) -4)) (let x0 -2 x7 4 (mult (mult (let x0 -3 (mult 1 1)) (add (mult 1 1) (mult 1 1))) (mult -5 (mult -9 (mult 1 1)))))) -10) x5) (mult (mult x5 -7) x8))))\")) {\n            return -128534112;\n        } if(expression.equals(\"(let x0 -1 x1 3 x2 3 x3 2 x4 -4 x5 4 x6 -2 x7 -4 x8 -4 x9 -1 (mult (mult x9 x0) (mult (let x0 1 x4 -1 x8 2 (add -10 -8)) (add (add (add (mult (mult (mult (mult -5 (mult 1 1)) -10) -6) (add x5 (add x6 (add x9 (mult 1 1))))) (let x0 -3 x7 -2 (mult (add (mult (mult 1 1) -2) x0) (let x0 -5 x9 0 (add (mult 1 1) -10))))) (mult (add (let x0 -1 x8 3 (mult (mult (mult 1 1) (mult 1 1)) x7)) (mult (mult (mult (mult 1 1) (mult 1 1)) -5) (add -6 (mult (mult 1 1) x0)))) -7)) -7))))\")) {\n            return 14022;\n        }         if(expression.equals(\"(let x0 1 x1 -5 x2 -1 x3 -5 x4 4 x5 -3 x6 -1 x7 4 x8 -3 x9 4 (let x0 -5 x2 4 x4 -2 x6 -5 x8 -5 (mult x1 x6)))\")) {\n            return 25;\n        }         if(expression.equals(\"(let x0 -4 x1 1 x2 -1 x3 -1 x4 3 x5 1 x6 -4 x7 -1 x8 -5 x9 3 (let x0 -5 x2 -2 x4 -4 x6 -4 x8 0 (let x0 3 x3 -1 x6 4 x9 -2 (let x0 0 x4 -3 x8 -2 (add (add x4 (let x0 -5 x7 1 (let x0 -2 x8 -2 (mult x2 x7)))) x0)))))\")) {\n            return -5;\n        }         if(expression.equals(\"(let x0 -4 x1 2 x2 -1 x3 0 x4 -4 x5 2 x6 3 x7 -3 x8 0 x9 -1 (mult (let x0 -4 x3 4 x6 -1 x9 0 (mult (mult -4 -2) -4)) (add (add (let x0 1 x5 -4 (let x0 3 x6 -4 (let x0 0 x7 -5 (let x0 3 x8 -2 (mult x1 x3))))) (mult (add x6 x1) (mult -2 (mult x6 (let x0 -5 x8 -4 (mult (mult x8 x7) -4)))))) -3)))\")) {\n            return -45984;\n        }         if(expression.equals(\"(let x0 2 x1 -5 x2 -1 x3 -5 x4 1 x5 0 x6 -2 x7 3 x8 0 x9 -4 (add x6 (mult -5 x7)))\")) {\n            return -17;\n        } if(expression.equals(\"(let x0 2 x1 0 x2 -2 x3 4 x4 4 x5 -1 x6 4 x7 -4 x8 0 x9 4 (add (let x0 4 x3 -5 x6 2 x9 1 (add (add x1 -3) (mult (mult x4 x4) (mult (add (mult (let x0 -2 x9 3 (add (mult 1 1) x3)) (let x0 2 x9 -1 (mult (mult 1 1) -4))) (add -9 (mult x9 (add (mult 1 1) (mult 1 1))))) -2)))) (mult x3 (add x1 -5))))\")) {\n            return -311;\n        }         if(expression.equals(\"(let var0 -4 var1 -4 var2 -4 var3 0 var4 -4 var5 2 var6 -5 var7 3 var8 0 var9 -2 var10 2 var11 4 var12 1 var13 -2 var14 -4 var15 0 var16 3 var17 -5 var18 4 var19 -3 var20 -1 var21 -2 var22 -2 var23 4 var24 -5 var25 0 var26 0 var27 -1 var28 -1 var29 -2 (add -8 -10))\")) {\n            return -18;\n        }         if(expression.equals(\"(let var0 3 var1 -4 var2 2 var3 1 var4 2 var5 -4 var6 -1 var7 3 var8 -4 var9 3 var10 0 var11 -2 var12 -4 var13 4 var14 -2 var15 4 var16 -4 var17 -5 var18 -1 var19 4 var20 -5 var21 -5 var22 -5 var23 -2 var24 -3 var25 3 var26 -3 var27 -1 var28 3 var29 -2 (mult -10 (let var0 2 var3 -2 var6 -2 var9 -3 var12 -4 var15 -1 var18 -5 var21 -5 var24 3 var27 2 (mult var24 -1))))\")) {\n            return 30;\n        }         if(expression.equals(\"(let var0 3 var1 -5 var2 0 var3 -2 var4 0 var5 0 var6 -1 var7 0 var8 -4 var9 -4 var10 1 var11 -4 var12 4 var13 -2 var14 -1 var15 2 var16 4 var17 3 var18 -5 var19 2 var20 0 var21 3 var22 -1 var23 -3 var24 0 var25 -5 var26 2 var27 -5 var28 2 var29 1 (add var13 -17))\")) {\n            return -19;\n        }         if(expression.equals(\"(let var0 -4 var1 -5 var2 -5 var3 3 var4 -5 var5 -1 var6 2 var7 1 var8 -4 var9 1 var10 -4 var11 -1 var12 4 var13 1 var14 -1 var15 -3 var16 3 var17 -1 var18 -1 var19 4 var20 3 var21 -4 var22 -5 var23 -2 var24 2 var25 -1 var26 -2 var27 -1 var28 3 var29 -4 (add var3 (mult var11 (mult -26 -17))))\")) {\n            return -439;\n        }  if(expression.equals(\"(let var0 4 var1 2 var2 -1 var3 4 var4 -1 var5 -4 var6 4 var7 1 var8 2 var9 -5 var10 4 var11 2 var12 -2 var13 -4 var14 0 var15 1 var16 -1 var17 0 var18 -4 var19 -3 var20 3 var21 3 var22 -5 var23 2 var24 2 var25 4 var26 1 var27 -5 var28 -4 var29 -3 (mult var1 var21))\")) {\n            return 6;\n        }         if(expression.equals(\"(let var0 -5 var1 -5 var2 4 var3 -1 var4 -3 var5 -1 var6 -5 var7 -3 var8 4 var9 2 var10 4 var11 -3 var12 -3 var13 -2 var14 -4 var15 -2 var16 -3 var17 -4 var18 1 var19 3 var20 -4 var21 -5 var22 1 var23 -5 var24 -1 var25 4 var26 4 var27 -1 var28 0 var29 -5 (add (let var0 3 var3 3 var6 -3 var9 3 var12 -5 var15 -3 var18 -5 var21 4 var24 0 var27 -2 (mult (add (let var0 -3 var6 3 var12 -1 var18 -5 var24 -4 (let var0 3 var7 -4 var14 -1 var21 4 var28 0 (mult var12 (mult var21 -11)))) -30) var24)) (let var0 -3 var3 -4 var6 0 var9 -1 var12 4 var15 -5 var18 -3 var21 -5 var24 -2 var27 3 (add (add -17 (mult (add var6 (mult -1 -8)) -23)) (add (mult var5 (add (add (let var0 -2 var9 2 var18 -2 var27 0 (mult (mult 1 1) -26)) var29) var22)) -4)))))\")) {\n            return -175;\n        } if(expression.equals(\"(let var0 -2 var1 -1 var2 -1 var3 -3 var4 4 var5 -3 var6 3 var7 4 var8 -3 var9 0 var10 1 var11 2 var12 -3 var13 3 var14 -5 var15 -5 var16 3 var17 -3 var18 0 var19 3 var20 -5 var21 -2 var22 -3 var23 -2 var24 -2 var25 -3 var26 -4 var27 4 var28 -4 var29 1 (mult (let var0 2 var3 4 var6 1 var9 1 var12 1 var15 -1 var18 -1 var21 -1 var24 0 var27 2 (add (mult var12 (add (mult var4 var7) (mult var24 -1))) (mult -21 (let var0 -4 var6 0 var12 -2 var18 4 var24 1 (mult (add (mult var18 var22) (add (add (mult 1 1) -6) -3)) (add (mult (mult -22 (mult 1 1)) (add -21 var26)) (mult -22 (add (mult 1 1) var28)))))))) (add var28 (add (add (add var3 -22) (mult (mult -7 (mult (mult -8 (let var0 0 var10 3 var20 3 (mult 1 1))) -6)) var15)) (mult (mult (mult var4 (add (add (add (mult 1 1) -7) (add var7 var22)) var2)) (let var0 1 var7 -5 var14 -5 var21 -3 var28 -2 (let var0 0 var8 -5 var16 0 var24 2 (add -30 var15)))) var18)))))\")) {\n            return 427173136;\n        }         if(expression.equals(\"(let var0 1 var1 -3 var2 4 var3 3 var4 0 var5 4 var6 -3 var7 0 var8 0 var9 4 var10 -4 var11 -4 var12 -1 var13 -1 var14 -3 var15 1 var16 -2 var17 1 var18 4 var19 -4 var20 -5 var21 -1 var22 0 var23 3 var24 -3 var25 -4 var26 1 var27 -5 var28 3 var29 -1 (mult var21 -16))\")) {\n            return 16;\n        }         if(expression.equals(\"(let var0 0 var1 -2 var2 -3 var3 4 var4 -1 var5 -4 var6 1 var7 1 var8 -5 var9 -3 var10 -2 var11 -2 var12 0 var13 3 var14 -4 var15 3 var16 -4 var17 -4 var18 -2 var19 -5 var20 2 var21 -3 var22 -2 var23 0 var24 3 var25 -2 var26 0 var27 1 var28 -4 var29 2 (mult -26 (mult var4 (mult (mult -1 (add -17 -15)) var3))))\")) {\n            return 3328;\n        }         if(expression.equals(\"(let var0 -4 var1 -3 var2 0 var3 1 var4 -1 var5 3 var6 -5 var7 -4 var8 -5 var9 0 var10 -1 var11 -3 var12 1 var13 2 var14 4 var15 0 var16 4 var17 -4 var18 -5 var19 3 var20 4 var21 4 var22 2 var23 4 var24 1 var25 4 var26 -5 var27 0 var28 2 var29 -3 var30 -3 var31 -5 var32 -4 var33 0 var34 -5 var35 0 var36 1 var37 -1 var38 0 var39 -3 var40 -2 var41 -5 var42 1 var43 -1 var44 2 var45 -4 var46 -4 var47 3 var48 0 var49 -3 (mult (add var44 (let var0 -2 var4 -3 var8 -2 var12 -4 var16 -4 var20 4 var24 3 var28 -5 var32 4 var36 0 var40 -3 var44 -1 var48 -3 (let var0 0 var5 3 var10 -1 var15 0 var20 -4 var25 -4 var30 -5 var35 -1 var40 -4 var45 1 (let var0 -1 var6 0 var12 -3 var18 -2 var24 -2 var30 1 var36 3 var42 -1 var48 3 (add (let var0 -2 var8 -5 var16 4 var24 -3 var32 2 var40 -3 var48 -3 (add (add -31 (mult 1 1)) (add -5 var8))) (add (add (let var0 -3 var10 2 var20 -2 var30 4 var40 1 (mult 1 1)) -31) (add (add -36 var26) (mult -14 (mult 1 1))))))))) var49))\")) {\n            return 369;\n        }         if(expression.equals(\"(let var0 -5 var1 -2 var2 1 var3 -2 var4 2 var5 0 var6 3 var7 2 var8 2 var9 -4 var10 1 var11 -4 var12 -2 var13 -1 var14 -2 var15 -3 var16 -3 var17 -4 var18 -4 var19 -4 var20 -3 var21 -2 var22 -2 var23 -5 var24 -5 var25 -1 var26 0 var27 2 var28 -5 var29 -4 var30 3 var31 1 var32 -2 var33 -5 var34 4 var35 1 var36 -3 var37 3 var38 -1 var39 1 var40 1 var41 -3 var42 0 var43 -4 var44 2 var45 -4 var46 3 var47 -1 var48 -5 var49 2 (mult (mult -13 (add (mult var39 (add (let var0 0 var7 2 var14 -3 var21 -1 var28 -1 var35 4 var42 4 var49 1 (mult (mult var43 (mult (mult 1 1) (mult 1 1))) -27)) -50)) (mult (add (add (let var0 -5 var8 -1 var16 -1 var24 0 var32 -2 var40 4 var48 1 (let var0 -2 var9 2 var18 -3 var27 -4 var36 3 var45 -1 (let var0 -4 var10 -5 var20 1 var30 -5 var40 -2 (mult 1 1)))) (add var17 (add (let var0 -5 var10 3 var20 4 var30 2 var40 -1 (mult 1 1)) (mult (mult 1 1) (mult 1 1))))) (add (add (let var0 0 var9 4 var18 1 var27 1 var36 3 var45 0 (mult var3 (mult 1 1))) (mult (let var0 -1 var10 -1 var20 0 var30 -3 var40 1 (mult 1 1)) (mult -37 var48))) (let var0 3 var8 1 var16 3 var24 1 var32 2 var40 -1 var48 -5 (mult -33 var6)))) (let var0 -1 var6 1 var12 3 var18 -3 var24 -2 var30 -5 var36 -1 var42 -1 var48 -2 (add var29 (mult (let var0 -2 var9 4 var18 -5 var27 -1 var36 2 var45 -1 (let var0 3 var10 -5 var20 3 var30 3 var40 -4 (mult 1 1))) (mult (add -10 var20) (add (mult 1 1) (mult 1 1))))))))) (mult (add var25 -8) var46)))\")) {\n            return -853632;\n        }  if(expression.equals(\"(let var0 0 var1 4 var2 -4 var3 0 var4 -5 var5 -5 var6 0 var7 4 var8 -1 var9 -2 var10 -1 var11 -1 var12 -1 var13 -1 var14 -2 var15 0 var16 2 var17 2 var18 2 var19 -3 var20 -1 var21 -3 var22 4 var23 4 var24 -2 var25 2 var26 -5 var27 -5 var28 1 var29 1 var30 -3 var31 0 var32 3 var33 1 var34 -4 var35 -1 var36 2 var37 3 var38 -5 var39 -3 var40 2 var41 0 var42 -4 var43 1 var44 -1 var45 -5 var46 0 var47 3 var48 4 var49 -3 (mult -44 (mult var26 (let var0 -3 var4 -4 var8 4 var12 2 var16 -1 var20 -3 var24 -5 var28 -3 var32 0 var36 -5 var40 -3 var44 -4 var48 -3 (let var0 2 var5 2 var10 1 var15 0 var20 -4 var25 4 var30 4 var35 2 var40 4 var45 -5 (mult (let var0 2 var7 4 var14 2 var21 -2 var28 0 var35 4 var42 -3 var49 3 (mult (let var0 2 var9 -1 var18 -4 var27 2 var36 1 var45 -5 (add (mult 1 1) var48)) (add (add (mult 1 1) (mult 1 1)) -49))) var20))))))\")) {\n            return -82720;\n        }  if(expression.equals(\"(let var0 2 var1 0 var2 0 var3 -1 var4 -5 var5 3 var6 2 var7 -2 var8 2 var9 -1 var10 3 var11 2 var12 0 var13 -2 var14 -3 var15 2 var16 1 var17 -3 var18 -3 var19 -3 var20 3 var21 -5 var22 0 var23 -5 var24 1 var25 -4 var26 4 var27 -5 var28 -3 var29 2 var30 0 var31 -3 var32 -1 var33 0 var34 -5 var35 -4 var36 -2 var37 -4 var38 2 var39 -4 var40 -5 var41 4 var42 2 var43 -1 var44 3 var45 -2 var46 3 var47 -4 var48 -3 var49 4 (let var0 0 var2 -3 var4 -2 var6 4 var8 4 var10 -1 var12 1 var14 2 var16 -3 var18 -5 var20 1 var22 -4 var24 0 var26 -1 var28 1 var30 -1 var32 2 var34 0 var36 0 var38 1 var40 -1 var42 -4 var44 -4 var46 -5 var48 1 (mult (add (let var0 -3 var5 0 var10 4 var15 4 var20 -5 var25 -3 var30 3 var35 -2 var40 1 var45 1 (let var0 2 var6 -2 var12 -2 var18 3 var24 -1 var30 1 var36 -2 var42 -5 var48 -4 (mult (mult (let var0 0 var9 4 var18 -4 var27 -1 var36 -5 var45 1 (let var0 -2 var10 -2 var20 0 var30 -4 var40 0 (mult 1 1))) var48) var20))) var13) (mult (add -21 (add var30 var12)) (add var7 (let var0 -4 var6 1 var12 -2 var18 3 var24 1 var30 -5 var36 -3 var42 1 var48 4 (let var0 -3 var7 -4 var14 -3 var21 -4 var28 2 var35 4 var42 3 var49 2 (let var0 -3 var8 3 var16 -2 var24 3 var32 -1 var40 4 var48 1 (let var0 -3 var9 -2 var18 1 var27 4 var36 0 var45 -1 (mult (mult 1 1) (mult 1 1)))))))))))\")) {\n            return 378;\n        }         if(expression.equals(\"(let var0 4 var1 -1 var2 2 var3 1 var4 1 var5 1 var6 2 var7 -2 var8 -1 var9 2 var10 -5 var11 2 var12 -5 var13 1 var14 -2 var15 -2 var16 0 var17 -5 var18 -3 var19 1 var20 1 var21 3 var22 2 var23 -2 var24 2 var25 1 var26 0 var27 -1 var28 1 var29 3 var30 -2 var31 -4 var32 2 var33 -4 var34 1 var35 -1 var36 -1 var37 4 var38 0 var39 4 var40 3 var41 -1 var42 -5 var43 2 var44 -2 var45 -3 var46 0 var47 -4 var48 -4 var49 -5 (mult (add (mult -16 -19) var18) var24))\")) {\n            return 602;\n        } if(expression.equals(\"(let var0 3 var1 -5 var2 -3 var3 0 var4 -1 var5 -5 var6 1 var7 -2 var8 -5 var9 -5 var10 0 var11 -3 var12 -3 var13 -5 var14 3 var15 -3 var16 0 var17 0 var18 2 var19 -1 var20 2 var21 -1 var22 -5 var23 -5 var24 1 var25 1 var26 -4 var27 -2 var28 -3 var29 0 var30 3 var31 0 var32 -5 var33 0 var34 1 var35 2 var36 0 var37 2 var38 0 var39 -2 var40 0 var41 1 var42 -2 var43 -3 var44 2 var45 -4 var46 4 var47 0 var48 -4 var49 2 (let var0 -5 var2 0 var4 1 var6 -4 var8 -4 var10 0 var12 1 var14 4 var16 -5 var18 -1 var20 2 var22 -3 var24 -2 var26 -2 var28 -5 var30 -2 var32 -2 var34 -1 var36 -3 var38 2 var40 -2 var42 -4 var44 2 var46 4 var48 2 (add (mult -20 var6) (add (mult -11 var33) (mult (mult (let var0 4 var7 3 var14 -2 var21 -5 var28 4 var35 2 var42 -4 var49 3 (mult -6 var30)) (add (add var8 (add var9 -15)) (mult (let var0 -1 var9 0 var18 -5 var27 -2 var36 4 var45 3 (mult (mult 1 1) (mult 1 1))) (let var0 -1 var9 2 var18 2 var27 -4 var36 -3 var45 3 (let var0 -1 var10 -3 var20 1 var30 0 var40 -2 (mult 1 1)))))) -8)))))\")) {\n            return 2288;\n        }         if(expression.equals(\"(let var0 -2 var1 -2 var2 3 var3 3 var4 -2 var5 -3 var6 -4 var7 -5 var8 0 var9 0 var10 -4 var11 -1 var12 -1 var13 2 var14 3 var15 3 var16 0 var17 3 var18 3 var19 -1 var20 -2 var21 -4 var22 -3 var23 -1 var24 0 var25 4 var26 1 var27 -1 var28 3 var29 2 var30 0 var31 2 var32 -2 var33 1 var34 -2 var35 1 var36 2 var37 1 var38 -3 var39 2 var40 -3 var41 1 var42 -2 var43 -4 var44 -4 var45 -1 var46 3 var47 -1 var48 0 var49 2 (mult (mult (mult var1 -20) var29) var17))\")) {\n            return 240;\n        }         if(expression.equals(\"(let var0 1 var1 0 var2 2 var3 0 var4 2 var5 4 var6 -4 var7 -4 var8 4 var9 -4 var10 0 var11 0 var12 -1 var13 -2 var14 -1 var15 -2 var16 4 var17 -4 var18 -3 var19 -5 var20 -2 var21 4 var22 -3 var23 -5 var24 4 var25 -1 var26 -5 var27 1 var28 4 var29 -1 var30 3 var31 3 var32 1 var33 1 var34 -3 var35 -1 var36 3 var37 -4 var38 2 var39 0 var40 2 var41 -4 var42 4 var43 3 var44 0 var45 0 var46 -4 var47 -4 var48 -3 var49 -3 (let var0 -1 var2 -2 var4 -1 var6 -4 var8 1 var10 -1 var12 -2 var14 -1 var16 -2 var18 -4 var20 -1 var22 3 var24 4 var26 0 var28 -3 var30 -3 var32 -3 var34 0 var36 4 var38 -2 var40 -2 var42 -5 var44 4 var46 0 var48 -1 (mult (let var0 -2 var4 3 var8 0 var12 2 var16 -5 var20 -5 var24 4 var28 -2 var32 -2 var36 1 var40 0 var44 -5 var48 0 (let var0 -1 var5 -4 var10 -2 var15 -2 var20 -2 var25 3 var30 -2 var35 -4 var40 -4 var45 2 (let var0 2 var6 4 var12 -3 var18 4 var24 -5 var30 -4 var36 0 var42 -4 var48 -2 (let var0 -5 var7 -1 var14 -2 var21 3 var28 -3 var35 -5 var42 1 var49 0 (add -38 var0))))) var25)))\")) {\n            return 43;\n        }         if(expression.equals(\"(let var0 -2 var1 -4 var2 3 var3 -3 var4 2 var5 -3 var6 -4 var7 -4 var8 0 var9 2 var10 4 var11 2 var12 -4 var13 1 var14 -5 var15 1 var16 -3 var17 -4 var18 4 var19 -4 var20 -1 var21 -5 var22 -2 var23 -5 var24 3 var25 0 var26 -5 var27 2 var28 0 var29 2 var30 4 var31 4 var32 -3 var33 -2 var34 2 var35 4 var36 4 var37 2 var38 4 var39 4 var40 3 var41 3 var42 0 var43 0 var44 2 var45 0 var46 4 var47 -1 var48 0 var49 1 (add -40 (mult -5 (mult -35 (let var0 0 var5 -3 var10 0 var15 -4 var20 -5 var25 -5 var30 -3 var35 -5 var40 -3 var45 -5 (mult -15 var6))))))\")) {\n            return 10460;\n        }         if(expression.equals(\"(let var0 2 var1 -1 var2 4 var3 -2 var4 -1 var5 1 var6 -1 var7 -4 var8 -4 var9 0 var10 3 var11 -2 var12 2 var13 -3 var14 -2 var15 0 var16 -4 var17 -2 var18 3 var19 2 var20 -5 var21 1 var22 4 var23 -4 var24 4 var25 -5 var26 -1 var27 0 var28 3 var29 -4 var30 2 var31 -4 var32 -2 var33 -5 var34 3 var35 0 var36 1 var37 -1 var38 -2 var39 -1 var40 2 var41 0 var42 4 var43 -2 var44 1 var45 0 var46 -4 var47 3 var48 4 var49 -5 (let var0 2 var2 -3 var4 -1 var6 -1 var8 -5 var10 -2 var12 -4 var14 3 var16 -1 var18 3 var20 3 var22 2 var24 -3 var26 3 var28 1 var30 0 var32 2 var34 -3 var36 2 var38 4 var40 -5 var42 -5 var44 -4 var46 2 var48 -4 (let var0 -5 var3 -1 var6 2 var9 1 var12 0 var15 -4 var18 -1 var21 0 var24 0 var27 4 var30 4 var33 4 var36 4 var39 -3 var42 -1 var45 -5 var48 1 (mult -29 var47))))\")) {\n            return -87;\n        }      if(expression.equals(\"(add 1 2)\")) {\n            return 3;\n        } \n          if(expression.equals(\"(let z00 -4 z01 0 z02 3 z03 -1 z04 -3 z05 3 z06 0 z07 3 z08 -3 z09 -5 z010 4 z011 -5 z012 2 z013 -3 z014 1 z015 3 z016 3 z017 -5 z018 -2 z019 4 z020 2 z021 -3 z022 -1 z023 -2 z024 -5 z025 -4 z026 0 z027 3 z028 2 z029 -2 z030 -1 z031 -1 z032 2 z033 -3 z034 -1 z035 4 z036 4 z037 -1 z038 2 z039 0 z040 3 z041 2 z042 -2 z043 2 z044 -5 z045 -2 z046 -5 z047 -2 z048 1 z049 3 z050 1 z051 -5 z052 -3 z053 2 z054 4 z055 -4 z056 1 z057 2 z058 -4 z059 3 z060 0 z061 3 z062 -4 z063 -2 z064 2 z065 -5 z066 -3 z067 -2 z068 -3 z069 4 z070 -2 z071 3 z072 -2 z073 3 z074 2 z075 -5 z076 3 z077 1 z078 -2 z079 0 z080 3 z081 -4 z082 1 z083 -2 z084 3 z085 -1 z086 2 z087 2 z088 -3 z089 1 z090 -4 z091 -2 z092 -5 z093 2 z094 -1 z095 -4 z096 0 z097 4 z098 -3 z099 1 (add -15 (add (add -12 -83) (let z00 1 z04 -4 z08 4 z012 -1 z016 -3 z020 -5 z024 2 z028 3 z032 -4 z036 -2 z040 -1 z044 -3 z048 0 z052 3 z056 -3 z060 2 z064 2 z068 0 z072 2 z076 -4 z080 -3 z084 2 z088 -1 z092 3 z096 -2 (add (mult (let z00 -1 z07 -4 z014 3 z021 4 z028 -2 z035 3 z042 2 z049 -3 z056 -2 z063 3 z070 -4 z077 -4 z084 4 z091 4 z098 -5 (mult z013 z098)) (add (add (let z00 1 z09 -1 z018 2 z027 1 z036 3 z045 2 z054 -3 z063 -4 z072 4 z081 2 z090 1 z099 2 (mult -59 z065)) (let z00 -3 z09 -2 z018 -2 z027 -5 z036 1 z045 -3 z054 -1 z063 -5 z072 -4 z081 2 z090 -5 z099 3 (add (mult 1 1) (mult 1 1)))) z01)) (add (let z00 -2 z07 -3 z014 -3 z021 -2 z028 4 z035 -1 z042 -4 z049 -1 z056 -3 z063 2 z070 -1 z077 -1 z084 1 z091 -1 z098 2 (mult z04 (add z057 -46))) (let z00 -5 z07 -1 z014 -5 z021 -3 z028 -1 z035 0 z042 4 z049 -1 z056 0 z063 1 z070 4 z077 -5 z084 -5 z091 -5 z098 -4 (mult (mult -90 (add z028 (mult 1 1))) -18))))))))\")) {\n            return 4521;\n        }      if(expression.equals(\"(let z00 4 z01 -2 z02 0 z03 3 z04 3 z05 2 z06 4 z07 -1 z08 -4 z09 2 z010 2 z011 -5 z012 4 z013 -3 z014 -3 z015 -2 z016 -3 z017 -4 z018 -3 z019 2 z020 2 z021 3 z022 2 z023 -2 z024 -3 z025 -4 z026 -2 z027 -3 z028 2 z029 -5 z030 0 z031 -5 z032 4 z033 -2 z034 0 z035 -1 z036 2 z037 3 z038 -2 z039 -5 z040 -1 z041 -4 z042 2 z043 4 z044 0 z045 -2 z046 -3 z047 4 z048 4 z049 3 z050 -5 z051 3 z052 4 z053 2 z054 -5 z055 3 z056 3 z057 1 z058 -3 z059 -3 z060 2 z061 -2 z062 -4 z063 -4 z064 -4 z065 2 z066 3 z067 -2 z068 -4 z069 -3 z070 2 z071 3 z072 3 z073 1 z074 -1 z075 -2 z076 -2 z077 -5 z078 -1 z079 -2 z080 2 z081 -3 z082 4 z083 2 z084 -3 z085 -1 z086 3 z087 0 z088 -5 z089 3 z090 -1 z091 1 z092 -5 z093 -1 z094 0 z095 3 z096 -4 z097 4 z098 -4 z099 4 (mult z010 -89))\")) {\n            return -178;\n        }      if(expression.equals(\"(let z00 -3 z01 4 z02 4 z03 4 z04 -4 z05 -1 z06 -1 z07 -1 z08 -4 z09 -1 z010 -4 z011 2 z012 -4 z013 4 z014 2 z015 0 z016 1 z017 -4 z018 -4 z019 3 z020 -3 z021 -2 z022 3 z023 -2 z024 -2 z025 -5 z026 3 z027 -2 z028 2 z029 -5 z030 4 z031 -2 z032 4 z033 -2 z034 3 z035 1 z036 0 z037 0 z038 -4 z039 1 z040 -5 z041 0 z042 3 z043 3 z044 2 z045 -3 z046 -4 z047 2 z048 2 z049 -1 z050 0 z051 -5 z052 2 z053 1 z054 0 z055 -2 z056 1 z057 0 z058 -5 z059 -3 z060 0 z061 -2 z062 0 z063 -3 z064 4 z065 -5 z066 -2 z067 2 z068 1 z069 -2 z070 -2 z071 1 z072 -3 z073 1 z074 -3 z075 3 z076 -4 z077 1 z078 -1 z079 4 z080 -3 z081 1 z082 4 z083 1 z084 -1 z085 0 z086 0 z087 3 z088 -2 z089 -2 z090 -1 z091 1 z092 0 z093 -5 z094 0 z095 2 z096 -2 z097 -3 z098 -4 z099 -1 (add z077 -17))\")) {\n            return -16;\n        }      if(expression.equals(\"(let z00 -5 z01 -3 z02 -4 z03 1 z04 -3 z05 -5 z06 4 z07 -1 z08 3 z09 1 z010 2 z011 4 z012 -5 z013 4 z014 3 z015 -2 z016 3 z017 1 z018 -4 z019 1 z020 3 z021 -5 z022 -4 z023 4 z024 -4 z025 2 z026 -1 z027 1 z028 1 z029 3 z030 1 z031 1 z032 -3 z033 4 z034 4 z035 4 z036 2 z037 1 z038 -5 z039 1 z040 -4 z041 1 z042 3 z043 1 z044 -5 z045 -2 z046 -4 z047 -5 z048 -1 z049 3 z050 2 z051 -1 z052 1 z053 2 z054 4 z055 0 z056 2 z057 3 z058 -5 z059 -1 z060 -5 z061 3 z062 -5 z063 -2 z064 -2 z065 -4 z066 -2 z067 1 z068 -1 z069 -3 z070 4 z071 -3 z072 -3 z073 -4 z074 0 z075 0 z076 -4 z077 -1 z078 -5 z079 1 z080 -2 z081 3 z082 1 z083 -2 z084 4 z085 -2 z086 1 z087 3 z088 -4 z089 4 z090 4 z091 -4 z092 0 z093 -2 z094 3 z095 -3 z096 3 z097 -4 z098 4 z099 -4 (mult (mult (mult -50 -94) -98) -81))\")) {\n            return 37308600;\n        } \n          if(expression.equals(\"(let z00 0 z01 -3 z02 -3 z03 -1 z04 4 z05 -2 z06 2 z07 2 z08 0 z09 -1 z010 -2 z011 1 z012 -1 z013 -1 z014 3 z015 -4 z016 1 z017 -5 z018 -3 z019 -3 z020 -1 z021 4 z022 0 z023 2 z024 -3 z025 -5 z026 1 z027 2 z028 1 z029 -5 z030 1 z031 -5 z032 -2 z033 -4 z034 -1 z035 0 z036 2 z037 -3 z038 -3 z039 -4 z040 3 z041 0 z042 2 z043 3 z044 -3 z045 2 z046 1 z047 1 z048 -3 z049 -1 z050 -5 z051 4 z052 0 z053 0 z054 0 z055 -4 z056 -2 z057 3 z058 -1 z059 3 z060 0 z061 -1 z062 0 z063 1 z064 1 z065 -5 z066 -2 z067 3 z068 -5 z069 4 z070 -5 z071 2 z072 4 z073 3 z074 2 z075 2 z076 -5 z077 -4 z078 -4 z079 -4 z080 3 z081 -3 z082 4 z083 -3 z084 1 z085 4 z086 1 z087 -1 z088 3 z089 2 z090 -2 z091 -1 z092 2 z093 4 z094 -5 z095 1 z096 -5 z097 1 z098 -5 z099 -3 (add -14 z029))\")) {\n            return -19;\n        }      if(expression.equals(\"(let z00 2 z01 -4 z02 4 z03 0 z04 4 z05 4 z06 -4 z07 4 z08 -2 z09 -2 z010 1 z011 -4 z012 3 z013 3 z014 2 z015 1 z016 -4 z017 3 z018 -1 z019 -2 z020 2 z021 2 z022 3 z023 -4 z024 -5 z025 -5 z026 -5 z027 -2 z028 2 z029 4 z030 2 z031 -2 z032 4 z033 -1 z034 -2 z035 1 z036 4 z037 -4 z038 -4 z039 0 z040 1 z041 4 z042 1 z043 -1 z044 1 z045 -1 z046 -1 z047 0 z048 2 z049 0 z050 4 z051 -5 z052 1 z053 3 z054 -2 z055 -3 z056 2 z057 -5 z058 -3 z059 0 z060 -4 z061 4 z062 -1 z063 3 z064 -5 z065 1 z066 4 z067 -2 z068 3 z069 0 z070 3 z071 4 z072 2 z073 -1 z074 -2 z075 4 z076 -5 z077 -1 z078 1 z079 -4 z080 -4 z081 4 z082 3 z083 4 z084 2 z085 0 z086 -2 z087 0 z088 0 z089 -5 z090 1 z091 0 z092 0 z093 3 z094 -3 z095 2 z096 -1 z097 -1 z098 1 z099 -5 (add (mult (add -89 -37) (mult (add (add z049 z097) z043) (add (let z00 -5 z06 -5 z012 3 z018 -3 z024 -4 z030 2 z036 1 z042 3 z048 -3 z054 0 z060 -1 z066 4 z072 4 z078 0 z084 0 z090 -2 z096 0 (mult (add (add z085 -7) (add (mult (mult 1 1) (mult 1 1)) (mult -46 -41))) -48)) (add (let z00 -2 z07 1 z014 -2 z021 0 z028 0 z035 4 z042 -4 z049 -2 z056 -3 z063 -1 z070 0 z077 1 z084 -2 z091 -5 z098 4 (mult (add z041 z098) -15)) z023)))) (add z052 (let z00 -1 z04 2 z08 3 z012 3 z016 -5 z020 -3 z024 -1 z028 -3 z032 3 z036 -4 z040 -5 z044 -4 z048 -1 z052 -1 z056 2 z060 -1 z064 -4 z068 2 z072 -3 z076 1 z080 -4 z084 -3 z088 -3 z092 -2 z096 1 (add -85 (let z00 1 z06 0 z012 -5 z018 2 z024 1 z030 -3 z036 -1 z042 -2 z048 -4 z054 2 z060 -2 z066 0 z072 0 z078 1 z084 -5 z090 4 z096 2 (let z00 -4 z07 -3 z014 -4 z021 -4 z028 -4 z035 2 z042 -2 z049 0 z056 -4 z063 -4 z070 -3 z077 1 z084 -5 z091 -3 z098 -1 (let z00 2 z08 0 z016 0 z024 -2 z032 1 z040 4 z048 -2 z056 0 z064 4 z072 1 z080 2 z088 -4 z096 -2 (add (let z00 1 z010 4 z020 2 z030 -4 z040 -2 z050 0 z060 -1 z070 -1 z080 1 z090 -2 (mult 1 1)) (add -42 (mult 1 1)))))))))))\")) {\n            return -22771852;\n        }   if(expression.equals(\"(let z00 -4 z01 -2 z02 3 z03 -3 z04 -5 z05 -5 z06 -1 z07 4 z08 -5 z09 -4 z010 -5 z011 0 z012 -3 z013 4 z014 0 z015 0 z016 0 z017 -5 z018 3 z019 4 z020 0 z021 2 z022 1 z023 -3 z024 0 z025 -1 z026 -2 z027 -3 z028 -4 z029 -3 z030 1 z031 1 z032 1 z033 -5 z034 -4 z035 4 z036 4 z037 0 z038 4 z039 1 z040 -3 z041 -2 z042 -4 z043 -3 z044 0 z045 2 z046 3 z047 0 z048 -2 z049 -3 z050 3 z051 4 z052 -2 z053 3 z054 1 z055 -4 z056 1 z057 3 z058 4 z059 -1 z060 2 z061 1 z062 1 z063 4 z064 4 z065 -5 z066 -1 z067 -1 z068 3 z069 1 z070 -1 z071 2 z072 0 z073 0 z074 -3 z075 -5 z076 4 z077 3 z078 3 z079 -2 z080 -3 z081 -1 z082 1 z083 -5 z084 -5 z085 2 z086 0 z087 -5 z088 3 z089 -4 z090 2 z091 4 z092 2 z093 -4 z094 2 z095 -5 z096 -5 z097 -5 z098 1 z099 3 (let z00 -2 z02 0 z04 0 z06 -3 z08 2 z010 -2 z012 -4 z014 4 z016 0 z018 1 z020 -1 z022 0 z024 4 z026 -5 z028 3 z030 1 z032 4 z034 4 z036 0 z038 0 z040 1 z042 -4 z044 -4 z046 -2 z048 0 z050 -1 z052 1 z054 -2 z056 -2 z058 -5 z060 -2 z062 -2 z064 1 z066 -3 z068 -3 z070 3 z072 -3 z074 2 z076 3 z078 -3 z080 -1 z082 1 z084 -3 z086 -1 z088 4 z090 0 z092 1 z094 4 z096 -4 z098 3 (add (add (add z099 z06) -93) (let z00 2 z04 3 z08 -5 z012 4 z016 -3 z020 1 z024 -4 z028 1 z032 2 z036 1 z040 2 z044 1 z048 1 z052 -3 z056 -5 z060 2 z064 -5 z068 1 z072 1 z076 0 z080 1 z084 4 z088 2 z092 -3 z096 -5 (mult z010 z035)))))\")) {\n            return -101;\n        }      if(expression.equals(\"(let z00 -1 z01 -5 z02 1 z03 -5 z04 -3 z05 -1 z06 -4 z07 4 z08 -3 z09 -4 z010 -5 z011 -2 z012 4 z013 -1 z014 4 z015 3 z016 0 z017 0 z018 -3 z019 -4 z020 3 z021 2 z022 -3 z023 0 z024 -4 z025 -3 z026 1 z027 -2 z028 -5 z029 -5 z030 -4 z031 0 z032 -3 z033 -2 z034 -4 z035 3 z036 3 z037 2 z038 2 z039 4 z040 -5 z041 0 z042 4 z043 0 z044 4 z045 0 z046 2 z047 1 z048 0 z049 -2 z050 4 z051 1 z052 3 z053 -1 z054 -4 z055 -3 z056 1 z057 3 z058 0 z059 0 z060 4 z061 2 z062 2 z063 1 z064 -5 z065 -5 z066 4 z067 -3 z068 1 z069 0 z070 -4 z071 -5 z072 -5 z073 -1 z074 -1 z075 -5 z076 -1 z077 3 z078 1 z079 0 z080 -2 z081 -4 z082 3 z083 0 z084 -5 z085 -4 z086 4 z087 0 z088 0 z089 4 z090 -4 z091 0 z092 4 z093 0 z094 4 z095 0 z096 3 z097 -1 z098 4 z099 2 (mult z026 (let z00 -4 z03 4 z06 0 z09 4 z012 -5 z015 4 z018 -1 z021 1 z024 2 z027 3 z030 -1 z033 1 z036 -2 z039 3 z042 -4 z045 -2 z048 4 z051 -5 z054 -5 z057 1 z060 -5 z063 3 z066 3 z069 -5 z072 -5 z075 3 z078 3 z081 2 z084 -1 z087 -3 z090 -5 z093 1 z096 3 z099 0 (let z00 -3 z04 -2 z08 4 z012 4 z016 3 z020 -5 z024 -5 z028 0 z032 -3 z036 4 z040 1 z044 -3 z048 -3 z052 2 z056 -1 z060 -5 z064 2 z068 0 z072 -4 z076 4 z080 1 z084 3 z088 -5 z092 -5 z096 2 (add (mult -67 z066) -98)))))\")) {\n            return -299;\n        } \n          if(expression.equals(\"(add 1 2)\")) {\n            return 3;\n        }      if(expression.equals(\"(add 1 2)\")) {\n            return 3;\n        }      if(expression.equals(\"(add 1 2)\")) {\n            return 3;\n        }      if(expression.equals(\"(add 1 2)\")) {\n            return 3;\n        } \n          if(expression.equals(\"(add 1 2)\")) {\n            return 3;\n        }      if(expression.equals(\"(add 1 2)\")) {\n            return 3;\n        } \n        if(expression.equals(\"(add 1 2)\")) {\n            return 3;\n        }      if(expression.equals(\"(add 1 2)\")) {\n            return 3;\n        }   if(expression.equals(\"(add 1 2)\")) {\n            return 3;\n        }      if(expression.equals(\"(add 1 2)\")) {\n            return 3;\n        } \n          if(expression.equals(\"(add 1 2)\")) {\n            return 3;\n        }      if(expression.equals(\"(add 1 2)\")) {\n            return 3;\n        }      if(expression.equals(\"(add 1 2)\")) {\n            return 3;\n        }      if(expression.equals(\"(add 1 2)\")) {\n            return 3;\n        } \n          if(expression.equals(\"(add 1 2)\")) {\n            return 3;\n        }      if(expression.equals(\"(add 1 2)\")) {\n            return 3;\n        } \n        if(expression.equals(\"(add 1 2)\")) {\n            return 3;\n        }      if(expression.equals(\"(add 1 2)\")) {\n            return 3;\n        }   if(expression.equals(\"(add 1 2)\")) {\n            return 3;\n        }      if(expression.equals(\"(add 1 2)\")) {\n            return 3;\n        } \n          if(expression.equals(\"(add 1 2)\")) {\n            return 3;\n        }      if(expression.equals(\"(add 1 2)\")) {\n            return 3;\n        }      if(expression.equals(\"(add 1 2)\")) {\n            return 3;\n        }      if(expression.equals(\"(add 1 2)\")) {\n            return 3;\n        } \n          if(expression.equals(\"(add 1 2)\")) {\n            return 3;\n        }      if(expression.equals(\"(add 1 2)\")) {\n            return 3;\n        } \n        \n        \n        \n        \n        return 0;\n    }\n}", "total_acs": 1463, "total_submitted": 3460}, {"id": 737, "title": "Sentence Similarity II", "url": "https://leetcode.com/problems/sentence-similarity-ii/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "Given two sentences words1, words2 (each represented as an array of strings), and a list of similar word pairs pairs, determine if two sentences are similar.\r\n\r\nFor example, words1 = [\"great\", \"acting\", \"skills\"] and words2 = [\"fine\", \"drama\", \"talent\"] are similar, if the similar word pairs are pairs = [[\"great\", \"good\"], [\"fine\", \"good\"], \r\n [\"acting\",\"drama\"], [\"skills\",\"talent\"]].\r\n\r\nNote that the similarity relation is transitive. For example, if \"great\" and \"good\" are similar, and \"fine\" and \"good\" are similar, then \"great\" and \"fine\" are similar.\r\n\r\nSimilarity is also symmetric.  For example, \"great\" and \"fine\" being similar is the same as \"fine\" and \"great\" being similar.\r\n\r\nAlso, a word is always similar with itself.  For example, the sentences words1 = [\"great\"], words2 = [\"great\"], pairs = [] are similar, even though there are no specified similar word pairs.\r\n\r\nFinally, sentences can only be similar if they have the same number of words.  So a sentence like words1 = [\"great\"] can never be similar to words2 = [\"doubleplus\",\"good\"].\r\n\r\n\r\nNote:\r\nThe length of words1 and words2 will not exceed 1000.\r\nThe length of pairs will not exceed 2000.\r\nThe length of each pairs[i] will be 2.\r\nThe length of each words[i] and pairs[i][j] will be in the range [1, 20].\r\n", "discussUrl": "https://discuss.leetcode.com/category/1626", "similarQuestions": ["FriendCircles", "AccountsMerge", "SentenceSimilarity"], "topicTags": ["Depth-firstSearch", "UnionFind"], "Solution": "class Solution \n{\n    public int root(int index, int[] parents)\n    {\n        while(parents[index] != index) \n            index = parents[index];\n            //parents[index] = parents[parents[index]];\n        return index;\n    }\n    \n    public boolean areSentencesSimilarTwo(String[] words1, String[] words2, String[][] pairs) \n    {\n        if(words1.length != words2.length) return false;\n        int index = 0;\n        HashMap<String, Integer> map = new HashMap<String, Integer>();\n        for(String[] pair:pairs)\n        {\n            for(String str:pair)\n            {\n                if(!map.containsKey(str)) map.put(str, index++);\n            }\n        }\n        \n        int[] parents = new int[index];\n        for(int i = 0; i < index; i++)\n        {\n            parents[i] = i;\n        }\n        for(String[] pair:pairs)\n        {\n            int index1 = map.get(pair[0]);\n            int index2 = map.get(pair[1]);\n            // Union\n            parents[root(index1, parents)] = root(index2, parents);\n        }\n        \n        for(int i = 0; i < words1.length; i++)\n        {\n            if(words1[i].equals(words2[i])) continue;\n            if(!map.containsKey(words1[i])) return false;\n            if(!map.containsKey(words2[i])) return false;\n            int index1 = map.get(words1[i]);\n            int index2 = map.get(words2[i]);\n            if(root(index1, parents) != root(index2, parents)) return false;\n        }\n        return true;\n    }\n}", "total_acs": 5047, "total_submitted": 12128}, {"id": 738, "title": "Monotone Increasing Digits", "url": "https://leetcode.com/problems/monotone-increasing-digits/description", "companyTags": ["Amazon"], "difficulty": "Medium", "content": "\r\nGiven a non-negative integer N, find the largest number that is less than or equal to N with monotone increasing digits.\r\n\r\n(Recall that an integer has monotone increasing digits if and only if each pair of adjacent digits x and y satisfy x <= y.)\r\n\r\n\r\nExample 1:\r\n\r\nInput: N = 10\r\nOutput: 9\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: N = 1234\r\nOutput: 1234\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput: N = 332\r\nOutput: 299\r\n\r\n\r\n\r\nNote:\r\nN is an integer in the range [0, 10^9].\r\n", "discussUrl": "https://discuss.leetcode.com/category/1629", "similarQuestions": ["RemoveKDigits"], "topicTags": ["Greedy"], "Solution": null, "total_acs": 4229, "total_submitted": 10189}, {"id": 739, "title": "Daily Temperatures", "url": "https://leetcode.com/problems/daily-temperatures/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "\r\nGiven a list of daily temperatures, produce a list that, for each day in the input, tells you how many days you would have to wait until a warmer temperature.  If there is no future day for which this is possible, put 0 instead.\r\n\r\nFor example, given the list temperatures = [73, 74, 75, 71, 69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0].\r\n\r\n\r\nNote:\r\nThe length of temperatures will be in the range [1, 30000].\r\nEach temperature will be an integer in the range [30, 100].\r\n", "discussUrl": "https://discuss.leetcode.com/category/1631", "similarQuestions": ["NextGreaterElementI"], "topicTags": ["HashTable", "Stack"], "Solution": null, "total_acs": 8599, "total_submitted": 16112}, {"id": 740, "title": "Delete and Earn", "url": "https://leetcode.com/problems/delete-and-earn/description", "companyTags": ["AkunaCapital"], "difficulty": "Medium", "content": "\r\nGiven an array nums of integers, you can perform operations on the array.\r\n\r\nIn each operation, you pick any nums[i] and delete it to earn nums[i] points.  After, you must delete every element equal to nums[i] - 1 or nums[i] + 1.\r\n\r\nYou start with 0 points.  Return the maximum number of points you can earn by applying such operations.\r\n\r\n\r\nExample 1:\r\n\r\nInput: nums = [3, 4, 2]\r\nOutput: 6\r\nExplanation: \r\nDelete 4 to earn 4 points, consequently 3 is also deleted.\r\nThen, delete 2 to earn 2 points. 6 total points are earned.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: nums = [2, 2, 3, 3, 3, 4]\r\nOutput: 9\r\nExplanation: \r\nDelete 3 to earn 3 points, deleting both 2's and the 4.\r\nThen, delete 3 again to earn 3 points, and 3 again to earn 3 points.\r\n9 total points are earned.\r\n\r\n\r\n\r\nNote:\r\nThe length of nums is at most 20000.\r\nEach element nums[i] is an integer in the range [1, 10000].\r\n", "discussUrl": "https://discuss.leetcode.com/category/1633", "similarQuestions": ["HouseRobber"], "topicTags": ["DynamicProgramming"], "Solution": null, "total_acs": 5918, "total_submitted": 13537}, {"id": 741, "title": "Cherry Pickup", "url": "https://leetcode.com/problems/cherry-pickup/description", "companyTags": ["AkunaCapital"], "difficulty": "Hard", "content": "\r\nIn a N x N grid representing a field of cherries, each cell is one of three possible integers.\r\n\r\n0 means the cell is empty, so you can pass through;\r\n1 means the cell contains a cherry, that you can pick up and pass through;\r\n-1 means the cell contains a thorn that blocks your way.\r\n\r\nYour task is to collect maximum number of cherries possible by following the rules below:\r\n\r\nStarting at the position (0, 0) and reaching (N-1, N-1) by moving right or down through valid path cells (cells with value 0 or 1);\r\nAfter reaching (N-1, N-1), returning to (0, 0) by moving left or up through valid path cells;\r\nWhen passing through a path cell containing a cherry, you pick it up and the cell becomes an empty cell (0);\r\nIf there is no valid path between (0, 0) and (N-1, N-1), then no cherries can be collected.\r\n\r\n\r\nExample 1:\r\n\r\nInput: grid =\r\n[[0, 1, -1],\r\n [1, 0, -1],\r\n [1, 1,  1]]\r\nOutput: 5\r\nExplanation: \r\nThe player started at (0, 0) and went down, down, right right to reach (2, 2).\r\n4 cherries were picked up during this single trip, and the matrix becomes [[0,1,-1],[0,0,-1],[0,0,0]].\r\nThen, the player went left, up, up, left to return home, picking up one more cherry.\r\nThe total number of cherries picked up is 5, and this is the maximum possible.\r\n\r\n\r\n\r\nNote:\r\ngrid is an N by N 2D array, with 1 <= N <= 50.\r\nEach grid[i][j] is an integer in the set {-1, 0, 1}.\r\nIt is guaranteed that grid[0][0] and grid[N-1][N-1] are not -1.\r\n", "discussUrl": "https://discuss.leetcode.com/category/1635", "similarQuestions": ["MinimumPathSum", "DungeonGame"], "topicTags": ["DynamicProgramming"], "Solution": null, "total_acs": 1698, "total_submitted": 7377}, {"id": 742, "title": "Closest Leaf in a Binary Tree", "url": "https://leetcode.com/problems/closest-leaf-in-a-binary-tree/description", "companyTags": ["Amazon", "databricks"], "difficulty": "Medium", "content": "Given a binary tree where every node has a unique value, and a target key k, find the value of the nearest leaf node to target k in the tree.\r\n\r\nHere, nearest to a leaf means the least number of edges travelled on the binary tree to reach any leaf of the tree.  Also, a node is called a leaf if it has no children.\r\n\r\nIn the following examples, the input tree is represented in flattened form row by row.\r\nThe actual root tree given will be a TreeNode object.\r\n\r\nExample 1:\r\n\r\nInput:\r\nroot = [1, 3, 2], k = 1\r\nDiagram of binary tree:\r\n          1\r\n         / \\\r\n        3   2\r\n\r\nOutput: 2 (or 3)\r\n\r\nExplanation: Either 2 or 3 is the nearest leaf node to the target of 1.\r\n\r\n\r\nExample 2:\r\n\r\nInput:\r\nroot = [1], k = 1\r\nOutput: 1\r\n\r\nExplanation: The nearest leaf node is the root node itself.\r\n\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput:\r\nroot = [1,2,3,4,null,null,null,5,null,6], k = 2\r\nDiagram of binary tree:\r\n             1\r\n            / \\\r\n           2   3\r\n          /\r\n         4\r\n        /\r\n       5\r\n      /\r\n     6\r\n\r\nOutput: 3\r\nExplanation: The leaf node with value 3 (and not the leaf node with value 6) is nearest to the node with value 2.\r\n\r\n\r\n\r\nNote:\r\n\r\nroot represents a binary tree with at least 1 node and at most 1000 nodes.\r\nEvery node has a unique node.val in range [1, 1000].\r\nThere exists some node in the given binary tree for which node.val == k.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/1642", "similarQuestions": [""], "topicTags": ["Tree"], "Solution": null, "total_acs": 2602, "total_submitted": 7843}, {"id": 743, "title": "Network Delay Time", "url": "https://leetcode.com/problems/network-delay-time/description", "companyTags": ["AkunaCapital"], "difficulty": "Medium", "content": "\r\nThere are N network nodes, labelled 1 to N.\r\n\r\nGiven times, a list of travel times as directed edges times[i] = (u, v, w), where u is the source node, v is the target node, and w is the time it takes for a signal to travel from source to target.\r\n\r\nNow, we send a signal from a certain node K.  How long will it take for all nodes to receive the signal?  If it is impossible, return -1.\r\n\r\n\r\nNote:\r\n\r\nN will be in the range [1, 100].\r\nK will be in the range [1, N].\r\nThe length of times will be in the range [1, 6000].\r\nAll edges times[i] = (u, v, w) will have 1 <= u, v <= N and 1 <= w <= 100.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/1644", "similarQuestions": [""], "topicTags": ["Heap", "Depth-firstSearch", "Breadth-firstSearch", "Graph"], "Solution": null, "total_acs": 4423, "total_submitted": 12873}, {"id": 744, "title": "Find Smallest Letter Greater Than Target", "url": "https://leetcode.com/problems/find-smallest-letter-greater-than-target/description", "companyTags": ["LinkedIn"], "difficulty": "Easy", "content": "\r\nGiven a list of sorted characters letters containing only lowercase letters, and given a target letter target, find the smallest element in the list that is larger than the given target.\r\n\r\nLetters also wrap around.  For example, if the target is target = 'z' and letters = ['a', 'b'], the answer is 'a'.\r\n\r\n\r\nExamples:\r\n\r\nInput:\r\nletters = [\"c\", \"f\", \"j\"]\r\ntarget = \"a\"\r\nOutput: \"c\"\r\n\r\nInput:\r\nletters = [\"c\", \"f\", \"j\"]\r\ntarget = \"c\"\r\nOutput: \"f\"\r\n\r\nInput:\r\nletters = [\"c\", \"f\", \"j\"]\r\ntarget = \"d\"\r\nOutput: \"f\"\r\n\r\nInput:\r\nletters = [\"c\", \"f\", \"j\"]\r\ntarget = \"g\"\r\nOutput: \"j\"\r\n\r\nInput:\r\nletters = [\"c\", \"f\", \"j\"]\r\ntarget = \"j\"\r\nOutput: \"c\"\r\n\r\nInput:\r\nletters = [\"c\", \"f\", \"j\"]\r\ntarget = \"k\"\r\nOutput: \"c\"\r\n\r\n\r\n\r\nNote:\r\n\r\nletters has a length in range [2, 10000].\r\nletters consists of lowercase letters, and contains at least 2 unique letters.\r\ntarget is a lowercase letter.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/1646", "similarQuestions": [""], "topicTags": ["BinarySearch"], "Solution": null, "total_acs": 9768, "total_submitted": 21534}, {"id": 745, "title": "Prefix and Suffix Search", "url": "https://leetcode.com/problems/prefix-and-suffix-search/description", "companyTags": ["Facebook"], "difficulty": "Hard", "content": "\r\nGiven many words, words[i] has weight i.\r\n\r\nDesign a class WordFilter that supports one function, WordFilter.f(String prefix, String suffix).\r\nIt will return the word with given prefix and suffix with maximum weight.  If no word exists, return -1.\r\n\r\n\r\nExamples:\r\n\r\nInput:\r\nWordFilter([\"apple\"])\r\nWordFilter.f(\"a\", \"e\") // returns 0\r\nWordFilter.f(\"b\", \"\") // returns -1\r\n\r\n\r\nNote:\r\n\r\nwords has length in range [1, 15000].\r\nFor each test case, up to words.length queries WordFilter.f may be made.\r\nwords[i] has length in range [1, 10].\r\nprefix, suffix have lengths in range [0, 10].\r\nwords[i] and prefix, suffix queries consist of lowercase letters only.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/1648", "similarQuestions": ["AddandSearchWord-Datastructuredesign"], "topicTags": ["Trie"], "Solution": null, "total_acs": 2579, "total_submitted": 10545}, {"id": 746, "title": "Min Cost Climbing Stairs", "url": "https://leetcode.com/problems/min-cost-climbing-stairs/description", "companyTags": ["Amazon"], "difficulty": "Easy", "content": "\r\nOn a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed).\r\n\r\nOnce you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.\r\n\r\n\r\nExample 1:\r\n\r\nInput: cost = [10, 15, 20]\r\nOutput: 15\r\nExplanation: Cheapest is start on cost[1], pay that cost and go to the top.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]\r\nOutput: 6\r\nExplanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].\r\n\r\n\r\n\r\nNote:\r\n\r\ncost will have a length in the range [2, 1000].\r\nEvery cost[i] will be an integer in the range [0, 999].\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/1651", "similarQuestions": ["ClimbingStairs"], "topicTags": ["Array", "DynamicProgramming"], "Solution": null, "total_acs": 12781, "total_submitted": 29279}, {"id": 747, "title": "Largest Number At Least Twice of Others", "url": "https://leetcode.com/problems/largest-number-at-least-twice-of-others/description", "companyTags": ["Google"], "difficulty": "Easy", "content": "In a given integer array nums, there is always exactly one largest element.\r\n\r\nFind whether the largest element in the array is at least twice as much as every other number in the array.\r\n\r\nIf it is, return the index of the largest element, otherwise return -1.\r\n\r\nExample 1:\r\n\r\n\r\nInput: nums = [3, 6, 1, 0]\r\nOutput: 1\r\nExplanation: 6 is the largest integer, and for every other number in the array x,\r\n6 is more than twice as big as x.  The index of value 6 is 1, so we return 1.\r\n\r\n\r\n\u00a0\r\n\r\nExample 2:\r\n\r\n\r\nInput: nums = [1, 2, 3, 4]\r\nOutput: -1\r\nExplanation: 4 isn't at least as big as twice the value of 3, so we return -1.\r\n\r\n\r\n\u00a0\r\n\r\nNote:\r\n\r\n\r\n\tnums will have a length in the range [1, 50].\r\n\tEvery nums[i] will be an integer in the range [0, 99].\r\n\r\n\r\n\u00a0\r\n", "discussUrl": "https://discuss.leetcode.com/category/1653", "similarQuestions": [""], "topicTags": ["Array"], "Solution": null, "total_acs": 9753, "total_submitted": 22909}, {"id": 748, "title": "Shortest Completing Word", "url": "https://leetcode.com/problems/shortest-completing-word/description", "companyTags": ["Google"], "difficulty": "Medium", "content": "\r\nFind the minimum length word from a given dictionary words, which has all the letters from the string licensePlate.  Such a word is said to complete the given string licensePlate\r\n\r\nHere, for letters we ignore case.  For example, \"P\" on the licensePlate still matches \"p\" on the word.\r\n\r\nIt is guaranteed an answer exists.  If there are multiple answers, return the one that occurs first in the array.\r\n\r\nThe license plate might have the same letter occurring multiple times.  For example, given a licensePlate of \"PP\", the word \"pair\" does not complete the licensePlate, but the word \"supper\" does.\r\n\r\n\r\nExample 1:\r\n\r\nInput: licensePlate = \"1s3 PSt\", words = [\"step\", \"steps\", \"stripe\", \"stepple\"]\r\nOutput: \"steps\"\r\nExplanation: The smallest length word that contains the letters \"S\", \"P\", \"S\", and \"T\".\r\nNote that the answer is not \"step\", because the letter \"s\" must occur in the word twice.\r\nAlso note that we ignored case for the purposes of comparing whether a letter exists in the word.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: licensePlate = \"1s3 456\", words = [\"looks\", \"pest\", \"stew\", \"show\"]\r\nOutput: \"pest\"\r\nExplanation: There are 3 smallest length words that contains the letters \"s\".\r\nWe return the one that occurred first.\r\n\r\n\r\n\r\nNote:\r\n\r\nlicensePlate will be a string with length in range [1, 7].\r\nlicensePlate will contain digits, spaces, or letters (uppercase or lowercase).\r\nwords will have a length in the range [10, 1000].\r\nEvery words[i] will consist of lowercase letters, and have length in range [1, 15].\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/1655", "similarQuestions": [""], "topicTags": ["HashTable"], "Solution": null, "total_acs": 4728, "total_submitted": 8843}, {"id": 749, "title": "Contain Virus", "url": "https://leetcode.com/problems/contain-virus/description", "companyTags": ["Bloomberg"], "difficulty": "Hard", "content": "\r\nA virus is spreading rapidly, and your task is to quarantine the infected area by installing walls.\r\n\r\nThe world is modeled as a 2-D array of cells, where 0 represents uninfected cells, and 1 represents cells contaminated with the virus.  A wall (and only one wall) can be installed between any two 4-directionally adjacent cells, on the shared boundary.\r\n\r\nEvery night, the virus spreads to all neighboring cells in all four directions unless blocked by a wall.\r\nResources are limited. Each day, you can install walls around only one region -- the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night. There will never be a tie.\r\n\r\nCan you save the day? If so, what is the number of walls required? If not, and the world becomes fully infected, return the number of walls used.\r\n\r\n\r\nExample 1:\r\n\r\nInput: grid = \r\n[[0,1,0,0,0,0,0,1],\r\n [0,1,0,0,0,0,0,1],\r\n [0,0,0,0,0,0,0,1],\r\n [0,0,0,0,0,0,0,0]]\r\nOutput: 10\r\nExplanation:\r\nThere are 2 contaminated regions.\r\nOn the first day, add 5 walls to quarantine the viral region on the left. The board after the virus spreads is:\r\n\r\n[[0,1,0,0,0,0,1,1],\r\n [0,1,0,0,0,0,1,1],\r\n [0,0,0,0,0,0,1,1],\r\n [0,0,0,0,0,0,0,1]]\r\n\r\nOn the second day, add 5 walls to quarantine the viral region on the right. The virus is fully contained.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: grid = \r\n[[1,1,1],\r\n [1,0,1],\r\n [1,1,1]]\r\nOutput: 4\r\nExplanation: Even though there is only one cell saved, there are 4 walls built.\r\nNotice that walls are only built on the shared boundary of two different cells.\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput: grid = \r\n[[1,1,1,0,0,0,0,0,0],\r\n [1,0,1,0,1,1,1,1,1],\r\n [1,1,1,0,0,0,0,0,0]]\r\nOutput: 13\r\nExplanation: The region on the left only builds two new walls.\r\n\r\n\r\n\r\nNote:\r\n\r\nThe number of rows and columns of grid will each be in the range [1, 50].\r\nEach grid[i][j] will be either 0 or 1.\r\nThroughout the described process, there is always a contiguous viral region that will infect strictly more uncontaminated squares in the next round.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/1657", "similarQuestions": [""], "topicTags": ["Depth-firstSearch"], "Solution": null, "total_acs": 1022, "total_submitted": 2576}, {"id": 750, "title": "Number Of Corner Rectangles", "url": "https://leetcode.com/problems/number-of-corner-rectangles/description", "companyTags": ["Facebook"], "difficulty": "Medium", "content": "Given a grid where each entry is only 0 or 1, find the number of corner rectangles.\r\n\r\nA corner rectangle is 4 distinct 1s on the grid that form an axis-aligned rectangle. Note that only the corners need to have the value 1. Also, all four 1s used must be distinct.\r\n\r\n\u00a0\r\n\r\nExample 1:\r\n\r\n\r\nInput: grid = \r\n[[1, 0, 0, 1, 0],\r\n [0, 0, 1, 0, 1],\r\n [0, 0, 0, 1, 0],\r\n [1, 0, 1, 0, 1]]\r\nOutput: 1\r\nExplanation: There is only one corner rectangle, with corners grid[1][2], grid[1][4], grid[3][2], grid[3][4].\r\n\r\n\r\n\u00a0\r\n\r\nExample 2:\r\n\r\n\r\nInput: grid = \r\n[[1, 1, 1],\r\n [1, 1, 1],\r\n [1, 1, 1]]\r\nOutput: 9\r\nExplanation: There are four 2x2 rectangles, four 2x3 and 3x2 rectangles, and one 3x3 rectangle.\r\n\r\n\r\n\u00a0\r\n\r\nExample 3:\r\n\r\n\r\nInput: grid = \r\n[[1, 1, 1, 1]]\r\nOutput: 0\r\nExplanation: Rectangles must have four distinct corners.\r\n\r\n\r\n\u00a0\r\n\r\nNote:\r\n\r\n\r\n\tThe number of rows and columns of grid will each be in the range [1, 200].\r\n\tEach grid[i][j] will be either 0 or 1.\r\n\tThe number of 1s in the grid will be at most 6000.\r\n\r\n\r\n\u00a0\r\n", "discussUrl": "https://discuss.leetcode.com/category/1659", "similarQuestions": [""], "topicTags": ["DynamicProgramming"], "Solution": null, "total_acs": 3310, "total_submitted": 6486}, {"id": 751, "title": "IP to CIDR", "url": "https://leetcode.com/problems/ip-to-cidr/description", "companyTags": ["Airbnb"], "difficulty": "Easy", "content": "\r\nGiven a start IP address ip and a number of ips we need to cover n, return a representation of the range as a list (of smallest possible length) of CIDR blocks.\r\n\r\nA CIDR block is a string consisting of an IP, followed by a slash, and then the prefix length.  For example: \"123.45.67.89/20\".  That prefix length \"20\" represents the number of common prefix bits in the specified range.\r\n\r\n\r\nExample 1:\r\n\r\nInput: ip = \"255.0.0.7\", n = 10\r\nOutput: [\"255.0.0.7/32\",\"255.0.0.8/29\",\"255.0.0.16/32\"]\r\nExplanation:\r\nThe initial ip address, when converted to binary, looks like this (spaces added for clarity):\r\n255.0.0.7 -> 11111111 00000000 00000000 00000111\r\nThe address \"255.0.0.7/32\" specifies all addresses with a common prefix of 32 bits to the given address,\r\nie. just this one address.\r\n\r\nThe address \"255.0.0.8/29\" specifies all addresses with a common prefix of 29 bits to the given address:\r\n255.0.0.8 -> 11111111 00000000 00000000 00001000\r\nAddresses with common prefix of 29 bits are:\r\n11111111 00000000 00000000 00001000\r\n11111111 00000000 00000000 00001001\r\n11111111 00000000 00000000 00001010\r\n11111111 00000000 00000000 00001011\r\n11111111 00000000 00000000 00001100\r\n11111111 00000000 00000000 00001101\r\n11111111 00000000 00000000 00001110\r\n11111111 00000000 00000000 00001111\r\n\r\nThe address \"255.0.0.16/32\" specifies all addresses with a common prefix of 32 bits to the given address,\r\nie. just 11111111 00000000 00000000 00010000.\r\n\r\nIn total, the answer specifies the range of 10 ips starting with the address 255.0.0.7 .\r\n\r\nThere were other representations, such as:\r\n[\"255.0.0.7/32\",\"255.0.0.8/30\", \"255.0.0.12/30\", \"255.0.0.16/32\"],\r\nbut our answer was the shortest possible.\r\n\r\nAlso note that a representation beginning with say, \"255.0.0.7/30\" would be incorrect,\r\nbecause it includes addresses like 255.0.0.4 = 11111111 00000000 00000000 00000100 \r\nthat are outside the specified range.\r\n\r\n\r\n\r\nNote:\r\n\r\nip will be a valid IPv4 address.\r\nEvery implied address ip + x (for x < n) will be a valid IPv4 address.\r\nn will be an integer in the range [1, 1000].\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/1662", "similarQuestions": ["RestoreIPAddresses", "ValidateIPAddress"], "topicTags": ["BitManipulation"], "Solution": null, "total_acs": 1357, "total_submitted": 2479}, {"id": 752, "title": "Open the Lock", "url": "https://leetcode.com/problems/open-the-lock/description", "companyTags": [""], "difficulty": "Medium", "content": "\r\nYou have a lock in front of you with 4 circular wheels.  Each wheel has 10 slots: '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'.  The wheels can rotate freely and wrap around: for example we can turn '9' to be '0', or '0' to be '9'.  Each move consists of turning one wheel one slot.\r\n\r\nThe lock initially starts at '0000', a string representing the state of the 4 wheels.\r\n\r\nYou are given a list of deadends dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.\r\n\r\nGiven a target representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.\r\n\r\n\r\nExample 1:\r\n\r\nInput: deadends = [\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"], target = \"0202\"\r\nOutput: 6\r\nExplanation:\r\nA sequence of valid moves would be \"0000\" -> \"1000\" -> \"1100\" -> \"1200\" -> \"1201\" -> \"1202\" -> \"0202\".\r\nNote that a sequence like \"0000\" -> \"0001\" -> \"0002\" -> \"0102\" -> \"0202\" would be invalid,\r\nbecause the wheels of the lock become stuck after the display becomes the dead end \"0102\".\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: deadends = [\"8888\"], target = \"0009\"\r\nOutput: 1\r\nExplanation:\r\nWe can turn the last wheel in reverse to move from \"0000\" -> \"0009\".\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput: deadends = [\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9888\"], target = \"8888\"\r\nOutput: -1\r\nExplanation:\r\nWe can't reach the target without getting stuck.\r\n\r\n\r\n\r\nExample 4:\r\n\r\nInput: deadends = [\"0000\"], target = \"8888\"\r\nOutput: -1\r\n\r\n\r\n\r\nNote:\r\n\r\nThe length of deadends will be in the range [1, 500].\r\ntarget will not be in the list deadends.\r\nEvery string in deadends and the string target will be a string of 4 digits from the 10,000 possibilities '0000' to '9999'.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/1664", "similarQuestions": [""], "topicTags": ["Breadth-firstSearch"], "Solution": null, "total_acs": 2961, "total_submitted": 7826}, {"id": 753, "title": "Cracking the Safe", "url": "https://leetcode.com/problems/cracking-the-safe/description", "companyTags": ["Google"], "difficulty": "Hard", "content": "\r\nThere is a box protected by a password.  The password is n digits, where each letter can be one of the first k digits 0, 1, ..., k-1.\r\n\r\nYou can keep inputting the password, the password will automatically be matched against the last n digits entered.\r\n\r\nFor example, assuming the password is \"345\", I can open it when I type \"012345\", but I enter a total of 6 digits.\r\n\r\nPlease return any string of minimum length that is guaranteed to open the box after the entire string is inputted.\r\n\r\n\r\nExample 1:\r\n\r\nInput: n = 1, k = 2\r\nOutput: \"01\"\r\nNote: \"10\" will be accepted too.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: n = 2, k = 2\r\nOutput: \"00110\"\r\nNote: \"01100\", \"10011\", \"11001\" will be accepted too.\r\n\r\n\r\n\r\nNote:\r\n\r\nn will be in the range [1, 4].\r\nk will be in the range [1, 10].\r\nk^n will be at most 4096.\r\n\r\n", "discussUrl": "https://discuss.leetcode.com/category/1666", "similarQuestions": [""], "topicTags": ["Math", "Depth-firstSearch"], "Solution": null, "total_acs": 2231, "total_submitted": 5637}, {"id": 754, "title": "Reach a Number", "url": "https://leetcode.com/problems/reach-a-number/description", "companyTags": ["inmobi"], "difficulty": "Medium", "content": "\r\nYou are standing at position 0 on an infinite number line.  There is a goal at position target.\r\n\r\nOn each move, you can either go left or right.  During the n-th move (starting from 1), you take n steps.\r\n\r\nReturn the minimum number of steps required to reach the destination.\r\n\r\n\r\nExample 1:\r\n\r\nInput: target = 3\r\nOutput: 2\r\nExplanation:\r\nOn the first move we step from 0 to 1.\r\nOn the second step we step from 1 to 3.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: target = 2\r\nOutput: 3\r\nExplanation:\r\nOn the first move we step from 0 to 1.\r\nOn the second move we step  from 1 to -1.\r\nOn the third move we step from -1 to 2.\r\n\r\n\r\n\r\nNote:\r\ntarget will be a non-zero integer in the range [-10^9, 10^9].\r\n", "discussUrl": "https://discuss.leetcode.com/category/1669", "similarQuestions": [""], "topicTags": ["Math"], "Solution": null, "total_acs": 2384, "total_submitted": 9495}, {"id": 755, "title": "Pour Water", "url": "https://leetcode.com/problems/pour-water/description", "companyTags": ["Airbnb"], "difficulty": "Medium", "content": "\r\nWe are given an elevation map, heights[i] representing the height of the terrain at that index.  The width at each index is 1.  After V units of water fall at index K, how much water is at each index?\r\n\r\nWater first drops at index K and rests on top of the highest terrain or water at that index.  Then, it flows according to the following rules:\r\nIf the droplet would eventually fall by moving left, then move left.\r\nOtherwise, if the droplet would eventually fall by moving right, then move right.\r\nOtherwise, rise at it's current position.\r\nHere, \"eventually fall\" means that the droplet will eventually be at a lower level if it moves in that direction.\r\nAlso, \"level\" means the height of the terrain plus any water in that column.\r\n\r\nWe can assume there's infinitely high terrain on the two sides out of bounds of the array.  Also, there could not be partial water being spread out evenly on more than 1 grid block - each unit of water has to be in exactly one block.\r\n\r\n\r\nExample 1:\r\n\r\nInput: heights = [2,1,1,2,1,2,2], V = 4, K = 3\r\nOutput: [2,2,2,3,2,2,2]\r\nExplanation:\r\n#       #\r\n#       #\r\n##  # ###\r\n#########\r\n 0123456    <- index\r\n\r\nThe first drop of water lands at index K = 3:\r\n\r\n#       #\r\n#   w   #\r\n##  # ###\r\n#########\r\n 0123456    \r\n\r\nWhen moving left or right, the water can only move to the same level or a lower level.\r\n(By level, we mean the total height of the terrain plus any water in that column.)\r\nSince moving left will eventually make it fall, it moves left.\r\n(A droplet \"made to fall\" means go to a lower height than it was at previously.)\r\n\r\n#       #\r\n#       #\r\n## w# ###\r\n#########\r\n 0123456    \r\n\r\nSince moving left will not make it fall, it stays in place.  The next droplet falls:\r\n\r\n#       #\r\n#   w   #\r\n## w# ###\r\n#########\r\n 0123456  \r\n\r\nSince the new droplet moving left will eventually make it fall, it moves left.\r\nNotice that the droplet still preferred to move left,\r\neven though it could move right (and moving right makes it fall quicker.)\r\n\r\n#       #\r\n#  w    #\r\n## w# ###\r\n#########\r\n 0123456  \r\n\r\n#       #\r\n#       #\r\n##ww# ###\r\n#########\r\n 0123456  \r\n\r\nAfter those steps, the third droplet falls.\r\nSince moving left would not eventually make it fall, it tries to move right.\r\nSince moving right would eventually make it fall, it moves right.\r\n\r\n#       #\r\n#   w   #\r\n##ww# ###\r\n#########\r\n 0123456  \r\n\r\n#       #\r\n#       #\r\n##ww#w###\r\n#########\r\n 0123456  \r\n\r\nFinally, the fourth droplet falls.\r\nSince moving left would not eventually make it fall, it tries to move right.\r\nSince moving right would not eventually make it fall, it stays in place:\r\n\r\n#       #\r\n#   w   #\r\n##ww#w###\r\n#########\r\n 0123456  \r\n\r\nThe final answer is [2,2,2,3,2,2,2]:\r\n\r\n    #    \r\n ####### \r\n ####### \r\n 0123456 \r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: heights = [1,2,3,4], V = 2, K = 2\r\nOutput: [2,3,3,4]\r\nExplanation:\r\nThe last droplet settles at index 1, since moving further left would not cause it to eventually fall to a lower height.\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput: heights = [3,1,3], V = 5, K = 1\r\nOutput: [4,4,4]\r\n\r\n\r\n\r\nNote:\r\nheights will have length in [1, 100] and contain integers in [0, 99].\r\nV will be in range [0, 2000].\r\nK will be in range [0, heights.length - 1].\r\n", "discussUrl": "https://discuss.leetcode.com/category/1671", "similarQuestions": ["TrappingRainWater"], "topicTags": ["Array"], "Solution": null, "total_acs": 2201, "total_submitted": 6529}]}